      REAL*8 FUNCTION S21BBF(X, Y, Z, IFAIL)

C     MARK 8 RELEASE. NAG COPYRIGHT 1979.

C

C     ******************************************************************

C

C      CALCULATES AN APPROXIMATE VALUE FOR THE ELLIPTIC INTEGRAL OF

C      THE FIRST KIND, RF(X,Y,Z), AS DEFINED BY B.C.CARLSON.

C      -SPECIAL FUNCTIONS OF APPLIED MATHS-ACADEMIC PRESS(1977).

C      THE ALGORITHM IS ALSO DUE TO CARLSON BUT HAS BEEN RECODED BY

C      J.L.SCHONFELDER TO AVOID INTERMEDIATE UNDER AND OVERFLOWS

C

C      RF(X,Y,Z)=INTEGRAL(ZERO TO INFINITY) OF

C          0.5/SQRT((T+X)*(T+Y)*(T+Z)) DT

C

C      FOR X,Y,Z ALL .GE. ZERO AND AT MOST ONE EQUAL TO ZERO

C

C     **************************************************************** *

C

C     ******************************************************************

C     PRECISION-DEPENDENT CONSTANT

C

C        ACC  CONTROLS FINAL TRUNCATION ACCURACY. AN ACCURACY

C                 CLOSE TO FULL MACHINE PRECISION CAN BE OBTAINED

C                 FOR ALL LEGAL ARGUMENTS IF ACC IS CHOSEN SO THAT

C           0.25*ACC**6/(1.0-ACC).LE.X02AAF/X02BAF

C

C     TO SELECT THE CORRECT VALUE FOR A PARTICULAR MACHINE-RANGE,

C     ACTIVATE THE STATEMENT CONTAINED IN A COMMENT BEGINNING  CDD ,

C     WHERE  DD  IS THE APPROXIMATE NUMBER OF SIGNIFICANT DECIMAL

C     DIGITS REPRESENTED BY THE MACHINE.

C     ******************************************************************

C

C     .. SCALAR ARGUMENTS ..

*      REAL X, Y, Z

      REAL*8 X, Y, Z

      INTEGER IFAIL

C     ..

C     .. LOCAL SCALARS ..

*+SELF,IF=IBM.

      CHARACTER*8 SRNAME

*+SELF.

*      REAL ACC, C1, C2, C3, CXN, CYN, CZN, E2, E3, LAMDA, LOLIM,

      REAL*8 ACC, C1, C2, C3, CXN, CYN, CZN, E2, E3, LAMDA, LOLIM,

     * MU, RSCALE, RTX, RTY, RTZ, UPLIM, XN, YN, ZN

      INTEGER IND

C     .. FUNCTION REFERENCES ..

*      REAL SQRT, X02ABE, X02ACE

      REAL*8 SQRT, X02ABF, X02ACF

      INTEGER P01AAE

*

      REAL*8 XARG

      SQRT(XARG)=DSQRT(XARG)

*

C     ..

*      DATA SRNAME /8H S21BBE /

      DATA SRNAME /8H S21BBF /

*+SELF,IF=E09.

*      DATA ACC/5.7E-2/

*+SELF,IF=E10.

*      DATA ACC/3.9E-2/

*+SELF,IF=E13.

*      DATA ACC/1.2E-2/

*+SELF,IF=E16.

      DATA ACC/3.9E-3/

*+SELF,IF=E18.

*      DATA ACC/1.8E-3/

*+SELF,IF=E20.

*      DATA ACC/8.5E-4/

*+SELF.

C

C     ORDER X,Y,Z INTO XN,YN,ZN  ST. XN.LE.YN.LE.ZN

      IF (X.LE.Y) GO TO 20

      XN = Y

      YN = X

      GO TO 40

   20 XN = X

      YN = Y

   40 ZN = Z

      IF (YN.LE.ZN) GO TO 60

      ZN = YN

      YN = Z

      IF (XN.LE.YN) GO TO 60

      YN = XN

      XN = Z

C

C     TEST FOR VALID ARGUMENTS

   60 IND = 1

      IF (XN.LT.0.0) GO TO 180

      IND = 2

      IF (YN.LE.0.0) GO TO 180

C

C     VALID CALL

      IFAIL = 0

      RSCALE = 1.0

*      LOLIM = 16.0*X02ABE(0.0)

      LOLIM = 16.0*X02ABF(0.0D0)

*      UPLIM = 0.0625*X02ACE(0.0)

      UPLIM = 0.0625*X02ACF(0.0D0)

C

C     FOR EXTREME ARGUMENTS SCALE TO AVOID UNDER AND OVERFLOWS

      IF (ZN.LE.UPLIM) GO TO 120

      RSCALE = 0.25

      ZN = ZN*0.0625

      IF (YN.LE.LOLIM) GO TO 80

      YN = YN*0.0625

      IF (XN.LE.LOLIM) GO TO 100

      XN = XN*0.0625

      GO TO 140

   80 LAMDA = (SQRT(XN)+SQRT(YN))*(SQRT(ZN)*0.25)

      XN = LAMDA*0.25

      YN = XN

      ZN = (ZN+LAMDA)*0.25

      GO TO 140

  100 RTZ = SQRT(ZN)

      RTY = SQRT(YN)

      LAMDA = RTZ*RTY + ((RTZ+RTY)*0.25)*SQRT(XN)

      XN = LAMDA*0.25

      YN = (YN+LAMDA)*0.25

      ZN = (ZN+LAMDA)*0.25

      GO TO 140

  120 IF (ZN.GT.LOLIM) GO TO 140

      RSCALE = 4.0

      XN = XN*16.0

      YN = YN*16.0

      ZN = ZN*16.0

C

C     MAIN RECURSION

  140 MU = (XN+YN+ZN)/3.0

      CZN = 2.0 - (ZN+MU)/MU

      CXN = 2.0 - (XN+MU)/MU

      IF (DMAX1(CXN,-CZN).LE.ACC) GO TO 160

      RTX = SQRT(XN)

      RTY = SQRT(YN)

      RTZ = SQRT(ZN)

      LAMDA = RTZ*(RTX+RTY) + RTX*RTY

      XN = (XN+LAMDA)*0.25

      YN = (YN+LAMDA)*0.25

      ZN = (ZN+LAMDA)*0.25

      GO TO 140

C

C     POWER SERIES EXPANSION

  160 C1 = 1.0/24.0

      C2 = 3.0/44.0

      C3 = 1.0/14.0

      CYN = -CXN - CZN

      E2 = CXN*CYN - CZN*CZN

      E3 = CXN*CZN*CYN

*      S21BBE = RSCALE*(1.0+(C1*E2-0.1-C2*E3)*E2+C3*E3)/SQRT(MU)

      S21BBF = RSCALE*(1.0+(C1*E2-0.1-C2*E3)*E2+C3*E3)/SQRT(MU)

      GO TO 200

C

C     FAILURE EXITS

  180 IFAIL = P01AAE(IFAIL,IND,SRNAME)

*      S21BBE = 0.0

      S21BBF = 0.0

  200 RETURN

      END



      REAL*8 FUNCTION S21BCF(X, Y, Z, IFAIL)

C     MARK 8 RELEASE. NAG COPYRIGHT 1979.

C

C     ******************************************************************

C

C      CALCULATES AN APPROXIMATE VALUE FOR THE ELLIPTIC INTEGRAL OF

C      THE SECOND KIND, RD(X,Y,Z), AS DEFINED BY B.C.CARLSON.

C      -SPECIAL FUNCTIONS OF APPLIED MATHS-ACADEMIC PRESS(1977).

C      THE ALGORITHM IS ALSO DUE TO CARLSON.

C

C      RD(X,Y,Z)=INTEGRAL(ZERO TO INFINITY) OF

C          1.5/SQRT((T+X)*(T+Y)*(T+Z)**3) DT

C

C      FOR X.GE.0.0 , Y.GE.0.0, Z.GT.0.0 AND AT MOST ONE OF X

C      AND Y EQUAL TO 0.0.

C

C     ******************************************************************

C

C     ******************************************************************

C     PRECISION-DEPENDENT CONSTANT

C

C        ACC  CONTROLS FINAL TRUNCATION ACCURACY. AN ACCURACY

C                 CLOSE TO FULL MACHINE PRECISION CAN BE OBTAINED

C                 FOR ALL LEGAL ARGUMENTS IF ACC IS CHOSEN SO THAT

C           3.0*ACC**6/(1.0-ACC)**1.5.LE.X02AAF/X02BAF

C

C     TO SELECT THE CORRECT VALUE FOR A PARTICULAR MACHINE-RANGE,

C     ACTIVATE THE STATEMENT CONTAINED IN A COMMENT BEGINNING  CDD ,

C     WHERE  DD  IS THE APPROXIMATE NUMBER OF SIGNIFICANT DECIMAL

C     DIGITS REPRESENTED BY THE MACHINE.

C     ******************************************************************

C

C     .. SCALAR ARGUMENTS ..

*      REAL X, Y, Z

      REAL*8 X, Y, Z

      INTEGER IFAIL

C     ..

C     .. LOCAL SCALARS ..

*+SELF,IF=IBM.

      CHARACTER*8 SRNAME

*+SELF.

*      REAL ACC, C1, C2, C3, C4, C5, C6, CXN, CYN, CZN, EA, EB, EC,

      REAL*8 ACC, C1, C2, C3, C4, C5, C6, CXN, CYN, CZN, EA, EB, EC,

     * ED, EF, LAMDA, LOLIM, MU, POW4, RTX, RTY, RTZ, SIGMA, UPLIM,

     * XN, YN, ZN

      INTEGER IND

C     .. FUNCTION REFERENCES ..

*      REAL SQRT, X02ABE, X02ACE

      REAL*8 SQRT, X02ABF, X02ACF

      INTEGER P01AAE

*

      REAL*8 XARG

      SQRT(XARG)=DSQRT(XARG)

*

C     ..

*      DATA SRNAME /8H S21BCE /

      DATA SRNAME /8H S21BCF /

*+SELF,IF=E09.

*      DATA ACC/3.8E-2/

*+SELF,IF=E10.

*      DATA ACC/2.6E-2/

*+SELF,IF=E13.

*      DATA ACC/8.3E-3/

*+SELF,IF=E16.

      DATA ACC/2.6E-3/

*+SELF,IF=E18.

*      DATA ACC/1.2E-3/

*+SELF,IF=E20.

*      DATA ACC/5.6E-4/

*+SELF.

C

C     TEST FOR VALID ARGUMENTS

      IND = 1

      IF (X.LT.0.0 .OR. Y.LT.0.0 .OR. X+Y.EQ.0.0) GO TO 60

      IND = 2

      IF (Z.LE.0.0) GO TO 60

      IND = 3

*      LOLIM = 2.0/X02ACE(0.0)**0.66667

      LOLIM = 2.0/X02ACF(0.0D0)**0.66667

      IF (DMIN1(X+Y,Z).LT.LOLIM) GO TO 60

      IND = 4

*      UPLIM = (0.1*ACC/X02ABE(0.0))**0.66667

      UPLIM = (0.1*ACC/X02ABF(0.0D0))**0.66667

      IF (DMAX1(X,Y,Z).GE.UPLIM) GO TO 60

C

C     VALID CALL

      IFAIL = 0

      XN = X

      YN = Y

      ZN = Z

      SIGMA = 0.0

      POW4 = 1.0

C

C     MAIN RECURSION

   20 MU = (XN+YN+3.0*ZN)*0.2

      CXN = (MU-XN)/MU

      CYN = (MU-YN)/MU

      CZN = (MU-ZN)/MU

      IF (DMAX1(ABS(CXN),ABS(CYN),ABS(CZN)).LT.ACC) GO TO 40

      RTX = SQRT(XN)

      RTY = SQRT(YN)

      RTZ = SQRT(ZN)

      LAMDA = RTX*RTY + RTY*RTZ + RTZ*RTX

      ZN = ZN + LAMDA

      SIGMA = SIGMA + POW4/(RTZ*ZN)

      POW4 = POW4*0.25

      ZN = ZN*0.25

      XN = (XN+LAMDA)*0.25

      YN = (YN+LAMDA)*0.25

      GO TO 20

C

C     POWER SERIES EVALUATION

   40 C1 = 3.0/14.0

      C2 = 9.0/88.0

      C3 = 9.0/52.0

      C4 = 1.0/6.0

      C5 = 9.0/22.0

      C6 = 3.0/26.0

      EA = CXN*CYN

      EB = CZN*CZN

      EC = 3.0*EA - 8.0*EB

      ED = EA - EB

      EF = EA - 6.0*EB

*      S21BCE = 3.0*SIGMA + POW4*(1.0+EF*(C2*EF-C1-C3*EC*CZN)+CZN*

      S21BCF = 3.0*SIGMA + POW4*(1.0+EF*(C2*EF-C1-C3*EC*CZN)+CZN*

     * (C4*EC+CZN*(CZN*C6*EA-C5*ED)))/(MU*SQRT(MU))

      GO TO 80

C

C     FAILURE EXITS

   60 IFAIL = P01AAE(IFAIL,IND,SRNAME)

*      S21BCE = 0.0

      S21BCF = 0.0

   80 RETURN

      END

      INTEGER FUNCTION P01AAE(IFAIL, ERROR, SRNAME)

C     MARK 1 RELEASE.  NAG COPYRIGHT 1971

C     MARK 3 REVISED

C     MARK 4A REVISED, IER-45

C     MARK 4.5 REVISED

C     MARK 7 REVISED (DEC 1978)

C     RETURNS THE VALUE OF ERROR OR TERMINATES THE PROGRAM.

      INTEGER ERROR, IFAIL, NOUT

C+SELF,IF=IBM.

      CHARACTER*8 SRNAME

C+SELF.

C     TEST IF NO ERROR DETECTED

      IF (ERROR.EQ.0) GO TO 20

C     DETERMINE OUTPUT UNIT FOR MESSAGE

      CALL X04AAE (0,NOUT)

C     TEST FOR SOFT FAILURE

      IF (MOD(IFAIL,10).EQ.1) GO TO 10

C     HARD FAILURE

      WRITE (NOUT,99999) SRNAME, ERROR

C     STOPPING MECHANISM MAY ALSO DIFFER

      STOP

C     SOFT FAIL

C     TEST IF ERROR MESSAGES SUPPRESSED

   10 IF (MOD(IFAIL/10,10).EQ.0) GO TO 20

      WRITE (NOUT,99999) SRNAME, ERROR

   20 P01AAE = ERROR

      RETURN

99999 FORMAT (1H0, 38HERROR DETECTED BY NAG LIBRARY ROUTINE , A8,

     * 11H - IFAIL = , I5//)

      END



      REAL*8 FUNCTION X02ABF(X)

C     NAG COPYRIGHT 1975

C     MARK 4.5 RELEASE

*      REAL X, Z

      REAL*8 X, Z

*+SELF,IF=R01.

*     DATA Z/Z00100000/

*+SELF,IF=R04.

*      DATA Z/0001 4000 0000 0000 0000B/

      DATA Z/1.D-15/

*+SELF.

C     * RMIN *

C     RETURNS THE VALUE OF THE SMALLEST POSITIVE REAL FLOATING-

C     POINT NUMBER EXACTLY REPRESENTABLE ON THE COMPUTER

C     THE X PARAMETER IS NOT USED

*      X02ABE = Z

      X02ABF = Z

      RETURN

      END

*+DECK,X02ACE.

*      REAL FUNCTION X02ACE(X)

      REAL*8 FUNCTION X02ACF(X)

C     NAG COPYRIGHT 1975

C     MARK 4.5 RELEASE

*      REAL X, Z

      REAL*8 X, Z

*+SELF,IF=R01.

*      DATA Z/Z7FFFFFFF/

*+SELF,IF=R04.

*    DATA Z/3776 7777 7777 7777 7777B/

      DATA Z/1.D+15/

*+SELF.

C     * RMAX *

C     RETURNS THE VALUE OF THE LARGEST POSITIVE REAL  FLOATING-

C     POINT NUMBER REPRESENTABLE ON THE COMPUTER

*      X02ACE = Z

      X02ACF = Z

      RETURN

      END



      SUBROUTINE X04AAE(I,NERR)

C     MARK 7 RELEASE. NAG COPYRIGHT 1978

C     MARK 7C REVISED IER-190 (MAY 1979)

C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER

C     (STORED IN NERR1).

C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO

C     VALUE SPECIFIED BY NERR.

C

C     *** NOTE ***

C     THIS ROUTINE ASSUMES THAT THE VALUE OF NERR1 IS SAVED

C     BETWEEN CALLS.  IN SOME IMPLEMENTATIONS IT MAY BE

C     NECESSARY TO STORE NERR1 IN A LABELLED COMMON

C     BLOCK /AX04AA/ TO ACHIEVE THIS.

C

C     .. SCALAR ARGUMENTS ..

      INTEGER I, NERR

C     ..

C     .. LOCAL SCALARS ..

      INTEGER NERR1

C     ..

C     DATA NERR1 /5/

      DATA NERR1 /6/

      IF (I.EQ.0) NERR = NERR1

      IF (I.EQ.1) NERR1 = NERR

      RETURN

      END

*     SUBROUTINE F02AFE(A, IA, N, RR, RI, INTGER, LFAIL)

      SUBROUTINE F02AFF(A, IA, N, RR, RI, INTGER, LFAIL)

C     MARK 2 RELEASE. NAG COPYRIGHT 1972

C     MARK 3 REVISED.

C     MARK 4.5 REVISED

C

C     EIGENVALUES OF A REAL UNSYMMETRIC MATRIX

C     1ST AUGUST 1971

C

      INTEGER P01AAE, ISAVE, LFAIL, N, IA, INTGER(N)

      CHARACTER*8 SRNAME

      REAL*8 ACC, XXXX, A(IA,N), RR(N), RI(N), X02AAE

      DATA SRNAME /'  F02AFE'/

      ISAVE = LFAIL

      LFAIL = 1

      ACC = X02AAE(XXXX)

      CALL F01AKF(N, 1, N, A, IA, INTGER)

      CALL F02APF(N, ACC, A, IA, RR, RI, INTGER, LFAIL)

      IF (LFAIL.NE.0) LFAIL = P01AAE(ISAVE,LFAIL,SRNAME)

      RETURN

      END

*     SUBROUTINE F02APE(NN, ACC, H, IH, WR, WI, ICNT, LFAIL)

      SUBROUTINE F02APF(NN, ACC, H, IH, WR, WI, ICNT, LFAIL)

C     MARK 2 RELEASE. NAG COPYRIGHT 1972

C     MARK 3 REVISED.

C     MARK 4 REVISED.

C     MARK 4.5 REVISED

C     MARK 7D REVISED IER-197 (JUL 1979)

C     MARK 7E REVISED IER-203 (JUL 1979)

C     MARK 8 REVISED. IER-234 (APR 1980).

C     MARK 9 REVISED. IER-326 (SEP 1981).

C

C     HQR

C     FINDS THE EIGENVALUES OF A REAL UPPER HESSENBERG MATRIX, H,

C     STORED IN THE ARRAY H(N,N), AND STORES THE REAL PARTS IN

C     THE ARRAY WR(N) AND THE IMAGINARY PARTS IN THE ARRAY

C     WI(N). ACC IS THE RELATIVE MACHINE PRECISION. THE

C     SUBROUTINE FAILS IF ALL EIGENVALUES TAKE MORE THAN 30*N

C     ITERATIONS.

C     1ST DECEMBER 1971

C

      INTEGER P01AAE, ISAVE, LFAIL, N, NN, ITS, NA, L, LL, I, M,

     * N2, MM, M2, M3, K, J, IH, ICNT(NN), NHS, ITN

      CHARACTER*8 SRNAME

      REAL*8 T, ACC, X, Y, W, S, Z, R, P, Q, H(IH,NN), WR(NN), WI(NN)

      REAL*8 NORM, X02ADE

      LOGICAL NOTLST

      DATA SRNAME /'  F02APE'/

      ISAVE = LFAIL

      LFAIL = 0

      T = 0.0

      N = NN

      ITN = 30*N

C     COMPUTE MATRIX NORM

      NORM = 0.0

      K = 1

      DO 30 I = 1,N

         DO 25 J = K,N

            NORM = NORM + ABS(H(I,J))

   25    CONTINUE

         K = I

   30 CONTINUE

      NHS = N*(N+1)/2 + N - 1

   20 IF (N.EQ.0) GO TO 600

      ITS = 0

      NA = N - 1

C     LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT

   40 L = N + 1

      IF (N.LT.2) GO TO 80

      DO 60 LL=2,N

         L = L - 1

         S = ABS(H(L-1,L-1)) + ABS(H(L,L))

         IF (S.LT.X02ADE(0.0D0)) S = NORM/FLOAT(NHS)

         IF (ABS(H(L,L-1)).LE.ACC*S) GO TO 100

   60 CONTINUE

   80 L = 1

  100 X = H(N,N)

      IF (L.EQ.N) GO TO 520

      Y = H(NA,NA)

      W = H(N,NA)*H(NA,N)

      IF (L.EQ.NA) GO TO 540

      IF (ITN.GT.0) GO TO 120

      LFAIL = P01AAE(ISAVE,1,SRNAME)

      RETURN

  120 IF ((ITS.EQ.10) .OR. (ITS.EQ.20)) GO TO 140

      GO TO 200

C     FORM EXCEPTIONAL SHIFT

  140 T = T + X

      IF (NA.LT.1) GO TO 180

      DO 160 I=1,NA

         H(I,I) = H(I,I) - X

  160 CONTINUE

  180 H(N,N) = 0.0

      S = ABS(H(N,NA)) + ABS(H(NA,N-2))

      X = 0.75*S

      Y = 0.75*S

      W = -0.4375*S**2

  200 ITS = ITS + 1

      ITN = ITN - 1

C     LOOK FOR TWO SMALL CONSECUTIVE SUB-DIAGONAL ELEMENTS

      IF (L.GT.(N-2)) GO TO 240

      M = N - 1

      N2 = N - 2

      DO 220 MM=L,N2

         M = M - 1

         Z = H(M,M)

         R = X - Z

         S = Y - Z

         P = (R*S-W)/H(M+1,M) + H(M,M+1)

         Q = H(M+1,M+1) - Z - R - S

         R = H(M+2,M+1)

         S = ABS(P) + ABS(Q) + ABS(R)

         P = P/S

         Q = Q/S

         R = R/S

         IF (M.EQ.L) GO TO 240

         IF ((ABS(H(M,M-1))*(ABS(Q)+ABS(R))).LE.(ACC*ABS(P)*

     *    (ABS(H(M-1,M-1))+ABS(Z)+ABS(H(M+1,M+1))))) GO TO 240

  220 CONTINUE

  240 M2 = M + 2

      IF (M2.GT.N) GO TO 280

      DO 260 I=M2,N

         H(I,I-2) = 0.0

  260 CONTINUE

  280 M3 = M + 3

      IF (M3.GT.N) GO TO 320

      DO 300 I=M3,N

         H(I,I-3) = 0.0

  300 CONTINUE

  320 IF (M.GT.NA) GO TO 40

C     DOUBLE QR STEP INVOLVING ROWS L TO N AND COLUMNS M TO N

      DO 500 K=M,NA

         NOTLST = .TRUE.

         IF (K.EQ.NA) NOTLST = .FALSE.

         IF (K.EQ.M) GO TO 340

         P = H(K,K-1)

         Q = H(K+1,K-1)

         R = 0.0

         IF (NOTLST) R = H(K+2,K-1)

         X = ABS(P) + ABS(Q) + ABS(R)

         IF (X.EQ.0.0) GO TO 500

         P = P/X

         Q = Q/X

         R = R/X

  340    S = SQRT(P**2+Q**2+R**2)

         IF (P.LT.0.0) S = -S

         IF (K.NE.M) GO TO 360

         IF (L.NE.M) H(K,K-1) = -H(K,K-1)

         GO TO 380

  360    H(K,K-1) = -S*X

  380    P = P + S

         X = P/S

         Y = Q/S

         Z = R/S

         Q = Q/P

         R = R/P

         IF (K.GT.N) GO TO 440

C     ROW MODIFICATION

         DO 420 J=K,N

            P = H(K,J) + Q*H(K+1,J)

            IF (.NOT.NOTLST) GO TO 400

            P = P + R*H(K+2,J)

            H(K+2,J) = H(K+2,J) - P*Z

  400       H(K+1,J) = H(K+1,J) - P*Y

            H(K,J) = H(K,J) - P*X

  420    CONTINUE

  440    J = N

         IF ((K+3).LT.N) J = K + 3

         IF (L.GT.J) GO TO 500

C     COLUMN MODIFICATION

         DO 480 I=L,J

            P = X*H(I,K) + Y*H(I,K+1)

            IF (.NOT.NOTLST) GO TO 460

            P = P + Z*H(I,K+2)

            H(I,K+2) = H(I,K+2) - P*R

  460       H(I,K+1) = H(I,K+1) - P*Q

            H(I,K) = H(I,K) - P

  480    CONTINUE

  500 CONTINUE

      GO TO 40

C     ONE ROOT FOUND

  520 WR(N) = X + T

      WI(N) = 0.0

      ICNT(N) = ITS

      N = NA

      GO TO 20

C     TWO ROOTS FOUND

  540 P = (Y-X)/2.0

      Q = P**2 + W

      Y = SQRT(ABS(Q))

      X = X + T

      ICNT(N) = -ITS

      ICNT(NA) = ITS

      IF (Q.GT.0.0) GO TO 560

C     COMPLEX PAIR

      WR(NA) = X + P

      WR(N) = X + P

      WI(NA) = Y

      WI(N) = -Y

      GO TO 580

C     REAL PAIR

  560 IF (P.LT.0.0) Y = -Y

      Y = P + Y

      WR(NA) = X + Y

      WR(N) = X - W/Y

      WI(N) = 0.0

      WI(NA) = 0.0

  580 N = N - 2

      GO TO 20

  600 RETURN

      END

*     SUBROUTINE F01AKE(N, K, L, A, IA, INTGER)

      SUBROUTINE F01AKF(N, K, L, A, IA, INTGER)

C     MARK 2 RELEASE. NAG COPYRIGHT 1972

C     MARK 4 REVISED.

C     MARK 4.5 REVISED

C     MARK 8 REVISED. IER-248 (JUN 1980).

C

C     DIRHES

C     AUGUST 1ST, 1971 .

C     GIVEN THE UNSYMMETRIC MATRIX, A, STORED IN THE ARRAY A(N,N),

C     THIS SUBROUTINE REDUCES THE SUB-MATRIX OF ORDER L - K + 1,

C     WHICH STARTS AT THE ELEMENT A(K,K) AND FINISHES AT THE

C     ELEMENT A(L,L), TO HESSENBERG FORM, H, BY THE DIRECT

C     METHOD(AN = NH). THE MATRIX H IS OVERWRITTEN ON A WITH

C     DETAILS OF THE TRANSFORMATIONS (N) STORED IN THE REMAINING

C     TRIANGLE UNDER H AND IN ELEMENTS K TO L OF THE ARRAY

C     INTGER(N).

C     1ST AUGUST 1971

C

      INTEGER IFAIL1, K1, K, L, J, M, I, N, J1, IA, IJ, INTGER(N)

      REAL*8 X, Y, D2, A(IA,N)

      IFAIL1 = 0

      K1 = K + 1

      IF (K1.GT.N) RETURN

      DO 200 J=K1,N

         M = J

         X = 0.0

         IF (J.GT.L) GO TO 120

         DO 20 I=J,L

            IF (ABS(A(I,J-1)).LE.ABS(X)) GO TO 20

            X = A(I,J-1)

            M = I

   20    CONTINUE

         INTGER(J) = M

         IF (M.EQ.J) GO TO 80

C     INTERCHANGE ROWS AND COLUMNS OF A.

         DO 40 I=K,N

            Y = A(M,I)

            A(M,I) = A(J,I)

            A(J,I) = Y

   40    CONTINUE

         DO 60 I=1,L

            Y = A(I,M)

            A(I,M) = A(I,J)

            A(I,J) = Y

   60    CONTINUE

   80    IF (X.EQ.0.0) GO TO 120

         IF (J.EQ.L) GO TO 120

         J1 = J + 1

         DO 100 I=J1,L

            A(I,J-1) = A(I,J-1)/X

  100    CONTINUE

  120    DO 180 I=1,L

            Y = A(I,J)

            D2 = 0.0

            IF (X.EQ.0.0) GO TO 140

            IF (J.GE.L) GO TO 140

            J1 = J + 1

            CALL X03AAF(A(I,J1), (N-J)*IA-I+1, A(J1,J-1),

     *       (N-J+2)*IA-J, L-J, IA, 1, Y, D2, Y, D2, .TRUE., IFAIL1)

  140       IJ = J

            IF (I.LE.J) IJ = I - 1

            Y = -Y

            D2 = -D2

            IF ((K+1).GT.IJ) GO TO 160

            CALL X03AAF(A(I,K), (N-K+1)*IA-I+1, A(K1,J),

     *       (N-J+1)*IA-K, IJ-K, IA, 1, Y, D2, Y, D2, .TRUE.,

     *       IFAIL1)

  160       A(I,J) = -Y

  180    CONTINUE

  200 CONTINUE

      RETURN

      END

*+PATCH,TEXTX03.

*+DECK,X03AAE.

*     SUBROUTINE X03AAE(A, ISIZEA, B, ISIZEB, N, ISTEPA, ISTEPB,

      SUBROUTINE X03AAF(A, ISIZEA, B, ISIZEB, N, ISTEPA, ISTEPB,

     * C1, C2, D1, D2, SW, IFAIL)

C     NAG COPYRIGHT 1975

C     MARK 4.5 RELEASE

C     MARK 6 REVISED

C

C     CALCULATES THE VALUE OF A SCALAR PRODUCT USING BASIC

C     OR ADDITIONAL PRECISION AND ADDS IT TO A BASIC OR ADDITIONAL

C     PRECISION INITIAL VALUE.

C

      INTEGER P01AAE, ISAVE, ISIZEA, ISIZEB, ISTEPA, ISTEPB, IFAIL,

     * IS, IT, N, I

      DOUBLE PRECISION SUM

*+SELF,IF=IBM.

      CHARACTER*8 SRNAME

*+SELF.

      REAL*8 A(ISIZEA), B(ISIZEB), C1, C2, D1, D2, X

      LOGICAL SW

      DATA SRNAME /8H X03AAE /

      ISAVE = IFAIL

      IFAIL = 0

      IF (ISTEPA.GT.0 .AND. ISTEPB.GT.0) GO TO 20

      IFAIL = P01AAE(ISAVE,1,SRNAME)

      RETURN

   20 IS = 1 - ISTEPA

      IT = 1 - ISTEPB

      IF (SW) GO TO 80

      X = 0.0

      IF (N.LT.1) GO TO 60

      DO 40 I=1,N

         IS = IS + ISTEPA

         IT = IT + ISTEPB

         X = X + A(IS)*B(IT)

   40 CONTINUE

   60 D1 = X + (C1+C2)

      D2 = 0.0

      RETURN

   80 SUM = 0.0D0

      IF (N.LT.1) GO TO 120

      DO 100 I=1,N

         IS = IS + ISTEPA

         IT = IT + ISTEPB

         SUM = SUM + DBLE(A(IS))*B(IT)

  100 CONTINUE

  120 SUM = SUM + (DBLE(C1)+C2)

      D1 = SUM + SUM - DBLE(SNGL(SUM))

C     THE LAST STATEMENT ASSUMES THAT THE MACHINE SIMPLY

C     TRUNCATES WHEN ASSIGNING A DOUBLE PRECISION QUANTITY

C     TO A SINGLE PRECISION VARIABLE. IF INSTEAD THE MACHINE

C     ROUNDS, REPLACE THE LAST STATEMENT BY

C     D1 = SUM

      D2 = SUM - D1

      RETURN

      END

*PATCH,TEXTX02.

*DECK,X02AAE.

      REAL*8 FUNCTION X02AAE(X)

C     NAG COPYRIGHT 1975

C     MARK 4.5 RELEASE

      REAL*8 X, Z

*SELF,IF=R01.

C      DATA Z/Z3C100000/

*SELF,IF=R04.

C      DATA Z/1641 4000 0000 0000 0000B/

      DATA Z/1.D-15/

*SELF.

C     * EPS *

C     RETURNS THE VALUE EPS WHERE EPS IS THE SMALLEST

C     POSITIVE

C     NUMBER SUCH THAT 1.0 + EPS > 1.0

C     THE X PARAMETER IS NOT USED

      X02AAE = Z

      RETURN

      END

*+DECK,X02ADE.

      REAL*8 FUNCTION X02ADE(X)

C     NAG COPYRIGHT 1975

C     MARK 4.5 RELEASE

      REAL*8 X, Z

*+SELF,IF=R01.

*       DATA Z/Z05100000/

*+SELF,IF=R04.

*      DATA Z/0060 4000 0000 0000 0000B/

*+SELF.

      DATA Z/1.D-15/

C     * TOL *

C     RETURNS THE RATIO OF THE SMALLEST POSITIVE REAL FLOATING-

C     POINT NUMBER REPRESENTABLE ON THE COMPUTER TO EPS

      X02ADE = Z

      RETURN

      END

*+DECK,X02ADE.

      SUBROUTINE E04ABE(FUN, EPS, T, A, B, MAXCAL, X, F, IFAIL)

C

C     MARK 6 RELEASE NAG COPYRIGHT 1977

C     MARK 8 REVISED. IER-231 (MAR 1980).

C     MARK 8D REVISED. IER-272 (DEC 1980).

C

C     **************************************************************

C

C     E04ABE ATTEMPTS TO FIND A MINIMUM IN AN INTERVAL A .LE. X .LE.

C     B OF A FUNCTION F(X) OF THE SCALAR X, USING FUNCTION VALUES

C     ONLY.

C

C     IT IS BASED ON THE SUBROUTINE UNIFUN IN THE NPL ALGORITHMS

C     LIBRARY (REF. NO. E4/13/F). THE FUNCTION F(X) IS DEFINED BY

C     THE USER-SUPPLIED SUBROUTINE FUN. T AND EPS DEFINE A TOLERANCE

C     TOL = EPS * ABS(X) + T, AND FUN IS NEVER EVALUATED AT TWO

C     POINTS CLOSER THAN TOL. IF FUN IS DELTA-UNIMODAL, FOR SOME

C     DELTA LESS THAN TOL, THEN X APPROXIMATES THE GLOBAL MINIMUM OF

C     FUN WITH AN ERROR LESS THAN 3*TOL. IF FUN IS NOT DELTA-

C     UNIMODAL ON (A, B), THEN X MAY APPROXIMATE A LOCAL, BUT NON

C     GLOBAL, MINIMUM. EPS SHOULD BE NO SMALLER THAN 2*EPSMCH, AND

C     PREFERABLY NOT MUCH LESS THAN SQRT(EPSMCH), WHERE EPSMCH IS

C     THE RELATIVE MACHINE PRECISION. T SHOULD BE POSITIVE. NOTE

C     THAT, FOR CONSISTENCY WITH OTHER E04 DOCUMENTATION, THE NAME

C     FUNCT IS USED INSTEAD OF FUN IN THE WRITE-UP.

C

C     PHILIP E. GILL, WALTER MURRAY, SUSAN M. PICKEN, HAZEL M.

C     BARBER AND MARGARET H. WRIGHT, D.N.A.C., NATIONAL PHYSICAL

C     LABORATORY, ENGLAND

C

C     **************************************************************

C

C     .. SCALAR ARGUMENTS ..

      REAL*8 A, B, EPS, F, T, X

      INTEGER IFAIL, MAXCAL

C     .. SUBROUTINE ARGUMENTS ..

C     FUN

C     ..

C     .. LOCAL SCALARS ..

      CHARACTER*8 SRNAME

      REAL*8 B1, D, E, EPSMCH, F1, F2, FA, FU, FV, FW, GTEST1,

     * GTEST2, GU, OLDF, PT2, PT4, PT6, RR, RTEPS, SCXBD, SS, TOL,

     * U, X1, X2, XLAMDA, XV, XW, SFTBND

      INTEGER IFLAG, ILOC, ISAVE, NUMF

C     .. FUNCTION REFERENCES ..

      REAL*8 SQRT, XARG, X02AAE

      INTEGER P01AAE

	SQRT(XARG)=DSQRT(XARG)



C     .. SUBROUTINE REFERENCES ..

C     ABZE04

C     ..

      DATA SRNAME /'  E04ABE'/

      ISAVE = IFAIL

C

C     A MACHINE-DEPENDENT CONSTANT IS SET HERE. EPSMCH IS THE

C     SMALLEST POSITIVE REAL NUMBER SUCH THAT 1.0 + EPSMCH .GT. 1.0

C

      EPSMCH = X02AAE(U)

      RTEPS = SQRT(EPSMCH)

      IF (EPS.LT.EPSMCH) EPS = RTEPS

      IF (T.LT.EPSMCH) T = RTEPS

C

C     ERROR IN INPUT PARAMETERS

C

      IFAIL = 1

      IF (A+T.GE.B .OR. MAXCAL.LT.3 .OR. IFAIL.LT.0 .OR.

     * IFAIL.GT.1) GO TO 140

      SFTBND = A

      PT2 = (B-A)*2.0E-1

      PT4 = PT2 + PT2

      PT6 = PT2 + PT4

      X1 = A + PT4

      CALL FUN(X1, F1)

      X2 = B - PT4

      CALL FUN(X2, F2)

      XLAMDA = B

      IF (F1.GT.F2) GO TO 20

      X = X1

      A = -PT4

      B = PT2

      XW = PT2

      B1 = PT2

      RR = 1.0E+0

      D = -PT2

      FW = F2

      FV = F1

      F = F1

C

C     SET STEP TO NEW POINT

C

      U = -PT2

      GO TO 40

   20 X = X2

      A = -PT2

      B = PT4 + EPS*ABS(XLAMDA) + T

      XW = -PT2

      B1 = B

      RR = -1.0E+0

      D = PT2

      FW = F1

      FV = F2

      F = F2

C

C     SET STEP TO NEW POINT

C

      U = PT2

   40 XV = 0.0E+0

      SCXBD = PT4

      E = PT6

      SS = 0.0E+0

      FA = FW + T

      OLDF = FA

      GTEST1 = 0.0E+0

      GTEST2 = 0.0E+0

      TOL = EPS*ABS(X) + T

      CALL FUN(X+U, FU)

      GU = 0.0E+0

      NUMF = 3

C

C     SET ILOC TO 3 SO THAT THE MAIN SECTION OF ABZE04 IS EXECUTED

C     AS THE INITIAL 3 POINTS HAVE ALREADY BEEN SET UP

C

      ILOC = 3

   60 CALL ABZE04(EPS, T, 0.0D+0, SFTBND, XLAMDA, U, FU, GU, X, F,

     * XW, FW, XV, FV, A, FA, B, OLDF, B1, SCXBD, E, D, RR, SS,

     * GTEST1, GTEST2, TOL, ILOC, IFLAG)

      IF (IFLAG.NE.1) GO TO 100

      IF (NUMF.GE.MAXCAL) GO TO 80

      CALL FUN(X+U, FU)

      NUMF = NUMF + 1

      GO TO 60

   80 IFAIL = 2

      GO TO 120

  100 IFAIL = 0

  120 MAXCAL = NUMF

      A = A + X

      B = B + X

  140 CONTINUE

      IF (IFAIL.EQ.0) RETURN

      IFAIL = P01AAE(ISAVE,IFAIL,SRNAME)

      RETURN

C

C     END OF E04ABE (UNIFUN)

C

      END

      SUBROUTINE ABZE04(EPS, T, ETA, SFTBND, XLAMDA, U, FU, GU,

     * XMIN, FMIN, XW, FW, XV, FV, A, FA, B, OLDF, B1, SCXBD, E, D,

     * RR, SS, GTEST1, GTEST2, TOL, ILOC, ITEST)

C

C     MARK 6 RELEASE NAG COPYRIGHT 1977

C     MARK 7 REISSUE

C     MARK 8 REVISED. IER-239 (APR 1980).

C     MARK 8 REVISED. IER-244 (MAY 1980).

C     MARK 9 REVISED. IER-317 (SEP 1981).

C

C     **************************************************************

C

C     ABZE04 (NEWPTQ), AN ALGORITHM FOR FINDING A STEPLENGTH, CALLED

C     REPEATEDLY BY NPL OPTIMIZATION ROUTINES WHICH REQUIRE A STEP-

C     LENGTH TO BE COMPUTED USING QUADRATIC INTERPOLATION.

C     THE PARAMETERS SET UP BEFORE THE CALL OF ABZE04 CONTAIN

C     INFORMATION ABOUT THE INTERVAL IN WHICH A LOWER POINT IS TO BE

C     FOUND AND FROM THIS ABZE04 PRODUCES A POINT AT WHICH THE

C     FUNCTION CAN BE EVALUATED OUTSIDE THIS SUBROUTINE.

C     THE VALUE OF THE INTEGER PARAMETER ILOC DETERMINES THE PATH

C     TAKEN THROUGH THE CODE. FOR A FURTHER DESCRIPTION OF ILOC

C     AND THE OTHER PARAMETERS SEE NPL ALGORITHMS LIBRARY REF. NO.

C     E4/15/F.

C

C     PHILIP E. GILL, WALTER MURRAY, SUSAN M. PICKEN,

C     MARGARET H. WRIGHT AND ENID M. LONG

C     D.N.A.C. NATIONAL PHYSICAL LABORATORY, ENGLAND

C

C     **************************************************************

C

C     .. SCALAR ARGUMENTS ..

      REAL*8 A, B1, B, D, E, EPS, ETA, FA, FMIN, FU, FV, FW, GTEST1,

     * GTEST2, GU, OLDF, RR, SCXBD, SFTBND, SS, T, TOL, U, XLAMDA,

     * XMIN, XV, XW

      INTEGER ILOC, ITEST

C     ..

C     .. LOCAL SCALARS ..

      REAL*8 A1, D1, D2, Q, R, S, T2, XM

C     .. FUNCTION REFERENCES ..

      REAL*8 SQRT, XARG

	SQRT(XARG)=DSQRT(XARG)

C     ..

C

C     BRANCH TO APPROPRIATE SECTION OF CODE DEPENDING ON THE

C     VALUE OF THE FLAG ILOC

C     THE SIGNIFICANCE OF THE FLAGS ILOC AND ITEST ARE DESCRIBED IN

C     NPL ALGORITHMS LIBRARY DOCUMENT REF. NO. E4/15/F.

C

      GO TO (20, 40, 40, 460, 440), ILOC

C

C     ILOC = 1

C

C     CHECK INPUT PARAMETERS

C

   20 ITEST = 2

      TOL = T

      T2 = TOL + TOL

      IF (U.LE.0.0E+0 .OR. XLAMDA.LE.T2 .OR. GU.GT.0.0E+0) RETURN

      ITEST = 1

C

C     A AND B DEFINE THE INTERVAL OF UNCERTAINTY. XMIN DENOTES

C     THE LOWEST POINT OBTAINED SO FAR, XW THE LAST VALUE

C     OF XMIN AND XV THE SCALED VALUE OF ALPHA CORRESPONDING TO

C     THE HIGHEST FUNCTION VALUE OF THE THREE POINTS THROUGH

C     WHICH A PARABOLA MAY BE FITTED. INITIALIZE A, XV, XW, XMIN

C     AT ORIGIN AND CORRESPONDING FUNCTION VALUES AT LATEST

C     ESTIMATE OF MINIMUM.

C

      XMIN = 0.0E+0

      XW = 0.0E+0

      XV = 0.0E+0

      A = 0.0E+0

      OLDF = FU

      FMIN = FU

      FW = FU

      FV = FU

      FA = FU

      D = U

C

C     THE PARAMETER RR HAS TWO USES DURING THE EXECUTION OF THIS

C     SUBROUTINE.  INITIALLY THE SIGN OF RR INDICATES WHETHER OR NOT

C     THE MINIMUM HAS BEEN BRACKETED. LATER, WHEN A POINT SATISFYING

C     THE GTEST2 CRITERION HAS BEEN FOUND, RR IS USED TO COMPUTE A

C     STEPLENGTH WHICH SATISFIES THE SECOND CRITERION INVOLVING

C     GTEST1.

C

      RR = -1.0E+0

C

C     SET UP XBND AS A BOUND ON THE STEP TO BE TAKEN. (XBND IS NOT

C     COMPUTED EXPLICITLY BUT SCXBD IS ITS SCALED VALUE.) SET THE

C     UPPER BOUND ON THE INTERVAL OF UNCERTAINTY INITIALLY TO

C     XLAMDA + TOL(XLAMDA).

C

      SCXBD = XLAMDA

      B = SCXBD + EPS*ABS(SCXBD) + T

      E = 2.0E+0*B

      B1 = B

C

C     COMPUTE THE CONSTANTS REQUIRED FOR THE TWO CONVERGENCE

C     CRITERIA.

C

      GTEST1 = -1.0E-4*GU

      GTEST2 = -ETA*GU

C

C     SET ILOC TO INDICATE THAT ONLY TWO POINTS ARE AVAILABLE

C

      ILOC = 2

      GO TO 380

C

C     ILOC = 2 OR 3

C

C     UPDATE A, B, XV, XW, AND XMIN.

C

   40 IF (FU.GT.FMIN) GO TO 100

C

C     IF FUNCTION VALUE NOT INCREASED, NEW POINT BECOMES

C     NEXT ORIGIN AND OTHER POINTS ARE SCALED ACCORDINGLY.

C

      IF (U.LT.0.0E+0) GO TO 60

      A = 0.0E+0

      FA = FMIN

      IF (XW.EQ.XV .AND. FMIN.EQ.FU) RR = 1.0E+0

      GO TO 80

   60 B = 0.0E+0

      RR = 1.0E+0

   80 XV = XW

      FV = FW

      FW = FMIN

      FMIN = FU

      XMIN = XMIN + U

      A = A - U

      B = B - U

      XV = XV - U

      XW = 0.0E+0 - U

C

C     THIS MAY BE CHANGED TO XW = - U IF THE COMPUTER IS

C     SUCH THAT  - U AND 0.0 - U ARE IDENTICAL.

C

      SCXBD = SCXBD - U

      TOL = EPS*ABS(XMIN) + T

      GO TO 180

C

C     IF FUNCTION VALUE INCREASED, ORIGIN REMAINS UNCHANGED

C     BUT OTHER POINTS MAY BE INTERCHANGED.

C

  100 IF (U.GE.0.0E+0) GO TO 120

      A = U

      FA = FU

      GO TO 140

  120 B = U

      RR = 1.0E+0

  140 IF (FU.GT.FW .AND. XW.NE.0.0E+0) GO TO 160

      XV = XW

      FV = FW

      XW = U

      FW = FU

      GO TO 180

  160 XV = U

      FV = FU

  180 T2 = TOL + TOL

      XM = 5.0E-1*(A+B)

C

C     CHECK TERMINATION CRITERIA.

C

      IF (ABS(XM).LE.T2-5.0E-1*(B-A) .OR. XMIN+B.LE.SFTBND .OR.

     * FA-FMIN.LE.ABS(A)*GTEST2 .AND. FMIN.LT.OLDF .AND.

     * (ABS(XMIN-XLAMDA).GT.TOL .OR. RR.LT.0.0E+0)) GO TO 420

      R = 0.0E+0

      Q = 0.0E+0

      S = 0.0E+0

      IF (ABS(E).LE.TOL) GO TO 240

C

C     FIT PARABOLA THROUGH XMIN, XV, XW.

C

      IF (ILOC.NE.2) GO TO 200

C

C     SPECIAL CASE. ONLY TWO POINTS ARE AVAILABLE FOR

C     QUADRATIC INTERPOLATION

C

      Q = 2.0E+0*(FW-FMIN-XW*GU)

      S = GU*XW*XW

      IF (XMIN.NE.0.0E+0) S = (2.0E+0*(FMIN-FW)+XW*GU)*XW

      GO TO 220

  200 R = XW*(FV-FMIN)

      Q = XV*(FW-FMIN)

      S = R*XW - Q*XV

      Q = 2.0E+0*(Q-R)

  220 IF (Q.GT.0.0E+0) S = -S

      IF (Q.LE.0.0E+0) Q = -Q

      R = E

C

C     IF THE LAST STEP EXPANDED THE INTERVAL OR THE MINIMUM HAS

C     ALREADY BEEN BRACKETED SET E AS THE LAST STEP TAKEN

C

      IF (D.NE.B1 .OR. RR.GT.0.0E+0) E = D

C

C     CONSTRUCT AN ARTIFICIAL BOUND ON THE ESTIMATED STEPLENGTH.

C

  240 A1 = A

      B1 = B

      IF (XMIN.NE.A) GO TO 260

      D = XM

      GO TO 330

  260 IF (RR.GT.0.0E+0) GO TO 280

      D = -4.0E+0*A

      IF (D.GE.SCXBD) D = SCXBD

      GO TO 320

C

C     DETERMINE INTERVAL OF LENGTH D2 IN WHICH TO SET

C     ARTIFICIAL BOUND.

C

  280 D1 = A

      D2 = B

      IF (ABS(D2).GT.TOL .AND. (XW.LE.0.0E+0 .OR. ABS(D1).LE.TOL))

     * GO TO 300

      U = D1

      D1 = D2

      D2 = U

  300 U = -D1/D2

      IF (U.GE.1.0E+0) D = 5.0E+0*D2*(1.0E-1+1.0E+0/U)/1.1E+1

      IF (U.LT.1.0E+0) D = 5.0E-1*D2*SQRT(U)

C

C     IF THE MINIMUM IS BRACKETED BY XV AND XW THE STEP MUST LIE

C     WITHIN (A, B).

C

  320 IF (XW.LT.0.0E+0 .AND. XV.GT.0.0E+0 .OR. XW.GT.0.0E+0 .AND.

     * XV.LT.0.0E+0) GO TO 330

C

C     IF THE MINIMUM IS NOT BRACKETED BY XV AND XW THE STEP MUST LIE

C     WITHIN (A1, B1).

C

      IF (D.LE.0.0E+0) A1 = D

      IF (D.GT.0.0E+0) B1 = D

C

C     REJECT THE STEP OBTAINED BY INTERPOLATION IF IT LIES OUTSIDE

C     THE REQUIRED INTERVAL OR IT IS GREATER THAN HALF THAT

C     OBTAINED DURING THE LAST-BUT-ONE ITERATION.

C

  330 IF (ABS(S).GE.ABS(5.0E-1*Q*R) .OR. S.LE.Q*A1 .OR. S.GE.Q*B1)

     * GO TO 340

C

C     A PARABOLIC INTERPOLATION STEP.

C

      D = S/Q

C

C     F MUST NOT BE EVALUATED TOO CLOSE TO A OR B.

C

      IF (D-A.GE.T2 .AND. B-D.GE.T2) GO TO 360

      D = TOL

      IF (XM.LE.0.0E+0) D = -TOL

      GO TO 360

C

C     A NON-INTERPOLATION STEP.

C

  340 E = B

      IF (XM.LE.0.0E+0) E = A

  360 ILOC = 3

C

C     CHECK THAT THE NEW STEP LENGTH WILL NOT BE GREATER THAN

C     XLAMDA.

C

  380 IF (D.LT.SCXBD) GO TO 400

C

C     REPLACE THE STEP LENGTH BY THE SCALED BOUND (SO AS TO COMPUTE

C     THE NEW POINT ON THE BOUNDARY.

C

      D = SCXBD

C

C     MOVE SCXBD TO THE LEFT SO THAT NEWXBND + TOL(NEWXBND) = XBND.

C

      SCXBD = (SCXBD - TOL)/(1.0E+0 + EPS)

  400 U = D

      IF (ABS(D).LT.TOL .AND. D.LE.0.0E+0) U = -TOL

      IF (ABS(D).LT.TOL .AND. D.GT.0.0E+0) U = TOL

      ITEST = 1

      RETURN

C

C     THE FIRST CONVERGENCE CRITERION HAS BEEN SATISFIED. NOW CHECK

C     THAT THE FUNCTION VALUE HAS BEEN REDUCED SUFFICIENTLY. THE

C     VARIABLE RR IS NOW USED TO REDUCE THE STEP LENGTH.

C

  420 D = RR

      RR = XMIN

      SS = 5.0E-1

      FU = FMIN

      IF (XMIN.EQ.0.0E+0) XMIN = T

C

C     IF XMIN LIES WITHIN TOL OF THE BOUNDARY AND THE MINIMUM HAS

C     BEEN BRACKETED, THEN RECOMPUTE THE POINT ON THE BOUNDARY.

C

  440 IF (ABS(XMIN-XLAMDA).GE.TOL .OR. XMIN.EQ.T) GO TO 460

      IF (SCXBD.LT.0.0E+0 .AND. XW.LT.0.0E+0 .AND. XV.LT.0.0E+0)

     * XMIN = XLAMDA

      IF (D.LT.0.0E+0) GO TO 460

      U = 0.0E+0

      ILOC = 4

      ITEST = 1

      RETURN

C

C     CHECK THAT THE NEW POINT SATISFIES SAFEGUARD CONDITIONS.

C     IF NECESSARY ATTEMPT TO FIND A SUFFICIENTLY LOWER POINT

C     BY SUCCESSIVELY DECREASING THE STEPLENGTH.

C

  460 IF (XMIN+B.GT.SFTBND) GO TO 480

      ITEST = 4

C

C     ITEST = 4 IMPLIES THAT THE REQUIRED STEP LENGTH IS SMALLER

C     THAN SFTBND.

C

      RETURN

  480 IF (OLDF-FU.LE.GTEST1*XMIN) GO TO 500

      FMIN = FU

      ITEST = 0

C

C     THE ALGORITHM HAS SUCCESSFULLY FOUND A SUFFICIENTLY LOWER

C     POINT.

C

      RETURN

  500 IF (XMIN.NE.T) GO TO 520

      ITEST = 3

C

C     DESPITE REPEATED REDUCTIONS IN THE STEP SIZE, A LOWER POINT

C     COULD NOT BE FOUND.

C

      RETURN

C

C     A SUFFICIENT REDUCTION IN THE FUNCTION VALUE HAS NOT YET BEEN

C     FOUND, TRY A FURTHER REDUCTION IN THE STEP LENGTH.

C

  520 XMIN = RR*SS

      SS = SS*SS

      IF (XMIN.LT.T) XMIN = T

      ITEST = 1

      U = 0.0E+0

      ILOC = 5

      RETURN

C

C     END OF ABZE04 (NEWPTQ)

C

      END

C

      SUBROUTINE E01BAF(M, X, Y, K, C, LCK, WRK, LWRK, IFAIL)

C     MARK 8 RELEASE. NAG COPYRIGHT 1979.

C

C     ******************************************************

C

C     NPL ALGORITHMS LIBRARY ROUTINE SP3INT

C

C     CREATED 16/5/79.                        RELEASE 00/00

C

C     AUTHORS ... GERALD T. ANTHONY, MAURICE G.COX

C                 J.GEOFFREY HAYES AND MICHAEL A. SINGER.

C     NATIONAL PHYSICAL LABORATORY, TEDDINGTON,

C     MIDDLESEX TW11 OLW, ENGLAND

C

C     ******************************************************

C

C     E01BAE.  AN ALGORITHM, WITH CHECKS, TO DETERMINE THE

C     COEFFICIENTS IN THE B-SPLINE REPRESENTATION OF A CUBIC

C     SPLINE WHICH INTERPOLATES (PASSES EXACTLY THROUGH) A

C     GIVEN SET OF POINTS.

C

C     INPUT PARAMETERS

C        M        THE NUMBER OF DISTINCT POINTS WHICH THE

C                    SPLINE IS TO INTERPOLATE.

C                    (M MUST BE AT LEAST 4.)

C        X        ARRAY CONTAINING THE DISTINCT VALUES OF THE

C                    INDEPENDENT VARIABLE. NB X(I) MUST BE

C                    STRICTLY GREATER THAN X(J) WHENEVER I IS

C                    STRICTLY GREATER THAN J.

C        Y        ARRAY CONTAINING THE VALUES OF THE DEPENDENT

C                    VARIABLE.

C        LCK      THE SMALLER OF THE ACTUALLY DECLARED DIMENSIONS

C                    OF K AND C. MUST BE AT LEAST M + 4.

C

C     OUTPUT PARAMETERS

C        K        ON SUCCESSFUL EXIT, K CONTAINS THE KNOTS

C                    SET UP BY THE ROUTINE. IF THE SPLINE IS

C                    TO BE EVALUATED (BY NPL ROUTINE E02BEF,

C                    FOR EXAMPLE) THE ARRAY K MUST NOT BE

C                    ALTERED BEFORE CALLING THAT ROUTINE.

C        C        ON SUCCESSFUL EXIT, C CONTAINS THE B-SPLINE

C                    COEFFICIENTS OF THE INTERPOLATING SPLINE.

C                    THESE ARE ALSO REQUIRED BY THE EVALUATING

C                    ROUTINE E02BEF.

C        IFAIL    FAILURE INDICATOR

C                    0 - SUCCESSFUL TERMINATION.

C                    1 - ONE OF THE FOLLOWING CONDITIONS HAS

C                        BEEN VIOLATED -

C                        M AT LEAST 4

C                        LK AT LEAST M + 4

C                        LWORK AT LEAST 6 * M + 16

C                    2 - THE VALUES OF THE INDEPENDENT VARIABLE

C                        ARE DISORDERED. IN OTHER WORDS, THE

C                        CONDITION MENTIONED UNDER X IS NOT

C                        SATISFIED.

C

C     WORKSPACE (AND ASSOCIATED DIMENSION) PARAMETERS

C        WRK     WORKSPACE ARRAY, OF LENGTH LWRK.

C        LWRK    ACTUAL DECLARED DIMENSION OF WRK.

C                    MUST BE AT LEAST 6 * M + 16.

C

C     .. SCALAR ARGUMENTS ..

      INTEGER IFAIL, LCK, LWRK, M

C     .. ARRAY ARGUMENTS ..

      REAL*8 C(LCK), K(LCK), WRK(LWRK), X(M), Y(M)

C     ..

C     .. LOCAL SCALARS ..



c      DOUBLE PRECISION SRNAME

      CHARACTER*8 SRNAME



      REAL*8 ONE, SS

      INTEGER I, IERROR, M1, M2

C     .. FUNCTION REFERENCES ..

      INTEGER P01AAE

C     .. SUBROUTINE REFERENCES ..

C     E02BAE

C     ..

      DATA ONE /1.0E+0/

      DATA SRNAME /'  E01BAE'/

      IERROR = 1

C

C     TESTS FOR ADEQUACY OF ARRAY LENGTHS AND THAT M IS GREATER

C     THAN 4.

C

      IF (LWRK.LT.6*M+16 .OR. M.LT.4) GO TO 80

      IF (LCK.LT.M+4) GO TO 80

C

C     TESTS FOR THE CORRECT ORDERING OF THE X(I)

C

      IERROR = 2

      DO 20 I=2,M

         IF (X(I).LE.X(I-1)) GO TO 80

   20 CONTINUE

C

C     INITIALISE THE ARRAY OF KNOTS AND THE ARRAY OF WEIGHTS

C

      WRK(1) = ONE

      WRK(2) = ONE

      WRK(3) = ONE

      WRK(4) = ONE

      IF (M.EQ.4) GO TO 60

      DO 40 I=5,M

         K(I) = X(I-2)

         WRK(I) = ONE

   40 CONTINUE

   60 M1 = M + 1

      M2 = M1 + M

C

C     CALL THE SPLINE FITTING ROUTINE

C

      IERROR = 0

      CALL E02BAF(M, M+4, X, Y, WRK, K, WRK(M1), WRK(M2), C, SS,

     * IERROR)

C

C     ALL THE TESTS PERFORMED BY E02BAE ARE REDUNDANT

C     BECAUSE OF THE ABOVE TESTS AND ASSIGNMENTS, AND SO

C     IERROR = 0 AFTER THIS CALL.

C

   80 IFAIL = P01AAE(IFAIL,IERROR,SRNAME)

      RETURN

C

C     END OF E01BAE.

C

      END

      SUBROUTINE E02BCF(NCAP7, K, C, X, LEFT, S, IFAIL)

C     MARK 7 RELEASE. NAG COPYRIGHT 1978.

C

C     **************************************************

C     *                                                *

C     *         NAG LIBRARY SUBROUTINE  E02BCE         *

C     *                                                *

C     *  EVALUATION OF CUBIC SPLINE AND ITS            *

C     *  DERIVATIVES FROM ITS B-SPLINE REPRESENTATION  *

C     *                                                *

C     *  ROUTINE CREATED ... 17 NOV 1977               *

C     *  LATEST UPDATE ....  24 APR 1978               *

C     *  RELEASE NUMBER ...  01                        *

C     *  AUTHORS ... MAURICE G. COX AND                *

C     *              J. GEOFFREY HAYES, N.P.L.         *

C     *                                                *

C     **************************************************

C

C     .. SCALAR ARGUMENTS ..

      REAL*8 X

      INTEGER IFAIL, LEFT, NCAP7

C     .. ARRAY ARGUMENTS ..

      REAL*8 C(NCAP7), K(NCAP7), S(4)

C     ..

C     .. LOCAL SCALARS ..

c      DOUBLE PRECISION SRNAME

      CHARACTER*8 SRNAME

      REAL*8 C1, C2, C3, C4, D1N41, D1N42, D1N43, D1N44, D2N41,

     * D2N42, D2N43, D2N44, D3N41, D3N42, D3N43, D3N44, E2, E3, E4,

     * E5, HALF, K1, K2, K3, K4, K5, K6, M11, M21, M22, M32, N41,

     * N42, N43, N44, P4, P5, P6, SIX, THREE

      INTEGER IERROR, J1, J, L

C     .. FUNCTION REFERENCES ..

      INTEGER P01AAE

C     ..

      DATA SRNAME /'  E02BCE'/

      HALF = 0.5E+00

      THREE = 3.0E+00

      SIX = 6.0E+00

C

C     *********  DATA VALIDATION  *********

C

C     CHECK WHETHER AT LEAST ONE INTERVAL HAS BEEN SPECIFIED -

C

      IERROR = 1

      IF (NCAP7.LT.8) GO TO 80

C

C     CHECK WHETHER THE RANGE OF DEFINITION OF THE SPLINE IS

C     STRICTLY POSITIVE IN LENGTH -

C

      IERROR = 2

      IF (K(4).GE.K(NCAP7-3)) GO TO 80

C

C     CHECK WHETHER  X  IS A VALID ARGUMENT -

C

      IF (X.LT.K(4) .OR. X.GT.K(NCAP7-3)) GO TO 80

C

C     *********  COMPUTATION  *********

C

C     BINARY SEARCH FOR INTERVAL CONTAINING  X  -

C

C     IF RIGHT-HAND DERIVATIVES ARE REQUIRED  (LEFT .NE. 1)

C     SEARCH FOR  J  SATISFYING

C     K(J + 3) .LE. X .LT. K(J + 4)

C     (SETTING  J = NCAP  IN THE EXCEPTIONAL CASE  X = K(NCAP +

C     4)).

C

C     IF LEFT-HAND DERIVATIVES ARE REQUIRED  (LEFT .EQ. 1)

C     SEARCH FOR  J  SATISFYING

C     K(J + 3) .LT. X .LE. K(J + 4)

C     (SETTING  J = 1  IN THE EXCEPTIONAL CASE  X = K(4)).

C

      IERROR = 0

      J1 = 4

      J = NCAP7 - 3

   20 L = (J1+J)/2

      IF (J-J1.LE.1) GO TO 60

      IF (LEFT.NE.1 .AND. X.GE.K(L)) GO TO 40

      IF (LEFT.EQ.1 .AND. X.GT.K(L)) GO TO 40

      J = L

      GO TO 20

   40 J1 = L

      GO TO 20

   60 J = J - 4

C

C     FORM CERTAIN CONSTANTS -

C

      K1 = K(J+1)

      K2 = K(J+2)

      K3 = K(J+3)

      K4 = K(J+4)

      K5 = K(J+5)

      K6 = K(J+6)

      E2 = X - K2

      E3 = X - K3

      E4 = K4 - X

      E5 = K5 - X

      P4 = K4 - K1

      P5 = K5 - K2

      P6 = K6 - K3

C

C     FORM BASIS FUNCTIONS AND THEIR DERIVATIVES -

C

C     THE VALUES OF THE NON-ZERO UN-NORMALIZED B-SPLINES OF ORDER R

C     ARE DENOTED BY  MR1, MR2,...  .  THE CORRESPONDING NORMALIZED

C     B-SPLINES ARE DENOTED BY  NR1, NR2,...  AND THEIR DERIVATIVES

C     OF ORDER  L  BY  DLNR1, DLNR2,...  .

C

      M11 = SIX/(K4-K3)

      M21 = -M11/(K4-K2)

      M22 = M11/(K5-K3)

      D3N41 = M21/P4

      M32 = (M21-M22)/P5

      D3N44 = M22/P6

      D3N42 = -D3N41 - M32

      D3N43 = M32 - D3N44

      M21 = -E4*M21

      M22 = E3*M22

      D2N41 = M21/P4

      M32 = (M21-M22)/P5

      D2N44 = M22/P6

      D2N42 = -D2N41 - M32

      D2N43 = M32 - D2N44

      M21 = HALF*M21

      M22 = HALF*M22

      D1N41 = -E4*M21/P4

      M32 = (E2*M21+E5*M22)/P5

      D1N44 = E3*M22/P6

      D1N42 = -D1N41 - M32

      D1N43 = M32 - D1N44

      N41 = -E4*D1N41/THREE

      N42 = (-(X-K1)*D1N41+E5*M32)/THREE

      N43 = (E2*M32+(K6-X)*D1N44)/THREE

      N44 = E3*D1N44/THREE

C

C     FORM THE VALUES OF THE CUBIC SPLINE AND ITS DERIVATIVES -

C

      C1 = C(J)

      C2 = C(J+1)

      C3 = C(J+2)

      C4 = C(J+3)

      S(1) = C1*N41 + C2*N42 + C3*N43 + C4*N44

      S(2) = C1*D1N41 + C2*D1N42 + C3*D1N43 + C4*D1N44

      S(3) = C1*D2N41 + C2*D2N42 + C3*D2N43 + C4*D2N44

      S(4) = C1*D3N41 + C2*D3N42 + C3*D3N43 + C4*D3N44

C

C     *********  ERROR DIAGNOSTICS  *********

C

   80 IFAIL = P01AAE(IFAIL,IERROR,SRNAME)

      RETURN

C

C     END OF SUBROUTINE  E02BCF

C

      END

      SUBROUTINE E02BAF(M, NCAP7, X, Y, W, K, WORK1, WORK2, C, SS,

     * IFAIL)

C     NAG COPYRIGHT 1975

C     MARK 5 RELEASE

C     MARK 6 REVISED  IER-84

C     MARK 8 RE-ISSUE. IER-224 (APR 1980).

C     MARK 9A REVISED. IER-356 (NOV 1981)

C

C     NAG LIBRARY SUBROUTINE  E02BAE

C

C     E02BAE  COMPUTES A WEIGHTED LEAST-SQUARES APPROXIMATION

C     TO AN ARBITRARY SET OF DATA POINTS BY A CUBIC SPLINE

C     WITH KNOTS PRESCRIBED BY THE USER.  CUBIC SPLINE

C     INTERPOLATION CAN ALSO BE CARRIED OUT.

C

C     COX-DE BOOR METHOD FOR EVALUATING B-SPLINES WITH

C     ADAPTATION OF GENTLEMAN*S PLANE ROTATION SCHEME FOR

C     SOLVING OVER-DETERMINED LINEAR SYSTEMS.

C

C     USES NAG LIBRARY ROUTINE  P01AAE.

C

C     STARTED - 1973.

C     COMPLETED - 1976.

C     AUTHOR - MGC AND JGH.

C

C     REDESIGNED TO USE CLASSICAL GIVENS ROTATIONS IN

C     ORDER TO AVOID THE OCCASIONAL UNDERFLOW (AND HENCE

C     OVERFLOW) PROBLEMS EXPERIENCED BY GENTLEMAN*S 3-

C     MULTIPLICATION PLANE ROTATION SCHEME

C

C     WORK1  AND  WORK2  ARE WORKSPACE AREAS.

C     WORK1(R)  CONTAINS THE VALUE OF THE  R TH  DISTINCT DATA

C     ABSCISSA AND, SUBSEQUENTLY, FOR  R = 1, 2, 3, 4,  THE

C     VALUES OF THE NON-ZERO B-SPLINES FOR EACH SUCCESSIVE

C     ABSCISSA VALUE.

C     WORK2(L, J)  CONTAINS, FOR  L = 1, 2, 3, 4,  THE VALUE OF

C     THE  J TH  ELEMENT IN THE  L TH  DIAGONAL OF THE

C     UPPER TRIANGULAR MATRIX OF BANDWIDTH  4  IN THE

C     TRIANGULAR SYSTEM DEFINING THE B-SPLINE COEFFICIENTS.

C

C     .. SCALAR ARGUMENTS ..

      REAL*8 SS

      INTEGER IFAIL, M, NCAP7

C     .. ARRAY ARGUMENTS ..

      REAL*8 C(NCAP7), K(NCAP7), W(M), WORK1(M), WORK2(4,NCAP7),

     * X(M), Y(M)

C     ..

C     .. LOCAL SCALARS ..

c      DOUBLE PRECISION SRNAME

      CHARACTER*8 SRNAME

      REAL*8 ACOL, AROW, CCOL, COSINE, CROW, D4, D5, D6, D7, D8, D9,

     * D, DPRIME, E2, E3, E4, E5, K0, K1, K2, K3, K4, K5, K6, N1,

     * N2, N3, RELEMT, S, SIGMA, SINE, WI, XI

      INTEGER I, IERROR, IPLUSJ, IU, J, JOLD, JPLUSL, JREV, L4,

     * L, LPLUS1, LPLUSU, NCAP3, NCAP, NCAPM1, R

C     .. FUNCTION REFERENCES ..

      REAL*8 SQRT

      INTEGER P01AAE

C     ..

      DATA SRNAME /'  E02BAE'/

      IERROR = 4

C     CHECK THAT THE VALUES OF  M  AND  NCAP7  ARE REASONABLE

      IF (NCAP7.LT.8 .OR. M.LT.NCAP7-4) GO TO 420

      NCAP = NCAP7 - 7

      NCAPM1 = NCAP - 1

      NCAP3 = NCAP + 3

C

C     IN ORDER TO DEFINE THE FULL B-SPLINE BASIS, AUGMENT THE

C     PRESCRIBED INTERIOR KNOTS BY KNOTS OF MULTIPLICITY FOUR

C     AT EACH END OF THE DATA RANGE.

C

      DO 20 J=1,4

         I = NCAP3 + J

         K(J) = X(1)

         K(I) = X(M)

   20 CONTINUE

C

C     TEST THE VALIDITY OF THE DATA.

C

C     CHECK THAT THE KNOTS ARE ORDERED AND ARE INTERIOR

C     TO THE DATA INTERVAL.

C

      IERROR = 1

      IF (K(5).LE.X(1) .OR. K(NCAP3).GE.X(M)) GO TO 420

      DO 40 J=4,NCAP3

         IF (K(J).GT.K(J+1)) GO TO 420

   40 CONTINUE

C

C     CHECK THAT THE WEIGHTS ARE STRICTLY POSITIVE.

C

      IERROR = 2

      DO 60 I=1,M

         IF (W(I).LE.0.0) GO TO 420

   60 CONTINUE

C

C     CHECK THAT THE DATA ABSCISSAE ARE ORDERED, THEN FORM THE

C     ARRAY  WORK1  FROM THE ARRAY  X.  THE ARRAY  WORK1  CONTAINS

C     THE

C     SET OF DISTINCT DATA ABSCISSAE.

C

      IERROR = 3

      WORK1(1) = X(1)

      J = 2

      DO 80 I=2,M

         IF (X(I).LT.WORK1(J-1)) GO TO 420

         IF (X(I).EQ.WORK1(J-1)) GO TO 80

         WORK1(J) = X(I)

         J = J + 1

   80 CONTINUE

      R = J - 1

C

C     CHECK THAT THERE ARE SUFFICIENT DISTINCT DATA ABSCISSAE FOR

C     THE PRESCRIBED NUMBER OF KNOTS.

C

      IERROR = 4

      IF (R.LT.NCAP3) GO TO 420

C

C     CHECK THE FIRST  S  AND THE LAST  S  SCHOENBERG-WHITNEY

C     CONDITIONS ( S = MIN(NCAP - 1, 4) ).

C

      IERROR = 5

      DO 100 J=1,4

         IF (J.GE.NCAP) GO TO 160

         I = NCAP3 - J + 1

         L = R - J + 1

         IF (WORK1(J).GE.K(J+4) .OR. K(I).GE.WORK1(L)) GO TO 420

  100 CONTINUE

C

C     CHECK ALL THE REMAINING SCHOENBERG-WHITNEY CONDITIONS.

C

      IF (NCAP.LE.5) GO TO 160

      R = R - 4

      I = 4

      DO 140 J=5,NCAPM1

         K0 = K(J+4)

         K4 = K(J)

  120    I = I + 1

         IF (WORK1(I).LE.K4) GO TO 120

         IF (I.GT.R .OR. WORK1(I).GE.K0) GO TO 420

  140 CONTINUE

C

C     INITIALISE A BAND TRIANGULAR SYSTEM (I.E. A

C     MATRIX AND A RIGHT HAND SIDE) TO ZERO. THE

C     PROCESSING OF EACH DATA POINT IN TURN RESULTS

C     IN AN UPDATING OF THIS SYSTEM. THE SUBSEQUENT

C     SOLUTION OF THE RESULTING BAND TRIANGULAR SYSTEM

C     YIELDS THE COEFFICIENTS OF THE B-SPLINES.

C

  160 DO 200 I=1,NCAP3

         DO 180 L=1,4

            WORK2(L,I) = 0.0

  180    CONTINUE

         C(I) = 0.0

  200 CONTINUE

      SIGMA = 0.0

      J = 0

      JOLD = 0

      DO 340 I=1,M

C

C     FOR THE DATA POINT  (X(I), Y(I))  DETERMINE AN INTERVAL

C     K(J + 3) .LE. X .LT. K(J + 4)  CONTAINING  X(I).  (IN THE

C     CASE  J + 4 .EQ. NCAP  THE SECOND EQUALITY IS RELAXED TO

C     INCLUDE

C     EQUALITY).

C

         WI = W(I)

         XI = X(I)

  220    IF (XI.LT.K(J+4) .OR. J.GT.NCAPM1) GO TO 240

         J = J + 1

         GO TO 220

  240    IF (J.EQ.JOLD) GO TO 260

C

C     SET CERTAIN CONSTANTS RELATING TO THE INTERVAL

C     K(J + 3) .LE. X .LE. K(J + 4).

C

         K1 = K(J+1)

         K2 = K(J+2)

         K3 = K(J+3)

         K4 = K(J+4)

         K5 = K(J+5)

         K6 = K(J+6)

         D4 = 1.0/(K4-K1)

         D5 = 1.0/(K5-K2)

         D6 = 1.0/(K6-K3)

         D7 = 1.0/(K4-K2)

         D8 = 1.0/(K5-K3)

         D9 = 1.0/(K4-K3)

         JOLD = J

C

C     COMPUTE AND STORE IN  WORK1(L) (L = 1, 2, 3, 4)  THE VALUES

C     OF

C     THE FOUR NORMALIZED CUBIC B-SPLINES WHICH ARE NON-ZERO AT

C     X=X(I).

C

  260    E5 = K5 - XI

         E4 = K4 - XI

         E3 = XI - K3

         E2 = XI - K2

         N1 = WI*D9

         N2 = E3*N1*D8

         N1 = E4*N1*D7

         N3 = E3*N2*D6

         N2 = (E2*N1+E5*N2)*D5

         N1 = E4*N1*D4

         WORK1(4) = E3*N3

         WORK1(3) = E2*N2 + (K6-XI)*N3

         WORK1(2) = (XI-K1)*N1 + E5*N2

         WORK1(1) = E4*N1

         CROW = Y(I)*WI

C

C     ROTATE THIS ROW INTO THE BAND TRIANGULAR SYSTEM USING PLANE

C     ROTATIONS.

C

         DO 320 LPLUS1=1,4

            L = LPLUS1 - 1

            RELEMT = WORK1(LPLUS1)

            IF (RELEMT.EQ.0.0) GO TO 320

            JPLUSL = J + L

            L4 = 4 - L

            D = WORK2(1,JPLUSL)

            IF (ABS(RELEMT).GE.D) DPRIME =

     *       ABS(RELEMT)*SQRT(1.0+(D/RELEMT)**2)

            IF (ABS(RELEMT).LT.D) DPRIME = D*SQRT(1.0+(RELEMT/D)**2)

            WORK2(1,JPLUSL) = DPRIME

            COSINE = D/DPRIME

            SINE = RELEMT/DPRIME

            IF (L4.LT.2) GO TO 300

            DO 280 IU=2,L4

               LPLUSU = L + IU

               ACOL = WORK2(IU,JPLUSL)

               AROW = WORK1(LPLUSU)

               WORK2(IU,JPLUSL) = COSINE*ACOL + SINE*AROW

               WORK1(LPLUSU) = COSINE*AROW - SINE*ACOL

  280       CONTINUE

  300       CCOL = C(JPLUSL)

            C(JPLUSL) = COSINE*CCOL + SINE*CROW

            CROW = COSINE*CROW - SINE*CCOL

  320    CONTINUE

         SIGMA = SIGMA + CROW**2

  340 CONTINUE

      SS = SIGMA

C

C     SOLVE THE BAND TRIANGULAR SYSTEM FOR THE B-SPLINE

C     COEFFICIENTS. IF A DIAGONAL ELEMENT IS ZERO, AND HENCE

C     THE TRIANGULAR SYSTEM IS SINGULAR, THE IMPLICATION IS

C     THAT THE SCHOENBERG-WHITNEY CONDITIONS ARE ONLY JUST

C     SATISFIED. THUS IT IS APPROPRIATE TO EXIT IN THIS

C     CASE WITH THE SAME VALUE  (IFAIL=5)  OF THE ERROR

C     INDICATOR.

C

      L = -1

      DO 400 JREV=1,NCAP3

         J = NCAP3 - JREV + 1

         D = WORK2(1,J)

         IF (D.EQ.0.0) GO TO 420

         IF (L.LT.3) L = L + 1

         S = C(J)

         IF (L.EQ.0) GO TO 380

         DO 360 I=1,L

            IPLUSJ = I + J

            S = S - WORK2(I+1,J)*C(IPLUSJ)

  360    CONTINUE

  380    C(J) = S/D

  400 CONTINUE

      IERROR = 0

  420 IF (IERROR) 440, 460, 440

  440 IFAIL = P01AAE(IFAIL,IERROR,SRNAME)

      RETURN

  460 IFAIL = 0

      RETURN

      END



