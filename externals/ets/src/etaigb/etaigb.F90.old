SUBROUTINE EtaiGB(eq, coreprof, coretransp)

!...  a simple turbulent transport model using gyroBohm diffusion
!...  includes an ITG threshold model
!...  mainly for testing purposes
!...  simple pinches are assumed to relax density to eta_e = etae_pinch
!...  pure deuterium fully ionised neutral plasma is assumed
!...  fluxes are assumed to be defined _between_ coreprof grid points
!...  edit this if you want many ion species

#ifdef MPI
  USE MPEs
#endif
  USE Phys_constants
  USE Mod_Turb
  USE ETAIGB_Coeff

  IMPLICIT NONE

  TYPE (type_equilibrium), pointer :: eq(:)
  TYPE (type_coreprof), pointer :: coreprof(:)
  TYPE (type_coretransp), pointer :: coretransp(:)

  INTEGER(ITM_I4) :: i,ip,im
  INTEGER(ITM_I4) :: nrho_prof
  REAL(R8) :: a00,b00,r00,hra
  REAL(R8) :: nne,tte,nni,tti,taui,rlne,rlte,rlti,hx0,rhos,cs,ra0
  REAL(R8) :: chigb,diffe,diffi,chie,chii,ffe,ffi,gge,ggi

!...  XML declarations

  integer(ITM_I4) :: return_status

  character(len = 132), target :: codename(1) = 'ETAIGB'
  character(len = 132), target :: codeversion(1) = '0'

  character(len = 132), allocatable :: parameters(:)
  target :: parameters
  character(len = 132) :: xml_line
  integer(ITM_I4) :: file_length, i_line, n_lines
  integer(ITM_I4) :: ios

!...  if running MPI you need these

#ifdef MPI
  INTEGER :: mype,npes
  CALL MPI_Comm_size( MPI_COMM_WORLD, npes, ierr )
  CALL MPI_Comm_rank( MPI_COMM_WORLD, mype, ierr )
#endif

!...  allocations

  IF (.NOT. ASSOCIATED(coretransp)) THEN
     ALLOCATE(coretransp(1))

!...  open files and get parms

#ifdef MPI
  DO ipe=0,npes-1
     IF (ipe == mype) THEN
#endif

!...  read input xml file

  open (unit = 15, file = 'input_etaigb.xml', status = 'old', &
        action = 'read', iostat = ios)

  if (ios /= 0) then
    stop ' ERROR:  input_etaigb.xml does not exist '
  end if

  n_lines = 0

  do
    read (15, '(a)', iostat = ios) xml_line
    if (ios == 0) then
      n_lines = n_lines + 1
    else
      exit
    end if
  end do

  rewind 15

  allocate(parameters(n_lines))

  do i_line = 1, n_lines
    read (15, '(a)', iostat = ios) parameters(i_line)
  end do

  close(15)

  allocate(coretransp(1)%codeparam%codename(1))
  allocate(coretransp(1)%codeparam%codeversion(1))
  allocate(coretransp(1)%codeparam%parameters(n_lines))

  coretransp(1)%codeparam%codename = codename
  coretransp(1)%codeparam%codeversion = codeversion
  coretransp(1)%codeparam%parameters = parameters

  call assign_etaigb_parameters(coretransp(1)%codeparam, return_status)

  if (return_status /= 0) then
    write(*,*) 'ERROR: Could not assign ETAIGB parameters.'
    return
  end if

  deallocate(parameters)

  write(*,*) 'done assigning ETAIGB parameters'

#ifdef MPI
     END IF
     CALL MPI_Barrier(MPI_COMM_WORLD,ierr)
  END DO
#endif

!...  find grid size for profiles
!...  default sets grid size to that of profiles
!...  find number of ion species also from coreprof

  nrho_prof=SIZE(coreprof(1)%rho_tor)
  IF (nrho_transp == 0) nrho_transp = nrho_prof
  IF (nion == 0) nion=SIZE(coreprof(1)%ni%value)/nrho_prof

  CALL Turb_Constructor(coretransp(1), 1, nrho_transp, nion)

!...  done initialisation

  END IF

!...  find grid sizes for transp

  nrho_transp=SIZE(coretransp(1)%rho_tor)
  nion=SIZE(coretransp(1)%ti_transp%flux)/nrho_transp

!...  set up transport as a function of parameters

  a00=eq(1)%eqgeometry%a_minor
  b00=eq(1)%global_param%toroid_field%b0
  r00=eq(1)%global_param%toroid_field%r0

!...  set transport grid

  hra=1.0_R8/nrho_transp
  coretransp(1)%rho_tor_norm=(/ (hra*(i-0.5_R8),i=1,nrho_transp) /)
  coretransp(1)%rho_tor=coretransp(1)%rho_tor_norm*a00

!...  at each location not at the boundaries...

  DO i=1,nrho_transp-1

!...  mid-node values

     nne=0.5_R8*(coreprof(1)%ne%value(i)+coreprof(1)%ne%value(i+1))
     tte=0.5_R8*(coreprof(1)%te%value(i)+coreprof(1)%te%value(i+1))
     nni=0.5_R8*(coreprof(1)%ni%value(i,1)+coreprof(1)%ni%value(i+1,1))
     tti=0.5_R8*(coreprof(1)%ti%value(i,1)+coreprof(1)%ti%value(i+1,1))

!...  define local parameters

     rhos=cc*SQRT(md*kb*tte)/(ee*b00)
     cs=SQRT(kb*tte/md)
     taui=tti/tte

!...  find local gradients R/L for each quantity

     hx0=r00/(coreprof(1)%rho_tor(i+1)-coreprof(1)%rho_tor(i))

     rlne=hx0*(LOG(coreprof(1)%ne%value(i+1))-LOG(coreprof(1)%ne%value(i)))
     rlte=hx0*(LOG(coreprof(1)%te%value(i+1))-LOG(coreprof(1)%te%value(i)))
     rlti=hx0*(LOG(coreprof(1)%ti%value(i+1,1))-LOG(coreprof(1)%ti%value(i,1)))

!...  the baseline gyroBohm diffusion coefficient uses LTe by itself

     chigb=rhos*rhos*cs*ABS(rlte)/r00

     chigb=chigb*MAX(0._R8, (ABS(rlti)-thresh))/tfloor

!...  the diffusion coefficients in this model

     diffe=chigb
     diffi=diffe
     chie=chi_d*chigb
     chii=chi_d*chigb

     coretransp(1)%ne_transp%diff_eff(i,3) = diffe
     coretransp(1)%te_transp%diff_eff(i) = chie
     coretransp(1)%ni_transp%diff_eff(i,1,3) = diffi
     coretransp(1)%ti_transp%diff_eff(i,1) = chii

!...  the effective flux velocities in this model
!...  for temperatures use the conductive part

     ffe= - diffe*(rlne-rlte/etae_pinch)/r00
     gge= - chie*rlte/r00
     ffi=ffe
     ggi= - chii*rlti/r00

!...  basic pinch dynamics in this model

     coretransp(1)%ne_transp%vconv_eff(i,3) = diffe*(rlte/etae_pinch)/r00
     coretransp(1)%te_transp%vconv_eff(i) = 0._R8
     coretransp(1)%ni_transp%vconv_eff(i,1,3) = diffe*(rlte/etae_pinch)/r00
     coretransp(1)%ti_transp%vconv_eff(i,1) = 0._R8

!...  the fluxes themselves
!...  for a mean field conserved quantity solver heat fluxes are totals
!...  different models can reconstruct theirs using the D's and V's
!...  the coefficient is 3/2 due to the Poynting flux cancellation

     coretransp(1)%ne_transp%flux(i) = nne*ffe
     coretransp(1)%te_transp%flux(i) = nne*kb*tte*(1.5_R8*ffe+gge)
     coretransp(1)%ni_transp%flux(i,1) = nni*ffe
     coretransp(1)%ti_transp%flux(i,1) = nni*kb*tti*(1.5_R8*ffe+ggi)

  END DO

END SUBROUTINE EtaiGB
