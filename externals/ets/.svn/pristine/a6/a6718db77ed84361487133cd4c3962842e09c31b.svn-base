!-------------------------------------------------------!
!> Module provides the dummy source to the ETS. 
!> 
!> \author D.Kalupin 
!>
!> \version "$Id$"                               
!-------------------------------------------------------!
MODULE SOURCE_DUMMY

CONTAINS




!-------------------------------------------------------!
!-------------------------------------------------------!

  SUBROUTINE G_SOURCE    (EQUILIBRIUM, COREPROF, CORESOURCE) 

!-------------------------------------------------------!
!     This routine provides dummy source for the        !
!     ETS workflow.                                     !
!-------------------------------------------------------!
!     Source:       ---                                 !
!     Developers:   D.Kalupin                           !
!     Kontacts:     Denis.Kalupin@efda.org              !
!                                                       !
!     Comments:     input parameter list is specified   !
!                   in "source_dummy.xml" file.         !
!                                                       !
!                   output CORESOURCE CPO is            !
!                   allocated inside the module         !
!                                                       !
!-------------------------------------------------------!


      USE  EUITM_SCHEMAS
      USE  EUITM_ROUTINES
      USE  ALLOCATE_DEALLOCATE
      USE  ITM_TYPES


      IMPLICIT NONE


      INTEGER                           :: ifail
 

! +++ CPO derived types:
      TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM(:)        !input CPO with geometry quantities from previous time
      TYPE (TYPE_COREPROF),    POINTER  :: COREPROF(:)           !input CPO with internal ETS parameters profiles from previous time
      TYPE (TYPE_CORESOURCE),  POINTER  :: CORESOURCE(:)         !output CPO with sources


! +++ Local variables:
      REAL(R8)                          :: TIME
      REAL(R8),            ALLOCATABLE  :: AMN(:)
      REAL(R8),            ALLOCATABLE  :: RHO(:)
      REAL(R8),            ALLOCATABLE  :: VPRIME(:)
      REAL(R8),            ALLOCATABLE  :: VPRIME_EQ(:)
      REAL(R8),            ALLOCATABLE  :: REQ(:)
      REAL(R8),            ALLOCATABLE  :: JNI(:)
      REAL(R8),            ALLOCATABLE  :: QEL(:)
      REAL(R8),            ALLOCATABLE  :: QION(:,:)
      REAL(R8),            ALLOCATABLE  :: SION(:,:)
      REAL(R8),            ALLOCATABLE  :: UION(:,:)
      REAL (R8)                         :: R0                  


! +++ Dimensions:
      INTEGER,               PARAMETER  :: NOCUR = 1             !number of CPO ocurancies in the work flow
      INTEGER                           :: NRHO                  !number of radial points     (input, determined from COREPROF CPO)
      INTEGER                           :: NEQ                   !number of radial points     (input, determined from EQUILIBRIUM CPO)
      INTEGER                           :: NNUCL                 !number of nuclei species
      INTEGER                           :: NION                  !number of ion species
      INTEGER                           :: NIMP,     IIMP        !number of impurity species
      INTEGER,              ALLOCATABLE :: NZIMP(:)              !number of ionization states for each impurity
      INTEGER                           :: NNEUT,    INEUT       !number of neutrals species
      INTEGER,              ALLOCATABLE :: NCOMP(:)              !number of components for each neutral
      INTEGER,              ALLOCATABLE :: NTYPE(:)              !number of types for each neutral




! +++ Set dimensions:
      NRHO                   = SIZE (COREPROF(1)%rho_tor, DIM=1)
      CALL GET_COMP_DIMENSIONS      (COREPROF(1)%COMPOSITIONS, NNUCL, NION,  NIMP,  NZIMP, NNEUT, NTYPE, NCOMP)

 
! +++ Allocate output CPO:
      CALL ALLOCATE_CORESOURCE_CPO  (NOCUR, NRHO, NNUCL, NION,  NIMP,  NZIMP, NNEUT, NTYPE, NCOMP, CORESOURCE)


! +++ Allocate local variables:
      ALLOCATE      (       AMN(NION)      )
      ALLOCATE      (       RHO(NRHO)      )
      ALLOCATE      (    VPRIME(NRHO)      )
      ALLOCATE      ( VPRIME_EQ(NEQ)       )
      ALLOCATE      (       REQ(NEQ)       )
      ALLOCATE      (       JNI(NRHO)      )
      ALLOCATE      (       QEL(NRHO)      )
      ALLOCATE      (      QION(NRHO,NION) )
      ALLOCATE      (      SION(NRHO,NION) )
      ALLOCATE      (      UION(NRHO,NION) )
      


! +++ Save output in CPO:
      TIME                              =  COREPROF(1)%time     !time    [s]

      AMN                               =  COREPROF(1)%composition%amn

      RHO                               =  COREPROF(1)%rho_tor  !rho     [m]

      REQ                               =  EQUILIBRIUM(1)%profiles_1d%rho_tor

      CALL L3deriv                  (EQUILIBRIUM(1)%profiles_1d%volume, REQ, NEQ,  &
                                     VPRIME_EQ,                         REQ, NEQ)

      R0                                =  EQUILIBRIUM(1)%global_param%toroid_field%r0

      CALL INTERPOLATE              (NEQ, REQ, VPRIME_EQ,      NRHO, RHO, VPRIME)


! +++ Calculate sources:
!                                    <<        input                >>  <<      output          >>
      CALL ADDITIONAL_SOURCE        (AMN, NRHO, RHO, R0, VPRIME, NION, QEL, QION, SION, UION, JNI)



! +++ Save output in CPO:
      CORESOURCE(1)%time                =  TIME                 !time    [s]

      CORESOURCE(1)%VALUES(1)%rho_tor             =  RHO                  !rho     [m]

      CORESOURCE(1)%VALUES(1)%j                   =  JNI                  !j_ni    [A/m^2]

      CORESOURCE(1)%VALUES(1)%qe%exp              =  QEL                  !Qe_exp  [W/m^3]
      CORESOURCE(1)%VALUES(1)%qe%imp              =  0.0E0_R8             !Qe_imp  [1/m^3/s]

      CORESOURCE(1)%VALUES(1)%si%exp              =  SION                 !Si_exp  [1/m^3/s]
      CORESOURCE(1)%VALUES(1)%si%imp              =  0.0E0_R8             !Si_imp  [1/s]

      CORESOURCE(1)%VALUES(1)%qi%exp              =  QION                 !Qi_exp  [W/m^3]
      CORESOURCE(1)%VALUES(1)%qi%imp              =  0.0E0_R8             !Qi_imp  [1/m^3/s]
 
      CORESOURCE(1)%VALUES(1)%ui%exp              =  UION                 !Ui_exp  [kg/m/s^2]
      CORESOURCE(1)%VALUES(1)%ui%imp              =  0.0E0_R8             !Ui_imp  [kg/m^2/s]
      

! +++ Deallocate local variables:
      DEALLOCATE    (AMN)
      DEALLOCATE    (RHO)
      DEALLOCATE    (VPRIME)
      DEALLOCATE    (VPRIME_EQ)
      DEALLOCATE    (REQ)
      DEALLOCATE    (JNI)
      DEALLOCATE    (QEL)
      DEALLOCATE    (QION)
      DEALLOCATE    (SION)
      DEALLOCATE    (UION)
        ! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
  ! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  



      RETURN


      END SUBROUTINE G_SOURCE  

!-------------------------------------------------------!
!-------------------------------------------------------!






!-------------------------------------------------------!
!-------------------------------------------------------!

      SUBROUTINE ADDITIONAL_SOURCE (AMN, NRHO, RHO, R0, VPRIME, NION, QEL, QION, SION, UION, JNI)

      USE ITM_CONSTANTS
      USE ITM_TYPES

      USE EUITM_ROUTINES
      USE EUITM_SCHEMAS
      USE EUITM_XML_PARSER  
      USE XML_FILE_READER  

      IMPLICIT NONE


! +++ Dimensions:
      INTEGER              :: I
      INTEGER              :: NRHO, IRHO
      INTEGER              :: NION


! +++ Local variables:
      REAL(R8)             :: RHO(NRHO)
      REAL(R8)             :: VPRIME(NRHO)

      REAL(R8)             :: AMN(NION)             

      REAL(R8)             :: JNI(NRHO)
      REAL(R8)             :: QEL(NRHO)
      REAL(R8)             :: QION(NRHO,NION)
      REAL(R8)             :: SION(NRHO,NION)
      REAL(R8)             :: UION(NRHO,NION)
      REAL(R8)             :: R0                  

      REAL(R8)             :: GFUN(NRHO)
      REAL(R8)             :: A, C, W, INTFUN
      REAL(R8)             :: FTOT


! +++ Parameters from XML:

!     HEATING:
      REAL(R8)             :: WTOT                       !total energy input  [W]
      REAL(R8)             :: RHEAT                      !rho position of heating profile maximum [m]
      REAL(R8)             :: FWHEAT(1:NION+1)           !A full width at half maximum of the heating profiles [m]
      REAL(R8)             :: FRACT(1:NION+1)            !fractions of energy going in different components, summ should not exceed 1.0 [-]
      REAL(R8)             :: PHEAT(NRHO)                !Heating power [W/m^3]

!     PARTICLES:
      REAL(R8)             :: AMI                        !Atomic mass number of injected particles [-]
      REAL(R8)             :: STOT                       !total particle input [s^-1]
      REAL(R8)             :: RPART                      !rho position of particle source profile maximum [m]
      REAL(R8)             :: FWPART                     !A full width at half maximum of the particle source profiles [m]
      REAL(R8)             :: SI(NRHO)                   !particle source density [s^-1*m^-3]

!     MOMENTUM:
      REAL(R8)             :: AMM                        !Atomic mass number of particles receiving momentum input[-]
      REAL(R8)             :: UTOT                       !Total momentum [kg*m^2*s^-1]
      REAL(R8)             :: RMOM                       !rho position of momentum source profile maximum [m]
      REAL(R8)             :: FWMOM                      !A full width at half maximum of the momentum source profiles [m]
      REAL(R8)             :: UI(NRHO)                   !momentum source density [kg*m^-1*s^-1]

!     CURRENT:
      REAL(R8)             :: JNITOT                     !total noninductive current [A]
      REAL(R8)             :: RCURR                      !rho position of current profile maximum [m]
      REAL(R8)             :: FWCURR                     !A full width at half maximum of the current profiles [m]


! +++ Other
      LOGICAL,  SAVE       :: first = .TRUE.
      INTEGER              :: return_status
      TYPE (TYPE_PARAM)    :: code_parameters


     CALL FILL_PARAM (code_parameters, 'XML/source_dummy.xml', '', 'XML/source_dummy.xsd')


     CALL ASSIGN_DUMMY_SOURCES(code_parameters, return_status)
    
     IF (return_status /= 0) THEN
        WRITE(*,*) 'ERROR: Could not assign source multipliers.'
     END IF



!-------------------------------------------------------!
! +++ Individual heating sources:

!    Check that summ of fractions is 1.0
      FTOT      = 0.0
      DO I = 1,NION+1
         FTOT    = FTOT + FRACT(I)
      END DO


      IF (FTOT.NE.1.0_R8) THEN
         WRITE (6,*) 'Total contribution for the dummy source is not 1.0'
         WRITE (6,*) 'Fractions will be renormalised'
         FRACT   = FRACT / FTOT
      END IF



      DO I = 1,NION+1

        A        = RHEAT
        C        = FWHEAT(I)/2.35482_R8
        W        = WTOT * FRACT(I)

        GFUN     = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                   * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                   * VPRIME
 
        CALL INTEG(NRHO, RHO, GFUN, INTFUN)

        PHEAT    = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                   * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                   * W / INTFUN 

        IF (I.LE.NION) THEN
          DO IRHO = 1, NRHO
             QION(IRHO,I) = PHEAT(IRHO)
          END DO
        ELSE IF (I.EQ.NION+1) THEN
          DO IRHO = 1, NRHO
             QEL(IRHO)  = PHEAT(IRHO)
          END DO

        END IF

      END DO



!-------------------------------------------------------!
! +++ Individual particle sources:
      DO I = 1,NION

        IF (AMI.EQ.AMN(I)) THEN

          A        = RPART
          C        = FWPART/2.35482_R8
          W        = STOT 

          GFUN     = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                     * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                     * VPRIME
 
          CALL INTEG(NRHO, RHO, GFUN, INTFUN)

          SI       = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                     * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                     * W / INTFUN

          DO IRHO = 1, NRHO
             SION(IRHO,I) = SI(IRHO)
          END DO

        END IF

      END DO



!-------------------------------------------------------!
! +++ Individual momentum sources:
      DO I = 1,NION

        IF (AMM.EQ.AMN(I)) THEN

          A        = RMOM
          C        = FWMOM/2.35482_R8
          W        = UTOT 

          GFUN     = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                     * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                     * VPRIME
 
          CALL INTEG(NRHO, RHO, GFUN, INTFUN)

          UI       = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                     * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                     * W / INTFUN

          DO IRHO = 1, NRHO
             UION(IRHO,I) = UI(IRHO)
          END DO

        END IF

      END DO



!-------------------------------------------------------!
! +++ Current sources:
      A        = RCURR
      C        = FWCURR/2.35482_R8
      W        = JNITOT 

      GFUN(2:) = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                 * EXP(-(RHO(2:)-A)**2 / 2.0_R8 / C**2) &
                 * VPRIME(2:) / 2.0_R8 / ITM_PI / RHO(2:)

      IF (RHO(1).EQ.0.0_R8)                         &
      GFUN(1)  = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                 * EXP(-A**2 / 2.0_R8 / C**2)       &
                 * 2.0_R8 * ITM_PI * R0
 
      CALL INTEG(NRHO, RHO, GFUN, INTFUN)

      JNI      = 1.0_R8 / (2.0_R8*ITM_PI)**0.5/ C   &
                 * EXP(-(RHO-A)**2 / 2.0_R8 / C**2) &
                 * W / INTFUN


      RETURN


!-------------------------------------------------------!
!-------------------------------------------------------!



      CONTAINS
!-------------------------------------------------------!
!-------------------------------------------------------!
      SUBROUTINE ASSIGN_DUMMY_SOURCES(codeparameters, return_status)

!-------------------------------------------------------!
!     This subroutine calls the XML parser for          !
!     the dummy sources and assign the                  !
!     resulting values to the corresponding variables   !
!-------------------------------------------------------!
!     Source:       ---                                 !
!     Developers:   D.Kalupin                           !
!     Kontacts:     Denis.Kalupin@efda.org              !
!                                                       !
!     Comments:     ---                                 !
!                                                       !
!-------------------------------------------------------!
  
      USE ITM_TYPES
      USE EUITM_SCHEMAS
      USE EUITM_XML_PARSER  

      IMPLICIT NONE


      TYPE(type_param)                  :: codeparameters
      INTEGER(ITM_I4)                   :: return_status 

      TYPE(tree)                        :: parameter_list
      TYPE(element),        POINTER     :: temp_pointer
      INTEGER(ITM_I4)                   :: i, nparm, n_values
      CHARACTER(len = 132)              :: cname

      INTEGER                           :: n_data

      return_status          = 0      ! no error

!-- parse xml-string codeparameters%parameters

      WRITE(6,*) 'Calling euitm_xml_parse'
      CALL EUITM_XML_PARSE  (codeparameters, nparm, parameter_list)
      WRITE(6,*) 'Called euitm_xml_parse'

!-- assign variables

      temp_pointer => parameter_list%first

      outer: DO
         cname = char2str(temp_pointer%cname)   ! necessary for AIX
         SELECT CASE (cname)


!--   parameters overall
         CASE ("parameters")
            temp_pointer => temp_pointer%child
            CYCLE

!--   Parameters for heating source
         CASE ("heating")
            temp_pointer => temp_pointer%child
            CYCLE

         CASE ("WTOT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, WTOT)
  
         CASE ("RHEAT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, RHEAT)

         CASE ("FRACT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL scan_str2real(char2str(temp_pointer%cvalue), FRACT, n_data)
            
         CASE ("FWHEAT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL scan_str2real(char2str(temp_pointer%cvalue), FWHEAT, n_data)
            
 
!--   Parameters for particle source
         CASE ("particles")
            temp_pointer => temp_pointer%child
            CYCLE

         CASE ("AMI")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, AMI)
  
         CASE ("STOT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, STOT)

         CASE ("RPART")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, RPART)
  
         CASE ("FWPART")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, FWPART)
            
 
!--   Parameters for momentum source
         CASE ("momentum")
            temp_pointer => temp_pointer%child
            CYCLE

         CASE ("AMM")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, AMM)
  
         CASE ("UTOT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, UTOT)

         CASE ("RMOM")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, RMOM)
  
         CASE ("FWMOM")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, FWMOM)
            
 
!--   Parameters for particle source
         CASE ("currents")
            temp_pointer => temp_pointer%child
            CYCLE

         CASE ("JNITOT")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, JNITOT)

         CASE ("RCURR")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, RCURR)
  
         CASE ("FWCURR")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, FWCURR)


 
        CASE default
            WRITE(*, *) 'ERROR: invalid parameter', cname
            return_status = 1
            EXIT
         END SELECT


         DO
            IF (ASSOCIATED(temp_pointer%sibling)) THEN
               temp_pointer => temp_pointer%sibling
               EXIT
            END IF
            IF (ASSOCIATED(temp_pointer%parent, parameter_list%first )) &
                 EXIT outer
            IF (ASSOCIATED(temp_pointer%parent)) THEN
               temp_pointer => temp_pointer%parent
            ELSE
               WRITE(*, *) 'ERROR: broken list.'
               RETURN
            END IF
         END DO
      END DO outer
      

!  -- destroy tree
      CALL DESTROY_XML_TREE(parameter_list)


      RETURN


      END SUBROUTINE ASSIGN_DUMMY_SOURCES
!-------------------------------------------------------!
!-------------------------------------------------------!


      END  SUBROUTINE ADDITIONAL_SOURCE
!-------------------------------------------------------!
!-------------------------------------------------------!






!-------------------------------------------------------!
!-------------------------------------------------------!
!  This subroutine calculates integral of a function y(x)
!  from X=0
      SUBROUTINE INTEG(N,X,Y,INTY)


      USE ITM_TYPES
  
   
      IMPLICIT NONE
  
      INTEGER :: N                                          ! number of radial points (input)
      INTEGER :: I
  
      REAL (R8) :: X(N), &                                  ! argument array (input)
                   Y(N), &                                  ! function array (input)
                   INTY                                     ! integral value (output)
  
      INTY      = 0.0_R8
      DO i=2,N
        INTY    = INTY + (Y(I)+Y(I-1))*(X(I)-X(I-1))/2.E0_R8
      END DO
  
      RETURN

      END SUBROUTINE INTEG
!-------------------------------------------------------!
!-------------------------------------------------------!




!-------------------------------------------------------!
!-------------------------------------------------------!
  SUBROUTINE INTERPOLATE(ninput,rinput,finput,nout,rout,fout)

    ! +++ this subroutine interpolates profile Finput(rinput) to the new greed Fout(rout)

    USE itm_types

    IMPLICIT NONE

    INTEGER              :: i,ii,jj, ninput,nout
    ! Input: radii, function
    REAL (R8)            :: rinput(ninput),finput(ninput)
    ! Output: radii, function
    REAL (R8)            :: rout(nout),fout(nout)
    REAL (R8)            :: f(2),r,h1,h2,y1,y2,y3,a,b,c,z


    DO i=1,nout
       r=rout(i)
       IF(r.LE.rinput(2)) THEN
          h1=rinput(2)-rinput(1)
          h2=rinput(3)-rinput(2)
          y1=finput(1)
          y2=finput(2)
          y3=finput(3)
          a=((y1-y2)*h2+(y3-y2)*h1)/h1/h2/(h1+h2)
          b=((y3-y2)*h1*h1-(y1-y2)*h2*h2)/h1/h2/(h1+h2)
          c=y2
          z=a*(r-rinput(2))**2+b*(r-rinput(2))+c
          GOTO 100
       ENDIF
       IF(r.GT.rinput(2).AND.r.LE.rinput(ninput-1)) THEN
          DO ii=3,ninput-1
             IF(r.GT.rinput(ii-1).AND.r.LE.rinput(ii)) THEN
                DO jj=1,2
                   h1=rinput(ii-2+jj)-rinput(ii-3+jj)
                   h2=rinput(ii-1+jj)-rinput(ii-2+jj)
                   y1=finput(ii-3+jj)
                   y2=finput(ii-2+jj)
                   y3=finput(ii-1+jj)
                   a=((y1-y2)*h2+(y3-y2)*h1)/h1/h2/(h1+h2)
                   b=((y3-y2)*h1*h1-(y1-y2)*h2*h2)/h1/h2/(h1+h2)
                   c=y2
                   f(jj)=a*(r-rinput(ii-2+jj))**2+b*(r-rinput(ii-2+jj))+c
                ENDDO
                z=(f(1)*(rinput(ii)-r)+f(2)*(r-rinput(ii-1)))/       &
                     (rinput(ii)-rinput(ii-1))
             ENDIF
          ENDDO
          GOTO 100
       ENDIF
       IF(r.GE.rinput(ninput-1)) THEN
          h1=rinput(ninput-1)-rinput(ninput-2)
          h2=rinput(ninput)-rinput(ninput-1)
          y1=finput(ninput-2)
          y2=finput(ninput-1)
          y3=finput(ninput)
          a=((y1-y2)*h2+(y3-y2)*h1)/h1/h2/(h1+h2)
          b=((y3-y2)*h1*h1-(y1-y2)*h2*h2)/h1/h2/(h1+h2)
          c=y2
          z=a*(r-rinput(ninput-1))**2+b*(r-rinput(ninput-1))+c
          GOTO 100
       ENDIF
100    fout(i)=z
    ENDDO

!DPC
    IF(rinput(1).EQ.rout(1)) THEN
       IF(finput(1).NE.fout(1)) THEN
          WRITE(*,*) 'INTERPOLATION corrected for ',rinput(1),finput(1),fout(1)
          fout(1)=finput(1)
       ENDIF
    ENDIF
    RETURN

  END SUBROUTINE INTERPOLATE
!-------------------------------------------------------!
!-------------------------------------------------------!



END MODULE SOURCE_DUMMY









