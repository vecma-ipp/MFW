! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
!> Module provides the interface between (external) CPO and internal ETS derived types.
!>
!> \author D.Kalupin
!>
!> \version "$Id$"
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
MODULE ETS

CONTAINS



! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
!> ETS
!>
!> This routine provides interface between CPO derived 
!> types and internal ETS derived types.
!>
!> \author D.Kalupin
!>
!> \version "$Id$"
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +   

  SUBROUTINE ITM_ETS    (COREPROF_OLD, COREPROF_ITER, COREPROF_NEW,  &
                         EQUILIBRIUM_OLD, EQUILIBRIUM_ITER,          &
                         CORETRANSP, CORESOURCE, COREIMPUR,          &
                         CONTROL_INTEGER, CONTROL_DOUBLE, code_parameters) 

!-------------------------------------------------------!
!     This routine provides interface between CPO       !
!     dderived types and internal ETS derived types.    !
!-------------------------------------------------------!
!     Source:       ---                                 !
!     Developers:   D.Kalupin                           !
!     Kontacts:     D.Kalupin@fz-juelich.de             !
!                                                       !
!     Comments:     might change after the ITM          !
!                   data stucture is finalized          !
!                                                       !
!-------------------------------------------------------!


    USE EUITM_SCHEMAS
    USE copy_structures
    USE ETS_PLASMA
    USE CONVERT
    USE ALLOCATE_DEALLOCATE

    IMPLICIT NONE

    INTEGER                           :: ifail

! +++ CPO derived types:
    TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM_OLD(:)  !input CPO with geometry quantities from previous time
    TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM_ITER(:) !input CPO with geometry quantities from previous iteration
    TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_OLD(:)     !input CPO with internal ETS parameters profiles from previous time
    TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_NEW(:)     !input/output CPO with internal ETS parameters profiles 
    TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_ITER(:)    !input/output CPO with internal ETS parameters profiles from previous iteration
    TYPE (TYPE_CORETRANSP),  POINTER  :: CORETRANSP(:)       !input CPO with transport coefficients
    TYPE (TYPE_CORESOURCE),  POINTER  :: CORESOURCE(:)       !input CPO with sources
    TYPE (TYPE_COREIMPUR),   POINTER  :: COREIMPUR(:)        !input CPO with impurities
    TYPE (type_param)                 :: code_parameters
    INTEGER(ITM_I4)                   :: return_status


! +++ Internal ETS derived types:
    TYPE (MAGNETIC_GEOMETRY)          :: GEOMETRY            !contains all geometry quantities
    TYPE (PLASMA_PROFILES)            :: PROFILES            !contains profiles of plasma parameters
    TYPE (TRANSPORT_COEFFICIENTS)     :: TRANSPORT           !contains profiles of trasport coefficients
    TYPE (SOURCES_AND_SINKS)          :: SOURCES             !contains profiles of sources
    TYPE (TIME_EVOLUTION)             :: EVOLUTION           !contains all parameters required by time evolution
    TYPE (RUN_CONTROL)                :: CONTROL             !contains all parameters required by run
    TYPE (IMPURITY_PROFILES)          :: IMPURITY            !contains profiles of impurities calculated by separate module


! +++ Dimensions:
    INTEGER,               PARAMETER  :: NOCUR = 1           !number of CPO ocurancies in the work flow
    INTEGER                           :: NRHO,irho           !number of radial points     (input, determined from COREPROF CPO)
    INTEGER                           :: NION                !number of ion species       (input, determined from COREPROF CPO)
    INTEGER                           :: NIMP                !number of impurity species  (input, determined from COREIMPUR CPO)
    INTEGER,             ALLOCATABLE  :: NZIMP(:)            !maximum number of impurity ionization states
    INTEGER                           :: IIMP, MAX_NZIMP

! +++ Control parameters:
    INTEGER                           :: CONTROL_INTEGER(3)  !integer control parameters
    REAL (R8)                         :: CONTROL_DOUBLE(6)   !real control parameters

! +++ codeparam quantities:
    REAL      (R8)                    :: RHON                !effective minor radius
    INTEGER                           :: SOLVER_TYPE         !representation of transport equations
    INTEGER                           :: SIGMA_SOURCE        !origin of Plasma electrical conductivity
    INTEGER                           :: QUASI_NEUT
    REAL      (R8)                    :: AMIX                !mixing factor
    REAL      (R8)                    :: AMIXTR              !mixing factor for profiles
    INTEGER                           :: PSI_BND_TYPE        !Type of boundary conditions current
    INTEGER                           :: NI_BND_TYPE         !Type of boundary conditions ion density 
    INTEGER                           :: TI_BND_TYPE         !Type of boundary conditions ion temperature
    INTEGER                           :: TE_BND_TYPE         !Type of boundary conditions electron temperature
    INTEGER                           :: VTOR_BND_TYPE       !Type of boundary conditions toroidal rotation

! +++ control parameters
    INTEGER, SAVE                     :: DEBUG_LEVEL=0       !debug level
    REAL (R8), SAVE                   :: ohmic_heating_multiplier=1.0_R8

! +++
    LOGICAL, SAVE                     :: FIRST=.TRUE.
    CHARACTER(LEN=500)                :: failstring
! +++ Set dimensions:

! +++ Stabilization scheme !AF 25.Apr.2016
    REAL (R8), PARAMETER              :: HYPER_DIFF_RATIO = 0.0_R8 !ratio of hyper diffusivity to maximum diffusivity !AF 25.Apr.2016
                                                                   !with a zero value "make ets_workflow" works without stabilization !AF 25.Apr.2016

    NRHO                   = SIZE (COREPROF_ITER(1)%rho_tor)
    NION                   = SIZE (COREPROF_ITER(1)%compositions%ions)
    if(associated(COREIMPUR)) then
       NIMP                   = SIZE (COREIMPUR(1)%compositions%impurities)
    else
       NIMP                   = 0
    endif
    ALLOCATE (NZIMP(NIMP))
    NZIMP = 0
    DO IIMP = 1, NIMP
       NZIMP(IIMP) = COREIMPUR(1)%compositions%impurities(IIMP)%nzimp
    ENDDO

    MAX_NZIMP = MAXVAL (NZIMP)

    IF(FIRST) THEN
       WRITE(*,*) 'Processing ets specific input'

       SOLVER_TYPE            = CONTROL_INTEGER(1)
       SIGMA_SOURCE           = CONTROL_INTEGER(2)
       QUASI_NEUT             = CONTROL_INTEGER(3)
       AMIX                   = CONTROL_DOUBLE(2)
       AMIXTR                 = CONTROL_DOUBLE(3)
       
       PSI_BND_TYPE           = itm_int_invalid
       NI_BND_TYPE            = itm_int_invalid
       TI_BND_TYPE            = itm_int_invalid
       TE_BND_TYPE            = itm_int_invalid
       VTOR_BND_TYPE          = itm_int_invalid

       CALL assign_code_parameters(code_parameters, return_status)

       CONTROL_INTEGER(1)           = SOLVER_TYPE              !number of numerical solver
       CONTROL_INTEGER(2)           = SIGMA_SOURCE             !number of numerical solver
       CONTROL_INTEGER(3)           = QUASI_NEUT
       CONTROL_DOUBLE(2)            = AMIX                     !mixing factor for profiles
       CONTROL_DOUBLE(3)            = AMIXTR                   !mixing factor for transport coefficients

       IF(PSI_BND_TYPE.NE.itm_int_invalid)  COREPROF_ITER(1)%psi%boundary%type     = PSI_BND_TYPE
       IF(NI_BND_TYPE.NE.itm_int_invalid)   COREPROF_ITER(1)%ni%boundary%type(:)   = NI_BND_TYPE
       IF(TI_BND_TYPE.NE.itm_int_invalid)   COREPROF_ITER(1)%ti%boundary%type(:)   = TI_BND_TYPE
       IF(TE_BND_TYPE.NE.itm_int_invalid)   COREPROF_ITER(1)%te%boundary%type      = TE_BND_TYPE
       IF(VTOR_BND_TYPE.NE.itm_int_invalid) COREPROF_ITER(1)%vtor%boundary%type(:) = VTOR_BND_TYPE

       FIRST = .FALSE.

    ENDIF

    ALLOCATE     (COREPROF_NEW(1))             
    CALL COPY_CPO(COREPROF_ITER(1),COREPROF_NEW(1))


! +++ Allocation of ETS derived types:
    CALL ALLOCATE_MAGNETIC_GEOMETRY        (NRHO,                GEOMETRY,  ifail)
    CALL ALLOCATE_PLASMA_PROFILES          (NRHO,NION,           PROFILES,  ifail)
    CALL ALLOCATE_TRANSPORT_COEFFICIENTS   (NRHO,NION,           TRANSPORT, ifail)
    CALL ALLOCATE_SOURCES_AND_SINKS        (NRHO,NION,           SOURCES,   ifail)
    CALL ALLOCATE_IMPURITY_PROFILES        (NRHO,NIMP,MAX_NZIMP, IMPURITY,  ifail)
    CALL ALLOCATE_TIME_EVOLUTION           (NRHO,NION,           EVOLUTION, ifail)
    CALL ALLOCATE_RUN_CONTROL              (                     CONTROL,   ifail)


! +++ Copy CPOs in ETS derived types:
   CALL CONVERT_CPO_TO_ETS_TYPES                                                 &
         (EQUILIBRIUM_OLD, EQUILIBRIUM_ITER, COREPROF_OLD, COREPROF_ITER,         &
         CORETRANSP, CORESOURCE, COREIMPUR, CONTROL_INTEGER, CONTROL_DOUBLE,      &
!
         GEOMETRY, PROFILES, TRANSPORT, SOURCES, IMPURITY, EVOLUTION, CONTROL)

   control%debug_level = debug_level
   control%ohmic_heating_multiplier = ohmic_heating_multiplier

! +++ Call MAIN_PLASMA with internal ETS derived types:
    CALL MAIN_PLASMA                                                              &
!         (GEOMETRY, PROFILES, TRANSPORT, SOURCES, IMPURITY, EVOLUTION, CONTROL,   &
         (GEOMETRY, PROFILES, TRANSPORT, SOURCES, IMPURITY, EVOLUTION, CONTROL, HYPER_DIFF_RATIO,  & !AF 25.Apr.2016
         ifail,failstring) 



! +++ Copy ETS derived types in CPOs:
    CALL CONVERT_ETS_TO_CPO_TYPES                                                 &
         (GEOMETRY, PROFILES, TRANSPORT, SOURCES, COREPROF_NEW)



! +++ Deallocation of ETS derived types:
    CALL DEALLOCATE_MAGNETIC_GEOMETRY      (GEOMETRY,  ifail)
    CALL DEALLOCATE_PLASMA_PROFILES        (PROFILES,  ifail)
    CALL DEALLOCATE_TRANSPORT_COEFFICIENTS (TRANSPORT, ifail)
    CALL DEALLOCATE_SOURCES_AND_SINKS      (SOURCES,   ifail)
    CALL DEALLOCATE_IMPURITY_PROFILES      (IMPURITY,  ifail)
    CALL DEALLOCATE_TIME_EVOLUTION         (EVOLUTION, ifail)
    CALL DEALLOCATE_RUN_CONTROL            (CONTROL,   ifail)




    RETURN

  CONTAINS

    SUBROUTINE assign_code_parameters(codeparameters, return_status)

      !-----------------------------------------------------------------------
      ! calls the XML parser for the code parameters and assign the
      ! resulting values to the corresponding variables
      !TODO: check an alternative and more elegant solution in Perl
      !-----------------------------------------------------------------------

      USE mod_f90_kind
      USE euitm_schemas
      USE EUITM_XML_PARSER  

      IMPLICIT NONE

      TYPE (type_param), INTENT(in) :: codeparameters
      INTEGER(ikind), INTENT(out) :: return_status 

      TYPE(tree) :: parameter_list
      TYPE(element), POINTER :: temp_pointer
      INTEGER(ikind) :: i, nparm, n_values
      CHARACTER(len = 132) :: cname

      return_status = 0      ! no error

      !-- parse xml-string codeparameters%parameters

      WRITE(*,*) 'Calling euitm_xml_parse'
      CALL euitm_xml_parse(code_parameters, nparm, parameter_list)
      WRITE(*,*) 'Called euitm_xml_parse'

      !-- assign variables

      temp_pointer => parameter_list%first

      outer: DO
         cname = char2str(temp_pointer%cname)   ! necessary for AIX
         SELECT CASE (cname)
         CASE ("parameters")
            temp_pointer => temp_pointer%child
            CYCLE

!--   dims parameters
         CASE ("dims")
            temp_pointer => temp_pointer%child
            CYCLE
         CASE ("nrho")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, nrho)
         CASE ("nion")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, nion)
         CASE ("nimp")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, nimp)
         CASE ("max_nzimp")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, max_nzimp)

!--   solver parameters
         CASE ("solver")
            temp_pointer => temp_pointer%child
            CYCLE
         CASE ("rhon")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, rhon)
         CASE ("solver_type")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, solver_type)
         CASE ("sigma_source")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, sigma_source)
         CASE ("amix")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, amix)
         CASE ("amixtr")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, amixtr)
         CASE ("debug_level")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, debug_level)
         CASE ("ohmic_heating_multiplier")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, ohmic_heating_multiplier)

!--   boundary parameters
         CASE ("boundary")
            temp_pointer => temp_pointer%child
            CYCLE
         CASE ("psi_bnd_type")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, psi_bnd_type)
         CASE ("ni_bnd_type")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, ni_bnd_type)
         CASE ("ti_bnd_type")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, ti_bnd_type)
         CASE ("te_bnd_type")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, te_bnd_type)
         CASE ("vtor_bnd_type")
            IF (ALLOCATED(temp_pointer%cvalue)) &
                 CALL char2num(temp_pointer%cvalue, vtor_bnd_type)

!--  default
         CASE default
            WRITE(*, *) 'ERROR: invalid parameter', cname
            return_status = 1
            EXIT
         END SELECT
         DO
            IF (ASSOCIATED(temp_pointer%sibling)) THEN
               temp_pointer => temp_pointer%sibling
               EXIT
            END IF
            IF (ASSOCIATED(temp_pointer%parent, parameter_list%first )) &
                 EXIT outer
            IF (ASSOCIATED(temp_pointer%parent)) THEN
               temp_pointer => temp_pointer%parent
            ELSE
               WRITE(*, *) 'ERROR: broken list.'
               RETURN
            END IF
         END DO
      END DO outer

      !-- destroy tree
      CALL destroy_xml_tree(parameter_list)

      RETURN

    END SUBROUTINE assign_code_parameters
    
  END SUBROUTINE ITM_ETS
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  







! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
  SUBROUTINE ITM_ETS_KEPLER                                          &
                        (COREPROF_OLD, COREPROF_ITER, COREPROF_NEW,  &
                         EQUILIBRIUM_OLD, EQUILIBRIUM_ITER,          &
                         CORETRANSP, CORESOURCE, COREIMPUR,          &
!                         CONTROL_INTEGER, CONTROL_DOUBLE, ifail,     &
                         CONTROL_INTEGER, CONTROL_DOUBLE, HYPER_DIFF_RATIO, ifail,     & !AF 25.Apr.2016
                         code_parameters) 

!-------------------------------------------------------!
!     This routine provides interface between CPO       !
!     derived types and internal ETS derived types      !
!     for KEPLER ETS actor.                             !
!-------------------------------------------------------!
!     Source:       ---                                 !
!     Developers:   D.Kalupin                           !
!     Kontacts:     D.Kalupin@fz-juelich.de             !
!                                                       !
!     Comments:     Code parameters are defined         !
!                   in the Wokflow                      !
!                                                       !
!-------------------------------------------------------!


    USE EUITM_SCHEMAS
    USE COPY_STRUCTURES
    USE ETS_PLASMA
    USE CONVERT
    USE ALLOCATE_DEALLOCATE

    IMPLICIT NONE

    INTEGER                           :: ifail

! +++ CPO derived types:
    TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM_OLD(:)  !input CPO with geometry quantities from previous time
    TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM_ITER(:) !input CPO with geometry quantities from previous iteration
    TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_OLD(:)     !input CPO with internal ETS parameters profiles from previous time
    TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_NEW(:)     !input/output CPO with internal ETS parameters profiles 
    TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_ITER(:)    !input/output CPO with internal ETS parameters profiles from previous iteration
    TYPE (TYPE_CORETRANSP),  POINTER  :: CORETRANSP(:)       !input CPO with transport coefficients
    TYPE (TYPE_CORESOURCE),  POINTER  :: CORESOURCE(:)       !input CPO with sources
    TYPE (TYPE_COREIMPUR),   POINTER  :: COREIMPUR(:)        !input CPO with impurities
    TYPE (type_param)                 :: code_parameters


! +++ Internal ETS derived types:
    TYPE (MAGNETIC_GEOMETRY)          :: GEOMETRY            !contains all geometry quantities
    TYPE (PLASMA_PROFILES)            :: PROFILES            !contains profiles of plasma parameters
    TYPE (TRANSPORT_COEFFICIENTS)     :: TRANSPORT           !contains profiles of trasport coefficients
    TYPE (SOURCES_AND_SINKS)          :: SOURCES             !contains profiles of sources
    TYPE (TIME_EVOLUTION)             :: EVOLUTION           !contains all parameters required by time evolution
    TYPE (RUN_CONTROL)                :: CONTROL             !contains all parameters required by run
    TYPE (IMPURITY_PROFILES)          :: IMPURITY            !contains profiles of impurities calculated by separate module


! +++ Dimensions:
    INTEGER,               PARAMETER  :: NOCUR = 1           !number of CPO ocurancies in the work flow
    INTEGER                           :: NRHO,irho           !number of radial points     (input, determined from COREPROF CPO)
    INTEGER                           :: NION                !number of ion species       (input, determined from COREPROF CPO)
    INTEGER                           :: NIMP                !number of impurity species  (input, determined from COREIMPUR CPO)
    INTEGER,             ALLOCATABLE  :: NZIMP(:)            !maximum number of impurity ionization states
    INTEGER                           :: IIMP, MAX_NZIMP
    INTEGER                           :: NNEUT
    INTEGER                           :: NNUCL
    INTEGER,             ALLOCATABLE  :: NCOMP(:)
    INTEGER,             ALLOCATABLE  :: NTYPE(:)



! +++ Control parameters:
    INTEGER,               INTENT(IN) :: CONTROL_INTEGER(3)  !integer control parameters
    REAL (R8),             INTENT(IN) :: CONTROL_DOUBLE(6)   !real control parameters
    CHARACTER(LEN=500)                :: failstring

! +++ Stabilization scheme !AF 25.Apr.2016
    REAL (R8)                         :: HYPER_DIFF_RATIO    !ratio of hyper diffusivity to maximum diffusivity !AF 25.Apr.2016

! +++ Set dimensions:
    NRHO                        =   SIZE (COREPROF_ITER(1)%rho_tor)
    CALL GET_COMP_DIMENSIONS             (COREPROF_ITER(1)%COMPOSITIONS, NNUCL, NION,  NIMP,  NZIMP, NNEUT, NTYPE, NCOMP)

    MAX_NZIMP                   =        0
    IF (NIMP.GE.1) MAX_NZIMP    = MAXVAL (NZIMP)

    ALLOCATE                             (COREPROF_NEW(1))        
    CALL COPY_CPO                        (COREPROF_ITER(1),COREPROF_NEW(1))


! +++ Allocation of ETS derived types:
    CALL ALLOCATE_MAGNETIC_GEOMETRY      (NRHO,                 GEOMETRY,  ifail)
    CALL ALLOCATE_PLASMA_PROFILES        (NRHO,NION,            PROFILES,  ifail)
    CALL ALLOCATE_TRANSPORT_COEFFICIENTS (NRHO,NION,            TRANSPORT, ifail)
    CALL ALLOCATE_SOURCES_AND_SINKS      (NRHO,NION,            SOURCES,   ifail)
    CALL ALLOCATE_IMPURITY_PROFILES      (NRHO,NIMP,MAX_NZIMP,  IMPURITY,  ifail)
    CALL ALLOCATE_TIME_EVOLUTION         (NRHO,NION,            EVOLUTION, ifail)
    CALL ALLOCATE_RUN_CONTROL            (                      CONTROL,   ifail)


! +++ Copy CPOs in ETS derived types:
   CALL CONVERT_CPO_TO_ETS_TYPES                                                  &
         (EQUILIBRIUM_OLD, EQUILIBRIUM_ITER, COREPROF_OLD, COREPROF_ITER,         &
         CORETRANSP, CORESOURCE, COREIMPUR, CONTROL_INTEGER, CONTROL_DOUBLE,      &
!
         GEOMETRY, PROFILES, TRANSPORT, SOURCES, IMPURITY, EVOLUTION, CONTROL)


! +++ Call MAIN_PLASMA with internal ETS derived types:
    CALL MAIN_PLASMA                                                              &
!         (GEOMETRY, PROFILES, TRANSPORT, SOURCES, IMPURITY, EVOLUTION, CONTROL,   &
         (GEOMETRY, PROFILES, TRANSPORT, SOURCES, IMPURITY, EVOLUTION, CONTROL, HYPER_DIFF_RATIO,  & !AF 25.Apr.2016
         ifail,failstring) 



! +++ Copy ETS derived types in CPOs:
    CALL CONVERT_ETS_TO_CPO_TYPES                                                 &
         (GEOMETRY, PROFILES, TRANSPORT, SOURCES, COREPROF_NEW)



! +++ Deallocation of ETS derived types:
    CALL DEALLOCATE_MAGNETIC_GEOMETRY      (GEOMETRY,  ifail)
    CALL DEALLOCATE_PLASMA_PROFILES        (PROFILES,  ifail)
    CALL DEALLOCATE_TRANSPORT_COEFFICIENTS (TRANSPORT, ifail)
    CALL DEALLOCATE_SOURCES_AND_SINKS      (SOURCES,   ifail)
    CALL DEALLOCATE_IMPURITY_PROFILES      (IMPURITY,  ifail)
    CALL DEALLOCATE_TIME_EVOLUTION         (EVOLUTION, ifail)
    CALL DEALLOCATE_RUN_CONTROL            (CONTROL,   ifail)

    IF (ALLOCATED(NZIMP)) DEALLOCATE(NZIMP)
    IF (ALLOCATED(NCOMP)) DEALLOCATE(NCOMP)
    IF (ALLOCATED(NTYPE)) DEALLOCATE(NTYPE)


    RETURN



  END SUBROUTINE ITM_ETS_KEPLER
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  


END MODULE ETS



#ifndef NO_EUITM_ROUTINES

! + + + + + + + + + + + + + + + + + + + + + + + + + + + +  
!> ITMETSKEPLER provides the coupling between the COS
!> type workflow and the ETS
!>
!> note that psi is rescaled by $-2 \pi$
!>
!> \author Ph.Huynh and V.Basiuk
!>
!> \version "$Id$"
! + + + + + + + + + + + + + + + + + + + + + + + + + + + +   

SUBROUTINE ITMETSKEPLER (EQUILIBRIUM_ITER,CORETRANSP,neotn,neotnp1, &
     COREPROF_OLD,COREPROF_NEW,COREPROF_ITER, &
     workflowtabint,workflowtabreal,code_parameters)

  USE euITM_schemas
  USE euITM_routines
  USE ETS
  USE ETS_PLASMA

  IMPLICIT NONE



  TYPE(type_neoclassic),POINTER           :: neotn(:),neotnp1(:)
  INTEGER,DIMENSION(3)                    :: workflowtabint
  REAL*8,DIMENSION(6)                     :: workflowtabreal
  INTEGER                                 :: CONTROL_INTEGER(3)
  REAL(R8)                                :: CONTROL_DOUBLE(6)

 


  TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM_OLD(:)  !input CPO with geometry quantities from previous time
  TYPE (TYPE_EQUILIBRIUM), POINTER  :: EQUILIBRIUM_ITER(:) !input CPO with geometry quantities from previous iteration
  TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_OLD(:)     !input CPO with internal ETS parameters profiles from previous time
  TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_NEW(:)     !input/output CPO with internal ETS parameters profiles 
  TYPE (TYPE_COREPROF),    POINTER  :: COREPROF_ITER(:)    !input/output CPO with internal ETS parameters profiles from previous iteration
  TYPE (TYPE_CORETRANSP),  POINTER  :: CORETRANSP(:)       !input CPO with transport coefficients
  TYPE (TYPE_CORESOURCE),  POINTER  :: CORESOURCE(:)       !input CPO with sources
  TYPE (TYPE_COREIMPUR),   POINTER  :: COREIMPUR(:)        !input CPO with impurities
  TYPE (type_param) :: code_parameters
  INTEGER :: nrhow,nspec,k
!
! rename the CPO for ETS structure
!
!	EQUILIBRIUM_ITER	equilibrium 	tn	input
!	CORETRANSP		coretransp 	tn	input
!	neotn			neoclassic	tn	input
!	neotnp1			neoclassic	tn	input
!	COREPROF_OLD		coreprof	tn	input
!	COREPROF_NEW		coreprof	tnp1	input/output
!	COREPROF_ITER		coreprof	tnp1	input/output
!	workflowtabint
!	workflowtabreal
!	code_parameters
!call euitm_copy(EQUILIBRIUM_ITER,EQUILIBRIUM_OLD)
!
! only the current diffusion equation is addressed
!
!        COREPROF_ITER=>COREPROF_NEW

        CALL euitm_copy(COREPROF_NEW,COREPROF_ITER)
        CALL euitm_copy(EQUILIBRIUM_ITER,EQUILIBRIUM_OLD)
        CALL euitm_deallocate(COREPROF_NEW)

        nrhow=SIZE(coreprof_iter(1)%te%value)
        nspec=SIZE(coreprof_iter(1)%ti%value,2)

        ALLOCATE(COREIMPUR(1))
        ALLOCATE(CORESOURCE(1))

        IF (.NOT.ASSOCIATED(CORETRANSP)) ALLOCATE(CORETRANSP(1))
        IF (.NOT.ASSOCIATED(CORETRANSP(1)%VALUES(1)%sigma)) ALLOCATE(CORETRANSP(1)%VALUES(1)%sigma(nrhow))
        ALLOCATE(CORESOURCE(1)%VALUES(1)%j(nrhow),CORESOURCE(1)%VALUES(1)%sigma(nrhow))
	CORETRANSP(1)%VALUES(1)%sigma(:) = neotn(1)%sigma(:)
        CORESOURCE(1)%VALUES(1)%sigma(:) = neotn(1)%sigma(:)
	CORESOURCE(1)%VALUES(1)%j(:)     = neotn(1)%jboot(:)

!workaround for unused values

        ALLOCATE(COREPROF_OLD(1)%vtor%value(nrhow,nspec))
        COREPROF_OLD(1)%vtor%value=0

        ALLOCATE(COREPROF_ITER(1)%ni%boundary%value(3,nspec))
        COREPROF_ITER(1)%ni%boundary%value=0
        ALLOCATE(COREPROF_ITER(1)%ti%boundary%value(3,nspec))
        COREPROF_ITER(1)%ti%boundary%value=0
        ALLOCATE(COREPROF_ITER(1)%te%boundary%value(3))
        COREPROF_ITER(1)%te%boundary%value=0
        ALLOCATE(COREPROF_ITER(1)%vtor%value(nrhow,nspec))
        COREPROF_ITER(1)%vtor%value=0
        ALLOCATE(COREPROF_ITER(1)%vtor%boundary%type(nspec))
        COREPROF_ITER(1)%vtor%boundary%type=0
        ALLOCATE(COREPROF_ITER(1)%vtor%boundary%value(3,nspec))
        COREPROF_ITER(1)%vtor%boundary%value=0

        ALLOCATE(CORETRANSP(1)%VALUES(1)%te_transp%diff_eff(nrhow))
        CORETRANSP(1)%VALUES(1)%te_transp%diff_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%te_transp%vconv_eff(nrhow))
        CORETRANSP(1)%VALUES(1)%te_transp%vconv_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%ni_transp%diff_eff(nrhow,nspec,3))
        CORETRANSP(1)%VALUES(1)%ni_transp%diff_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%ni_transp%vconv_eff(nrhow,nspec,3))
        CORETRANSP(1)%VALUES(1)%ni_transp%vconv_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%ti_transp%diff_eff(nrhow,nspec))
        CORETRANSP(1)%VALUES(1)%ti_transp%diff_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%ti_transp%vconv_eff(nrhow,nspec))
        CORETRANSP(1)%VALUES(1)%ti_transp%vconv_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%vtor_transp%diff_eff(nrhow,nspec))
        CORETRANSP(1)%VALUES(1)%vtor_transp%diff_eff=0
        ALLOCATE(CORETRANSP(1)%VALUES(1)%vtor_transp%vconv_eff(nrhow,nspec))
        CORETRANSP(1)%VALUES(1)%vtor_transp%vconv_eff=0

        ALLOCATE(CORESOURCE(1)%VALUES(1)%qe%exp(nrhow))
        CORESOURCE(1)%VALUES(1)%qe%exp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%qe%imp(nrhow))
        CORESOURCE(1)%VALUES(1)%qe%imp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%si%exp(nrhow,nspec))
        CORESOURCE(1)%VALUES(1)%si%exp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%si%imp(nrhow,nspec))
        CORESOURCE(1)%VALUES(1)%si%imp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%qi%exp(nrhow,nspec))
        CORESOURCE(1)%VALUES(1)%qi%exp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%qi%imp(nrhow,nspec))
        CORESOURCE(1)%VALUES(1)%qi%imp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%ui%exp(nrhow,nspec))
        CORESOURCE(1)%VALUES(1)%ui%exp=0
        ALLOCATE(CORESOURCE(1)%VALUES(1)%ui%imp(nrhow,nspec))
        CORESOURCE(1)%VALUES(1)%ui%imp=0

        ALLOCATE(COREIMPUR(1)%impurity(1))
        ALLOCATE(COREIMPUR(1)%IMPURITY(1)%nz(nrhow,1))
        COREIMPUR(1)%IMPURITY(1)%nz=0
        ALLOCATE(COREIMPUR(1)%IMPURITY(1)%flux%flux_dv(nrhow,1))
        COREIMPUR(1)%IMPURITY(1)%flux%flux_dv=0
        ALLOCATE(COREIMPUR(1)%IMPURITY(1)%z(nrhow,1))
        COREIMPUR(1)%IMPURITY(1)%z=0
        ALLOCATE(COREIMPUR(1)%IMPURITY(1)%zsq(nrhow,1))
        COREIMPUR(1)%IMPURITY(1)%zsq=0

!
!	actual COS parameters
!
!	workflowtabint(1) = current iteration
!	workflowtabint(2) = iteration maximum
!	workflowtabint(3) = best value
!       workflowtabreal(1) = error
!       workflowtabreal(2) = tolerance
!       workflowtabreal(3) = dt
!       workflowtabreal(4) = tn
!       workflowtabreal(5) = tnp1
!       workflowtabreal(5) = tend
!

! ---> needs to map yours own parameters (possible to add new one in the kepler framework

        CONTROL_INTEGER(1) = 3 !solver type
        CONTROL_INTEGER(2) = 1 !sigma source
        !write(*,*) "parameters of the solver",workflowtabreal
	CONTROL_DOUBLE(1)  = workflowtabreal(4) 
	!CONTROL_DOUBLE(2)  = 0. !amix between old and new 
        CONTROL_DOUBLE(2)  = 1.
	CONTROL_DOUBLE(3)  = 1. !amixtr
	CONTROL_DOUBLE(4)  = workflowtabreal(1)
	CONTROL_DOUBLE(5)  = workflowtabreal(2)
        COREPROF_OLD(1)%psi%value = -2.0*ACOS(-1.0)*COREPROF_OLD(1)%psi%value
        COREPROF_ITER(1)%psi%value = -2.0*ACOS(-1.0)*COREPROF_ITER(1)%psi%value
        CALL ITM_ETS    (COREPROF_OLD, COREPROF_ITER, COREPROF_NEW,  &
                         EQUILIBRIUM_OLD, EQUILIBRIUM_ITER,          &
                         CORETRANSP, CORESOURCE, COREIMPUR,          &
                         CONTROL_INTEGER, CONTROL_DOUBLE, code_parameters)
        COREPROF_ITER(1)%psi%value=-COREPROF_ITER(1)%psi%value/(2.0*ACOS(-1.0))
        COREPROF_NEW(1)%psi%value=-COREPROF_NEW(1)%psi%value/(2.0*ACOS(-1.0))
        CALL euitm_deallocate(CORESOURCE)
        CALL euitm_deallocate(COREIMPUR)
         
END SUBROUTINE

#endif


