.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Fortran::F90Namelist 3"
.TH Fortran::F90Namelist 3 "2007-05-19" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Fortran::F90Namelist \- Parse F90 namelists into hash and export in different formats
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Fortran::F90Namelist;
\&  my $nl = Fortran::F90Namelist->new() or die "Couldn't get object\en";
.Ve
.PP
.Vb 1
\&  $nl->parse("&runpars\enx=2,y=3\envec1=1,2,3\envec2=3*1.3\en/");
.Ve
.PP
.Vb 6
\&  # Operate on each namelist in $text (only works with [mutable]
\&  # strings, not with files)
\&  my $text = "&spars\enx=2,y=3\en/\en&runpars\envec1=1,2,3\envec2=3*1.3\en/";
\&  while ($nl->parse($text)) {
\&      print $nl->name(), "\en";
\&  }
.Ve
.PP
Dump in arbitrary order:
.PP
.Vb 3
\&  use Data::Dumper;
\&  print "F90Namelist ", $nl->name(), " has ", $nl->nslots(), " slots:\en";
\&  print Dumper($nl->hash());
.Ve
.PP
Retain original order:
.PP
.Vb 6
\&  print "&",$nl->name(),"\en";
\&  my $nl_hash = $nl->hash();
\&  foreach my $var (@{$nl->slots()}) {
\&    print "  $var: ", Dumper($nl_hash->{$var});
\&  }
\&  print "/\en";
.Ve
.PP
Read from file:
.PP
.Vb 2
\&  # Read one namelist from file `one_list.nml'
\&  $nl->parse(file => 't/files/one_list.nml');
.Ve
.PP
.Vb 6
\&  # Read one namelist from file handle
\&  open(my $fh , "< t/files/one_list.nml") or die "Couldn't get file handle\en";
\&  $nl->parse(file => $fh);
\&  # or
\&  open(NAMELIST , "< t/files/one_list.nml") or die "Couldn't open file\en";
\&  $nl->parse(file => \e*NAMELIST);
.Ve
.PP
Read all namelists from file `start.in' and merge into one namelist
called `nlist'
.PP
.Vb 5
\&  $nl->parse(file     => 't/files/start.in',
\&             all      => 1,
\&             namelist => 'nlist');
\&  print "Merged namelist ", $nl->name, " contains:\en",
\&      join(",  ", @{$nl->slots}), "\en";
.Ve
.PP
Merge two namelists
.PP
.Vb 5
\&  my $nl2 = Fortran::F90Namelist->new() or die "Couldn't get object\en";
\&  $nl2->parse(file => 't/files/one_list.nml');
\&  $nl->merge($nl2,
\&             { dups_ok => 1 } );
\&  print $nl->name, " now has ", $nl->nslots, " slots\en";
.Ve
.PP
Write namelist:
.PP
.Vb 2
\&  # Write namelist in F90 namelist format
\&  print "F90 format:\en", $nl->output();
.Ve
.PP
.Vb 2
\&  # Write namelist as IDL structure
\&  print "IDL format:\en", $nl->output(format => 'idl', name => 'par2');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Fortran::F90Namelist is a module for parsing Fortran90 namelists into hashs and
re-exporting these hashs in different formats. Currently, the following
data types are supported:
.IP "\(bu" 4
integer
.IP "\(bu" 4
float/double
.IP "\(bu" 4
complex numbers
.IP "\(bu" 4
strings [character(LEN=*)], possibly containing all sorts of quotation
marks
.IP "\(bu" 4
logical
.PP
The following backends exist for re-exporting (or importing into other
languages):
.IP "\(bu" 4
F90 namelist
.IP "\(bu" 4
\&\s-1IDL\s0 struct
.PP
This module is used with the \fIPencil Code\fR
(<http://www.nordita.dk/software/pencil\-code/>) to import the values of
all available input parameters into \s-1GDL/IDL\s0 or other visualization
software.
.Sh "Methods"
.IX Subsection "Methods"
.IP "\fB$nl\->new\fR()" 4
.IX Item "$nl->new()"
Create a new namelist object
.IP "\fB$nl\->parse\fR(\fIstring\fR)" 4
.IX Item "$nl->parse(string)"
.PD 0
.IP "\fB$nl\->parse\fR(text => \fIstring\fR)" 4
.IX Item "$nl->parse(text => string)"
.IP "\fB$nl\->parse\fR(file =>(\fIfname\fR|\fI\s-1FHANDLE\s0\fR))" 4
.IX Item "$nl->parse(file =>(fname|FHANDLE))"
.IP "\fB$nl\->parse\fR(file => (\fIfname\fR|\fI\s-1FHANDLE\s0\fR) [, \fIoptions\fR ])" 4
.IX Item "$nl->parse(file => (fname|FHANDLE) [, options ])"
.IP "\fB$nl\->parse\fR(\e%options)" 4
.IX Item "$nl->parse(%options)"
.PD
Parse \fIstring\fR or the file represented by \fIfname\fR or \fI\s-1FHANDLE\s0\fR (a file
handle), returns the name of the namelist parsed, or undef if parsing
failed.
.Sp
When reading from a mutable text string \f(CW$text\fR, the string is modified and
contains everything following the namelist just parsed.
.Sp
This allows \f(CW\*(C`while\*(C'\fR loops like
.Sp
.Vb 3
\&  while ($nl->parse($text)) {
\&      print $nl->name(), "\en";
\&  }
.Ve
.Sp
to work.
This does however not work for files or immutable strings, so
.Sp
.Vb 3
\&  while ($nl->parse(file => "t/files/start.in")) {
\&      print $nl->name(), "\en";
\&  }
.Ve
.Sp
and
.Sp
.Vb 3
\&  while ($nl->parse("&nl1\enx=5.\en/\en&nl2\en/")) {
\&      print $nl->name(), "\en";
\&  }
.Ve
.Sp
will fail.
.Sp
Generally speaking, Fortran::F90Namelist::Group
is the more appropriate tool for handling several namelists in one file or
string.
.Sp
Additional \fIoptions\fR are:
.RS 4
.IP "\fBmerge\fR" 8
.IX Item "merge"
If true, merge data from namelist with any data that may already be
stored in the object.
See Fortran::F90Namelist::Group for a more
flexible framework for dealing with groups of namelists.
.IP "\fBall\fR" 8
.IX Item "all"
If true, parse all namelists from string or file and merge them into one
namelist object.
.IP "\fBname\fR" 8
.IX Item "name"
Set name of resulting namelist (default: name of first namelist read).
.IP "\fBdups_ok\fR" 8
.IX Item "dups_ok"
With \fBmerge\fR, don't warn if new slots have same names, but different
values as existing slots.
.IP "\fBbroken\fR" 8
.IX Item "broken"
Try to parse broken namelists as produced by ifc 7.x, where you can get
something like
.Sp
.Vb 2
\&   COOLING_PROFILE='gaussian              ',COOLTYPE='Temp    
\&   'COOL= 0.0,CS2COOL= 0.0,RCOOL= 1.000000
.Ve
.Sp
if the closing quote for a string (`Temp    ') would end up in column 81.
.Sp
All options can be passed in a hash(\-ref):
.Sp
.Vb 5
\&  my %options = ( file   => 't/files/one_list.nml',
\&                  name   => 'broken_nlist',
\&                  broken => 1 );
\&  $nl->parse(%options);
\&  $nl->parse(\e%options);  # the same
.Ve
.RE
.RS 4
.RE
.IP "\fB$nl\->merge\fR($nl2 [, \fIoptions\fR])" 4
.IX Item "$nl->merge($nl2 [, options])"
Merge namelist object \f(CW$nl2\fR into \f(CW$nl\fR.
.Sp
\&\fIOptions\fR are:
.RS 4
.IP "\fBname\fR" 8
.IX Item "name"
Set name of resulting namelist (default: name of \f(CW$nl\fR).
.IP "\fBdups_ok\fR" 8
.IX Item "dups_ok"
With \fBmerge\fR, don't warn if new slots have same names, but different
values as existing slots.
.RE
.RS 4
.RE
.IP "\fB$nl\->name\fR()" 4
.IX Item "$nl->name()"
.PD 0
.IP "\fB$nl\->name\fR($newname)" 4
.IX Item "$nl->name($newname)"
.PD
Return or set name of namelist.
.IP "\fB$nl\->nslots\fR()" 4
.IX Item "$nl->nslots()"
Return number of slots in namelist
.IP "\fB$nl\->slots\fR()" 4
.IX Item "$nl->slots()"
Return ref to list of variable (slot) names in original order
.IP "\fB$nl\->hash\fR()" 4
.IX Item "$nl->hash()"
Return namelists as Perl hashref.
See \s-1HASH\s0 \s-1FORMAT\s0 below for details of the hash format.
.IP "\fB$nl\->output\fR([options])" 4
.IX Item "$nl->output([options])"
Write namelist in given \fIformat\fR.
.Sp
Options are
.RS 4
.IP "\fBformat\fR=\fIformat\fR" 8
.IX Item "format=format"
Set the output format.
Currently supported formats are `f90' (default), and `idl'.
.IP "\fBname\fR=\fIname\fR" 8
.IX Item "name=name"
Set the name of the namelist (default: \f(CW\*(C`$nl\->name\*(C'\fR()).
.IP "\fBtrim\fR" 8
.IX Item "trim"
Trim all trailing whitespace from strings.
.IP "\fBdouble\fR" 8
.IX Item "double"
Write all floating point numbers as double precision numbers.
.IP "\fBoneline\fR" 8
.IX Item "oneline"
Print whole namelist in one line (if compatible with the output format).
.IP "\fBmaxslots\fR=\fIN\fR" 8
.IX Item "maxslots=N"
Print only N slots per line.
Useful for programs like \s-1IDL\s0 that have restrictions on the length of lines
read from a pipe, so \fBoneline\fR is dangerous.
.RE
.RS 4
.RE
.SH "HASH FORMAT"
.IX Header "HASH FORMAT"
The \fBhash\fR method returns a hash reference of the following structure:
.PP
.Vb 10
\&    { 'name of var1' => { 'value' => [ value1, value2, ..],
\&                          'type'  => numerical_type,
\&                          'stype' => "type string"
\&                        },
\&      'name of var2' => { 'value' => [ value1, value2, ..],
\&                          'type'  => numerical_type
\&                          'stype' => "type string"
\&                        },
\&      ...
\&    }
.Ve
.PP
Here \fInumerical_type\fR is a number identifying each data type, while
\&\fIstype\fR is a textual description of the given data type.
.PP
E.g.
.PP
.Vb 9
\&    { 'xyz0' => { 'value' => [ 0., -3.141593, 0. ],
\&                  'type'  => 6,
\&                  'stype' => 'single precision float'
\&                },
\&      'nt'   => { 'value' => [ '1000' ],
\&                  'type'  => 4,
\&                  'stype' => 'integer'
\&                }
\&    }
.Ve
.PP
Note: This is currently just the internal format used to represent
namelists and can thus change in the future.
In particular the \f(CW\*(C`type\*(C'\fR numbers should not considered to be stable
between releases.
.SH "TO DO"
.IX Header "TO DO"
.IP "1." 4
\&\fInew()\fR, \fIparse()\fR, \fIoutput()\fR, etc. should check for unknown args and complain,
not silently ignore them as is currently the case.
.IP "2." 4
More output methods:
.RS 4
.IP "*" 8
Octave/matlab , C structs, \s-1YAML\s0, \s-1XML\s0(?), ...
.RE
.RS 4
.RE
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.IP "\(bu" 4
No user-defined types (records) are supported, so if you have these LaTeX
comment characters in your namelist data, you are out of luck.
.SH "AUTHOR"
.IX Header "AUTHOR"
Wolfgang Dobler <Wolfgang.Dobler@kis.uni\-freiburg.de>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2007, Wolfgang Dobler <Wolfgang.Dobler@kis.uni\-freiburg.de>.
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same conditions as Perl or under the \s-1GNU\s0 General Public
License, version 2 or later.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
Use completely at your own risk.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Fortran::Namelist by Victor Marcello Santillan.
That module has a more limited scope (reading a namelist group from file,
inserting namelists, and writing the resulting group to another file [my
interpretation]), but is way faster on large files.
