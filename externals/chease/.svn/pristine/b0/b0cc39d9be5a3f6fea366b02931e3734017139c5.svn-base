.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Fortran::F90Namelist::Group 3"
.TH Fortran::F90Namelist::Group 3 "2007-05-19" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Fortran::F90Namelist::Group \- Parse F90 namelist groups and export in different formats
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Fortran::F90Namelist::Group;
\&  my $nlgrp = Fortran::F90Namelist::Group->new() or die "Couldn't get object\en";
.Ve
.PP
.Vb 11
\&  $nlgrp->parse(<<'  HERE');
\&    &runpars
\&      x=2,y=3
\&      vec1=1,2,3
\&      vec2=3*1.3
\&    /
\&    &more_runpars
\&      z=7
\&      vec1=0,1,2,3
\&    /
\&  HERE
.Ve
.PP
Read from file:
.PP
.Vb 2
\&  # Read namelist group from file `some_lists.nml':
\&  $nlgrp->parse(file => 't/files/some_lists.nml');
.Ve
.PP
.Vb 6
\&  # Read namelist group from file handle
\&  open(my $fh , "< t/files/some_lists.nml") or die "Couldn't get file handle\en";
\&  $nlgrp->parse(file => $fh);
\&  # or
\&  open(NLGROUP , "< t/files/some_lists.nml") or die "Couldn't get file handle\en";
\&  $nlgrp->parse(file => \e*NLGROUP);
.Ve
.PP
.Vb 3
\&  # Print names of all namelists in file `start.in'
\&  $nlgrp->parse(file => 't/files/start.in') or die "Couldn't parse\en";
\&  print join(" ", $nlgrp->names), "\en";
.Ve
.PP
Extract or merge namelists from group and return \fIFortran::F90Namelist\fR object:
.PP
.Vb 3
\&  my $nl_1   = $nlgrp->first();   # Extract first namelist from group
\&  my $nl_3   = $nlgrp->nth(3);    # Extract 4th namelist from group
\&  my $nl_all = $nlgrp->flatten(); # Flatten all namelists into one
.Ve
.PP
Write namelist group:
.PP
.Vb 2
\&  # Write namelist group in F90 namelist format
\&  print $nlgrp->output();
.Ve
.PP
.Vb 2
\&  # Write namelist as IDL structure
\&  print $nlgrp->output(format => 'idl');
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIFortran::F90Namelist::Group\fR is a module for parsing Fortran90 namelist
groups into an internal format based on
Fortran::F90Namelist, and re-exporting in different
formats.
Parsing is done by Fortran::F90Namelist, see the
documentation of that module for more details.
.Sh "Methods"
.IX Subsection "Methods"
.IP "\fB$nlgrp\->new\fR()" 4
.IX Item "$nlgrp->new()"
Create a new namelist group object
.IP "\fB$nlgrp\->parse\fR(\fIstring\fR)" 4
.IX Item "$nlgrp->parse(string)"
.PD 0
.IP "\fB$nlgrp\->parse\fR(text => \fIstring\fR)" 4
.IX Item "$nlgrp->parse(text => string)"
.IP "\fB$nlgrp\->parse\fR(file => \fIfname\fR|\fIfhandle\fR)" 4
.IX Item "$nlgrp->parse(file => fname|fhandle)"
.IP "\fB$nlgrp\->parse\fR(file => \fIfname\fR|\fIfhandle\fR [, <options> ])" 4
.IX Item "$nlgrp->parse(file => fname|fhandle [, <options> ])"
.PD
Parse \fIstring\fR or the file represented by \fIfname\fR or i<fhandle> (a file
handle or File::Handle object [not yet implemeted]);
returns number of parsed namelists, or undef if parsing failed.
.Sp
Additional \fIoptions\fR are:
.RS 4
.IP "\fBappend\fR" 8
.IX Item "append"
If true, append newly parsed namelists to already existing data in the
object.
.RE
.RS 4
.RE
.IP "\fB$nlgrp\->nlists\fR()" 4
.IX Item "$nlgrp->nlists()"
Return number of namelists in group.
.IP "\fB$nlgrp\->names\fR()" 4
.IX Item "$nlgrp->names()"
Return list of namelist names in group (in original order).
.IP "\fB$nlgrp\->insert\fR(nl [, pos])" 4
.IX Item "$nlgrp->insert(nl [, pos])"
Insert namelist into namelist group at position \s-1POS\s0 (defaults to appending
nl at end of group.
Returns 1 if successfull, 0 or undef otherwise.
.IP "\fB$nlgrp\->delete\fR(nl)" 4
.IX Item "$nlgrp->delete(nl)"
.PD 0
.IP "\fB$nlgrp\->delete\fR(name)" 4
.IX Item "$nlgrp->delete(name)"
.IP "\fB$nlgrp\->delete\fR(num)" 4
.IX Item "$nlgrp->delete(num)"
.PD
Delete namelist (identified by namelist object, name, or position in
\&\f(CW$nlgrp\fR\->names) from namelist group.
Returns 1 if successfull, 0 otherwise.
.IP "\fB$nlgrp\->first\fR()" 4
.IX Item "$nlgrp->first()"
Return the first namelist in the group as
Fortran::F90Namelist object.
.IP "\fB$nlgrp\->nth\fR(n)" 4
.IX Item "$nlgrp->nth(n)"
Return the namelist with index n from the group as
Fortran::F90Namelist object.
Indices count from 0, so this returns the (n+1)st namelist.
.IP "\fB$nlgrp\->pop\fR(n)" 4
.IX Item "$nlgrp->pop(n)"
Return the first namelist in the group as
Fortran::F90Namelist object and remove it from the
group.
Returns \f(CW\*(C`undef\*(C'\fR for an empty group.
This allows to write:
.Sp
.Vb 3
\&  while (my $nl = $nlgrp->pop()) {
\&      print $nl->name(), " has ", $nl->nslots(), "slots\en";
\&  }
.Ve
.IP "\fB$nlgrp\->flatten([options])\fR" 4
.IX Item "$nlgrp->flatten([options])"
Merge all namelist data in the group into one
Fortran::F90Namelist object.
Thus,
.Sp
.Vb 2
\&  $nlgrp->parse(file => 't/files/some_lists.nml');
\&  my $nl = $nlgrp->flatten();
.Ve
.Sp
is another way of doing
.Sp
.Vb 3
\&  my $nl = Fortran::F90Namelist->new();
\&  $nl->parse(file => 't/files/some_lists.nml',
\&             all  => 1    );
.Ve
.Sp
\&\fIOptions\fR are:
.RS 4
.IP "\fBname\fR" 8
.IX Item "name"
Set name of resulting namelist (default: name of first namelist read).
.IP "\fBdups_ok\fR" 8
.IX Item "dups_ok"
Don't warn if new slots have same names as existing slots.
.RE
.RS 4
.RE
.IP "\fB$nlgrp\->hash\fR()" 4
.IX Item "$nlgrp->hash()"
Return namelist group as Perl hash.
See \s-1HASH\s0 \s-1FORMAT\s0 below for details of the hash format.
.IP "\fB$nlgrp\->output\fR(format => \fIformat\fR)" 4
.IX Item "$nlgrp->output(format => format)"
Write namelist group in given \fIformat\fR.
Currently supported formats are `f90' (default), and `idl'
.SH "HASH FORMAT"
.IX Header "HASH FORMAT"
The \fBhash\fR method returns a hash reference of the following structure:
.PP
.Vb 18
\&    { namelist1 => { var1 => { 'value' => [ value1, value2, ..],
\&                               'type'  => numerical_type,
\&                               'stype' => "type string"
\&                             },
\&                     var2 => { 'value' => [ value1, value2, ..],
\&                               'type'  => numerical_type
\&                               'stype' => "type string"
\&                             },
\&                     ...
\&                   },
\&      namelist2 => { var1 => { 'value' => [ value1, value2, ..],
\&                               'type'  => numerical_type,
\&                               'stype' => "type string"
\&                             },
\&                     ...
\&                   },
\&      ...
\&    }
.Ve
.PP
Here \fInumerical_type\fR is a number identifying each data type, while
\&\fIstype\fR is a textual description of the given data type.
.PP
E.g.
.PP
.Vb 19
\&    { 'hydro_init_pars'   => { 'u0' => { 'value' => [ 0., -3.141593, 0. ],
\&                                         'type'  => 6,
\&                                         'stype' => 'single precision float'
\&                                       },
\&                               'u1' => { 'value' => [ 0., 0., 0.],
\&                                         'type'  => 6,
\&                                         'stype' => 'single precision float'
\&                                       },
\&                             },
\&      'density_init_pars' => { 'rho0'   => { 'value' => [ -2.78 ],
\&                                             'type'  => 6,
\&                                             'stype' => 'single precision float'
\&                                           },
\&                               'ilnrho' => { 'value' => [ 3 ],
\&                                             'type'  => 4,
\&                                             'stype' => 'integer'
\&                                           },
\&                            },
\&    }
.Ve
.PP
Note: This is currently just the internal format used to represent
namelists and can thus change in the future.
In particular the \f(CW\*(C`type\*(C'\fR numbers should not be considered to be stable
between releases.
.SH "TO DO"
.IX Header "TO DO"
.IP "1." 4
More output methods:
.RS 4
.IP "*" 8
Octave/Matlab , C struct, \s-1YAML\s0, \s-1XML\s0(?), ...
.RE
.RS 4
.RE
.SH "BUGS AND LIMITATIONS"
.IX Header "BUGS AND LIMITATIONS"
.IP "\(bu" 4
No user-defined types (records) are supported, so if you have these LaTeX
comment characters in your namelist data, you are out of luck.
.SH "AUTHOR"
.IX Header "AUTHOR"
Wolfgang Dobler <Wolfgang.Dobler@kis.uni\-freiburg.de>
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright (c) 2007, Wolfgang Dobler <Wolfgang.Dobler@kis.uni\-freiburg.de>.
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it
under the same conditions as Perl or under the \s-1GNU\s0 General Public
License, version 2 or later.
.SH "DISCLAIMER OF WARRANTY"
.IX Header "DISCLAIMER OF WARRANTY"
Use completely at your own risk.
