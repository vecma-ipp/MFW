# -*- coding: utf-8 -*-
from .ualdef import *
from . import ual_low_level_wrapper as ull
import numpy

class scenario:
	'''
	class scenario
	Scenario characteristics, to be used as input or output of a whole discharge simulator. Time-dependent CPO.

	Attributes:
	- datainfo : class datainfostructuredatainfo
	   Generic information on a data item
	- centre : class centrestructurescenario_centre
	   central values of the profiles (at magnetic axis)
	- composition : class compositionstructurescenario_composition
	   Plasma composition (description of ion species).
	- configs : class configsstructurescenario_configuration
	   Strings describing the tokamak configuration
	- confinement : class confinementstructurescenario_confinement
	   characteristic confinement times
	- currents : class currentsstructurescenario_currents
	   data related to current sources and current diffusion
	- edge : class edgestructurescenario_edge
	   edge value (@ LCMS)
	- energy : class energystructurescenario_energy
	   plasma energy content
	- eqgeometry : class eqgeometrystructureeqgeometry
	   Geometry of the plasma boundary
	- global_param : class global_paramstructurescenario_global
	   Global scalar values
	- heat_power : class heat_powerstructurescenario_heat_power
	   Power delivred to plasma (thermal and non thermal)
	- itb : class itbstructurescenario_itb
	   Values characteristics of the Internal Transport Barrier
	- lim_div_wall : class lim_div_wallstructurescenario_lim_div_wall
	   values on the plate of divertor or on the limitor or on the wall (@ LCMS)
	- line_ave : class line_avestructurescenario_line_ave
	   line averaged value
	- neutron : class neutronstructurescenario_neutron
	   neutron flux for DD and DT reactions
	- ninety_five : class ninety_fivestructurescenario_ninety_five
	   values at 95% of poloidal flux
	- pedestal : class pedestalstructurescenario_pedestal
	   Values at the top of the H-mode pedestal
	- references : class referencesstructurescenario_references
	   References
	- reactor : class reactorstructurescenario_reactor
	   reactor data (such as electricity cost ...)
	- sol : class solstructurescenario_sol
	   SOL characteristic  (@ LCMS)
	- vol_ave : class vol_avestructurescenario_vol_ave
	   volume averaged value
	- codeparam : class codeparamstructurecodeparam
	   Code parameters
	- time : float
	   Time [s]; Time-dependent; Scalar
	'''

	def __init__(self):
		self.base_path = 'scenario'
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.maxOccurrences = 3
		self.datainfo = datainfostructuredatainfo('datainfo')
		self.centre = centrestructurescenario_centre('centre')
		self.composition = compositionstructurescenario_composition('composition')
		self.configs = configsstructurescenario_configuration('configs')
		self.confinement = confinementstructurescenario_confinement('confinement')
		self.currents = currentsstructurescenario_currents('currents')
		self.edge = edgestructurescenario_edge('edge')
		self.energy = energystructurescenario_energy('energy')
		self.eqgeometry = eqgeometrystructureeqgeometry('eqgeometry')
		self.global_param = global_paramstructurescenario_global('global_param')
		self.heat_power = heat_powerstructurescenario_heat_power('heat_power')
		self.itb = itbstructurescenario_itb('itb')
		self.lim_div_wall = lim_div_wallstructurescenario_lim_div_wall('lim_div_wall')
		self.line_ave = line_avestructurescenario_line_ave('line_ave')
		self.neutron = neutronstructurescenario_neutron('neutron')
		self.ninety_five = ninety_fivestructurescenario_ninety_five('ninety_five')
		self.pedestal = pedestalstructurescenario_pedestal('pedestal')
		self.references = referencesstructurescenario_references('references')
		self.reactor = reactorstructurescenario_reactor('reactor')
		self.sol = solstructurescenario_sol('sol')
		self.vol_ave = vol_avestructurescenario_vol_ave('vol_ave')
		self.codeparam = codeparamstructurecodeparam('codeparam')
		self.time = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class scenario\n'
		ret = ret + space + 'Attribute datainfo\n ' + self.datainfo.__str__(depth+1)
		ret = ret + space + 'Attribute centre\n ' + self.centre.__str__(depth+1)
		ret = ret + space + 'Attribute composition\n ' + self.composition.__str__(depth+1)
		ret = ret + space + 'Attribute configs\n ' + self.configs.__str__(depth+1)
		ret = ret + space + 'Attribute confinement\n ' + self.confinement.__str__(depth+1)
		ret = ret + space + 'Attribute currents\n ' + self.currents.__str__(depth+1)
		ret = ret + space + 'Attribute edge\n ' + self.edge.__str__(depth+1)
		ret = ret + space + 'Attribute energy\n ' + self.energy.__str__(depth+1)
		ret = ret + space + 'Attribute eqgeometry\n ' + self.eqgeometry.__str__(depth+1)
		ret = ret + space + 'Attribute global_param\n ' + self.global_param.__str__(depth+1)
		ret = ret + space + 'Attribute heat_power\n ' + self.heat_power.__str__(depth+1)
		ret = ret + space + 'Attribute itb\n ' + self.itb.__str__(depth+1)
		ret = ret + space + 'Attribute lim_div_wall\n ' + self.lim_div_wall.__str__(depth+1)
		ret = ret + space + 'Attribute line_ave\n ' + self.line_ave.__str__(depth+1)
		ret = ret + space + 'Attribute neutron\n ' + self.neutron.__str__(depth+1)
		ret = ret + space + 'Attribute ninety_five\n ' + self.ninety_five.__str__(depth+1)
		ret = ret + space + 'Attribute pedestal\n ' + self.pedestal.__str__(depth+1)
		ret = ret + space + 'Attribute references\n ' + self.references.__str__(depth+1)
		ret = ret + space + 'Attribute reactor\n ' + self.reactor.__str__(depth+1)
		ret = ret + space + 'Attribute sol\n ' + self.sol.__str__(depth+1)
		ret = ret + space + 'Attribute vol_ave\n ' + self.vol_ave.__str__(depth+1)
		ret = ret + space + 'Attribute codeparam\n ' + self.codeparam.__str__(depth+1)
		ret = ret + space + 'Attribute time: ' + str(self.time) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.datainfo.setExpIdx(idx)
		self.centre.setExpIdx(idx)
		self.composition.setExpIdx(idx)
		self.configs.setExpIdx(idx)
		self.confinement.setExpIdx(idx)
		self.currents.setExpIdx(idx)
		self.edge.setExpIdx(idx)
		self.energy.setExpIdx(idx)
		self.eqgeometry.setExpIdx(idx)
		self.global_param.setExpIdx(idx)
		self.heat_power.setExpIdx(idx)
		self.itb.setExpIdx(idx)
		self.lim_div_wall.setExpIdx(idx)
		self.line_ave.setExpIdx(idx)
		self.neutron.setExpIdx(idx)
		self.ninety_five.setExpIdx(idx)
		self.pedestal.setExpIdx(idx)
		self.references.setExpIdx(idx)
		self.reactor.setExpIdx(idx)
		self.sol.setExpIdx(idx)
		self.vol_ave.setExpIdx(idx)
		self.codeparam.setExpIdx(idx)

	def getMaxOccurrences(self):
		return self.maxOccurrences

	def getCPOName(self):
		return self.base_path

	def putSlice(self, occurrence=0):
		if occurrence==0:
			path = self.base_path
		else:
			path = self.base_path + '/' + str(occurrence)
		cpopath = '' 
		self.cpoTime = self.time
		status = ull.beginCPOPutSlice(self.idx, path)
		self.datainfo.cpoTime = self.cpoTime
		self.datainfo.putSlice(path, cpopath)
		self.centre.cpoTime = self.cpoTime
		self.centre.putSlice(path, cpopath)
		self.composition.cpoTime = self.cpoTime
		self.composition.putSlice(path, cpopath)
		self.configs.cpoTime = self.cpoTime
		self.configs.putSlice(path, cpopath)
		self.confinement.cpoTime = self.cpoTime
		self.confinement.putSlice(path, cpopath)
		self.currents.cpoTime = self.cpoTime
		self.currents.putSlice(path, cpopath)
		self.edge.cpoTime = self.cpoTime
		self.edge.putSlice(path, cpopath)
		self.energy.cpoTime = self.cpoTime
		self.energy.putSlice(path, cpopath)
		self.eqgeometry.cpoTime = self.cpoTime
		self.eqgeometry.putSlice(path, cpopath)
		self.global_param.cpoTime = self.cpoTime
		self.global_param.putSlice(path, cpopath)
		self.heat_power.cpoTime = self.cpoTime
		self.heat_power.putSlice(path, cpopath)
		self.itb.cpoTime = self.cpoTime
		self.itb.putSlice(path, cpopath)
		self.lim_div_wall.cpoTime = self.cpoTime
		self.lim_div_wall.putSlice(path, cpopath)
		self.line_ave.cpoTime = self.cpoTime
		self.line_ave.putSlice(path, cpopath)
		self.neutron.cpoTime = self.cpoTime
		self.neutron.putSlice(path, cpopath)
		self.ninety_five.cpoTime = self.cpoTime
		self.ninety_five.putSlice(path, cpopath)
		self.pedestal.cpoTime = self.cpoTime
		self.pedestal.putSlice(path, cpopath)
		self.references.cpoTime = self.cpoTime
		self.references.putSlice(path, cpopath)
		self.reactor.cpoTime = self.cpoTime
		self.reactor.putSlice(path, cpopath)
		self.sol.cpoTime = self.cpoTime
		self.sol.putSlice(path, cpopath)
		self.vol_ave.cpoTime = self.cpoTime
		self.vol_ave.putSlice(path, cpopath)
		self.codeparam.cpoTime = self.cpoTime
		self.codeparam.putSlice(path, cpopath)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'time', self.time, self.cpoTime)
		check_status(status)
		status = ull.endCPOPutSlice(self.idx, path)

	def replaceLastSlice(self, occurrence=0):
		if occurrence==0:
			path = self.base_path
		else:
			path = self.base_path + '/' + str(occurrence)
		cpopath = '' 
		self.cpoTime = self.time
		status = ull.beginCPOReplaceLastSlice(self.idx, path)
		self.datainfo.replaceLastSlice(path, cpopath)
		self.centre.replaceLastSlice(path, cpopath)
		self.composition.replaceLastSlice(path, cpopath)
		self.configs.replaceLastSlice(path, cpopath)
		self.confinement.replaceLastSlice(path, cpopath)
		self.currents.replaceLastSlice(path, cpopath)
		self.edge.replaceLastSlice(path, cpopath)
		self.energy.replaceLastSlice(path, cpopath)
		self.eqgeometry.replaceLastSlice(path, cpopath)
		self.global_param.replaceLastSlice(path, cpopath)
		self.heat_power.replaceLastSlice(path, cpopath)
		self.itb.replaceLastSlice(path, cpopath)
		self.lim_div_wall.replaceLastSlice(path, cpopath)
		self.line_ave.replaceLastSlice(path, cpopath)
		self.neutron.replaceLastSlice(path, cpopath)
		self.ninety_five.replaceLastSlice(path, cpopath)
		self.pedestal.replaceLastSlice(path, cpopath)
		self.references.replaceLastSlice(path, cpopath)
		self.reactor.replaceLastSlice(path, cpopath)
		self.sol.replaceLastSlice(path, cpopath)
		self.vol_ave.replaceLastSlice(path, cpopath)
		self.codeparam.replaceLastSlice(path, cpopath)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'time', self.time)
		check_status(status)
		status = ull.endCPOReplaceLastSlice(self.idx, path)

	def putNonTimed(self, occurrence=0):
		if occurrence==0:
			path = self.base_path
		else:
			path = self.base_path + '/' + str(occurrence)
		cpopath = '' 
		self.deleteData(occurrence)
		status = ull.beginCPOPutNonTimed(self.idx, path)
		self.datainfo.putNonTimed(path, cpopath)
		self.centre.putNonTimed(path, cpopath)
		self.composition.putNonTimed(path, cpopath)
		self.configs.putNonTimed(path, cpopath)
		self.confinement.putNonTimed(path, cpopath)
		self.currents.putNonTimed(path, cpopath)
		self.edge.putNonTimed(path, cpopath)
		self.energy.putNonTimed(path, cpopath)
		self.eqgeometry.putNonTimed(path, cpopath)
		self.global_param.putNonTimed(path, cpopath)
		self.heat_power.putNonTimed(path, cpopath)
		self.itb.putNonTimed(path, cpopath)
		self.lim_div_wall.putNonTimed(path, cpopath)
		self.line_ave.putNonTimed(path, cpopath)
		self.neutron.putNonTimed(path, cpopath)
		self.ninety_five.putNonTimed(path, cpopath)
		self.pedestal.putNonTimed(path, cpopath)
		self.references.putNonTimed(path, cpopath)
		self.reactor.putNonTimed(path, cpopath)
		self.sol.putNonTimed(path, cpopath)
		self.vol_ave.putNonTimed(path, cpopath)
		self.codeparam.putNonTimed(path, cpopath)
		status = ull.endCPOPutNonTimed(self.idx, path)

	def getSlice(self, inTime, interpolMode, occurrence=0):
		if occurrence==0:
			path = self.base_path
		else:
			path = self.base_path + '/' + str(occurrence)
		cpopath = '' 
		self.cpoTime = self.time
		status = ull.beginCPOGetSlice(self.idx, path, inTime)
		self.datainfo.getSlice(path, cpopath, inTime, interpolMode)
		self.centre.getSlice(path, cpopath, inTime, interpolMode)
		self.composition.getSlice(path, cpopath, inTime, interpolMode)
		self.configs.getSlice(path, cpopath, inTime, interpolMode)
		self.confinement.getSlice(path, cpopath, inTime, interpolMode)
		self.currents.getSlice(path, cpopath, inTime, interpolMode)
		self.edge.getSlice(path, cpopath, inTime, interpolMode)
		self.energy.getSlice(path, cpopath, inTime, interpolMode)
		self.eqgeometry.getSlice(path, cpopath, inTime, interpolMode)
		self.global_param.getSlice(path, cpopath, inTime, interpolMode)
		self.heat_power.getSlice(path, cpopath, inTime, interpolMode)
		self.itb.getSlice(path, cpopath, inTime, interpolMode)
		self.lim_div_wall.getSlice(path, cpopath, inTime, interpolMode)
		self.line_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.neutron.getSlice(path, cpopath, inTime, interpolMode)
		self.ninety_five.getSlice(path, cpopath, inTime, interpolMode)
		self.pedestal.getSlice(path, cpopath, inTime, interpolMode)
		self.references.getSlice(path, cpopath, inTime, interpolMode)
		self.reactor.getSlice(path, cpopath, inTime, interpolMode)
		self.sol.getSlice(path, cpopath, inTime, interpolMode)
		self.vol_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.codeparam.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_time, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'time', inTime, interpolMode)
		check_status(status)
		if not status:
			self.time = ret_time
			self.cpoTime = retTime
		status = ull.endCPOGetSlice(self.idx, path)

	def build_non_resampled_data(self, occurrence=0):
		if occurrence==0:
			path = self.base_path
		else:
			path = self.base_path + '/' + str(occurrence)
		cpopath = '' 
		status, nbslice = ull.beginCPOGet(self.idx, path, True)
		check_status(status)
		array=None
		if nbslice > 0:
			datainfoList = self.datainfo.build_non_resampled_data(path, cpopath, nbslice)
			centreList = self.centre.build_non_resampled_data(path, cpopath, nbslice)
			compositionList = self.composition.build_non_resampled_data(path, cpopath, nbslice)
			configsList = self.configs.build_non_resampled_data(path, cpopath, nbslice)
			confinementList = self.confinement.build_non_resampled_data(path, cpopath, nbslice)
			currentsList = self.currents.build_non_resampled_data(path, cpopath, nbslice)
			edgeList = self.edge.build_non_resampled_data(path, cpopath, nbslice)
			energyList = self.energy.build_non_resampled_data(path, cpopath, nbslice)
			eqgeometryList = self.eqgeometry.build_non_resampled_data(path, cpopath, nbslice)
			global_paramList = self.global_param.build_non_resampled_data(path, cpopath, nbslice)
			heat_powerList = self.heat_power.build_non_resampled_data(path, cpopath, nbslice)
			itbList = self.itb.build_non_resampled_data(path, cpopath, nbslice)
			lim_div_wallList = self.lim_div_wall.build_non_resampled_data(path, cpopath, nbslice)
			line_aveList = self.line_ave.build_non_resampled_data(path, cpopath, nbslice)
			neutronList = self.neutron.build_non_resampled_data(path, cpopath, nbslice)
			ninety_fiveList = self.ninety_five.build_non_resampled_data(path, cpopath, nbslice)
			pedestalList = self.pedestal.build_non_resampled_data(path, cpopath, nbslice)
			referencesList = self.references.build_non_resampled_data(path, cpopath, nbslice)
			reactorList = self.reactor.build_non_resampled_data(path, cpopath, nbslice)
			solList = self.sol.build_non_resampled_data(path, cpopath, nbslice)
			vol_aveList = self.vol_ave.build_non_resampled_data(path, cpopath, nbslice)
			codeparamList = self.codeparam.build_non_resampled_data(path, cpopath, nbslice)
			status, timeList = ull.getVect1DDouble(self.idx, path, cpopath + 'time')
			if len(timeList) == 0:
				timeList = numpy.resize(timeList, (nbslice))
			check_status(status)
			array = []
			for i in range(nbslice):
				slice = scenario()
				slice.setExpIdx(self.idx)
				slice.datainfo = datainfoList[i]
				slice.centre = centreList[i]
				slice.composition = compositionList[i]
				slice.configs = configsList[i]
				slice.confinement = confinementList[i]
				slice.currents = currentsList[i]
				slice.edge = edgeList[i]
				slice.energy = energyList[i]
				slice.eqgeometry = eqgeometryList[i]
				slice.global_param = global_paramList[i]
				slice.heat_power = heat_powerList[i]
				slice.itb = itbList[i]
				slice.lim_div_wall = lim_div_wallList[i]
				slice.line_ave = line_aveList[i]
				slice.neutron = neutronList[i]
				slice.ninety_five = ninety_fiveList[i]
				slice.pedestal = pedestalList[i]
				slice.references = referencesList[i]
				slice.reactor = reactorList[i]
				slice.sol = solList[i]
				slice.vol_ave = vol_aveList[i]
				slice.codeparam = codeparamList[i]
				slice.time = timeList[i].copy().astype(float)
				array.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		status = ull.endCPOGet(self.idx, path)
		return array

	def deleteData(self, occurrence=0):
		if occurrence==0:
			path = self.base_path
		else:
			path = self.base_path + '/' + str(occurrence)
		cpopath = '' 
		self.datainfo.deleteData(path, cpopath)
		self.centre.deleteData(path, cpopath)
		self.composition.deleteData(path, cpopath)
		self.configs.deleteData(path, cpopath)
		self.confinement.deleteData(path, cpopath)
		self.currents.deleteData(path, cpopath)
		self.edge.deleteData(path, cpopath)
		self.energy.deleteData(path, cpopath)
		self.eqgeometry.deleteData(path, cpopath)
		self.global_param.deleteData(path, cpopath)
		self.heat_power.deleteData(path, cpopath)
		self.itb.deleteData(path, cpopath)
		self.lim_div_wall.deleteData(path, cpopath)
		self.line_ave.deleteData(path, cpopath)
		self.neutron.deleteData(path, cpopath)
		self.ninety_five.deleteData(path, cpopath)
		self.pedestal.deleteData(path, cpopath)
		self.references.deleteData(path, cpopath)
		self.reactor.deleteData(path, cpopath)
		self.sol.deleteData(path, cpopath)
		self.vol_ave.deleteData(path, cpopath)
		self.codeparam.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'time')


class scenarioArray:
	'''
	class scenarioArray
	Scenario characteristics, to be used as input or output of a whole discharge simulator. Time-dependent CPO.

	Attributes:
	- array : list of scenario
	   Each list element correspond to one time slice.
	'''

	def __init__(self):
		self.array = []
		self.idx = EMPTY_INT
	def __getitem__(self, key):
		return self.array[key]
	def __len__(self):
		return len(self.array)
	def __iter__(self):
		return self.array.__iter__()

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class scenarioArray nb_cpos=%d\n' %(len(self.array))
		for i in range(len(self.array)):
			ret = ret + space + 'scenario cpos=%d\n' %(i) + self.array[i].__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		for i in range(len(self.array)):
			self.array[i].setExpIdx(idx)

	def put(self, occurrence=0):
		if (len(self.array)>0):
			self.array[0].putNonTimed(occurrence)
			for i in self.array:
				i.putSlice(occurrence)
		else:
			print('no time slice to be put')

	def get(self, occurrence=0):
		cpo = scenario()
		cpo.setExpIdx(self.idx)
		self.array = cpo.build_non_resampled_data(occurrence)

	def resize(self, nb_cpos):
		self.array = []
		for i in range(nb_cpos):
			self.array.append(scenario())
			self.array[i].setExpIdx(self.idx)

	def deleteAll(self, occurrence=0):
		cpo = scenario()
		cpo.setExpIdx(self.idx)
		cpo.deleteData(occurrence)


class datainfostructuredatainfo:
	'''
	class datainfostructuredatainfo
	Generic information on a data item

	Attributes:
	- dataprovider : str
	   Name of the actual data provider (the person who filled the data)
	- putdate : str
	   Date at which the data has been put in the DB
	- source : str
	   Exact reference of the data source (e.g. original reference in the native machine data base)
	- comment : str
	   Any additional comment
	- cocos : int
	   COordinates COnventionS followed by this CPO
	- id : int
	   CPO id for checking its provenance in the workflow
	- isref : int
	   1 if the data can be found in the present data base entry; 2 if the data can be found in a parent data base entry; 0 if no data consistent with the present entry can be found.
	- whatref : class whatrefstructurewhatref
	   Structure defining a database entry and the CPO occurrence
	- putinfo : class putinfostructureputinfo
	   Level 2 information describing how to retrieve the actual data for the UAL. Not to be filled/used by the ITM user !
	'''

	def __init__(self, base_path_in='datainfo'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.dataprovider = ''
		self.putdate = ''
		self.source = ''
		self.comment = ''
		self.cocos = EMPTY_INT
		self.id = EMPTY_INT
		self.isref = EMPTY_INT
		self.whatref = whatrefstructurewhatref('whatref')
		self.putinfo = putinfostructureputinfo('putinfo')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class datainfostructuredatainfo\n'
		ret = ret + space + 'Attribute dataprovider: ' + str(self.dataprovider) + '\n'
		ret = ret + space + 'Attribute putdate: ' + str(self.putdate) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		ret = ret + space + 'Attribute comment: ' + str(self.comment) + '\n'
		ret = ret + space + 'Attribute cocos: ' + str(self.cocos) + '\n'
		ret = ret + space + 'Attribute id: ' + str(self.id) + '\n'
		ret = ret + space + 'Attribute isref: ' + str(self.isref) + '\n'
		ret = ret + space + 'Attribute whatref\n ' + self.whatref.__str__(depth+1)
		ret = ret + space + 'Attribute putinfo\n ' + self.putinfo.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.whatref.setExpIdx(idx)
		self.putinfo.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type datainfostructuredatainfo, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.whatref.cpoTime = self.cpoTime
		self.whatref.putSlice(path, cpopath)
		self.putinfo.cpoTime = self.cpoTime
		self.putinfo.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type datainfostructuredatainfo, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.whatref.replaceLastSlice(path, cpopath)
		self.putinfo.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type datainfostructuredatainfo, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'dataprovider', self.dataprovider)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'putdate', self.putdate)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'comment', self.comment)
		check_status(status)
		status = ull.putInt(self.idx, path, cpopath + 'cocos', self.cocos)
		check_status(status)
		status = ull.putInt(self.idx, path, cpopath + 'id', self.id)
		check_status(status)
		status = ull.putInt(self.idx, path, cpopath + 'isref', self.isref)
		check_status(status)
		self.whatref.putNonTimed(path, cpopath)
		self.putinfo.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type datainfostructuredatainfo, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_dataprovider = ull.getString(self.idx, path, cpopath + 'dataprovider')
		check_status(status)
		if not status:
			self.dataprovider = ret_dataprovider
		status, ret_putdate = ull.getString(self.idx, path, cpopath + 'putdate')
		check_status(status)
		if not status:
			self.putdate = ret_putdate
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source
		status, ret_comment = ull.getString(self.idx, path, cpopath + 'comment')
		check_status(status)
		if not status:
			self.comment = ret_comment
		status, ret_cocos = ull.getInt(self.idx, path, cpopath + 'cocos')
		check_status(status)
		if not status:
			self.cocos = ret_cocos
		status, ret_id = ull.getInt(self.idx, path, cpopath + 'id')
		check_status(status)
		if not status:
			self.id = ret_id
		status, ret_isref = ull.getInt(self.idx, path, cpopath + 'isref')
		check_status(status)
		if not status:
			self.isref = ret_isref
		self.whatref.getSlice(path, cpopath, inTime, interpolMode)
		self.putinfo.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type datainfostructuredatainfo, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, dataproviderVal = ull.getString(self.idx, path, cpopath + 'dataprovider')
			check_status(status)
			status, putdateVal = ull.getString(self.idx, path, cpopath + 'putdate')
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			status, commentVal = ull.getString(self.idx, path, cpopath + 'comment')
			check_status(status)
			status, cocosVal = ull.getInt(self.idx, path, cpopath + 'cocos')
			check_status(status)
			status, idVal = ull.getInt(self.idx, path, cpopath + 'id')
			check_status(status)
			status, isrefVal = ull.getInt(self.idx, path, cpopath + 'isref')
			check_status(status)
			whatrefList = self.whatref.build_non_resampled_data(path, cpopath, nbslice)
			putinfoList = self.putinfo.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = datainfostructuredatainfo(self.base_path)
				slice.setExpIdx(self.idx)
				slice.dataprovider = dataproviderVal
				slice.putdate = putdateVal
				slice.source = sourceVal
				slice.comment = commentVal
				slice.cocos = cocosVal
				slice.id = idVal
				slice.isref = isrefVal
				slice.whatref = whatrefList[i]
				slice.putinfo = putinfoList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type datainfostructuredatainfoObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type datainfostructuredatainfoObj, run function getTimedElt') 
		cpopath = cpopath + '/' 

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type datainfostructuredatainfoObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'dataprovider') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'dataprovider', i, self.dataprovider)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'putdate') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'putdate', i, self.putdate)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'comment') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'comment', i, self.comment)
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'cocos') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'cocos', i, self.cocos)
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'id') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'id', i, self.id)
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'isref') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'isref', i, self.isref)
		obj = self.whatref.putNonTimedElt(path, cpopath + 'whatref', i, obj)
		obj = self.putinfo.putNonTimedElt(path, cpopath + 'putinfo', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type datainfostructuredatainfoObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'dataprovider') 
			print ('obj = ' + str(obj))
		status, ret_dataprovider = ull.getStringFromObject(self.idx, obj, cpopath + 'dataprovider', i)
		check_status(status)
		if not status:
			self.dataprovider = ret_dataprovider
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'putdate') 
			print ('obj = ' + str(obj))
		status, ret_putdate = ull.getStringFromObject(self.idx, obj, cpopath + 'putdate', i)
		check_status(status)
		if not status:
			self.putdate = ret_putdate
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'comment') 
			print ('obj = ' + str(obj))
		status, ret_comment = ull.getStringFromObject(self.idx, obj, cpopath + 'comment', i)
		check_status(status)
		if not status:
			self.comment = ret_comment
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'cocos') 
			print ('obj = ' + str(obj))
		status, ret_cocos = ull.getIntFromObject(self.idx, obj, cpopath + 'cocos', i)
		check_status(status)
		if not status:
			self.cocos = ret_cocos
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'id') 
			print ('obj = ' + str(obj))
		status, ret_id = ull.getIntFromObject(self.idx, obj, cpopath + 'id', i)
		check_status(status)
		if not status:
			self.id = ret_id
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'isref') 
			print ('obj = ' + str(obj))
		status, ret_isref = ull.getIntFromObject(self.idx, obj, cpopath + 'isref', i)
		check_status(status)
		if not status:
			self.isref = ret_isref
		self.whatref.getNonTimedElt(path, cpopath + 'whatref', i, obj)
		self.putinfo.getNonTimedElt(path, cpopath + 'putinfo', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'dataprovider')
		ull.deleteData(self.idx, path, cpopath + 'putdate')
		ull.deleteData(self.idx, path, cpopath + 'source')
		ull.deleteData(self.idx, path, cpopath + 'comment')
		ull.deleteData(self.idx, path, cpopath + 'cocos')
		ull.deleteData(self.idx, path, cpopath + 'id')
		ull.deleteData(self.idx, path, cpopath + 'isref')
		self.whatref.deleteData(path, cpopath)
		self.putinfo.deleteData(path, cpopath)


class whatrefstructurewhatref:
	'''
	class whatrefstructurewhatref
	Structure defining a database entry and the CPO occurrence

	Attributes:
	- user : str
	   Name of the user if private data, public if public ITM database.
	- machine : str
	   Name of the device
	- shot : int
	   Shot number
	- run : int
	   Run number
	- occurrence : int
	   Occurrence number of the CPO in the reference entry
	'''

	def __init__(self, base_path_in='whatref'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.user = ''
		self.machine = ''
		self.shot = EMPTY_INT
		self.run = EMPTY_INT
		self.occurrence = EMPTY_INT

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class whatrefstructurewhatref\n'
		ret = ret + space + 'Attribute user: ' + str(self.user) + '\n'
		ret = ret + space + 'Attribute machine: ' + str(self.machine) + '\n'
		ret = ret + space + 'Attribute shot: ' + str(self.shot) + '\n'
		ret = ret + space + 'Attribute run: ' + str(self.run) + '\n'
		ret = ret + space + 'Attribute occurrence: ' + str(self.occurrence) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type whatrefstructurewhatref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type whatrefstructurewhatref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type whatrefstructurewhatref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'user', self.user)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'machine', self.machine)
		check_status(status)
		status = ull.putInt(self.idx, path, cpopath + 'shot', self.shot)
		check_status(status)
		status = ull.putInt(self.idx, path, cpopath + 'run', self.run)
		check_status(status)
		status = ull.putInt(self.idx, path, cpopath + 'occurrence', self.occurrence)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type whatrefstructurewhatref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_user = ull.getString(self.idx, path, cpopath + 'user')
		check_status(status)
		if not status:
			self.user = ret_user
		status, ret_machine = ull.getString(self.idx, path, cpopath + 'machine')
		check_status(status)
		if not status:
			self.machine = ret_machine
		status, ret_shot = ull.getInt(self.idx, path, cpopath + 'shot')
		check_status(status)
		if not status:
			self.shot = ret_shot
		status, ret_run = ull.getInt(self.idx, path, cpopath + 'run')
		check_status(status)
		if not status:
			self.run = ret_run
		status, ret_occurrence = ull.getInt(self.idx, path, cpopath + 'occurrence')
		check_status(status)
		if not status:
			self.occurrence = ret_occurrence

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type whatrefstructurewhatref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, userVal = ull.getString(self.idx, path, cpopath + 'user')
			check_status(status)
			status, machineVal = ull.getString(self.idx, path, cpopath + 'machine')
			check_status(status)
			status, shotVal = ull.getInt(self.idx, path, cpopath + 'shot')
			check_status(status)
			status, runVal = ull.getInt(self.idx, path, cpopath + 'run')
			check_status(status)
			status, occurrenceVal = ull.getInt(self.idx, path, cpopath + 'occurrence')
			check_status(status)
			for i in range(nbslice):
				slice = whatrefstructurewhatref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.user = userVal
				slice.machine = machineVal
				slice.shot = shotVal
				slice.run = runVal
				slice.occurrence = occurrenceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type whatrefstructurewhatrefObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type whatrefstructurewhatrefObj, run function getTimedElt') 
		cpopath = cpopath + '/' 

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type whatrefstructurewhatrefObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'user') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'user', i, self.user)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'machine') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'machine', i, self.machine)
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'shot') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'shot', i, self.shot)
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'run') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'run', i, self.run)
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'occurrence') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'occurrence', i, self.occurrence)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type whatrefstructurewhatrefObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'user') 
			print ('obj = ' + str(obj))
		status, ret_user = ull.getStringFromObject(self.idx, obj, cpopath + 'user', i)
		check_status(status)
		if not status:
			self.user = ret_user
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'machine') 
			print ('obj = ' + str(obj))
		status, ret_machine = ull.getStringFromObject(self.idx, obj, cpopath + 'machine', i)
		check_status(status)
		if not status:
			self.machine = ret_machine
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'shot') 
			print ('obj = ' + str(obj))
		status, ret_shot = ull.getIntFromObject(self.idx, obj, cpopath + 'shot', i)
		check_status(status)
		if not status:
			self.shot = ret_shot
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'run') 
			print ('obj = ' + str(obj))
		status, ret_run = ull.getIntFromObject(self.idx, obj, cpopath + 'run', i)
		check_status(status)
		if not status:
			self.run = ret_run
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'occurrence') 
			print ('obj = ' + str(obj))
		status, ret_occurrence = ull.getIntFromObject(self.idx, obj, cpopath + 'occurrence', i)
		check_status(status)
		if not status:
			self.occurrence = ret_occurrence

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'user')
		ull.deleteData(self.idx, path, cpopath + 'machine')
		ull.deleteData(self.idx, path, cpopath + 'shot')
		ull.deleteData(self.idx, path, cpopath + 'run')
		ull.deleteData(self.idx, path, cpopath + 'occurrence')


class putinfostructureputinfo:
	'''
	class putinfostructureputinfo
	Level 2 information describing how to retrieve the actual data for the UAL. Not to be filled/used by the ITM user !

	Attributes:
	- putmethod : str
	   Storage method for this data
	- putaccess : str
	   Instructions to access the data using this method
	- putlocation : str
	   Name of this data under this method
	- rights : str
	   Access rights to this data
	'''

	def __init__(self, base_path_in='putinfo'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.putmethod = ''
		self.putaccess = ''
		self.putlocation = ''
		self.rights = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class putinfostructureputinfo\n'
		ret = ret + space + 'Attribute putmethod: ' + str(self.putmethod) + '\n'
		ret = ret + space + 'Attribute putaccess: ' + str(self.putaccess) + '\n'
		ret = ret + space + 'Attribute putlocation: ' + str(self.putlocation) + '\n'
		ret = ret + space + 'Attribute rights: ' + str(self.rights) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type putinfostructureputinfo, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type putinfostructureputinfo, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type putinfostructureputinfo, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'putmethod', self.putmethod)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'putaccess', self.putaccess)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'putlocation', self.putlocation)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'rights', self.rights)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type putinfostructureputinfo, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_putmethod = ull.getString(self.idx, path, cpopath + 'putmethod')
		check_status(status)
		if not status:
			self.putmethod = ret_putmethod
		status, ret_putaccess = ull.getString(self.idx, path, cpopath + 'putaccess')
		check_status(status)
		if not status:
			self.putaccess = ret_putaccess
		status, ret_putlocation = ull.getString(self.idx, path, cpopath + 'putlocation')
		check_status(status)
		if not status:
			self.putlocation = ret_putlocation
		status, ret_rights = ull.getString(self.idx, path, cpopath + 'rights')
		check_status(status)
		if not status:
			self.rights = ret_rights

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type putinfostructureputinfo, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, putmethodVal = ull.getString(self.idx, path, cpopath + 'putmethod')
			check_status(status)
			status, putaccessVal = ull.getString(self.idx, path, cpopath + 'putaccess')
			check_status(status)
			status, putlocationVal = ull.getString(self.idx, path, cpopath + 'putlocation')
			check_status(status)
			status, rightsVal = ull.getString(self.idx, path, cpopath + 'rights')
			check_status(status)
			for i in range(nbslice):
				slice = putinfostructureputinfo(self.base_path)
				slice.setExpIdx(self.idx)
				slice.putmethod = putmethodVal
				slice.putaccess = putaccessVal
				slice.putlocation = putlocationVal
				slice.rights = rightsVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type putinfostructureputinfoObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type putinfostructureputinfoObj, run function getTimedElt') 
		cpopath = cpopath + '/' 

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type putinfostructureputinfoObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'putmethod') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'putmethod', i, self.putmethod)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'putaccess') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'putaccess', i, self.putaccess)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'putlocation') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'putlocation', i, self.putlocation)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'rights') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'rights', i, self.rights)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type putinfostructureputinfoObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'putmethod') 
			print ('obj = ' + str(obj))
		status, ret_putmethod = ull.getStringFromObject(self.idx, obj, cpopath + 'putmethod', i)
		check_status(status)
		if not status:
			self.putmethod = ret_putmethod
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'putaccess') 
			print ('obj = ' + str(obj))
		status, ret_putaccess = ull.getStringFromObject(self.idx, obj, cpopath + 'putaccess', i)
		check_status(status)
		if not status:
			self.putaccess = ret_putaccess
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'putlocation') 
			print ('obj = ' + str(obj))
		status, ret_putlocation = ull.getStringFromObject(self.idx, obj, cpopath + 'putlocation', i)
		check_status(status)
		if not status:
			self.putlocation = ret_putlocation
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'rights') 
			print ('obj = ' + str(obj))
		status, ret_rights = ull.getStringFromObject(self.idx, obj, cpopath + 'rights', i)
		check_status(status)
		if not status:
			self.rights = ret_rights

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'putmethod')
		ull.deleteData(self.idx, path, cpopath + 'putaccess')
		ull.deleteData(self.idx, path, cpopath + 'putlocation')
		ull.deleteData(self.idx, path, cpopath + 'rights')


class centrestructurescenario_centre:
	'''
	class centrestructurescenario_centre
	central values of the profiles (at magnetic axis)

	Attributes:
	- te0 : class te0structurescenario_ref
	   central electron temperature [eV]. Time-dependent.
	- ti0 : class ti0structurescenario_ref
	   central ion temperature [eV]. Time-dependent.
	- ne0 : class ne0structurescenario_ref
	   central electron density [m^-3]. Time-dependent.
	- ni0 : class ni0structurescenario_ref
	   central ion density [m^-3]. Time-dependent.
	- shift0 : class shift0structurescenario_ref
	   central value of Shafranov shift [m]. Time-dependent.
	- psi0 : class psi0structurescenario_ref
	   pedestal poloidal flux [Wb]. Time-dependent.
	- phi0 : class phi0structurescenario_ref
	   central toroidal flux [Wb]. Time-dependent.
	- q0 : class q0structurescenario_ref
	   central safety factor value []. Time-dependent.
	- Rmag : class Rmagstructurescenario_ref
	   radius of magnetic axis [R]. Time-dependent.
	- Zmag : class Zmagstructurescenario_ref
	   Z coordinate of magnetic axis [R]. Time-dependent.
	- vtor_0 : class vtor_0structurescenario_ref
	   central rotation velocity of selected impurity [m/s]. Time-dependent.
	'''

	def __init__(self, base_path_in='centre'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.te0 = te0structurescenario_ref('te0')
		self.ti0 = ti0structurescenario_ref('ti0')
		self.ne0 = ne0structurescenario_ref('ne0')
		self.ni0 = ni0structurescenario_ref('ni0')
		self.shift0 = shift0structurescenario_ref('shift0')
		self.psi0 = psi0structurescenario_ref('psi0')
		self.phi0 = phi0structurescenario_ref('phi0')
		self.q0 = q0structurescenario_ref('q0')
		self.Rmag = Rmagstructurescenario_ref('Rmag')
		self.Zmag = Zmagstructurescenario_ref('Zmag')
		self.vtor_0 = vtor_0structurescenario_ref('vtor_0')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class centrestructurescenario_centre\n'
		ret = ret + space + 'Attribute te0\n ' + self.te0.__str__(depth+1)
		ret = ret + space + 'Attribute ti0\n ' + self.ti0.__str__(depth+1)
		ret = ret + space + 'Attribute ne0\n ' + self.ne0.__str__(depth+1)
		ret = ret + space + 'Attribute ni0\n ' + self.ni0.__str__(depth+1)
		ret = ret + space + 'Attribute shift0\n ' + self.shift0.__str__(depth+1)
		ret = ret + space + 'Attribute psi0\n ' + self.psi0.__str__(depth+1)
		ret = ret + space + 'Attribute phi0\n ' + self.phi0.__str__(depth+1)
		ret = ret + space + 'Attribute q0\n ' + self.q0.__str__(depth+1)
		ret = ret + space + 'Attribute Rmag\n ' + self.Rmag.__str__(depth+1)
		ret = ret + space + 'Attribute Zmag\n ' + self.Zmag.__str__(depth+1)
		ret = ret + space + 'Attribute vtor_0\n ' + self.vtor_0.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.te0.setExpIdx(idx)
		self.ti0.setExpIdx(idx)
		self.ne0.setExpIdx(idx)
		self.ni0.setExpIdx(idx)
		self.shift0.setExpIdx(idx)
		self.psi0.setExpIdx(idx)
		self.phi0.setExpIdx(idx)
		self.q0.setExpIdx(idx)
		self.Rmag.setExpIdx(idx)
		self.Zmag.setExpIdx(idx)
		self.vtor_0.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type centrestructurescenario_centre, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te0.cpoTime = self.cpoTime
		self.te0.putSlice(path, cpopath)
		self.ti0.cpoTime = self.cpoTime
		self.ti0.putSlice(path, cpopath)
		self.ne0.cpoTime = self.cpoTime
		self.ne0.putSlice(path, cpopath)
		self.ni0.cpoTime = self.cpoTime
		self.ni0.putSlice(path, cpopath)
		self.shift0.cpoTime = self.cpoTime
		self.shift0.putSlice(path, cpopath)
		self.psi0.cpoTime = self.cpoTime
		self.psi0.putSlice(path, cpopath)
		self.phi0.cpoTime = self.cpoTime
		self.phi0.putSlice(path, cpopath)
		self.q0.cpoTime = self.cpoTime
		self.q0.putSlice(path, cpopath)
		self.Rmag.cpoTime = self.cpoTime
		self.Rmag.putSlice(path, cpopath)
		self.Zmag.cpoTime = self.cpoTime
		self.Zmag.putSlice(path, cpopath)
		self.vtor_0.cpoTime = self.cpoTime
		self.vtor_0.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type centrestructurescenario_centre, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te0.replaceLastSlice(path, cpopath)
		self.ti0.replaceLastSlice(path, cpopath)
		self.ne0.replaceLastSlice(path, cpopath)
		self.ni0.replaceLastSlice(path, cpopath)
		self.shift0.replaceLastSlice(path, cpopath)
		self.psi0.replaceLastSlice(path, cpopath)
		self.phi0.replaceLastSlice(path, cpopath)
		self.q0.replaceLastSlice(path, cpopath)
		self.Rmag.replaceLastSlice(path, cpopath)
		self.Zmag.replaceLastSlice(path, cpopath)
		self.vtor_0.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type centrestructurescenario_centre, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te0.putNonTimed(path, cpopath)
		self.ti0.putNonTimed(path, cpopath)
		self.ne0.putNonTimed(path, cpopath)
		self.ni0.putNonTimed(path, cpopath)
		self.shift0.putNonTimed(path, cpopath)
		self.psi0.putNonTimed(path, cpopath)
		self.phi0.putNonTimed(path, cpopath)
		self.q0.putNonTimed(path, cpopath)
		self.Rmag.putNonTimed(path, cpopath)
		self.Zmag.putNonTimed(path, cpopath)
		self.vtor_0.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type centrestructurescenario_centre, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te0.getSlice(path, cpopath, inTime, interpolMode)
		self.ti0.getSlice(path, cpopath, inTime, interpolMode)
		self.ne0.getSlice(path, cpopath, inTime, interpolMode)
		self.ni0.getSlice(path, cpopath, inTime, interpolMode)
		self.shift0.getSlice(path, cpopath, inTime, interpolMode)
		self.psi0.getSlice(path, cpopath, inTime, interpolMode)
		self.phi0.getSlice(path, cpopath, inTime, interpolMode)
		self.q0.getSlice(path, cpopath, inTime, interpolMode)
		self.Rmag.getSlice(path, cpopath, inTime, interpolMode)
		self.Zmag.getSlice(path, cpopath, inTime, interpolMode)
		self.vtor_0.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type centrestructurescenario_centre, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			te0List = self.te0.build_non_resampled_data(path, cpopath, nbslice)
			ti0List = self.ti0.build_non_resampled_data(path, cpopath, nbslice)
			ne0List = self.ne0.build_non_resampled_data(path, cpopath, nbslice)
			ni0List = self.ni0.build_non_resampled_data(path, cpopath, nbslice)
			shift0List = self.shift0.build_non_resampled_data(path, cpopath, nbslice)
			psi0List = self.psi0.build_non_resampled_data(path, cpopath, nbslice)
			phi0List = self.phi0.build_non_resampled_data(path, cpopath, nbslice)
			q0List = self.q0.build_non_resampled_data(path, cpopath, nbslice)
			RmagList = self.Rmag.build_non_resampled_data(path, cpopath, nbslice)
			ZmagList = self.Zmag.build_non_resampled_data(path, cpopath, nbslice)
			vtor_0List = self.vtor_0.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = centrestructurescenario_centre(self.base_path)
				slice.setExpIdx(self.idx)
				slice.te0 = te0List[i]
				slice.ti0 = ti0List[i]
				slice.ne0 = ne0List[i]
				slice.ni0 = ni0List[i]
				slice.shift0 = shift0List[i]
				slice.psi0 = psi0List[i]
				slice.phi0 = phi0List[i]
				slice.q0 = q0List[i]
				slice.Rmag = RmagList[i]
				slice.Zmag = ZmagList[i]
				slice.vtor_0 = vtor_0List[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type centrestructurescenario_centreObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te0.putTimedElt(path, cpopath + 'te0', i, obj)
		obj = self.ti0.putTimedElt(path, cpopath + 'ti0', i, obj)
		obj = self.ne0.putTimedElt(path, cpopath + 'ne0', i, obj)
		obj = self.ni0.putTimedElt(path, cpopath + 'ni0', i, obj)
		obj = self.shift0.putTimedElt(path, cpopath + 'shift0', i, obj)
		obj = self.psi0.putTimedElt(path, cpopath + 'psi0', i, obj)
		obj = self.phi0.putTimedElt(path, cpopath + 'phi0', i, obj)
		obj = self.q0.putTimedElt(path, cpopath + 'q0', i, obj)
		obj = self.Rmag.putTimedElt(path, cpopath + 'Rmag', i, obj)
		obj = self.Zmag.putTimedElt(path, cpopath + 'Zmag', i, obj)
		obj = self.vtor_0.putTimedElt(path, cpopath + 'vtor_0', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type centrestructurescenario_centreObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.te0.getTimedElt(path, cpopath + 'te0', i, obj)
		self.ti0.getTimedElt(path, cpopath + 'ti0', i, obj)
		self.ne0.getTimedElt(path, cpopath + 'ne0', i, obj)
		self.ni0.getTimedElt(path, cpopath + 'ni0', i, obj)
		self.shift0.getTimedElt(path, cpopath + 'shift0', i, obj)
		self.psi0.getTimedElt(path, cpopath + 'psi0', i, obj)
		self.phi0.getTimedElt(path, cpopath + 'phi0', i, obj)
		self.q0.getTimedElt(path, cpopath + 'q0', i, obj)
		self.Rmag.getTimedElt(path, cpopath + 'Rmag', i, obj)
		self.Zmag.getTimedElt(path, cpopath + 'Zmag', i, obj)
		self.vtor_0.getTimedElt(path, cpopath + 'vtor_0', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type centrestructurescenario_centreObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te0.putNonTimedElt(path, cpopath + 'te0', i, obj)
		obj = self.ti0.putNonTimedElt(path, cpopath + 'ti0', i, obj)
		obj = self.ne0.putNonTimedElt(path, cpopath + 'ne0', i, obj)
		obj = self.ni0.putNonTimedElt(path, cpopath + 'ni0', i, obj)
		obj = self.shift0.putNonTimedElt(path, cpopath + 'shift0', i, obj)
		obj = self.psi0.putNonTimedElt(path, cpopath + 'psi0', i, obj)
		obj = self.phi0.putNonTimedElt(path, cpopath + 'phi0', i, obj)
		obj = self.q0.putNonTimedElt(path, cpopath + 'q0', i, obj)
		obj = self.Rmag.putNonTimedElt(path, cpopath + 'Rmag', i, obj)
		obj = self.Zmag.putNonTimedElt(path, cpopath + 'Zmag', i, obj)
		obj = self.vtor_0.putNonTimedElt(path, cpopath + 'vtor_0', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type centrestructurescenario_centreObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.te0.getNonTimedElt(path, cpopath + 'te0', i, obj)
		self.ti0.getNonTimedElt(path, cpopath + 'ti0', i, obj)
		self.ne0.getNonTimedElt(path, cpopath + 'ne0', i, obj)
		self.ni0.getNonTimedElt(path, cpopath + 'ni0', i, obj)
		self.shift0.getNonTimedElt(path, cpopath + 'shift0', i, obj)
		self.psi0.getNonTimedElt(path, cpopath + 'psi0', i, obj)
		self.phi0.getNonTimedElt(path, cpopath + 'phi0', i, obj)
		self.q0.getNonTimedElt(path, cpopath + 'q0', i, obj)
		self.Rmag.getNonTimedElt(path, cpopath + 'Rmag', i, obj)
		self.Zmag.getNonTimedElt(path, cpopath + 'Zmag', i, obj)
		self.vtor_0.getNonTimedElt(path, cpopath + 'vtor_0', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te0.deleteData(path, cpopath)
		self.ti0.deleteData(path, cpopath)
		self.ne0.deleteData(path, cpopath)
		self.ni0.deleteData(path, cpopath)
		self.shift0.deleteData(path, cpopath)
		self.psi0.deleteData(path, cpopath)
		self.phi0.deleteData(path, cpopath)
		self.q0.deleteData(path, cpopath)
		self.Rmag.deleteData(path, cpopath)
		self.Zmag.deleteData(path, cpopath)
		self.vtor_0.deleteData(path, cpopath)


class te0structurescenario_ref:
	'''
	class te0structurescenario_ref
	central electron temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti0structurescenario_ref:
	'''
	class ti0structurescenario_ref
	central ion temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne0structurescenario_ref:
	'''
	class ne0structurescenario_ref
	central electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni0structurescenario_ref:
	'''
	class ni0structurescenario_ref
	central ion density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class shift0structurescenario_ref:
	'''
	class shift0structurescenario_ref
	central value of Shafranov shift [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='shift0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class shift0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type shift0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type shift0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type shift0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type shift0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type shift0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = shift0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type shift0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type shift0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type shift0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type shift0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class psi0structurescenario_ref:
	'''
	class psi0structurescenario_ref
	pedestal poloidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='psi0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class psi0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type psi0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type psi0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = psi0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class phi0structurescenario_ref:
	'''
	class phi0structurescenario_ref
	central toroidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='phi0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class phi0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type phi0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type phi0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = phi0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class q0structurescenario_ref:
	'''
	class q0structurescenario_ref
	central safety factor value []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class Rmagstructurescenario_ref:
	'''
	class Rmagstructurescenario_ref
	radius of magnetic axis [R]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='Rmag'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class Rmagstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type Rmagstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type Rmagstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type Rmagstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type Rmagstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type Rmagstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = Rmagstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Rmagstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Rmagstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Rmagstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Rmagstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class Zmagstructurescenario_ref:
	'''
	class Zmagstructurescenario_ref
	Z coordinate of magnetic axis [R]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='Zmag'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class Zmagstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type Zmagstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type Zmagstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type Zmagstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type Zmagstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type Zmagstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = Zmagstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Zmagstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Zmagstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Zmagstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type Zmagstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class vtor_0structurescenario_ref:
	'''
	class vtor_0structurescenario_ref
	central rotation velocity of selected impurity [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='vtor_0'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class vtor_0structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_0structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_0structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_0structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_0structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_0structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = vtor_0structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_0structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_0structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_0structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_0structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class compositionstructurescenario_composition:
	'''
	class compositionstructurescenario_composition
	Plasma composition (description of ion species).

	Attributes:
	- amn : numpy.ndarray 1D with float
	   Atomic mass number (lumped ions are allowed); Vector (nion)
	- zn : numpy.ndarray 1D with float
	   Nuclear charge (lumped ions are allowed); Vector (nion)
	- zion : numpy.ndarray 1D with float
	   Ion charge (of the dominant ionisation state; lumped ions are allowed); Vector (nion)
	- imp_flag : numpy.ndarray 1D with int)
	   Multiple charge state calculation flag : 0-Only one charge state is considered; 1-Multiple charge state are considered and are described in impurity CPO; Vector (nion)
	- rot_imp_flag : numpy.ndarray 1D with int)
	   set to 1 for the impurity corresponding at the given toroidal rotation, otherwise = 0
	- pellet_amn : numpy.ndarray 1D with float
	   Atomic mass number (for pellet injector); Vector (nion)
	- pellet_zn : numpy.ndarray 1D with float
	   Nuclear charge (pellet injector); Vector (nion)
	- nbi_amn : numpy.ndarray 1D with float
	   Atomic mass number (for neutral beam injection); Vector (nion)
	- nbi_zn : numpy.ndarray 1D with float
	   Nuclear charge (for neutral beam injection); Vector (nion)
	'''

	def __init__(self, base_path_in='composition'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.amn = numpy.zeros(0, numpy.float64, order='C')
		self.zn = numpy.zeros(0, numpy.float64, order='C')
		self.zion = numpy.zeros(0, numpy.float64, order='C')
		self.imp_flag = numpy.zeros(0, numpy.int32, order='C')
		self.rot_imp_flag = numpy.zeros(0, numpy.int32, order='C')
		self.pellet_amn = numpy.zeros(0, numpy.float64, order='C')
		self.pellet_zn = numpy.zeros(0, numpy.float64, order='C')
		self.nbi_amn = numpy.zeros(0, numpy.float64, order='C')
		self.nbi_zn = numpy.zeros(0, numpy.float64, order='C')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class compositionstructurescenario_composition\n'
		s = self.amn.__str__()
		ret = ret + space + 'Attribute amn\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.zn.__str__()
		ret = ret + space + 'Attribute zn\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.zion.__str__()
		ret = ret + space + 'Attribute zion\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.imp_flag.__str__()
		ret = ret + space + 'Attribute imp_flag\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.rot_imp_flag.__str__()
		ret = ret + space + 'Attribute rot_imp_flag\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.pellet_amn.__str__()
		ret = ret + space + 'Attribute pellet_amn\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.pellet_zn.__str__()
		ret = ret + space + 'Attribute pellet_zn\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.nbi_amn.__str__()
		ret = ret + space + 'Attribute nbi_amn\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.nbi_zn.__str__()
		ret = ret + space + 'Attribute nbi_zn\n' + space + s.replace('\n', '\n'+space) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type compositionstructurescenario_composition, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type compositionstructurescenario_composition, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type compositionstructurescenario_composition, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'amn', numpy.array(self.amn).astype(numpy.float64), False)
		check_status(status)
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'zn', numpy.array(self.zn).astype(numpy.float64), False)
		check_status(status)
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'zion', numpy.array(self.zion).astype(numpy.float64), False)
		check_status(status)
		status = ull.putVect1DInt(self.idx, path, cpopath + 'imp_flag', numpy.array(self.imp_flag).astype(numpy.int32), False)
		check_status(status)
		status = ull.putVect1DInt(self.idx, path, cpopath + 'rot_imp_flag', numpy.array(self.rot_imp_flag).astype(numpy.int32), False)
		check_status(status)
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'pellet_amn', numpy.array(self.pellet_amn).astype(numpy.float64), False)
		check_status(status)
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'pellet_zn', numpy.array(self.pellet_zn).astype(numpy.float64), False)
		check_status(status)
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'nbi_amn', numpy.array(self.nbi_amn).astype(numpy.float64), False)
		check_status(status)
		status = ull.putVect1DDouble(self.idx, path, cpopath + 'nbi_zn', numpy.array(self.nbi_zn).astype(numpy.float64), False)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type compositionstructurescenario_composition, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_amn = ull.getVect1DDouble(self.idx, path, cpopath + 'amn')
		check_status(status)
		if not status:
			self.amn = ret_amn
		status, ret_zn = ull.getVect1DDouble(self.idx, path, cpopath + 'zn')
		check_status(status)
		if not status:
			self.zn = ret_zn
		status, ret_zion = ull.getVect1DDouble(self.idx, path, cpopath + 'zion')
		check_status(status)
		if not status:
			self.zion = ret_zion
		status, ret_imp_flag = ull.getVect1DInt(self.idx, path, cpopath + 'imp_flag')
		check_status(status)
		if not status:
			self.imp_flag = ret_imp_flag
		status, ret_rot_imp_flag = ull.getVect1DInt(self.idx, path, cpopath + 'rot_imp_flag')
		check_status(status)
		if not status:
			self.rot_imp_flag = ret_rot_imp_flag
		status, ret_pellet_amn = ull.getVect1DDouble(self.idx, path, cpopath + 'pellet_amn')
		check_status(status)
		if not status:
			self.pellet_amn = ret_pellet_amn
		status, ret_pellet_zn = ull.getVect1DDouble(self.idx, path, cpopath + 'pellet_zn')
		check_status(status)
		if not status:
			self.pellet_zn = ret_pellet_zn
		status, ret_nbi_amn = ull.getVect1DDouble(self.idx, path, cpopath + 'nbi_amn')
		check_status(status)
		if not status:
			self.nbi_amn = ret_nbi_amn
		status, ret_nbi_zn = ull.getVect1DDouble(self.idx, path, cpopath + 'nbi_zn')
		check_status(status)
		if not status:
			self.nbi_zn = ret_nbi_zn

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type compositionstructurescenario_composition, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, amnVal = ull.getVect1DDouble(self.idx, path, cpopath + 'amn')
			check_status(status)
			status, znVal = ull.getVect1DDouble(self.idx, path, cpopath + 'zn')
			check_status(status)
			status, zionVal = ull.getVect1DDouble(self.idx, path, cpopath + 'zion')
			check_status(status)
			status, imp_flagVal = ull.getVect1DInt(self.idx, path, cpopath + 'imp_flag')
			check_status(status)
			status, rot_imp_flagVal = ull.getVect1DInt(self.idx, path, cpopath + 'rot_imp_flag')
			check_status(status)
			status, pellet_amnVal = ull.getVect1DDouble(self.idx, path, cpopath + 'pellet_amn')
			check_status(status)
			status, pellet_znVal = ull.getVect1DDouble(self.idx, path, cpopath + 'pellet_zn')
			check_status(status)
			status, nbi_amnVal = ull.getVect1DDouble(self.idx, path, cpopath + 'nbi_amn')
			check_status(status)
			status, nbi_znVal = ull.getVect1DDouble(self.idx, path, cpopath + 'nbi_zn')
			check_status(status)
			for i in range(nbslice):
				slice = compositionstructurescenario_composition(self.base_path)
				slice.setExpIdx(self.idx)
				slice.amn = amnVal
				slice.zn = znVal
				slice.zion = zionVal
				slice.imp_flag = imp_flagVal
				slice.rot_imp_flag = rot_imp_flagVal
				slice.pellet_amn = pellet_amnVal
				slice.pellet_zn = pellet_znVal
				slice.nbi_amn = nbi_amnVal
				slice.nbi_zn = nbi_znVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type compositionstructurescenario_compositionObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type compositionstructurescenario_compositionObj, run function getTimedElt') 
		cpopath = cpopath + '/' 

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type compositionstructurescenario_compositionObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'amn') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'amn', i, numpy.array(self.amn).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'zn') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'zn', i, numpy.array(self.zn).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'zion') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'zion', i, numpy.array(self.zion).astype(numpy.float64))
		if (dev()):
			print ('putVect1DIntInObject : ' + cpopath + 'imp_flag') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DIntInObject(self.idx, obj, cpopath + 'imp_flag', i, numpy.array(self.imp_flag).astype(numpy.int32))
		if (dev()):
			print ('putVect1DIntInObject : ' + cpopath + 'rot_imp_flag') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DIntInObject(self.idx, obj, cpopath + 'rot_imp_flag', i, numpy.array(self.rot_imp_flag).astype(numpy.int32))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'pellet_amn') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'pellet_amn', i, numpy.array(self.pellet_amn).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'pellet_zn') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'pellet_zn', i, numpy.array(self.pellet_zn).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'nbi_amn') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'nbi_amn', i, numpy.array(self.nbi_amn).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'nbi_zn') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'nbi_zn', i, numpy.array(self.nbi_zn).astype(numpy.float64))
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type compositionstructurescenario_compositionObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'amn') 
			print ('obj = ' + str(obj))
		status, ret_amn = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'amn', i)
		check_status(status)
		if not status:
			self.amn = ret_amn
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'zn') 
			print ('obj = ' + str(obj))
		status, ret_zn = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'zn', i)
		check_status(status)
		if not status:
			self.zn = ret_zn
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'zion') 
			print ('obj = ' + str(obj))
		status, ret_zion = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'zion', i)
		check_status(status)
		if not status:
			self.zion = ret_zion
		if (dev()):
			print ('getVect1DIntInObject : ' + cpopath + 'imp_flag') 
			print ('obj = ' + str(obj))
		status, ret_imp_flag = ull.getVect1DIntFromObject(self.idx, obj, cpopath + 'imp_flag', i)
		check_status(status)
		if not status:
			self.imp_flag = ret_imp_flag
		if (dev()):
			print ('getVect1DIntInObject : ' + cpopath + 'rot_imp_flag') 
			print ('obj = ' + str(obj))
		status, ret_rot_imp_flag = ull.getVect1DIntFromObject(self.idx, obj, cpopath + 'rot_imp_flag', i)
		check_status(status)
		if not status:
			self.rot_imp_flag = ret_rot_imp_flag
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'pellet_amn') 
			print ('obj = ' + str(obj))
		status, ret_pellet_amn = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'pellet_amn', i)
		check_status(status)
		if not status:
			self.pellet_amn = ret_pellet_amn
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'pellet_zn') 
			print ('obj = ' + str(obj))
		status, ret_pellet_zn = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'pellet_zn', i)
		check_status(status)
		if not status:
			self.pellet_zn = ret_pellet_zn
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'nbi_amn') 
			print ('obj = ' + str(obj))
		status, ret_nbi_amn = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'nbi_amn', i)
		check_status(status)
		if not status:
			self.nbi_amn = ret_nbi_amn
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'nbi_zn') 
			print ('obj = ' + str(obj))
		status, ret_nbi_zn = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'nbi_zn', i)
		check_status(status)
		if not status:
			self.nbi_zn = ret_nbi_zn

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'amn')
		ull.deleteData(self.idx, path, cpopath + 'zn')
		ull.deleteData(self.idx, path, cpopath + 'zion')
		ull.deleteData(self.idx, path, cpopath + 'imp_flag')
		ull.deleteData(self.idx, path, cpopath + 'rot_imp_flag')
		ull.deleteData(self.idx, path, cpopath + 'pellet_amn')
		ull.deleteData(self.idx, path, cpopath + 'pellet_zn')
		ull.deleteData(self.idx, path, cpopath + 'nbi_amn')
		ull.deleteData(self.idx, path, cpopath + 'nbi_zn')


class configsstructurescenario_configuration:
	'''
	class configsstructurescenario_configuration
	Strings describing the tokamak configuration

	Attributes:
	- config : class configstructurescenario_int
	   plasma configuration (limiter/divertor ...) []. Time-dependent. Possible values : 0 = undetermined; 1 = poloidal limiter (ring); 2 = poloidal limiter (LFS); 3 = poloidal limiter (HFS); 4 = toroidal limiter (ring); 5 = toroidal limiter (segment); 6 = poloidal divertor; 7 = toroidal divertor (single null, ion drift in direction of divertor); 8 = toroidal divertor (single null, ion drift in oposite direction of divertor); 9 = toroidal divertor (double null).
	- lmode_sc : str
	   name of the L-mode scaling law. String.
	- hmode_sc : str
	   name of the H-mode scaling law. String.
	- core_sc : str
	   name of the core plasma  energy scaling law. String.
	- pedestal_sc : str
	   name of the  pedestal energy scaling law. String.
	- helium_sc : str
	   name of the  helium confinement time scaling law. String.
	- impurity_sc : str
	   name of the impurities confinement time scaling law
	- l2h_sc : str
	   name of the  L-mode to H-mode power threshold scaling law. String.
	- tor_rot_sc : str
	   name of the toroidal spontaneous rotation  scaling law. String.
	- wall_mat : str
	   chemical compostion of the wall. String.
	- evap_mat : str
	   chemical compostion evaporated wall conditioning material. String.
	- lim_mat : str
	   chemical compostion of the limiter. String.
	- div_mat : str
	   chemical compostion of the divertor
	- coordinate : str
	   name/definition of the internal coordinate of the simulator that are given by the data named rho
	- ecrh_freq : class ecrh_freqstructurescenario_ref
	   ECRH frequency [Hz]. Time-dependent.
	- ecrh_loc : class ecrh_locstructurescenario_ref
	   position of maximum ECRH deposition on scale of rho [rho]. Time-dependent.
	- ecrh_mode : class ecrh_modestructurescenario_int
	   polarisation of ecrh wave (0 = O mode, 1 = X mode) []. Time-dependent.
	- ecrh_tor_ang : class ecrh_tor_angstructurescenario_ref
	   toroidal angle of ECRH at resonance  [rad] Time-dependent.
	- ecrh_pol_ang : class ecrh_pol_angstructurescenario_ref
	   poloidal angle of ECRH resonance positon (0= LFS, pi/2 = top, -pi/2 = down, pi = HFS)  [rad]. Time-dependent.
	- ecrh_harm : class ecrh_harmstructurescenario_int
	   harmonic number of the apsorbed ecrh wave []. Time-dependent.
	- enbi : class enbistructurescenario_ref
	   energy of the neutral beam [eV]. Time-dependent.
	- r_nbi : class r_nbistructurescenario_ref
	   Major radius of tengance of NBI [m]. Time-dependent.
	- grad_b_drift : class grad_b_driftstructurescenario_int
	   direction of ion grad-B drift (1= to lower divertor, -1 = from lower divertor)  []. Time-dependent.
	- icrh_freq : class icrh_freqstructurescenario_ref
	   ICRH frequency [Hz]. Time-dependent.
	- icrh_scheme : str
	   icrh scheme either : H_min_1; He3_min; T_harm_2; FW; FW_CD; FW_CCD
	- icrh_phase : class icrh_phasestructurescenario_ref
	   ICRH antenna phasing [rad]. Time-dependent.
	- LH_freq : class LH_freqstructurescenario_ref
	   LHCD frequency [Hz]. Time-dependent.
	- LH_npar : class LH_nparstructurescenario_ref
	   LHCD parallel indice []. Time-dependent.
	- pellet_ang : class pellet_angstructurescenario_ref
	   pellet injection positon (0= LFS, pi/2 = top, -pi/2 = down, pi = HFS)  [rad]. Time-dependent.
	- pellet_v : class pellet_vstructurescenario_ref
	   pellet injection velocity [m/s]. Time-dependent.
	- pellet_nba : class pellet_nbastructurescenario_ref
	   initial number of atoms in pellet  []. Time-dependent.
	'''

	def __init__(self, base_path_in='configs'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.config = configstructurescenario_int('config')
		self.lmode_sc = ''
		self.hmode_sc = ''
		self.core_sc = ''
		self.pedestal_sc = ''
		self.helium_sc = ''
		self.impurity_sc = ''
		self.l2h_sc = ''
		self.tor_rot_sc = ''
		self.wall_mat = ''
		self.evap_mat = ''
		self.lim_mat = ''
		self.div_mat = ''
		self.coordinate = ''
		self.ecrh_freq = ecrh_freqstructurescenario_ref('ecrh_freq')
		self.ecrh_loc = ecrh_locstructurescenario_ref('ecrh_loc')
		self.ecrh_mode = ecrh_modestructurescenario_int('ecrh_mode')
		self.ecrh_tor_ang = ecrh_tor_angstructurescenario_ref('ecrh_tor_ang')
		self.ecrh_pol_ang = ecrh_pol_angstructurescenario_ref('ecrh_pol_ang')
		self.ecrh_harm = ecrh_harmstructurescenario_int('ecrh_harm')
		self.enbi = enbistructurescenario_ref('enbi')
		self.r_nbi = r_nbistructurescenario_ref('r_nbi')
		self.grad_b_drift = grad_b_driftstructurescenario_int('grad_b_drift')
		self.icrh_freq = icrh_freqstructurescenario_ref('icrh_freq')
		self.icrh_scheme = ''
		self.icrh_phase = icrh_phasestructurescenario_ref('icrh_phase')
		self.LH_freq = LH_freqstructurescenario_ref('LH_freq')
		self.LH_npar = LH_nparstructurescenario_ref('LH_npar')
		self.pellet_ang = pellet_angstructurescenario_ref('pellet_ang')
		self.pellet_v = pellet_vstructurescenario_ref('pellet_v')
		self.pellet_nba = pellet_nbastructurescenario_ref('pellet_nba')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class configsstructurescenario_configuration\n'
		ret = ret + space + 'Attribute config\n ' + self.config.__str__(depth+1)
		ret = ret + space + 'Attribute lmode_sc: ' + str(self.lmode_sc) + '\n'
		ret = ret + space + 'Attribute hmode_sc: ' + str(self.hmode_sc) + '\n'
		ret = ret + space + 'Attribute core_sc: ' + str(self.core_sc) + '\n'
		ret = ret + space + 'Attribute pedestal_sc: ' + str(self.pedestal_sc) + '\n'
		ret = ret + space + 'Attribute helium_sc: ' + str(self.helium_sc) + '\n'
		ret = ret + space + 'Attribute impurity_sc: ' + str(self.impurity_sc) + '\n'
		ret = ret + space + 'Attribute l2h_sc: ' + str(self.l2h_sc) + '\n'
		ret = ret + space + 'Attribute tor_rot_sc: ' + str(self.tor_rot_sc) + '\n'
		ret = ret + space + 'Attribute wall_mat: ' + str(self.wall_mat) + '\n'
		ret = ret + space + 'Attribute evap_mat: ' + str(self.evap_mat) + '\n'
		ret = ret + space + 'Attribute lim_mat: ' + str(self.lim_mat) + '\n'
		ret = ret + space + 'Attribute div_mat: ' + str(self.div_mat) + '\n'
		ret = ret + space + 'Attribute coordinate: ' + str(self.coordinate) + '\n'
		ret = ret + space + 'Attribute ecrh_freq\n ' + self.ecrh_freq.__str__(depth+1)
		ret = ret + space + 'Attribute ecrh_loc\n ' + self.ecrh_loc.__str__(depth+1)
		ret = ret + space + 'Attribute ecrh_mode\n ' + self.ecrh_mode.__str__(depth+1)
		ret = ret + space + 'Attribute ecrh_tor_ang\n ' + self.ecrh_tor_ang.__str__(depth+1)
		ret = ret + space + 'Attribute ecrh_pol_ang\n ' + self.ecrh_pol_ang.__str__(depth+1)
		ret = ret + space + 'Attribute ecrh_harm\n ' + self.ecrh_harm.__str__(depth+1)
		ret = ret + space + 'Attribute enbi\n ' + self.enbi.__str__(depth+1)
		ret = ret + space + 'Attribute r_nbi\n ' + self.r_nbi.__str__(depth+1)
		ret = ret + space + 'Attribute grad_b_drift\n ' + self.grad_b_drift.__str__(depth+1)
		ret = ret + space + 'Attribute icrh_freq\n ' + self.icrh_freq.__str__(depth+1)
		ret = ret + space + 'Attribute icrh_scheme: ' + str(self.icrh_scheme) + '\n'
		ret = ret + space + 'Attribute icrh_phase\n ' + self.icrh_phase.__str__(depth+1)
		ret = ret + space + 'Attribute LH_freq\n ' + self.LH_freq.__str__(depth+1)
		ret = ret + space + 'Attribute LH_npar\n ' + self.LH_npar.__str__(depth+1)
		ret = ret + space + 'Attribute pellet_ang\n ' + self.pellet_ang.__str__(depth+1)
		ret = ret + space + 'Attribute pellet_v\n ' + self.pellet_v.__str__(depth+1)
		ret = ret + space + 'Attribute pellet_nba\n ' + self.pellet_nba.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.config.setExpIdx(idx)
		self.ecrh_freq.setExpIdx(idx)
		self.ecrh_loc.setExpIdx(idx)
		self.ecrh_mode.setExpIdx(idx)
		self.ecrh_tor_ang.setExpIdx(idx)
		self.ecrh_pol_ang.setExpIdx(idx)
		self.ecrh_harm.setExpIdx(idx)
		self.enbi.setExpIdx(idx)
		self.r_nbi.setExpIdx(idx)
		self.grad_b_drift.setExpIdx(idx)
		self.icrh_freq.setExpIdx(idx)
		self.icrh_phase.setExpIdx(idx)
		self.LH_freq.setExpIdx(idx)
		self.LH_npar.setExpIdx(idx)
		self.pellet_ang.setExpIdx(idx)
		self.pellet_v.setExpIdx(idx)
		self.pellet_nba.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type configsstructurescenario_configuration, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.config.cpoTime = self.cpoTime
		self.config.putSlice(path, cpopath)
		self.ecrh_freq.cpoTime = self.cpoTime
		self.ecrh_freq.putSlice(path, cpopath)
		self.ecrh_loc.cpoTime = self.cpoTime
		self.ecrh_loc.putSlice(path, cpopath)
		self.ecrh_mode.cpoTime = self.cpoTime
		self.ecrh_mode.putSlice(path, cpopath)
		self.ecrh_tor_ang.cpoTime = self.cpoTime
		self.ecrh_tor_ang.putSlice(path, cpopath)
		self.ecrh_pol_ang.cpoTime = self.cpoTime
		self.ecrh_pol_ang.putSlice(path, cpopath)
		self.ecrh_harm.cpoTime = self.cpoTime
		self.ecrh_harm.putSlice(path, cpopath)
		self.enbi.cpoTime = self.cpoTime
		self.enbi.putSlice(path, cpopath)
		self.r_nbi.cpoTime = self.cpoTime
		self.r_nbi.putSlice(path, cpopath)
		self.grad_b_drift.cpoTime = self.cpoTime
		self.grad_b_drift.putSlice(path, cpopath)
		self.icrh_freq.cpoTime = self.cpoTime
		self.icrh_freq.putSlice(path, cpopath)
		self.icrh_phase.cpoTime = self.cpoTime
		self.icrh_phase.putSlice(path, cpopath)
		self.LH_freq.cpoTime = self.cpoTime
		self.LH_freq.putSlice(path, cpopath)
		self.LH_npar.cpoTime = self.cpoTime
		self.LH_npar.putSlice(path, cpopath)
		self.pellet_ang.cpoTime = self.cpoTime
		self.pellet_ang.putSlice(path, cpopath)
		self.pellet_v.cpoTime = self.cpoTime
		self.pellet_v.putSlice(path, cpopath)
		self.pellet_nba.cpoTime = self.cpoTime
		self.pellet_nba.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type configsstructurescenario_configuration, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.config.replaceLastSlice(path, cpopath)
		self.ecrh_freq.replaceLastSlice(path, cpopath)
		self.ecrh_loc.replaceLastSlice(path, cpopath)
		self.ecrh_mode.replaceLastSlice(path, cpopath)
		self.ecrh_tor_ang.replaceLastSlice(path, cpopath)
		self.ecrh_pol_ang.replaceLastSlice(path, cpopath)
		self.ecrh_harm.replaceLastSlice(path, cpopath)
		self.enbi.replaceLastSlice(path, cpopath)
		self.r_nbi.replaceLastSlice(path, cpopath)
		self.grad_b_drift.replaceLastSlice(path, cpopath)
		self.icrh_freq.replaceLastSlice(path, cpopath)
		self.icrh_phase.replaceLastSlice(path, cpopath)
		self.LH_freq.replaceLastSlice(path, cpopath)
		self.LH_npar.replaceLastSlice(path, cpopath)
		self.pellet_ang.replaceLastSlice(path, cpopath)
		self.pellet_v.replaceLastSlice(path, cpopath)
		self.pellet_nba.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type configsstructurescenario_configuration, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.config.putNonTimed(path, cpopath)
		status = ull.putString(self.idx, path, cpopath + 'lmode_sc', self.lmode_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'hmode_sc', self.hmode_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'core_sc', self.core_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'pedestal_sc', self.pedestal_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'helium_sc', self.helium_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'impurity_sc', self.impurity_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'l2h_sc', self.l2h_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'tor_rot_sc', self.tor_rot_sc)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'wall_mat', self.wall_mat)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'evap_mat', self.evap_mat)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'lim_mat', self.lim_mat)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'div_mat', self.div_mat)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'coordinate', self.coordinate)
		check_status(status)
		self.ecrh_freq.putNonTimed(path, cpopath)
		self.ecrh_loc.putNonTimed(path, cpopath)
		self.ecrh_mode.putNonTimed(path, cpopath)
		self.ecrh_tor_ang.putNonTimed(path, cpopath)
		self.ecrh_pol_ang.putNonTimed(path, cpopath)
		self.ecrh_harm.putNonTimed(path, cpopath)
		self.enbi.putNonTimed(path, cpopath)
		self.r_nbi.putNonTimed(path, cpopath)
		self.grad_b_drift.putNonTimed(path, cpopath)
		self.icrh_freq.putNonTimed(path, cpopath)
		status = ull.putString(self.idx, path, cpopath + 'icrh_scheme', self.icrh_scheme)
		check_status(status)
		self.icrh_phase.putNonTimed(path, cpopath)
		self.LH_freq.putNonTimed(path, cpopath)
		self.LH_npar.putNonTimed(path, cpopath)
		self.pellet_ang.putNonTimed(path, cpopath)
		self.pellet_v.putNonTimed(path, cpopath)
		self.pellet_nba.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type configsstructurescenario_configuration, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.config.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_lmode_sc = ull.getString(self.idx, path, cpopath + 'lmode_sc')
		check_status(status)
		if not status:
			self.lmode_sc = ret_lmode_sc
		status, ret_hmode_sc = ull.getString(self.idx, path, cpopath + 'hmode_sc')
		check_status(status)
		if not status:
			self.hmode_sc = ret_hmode_sc
		status, ret_core_sc = ull.getString(self.idx, path, cpopath + 'core_sc')
		check_status(status)
		if not status:
			self.core_sc = ret_core_sc
		status, ret_pedestal_sc = ull.getString(self.idx, path, cpopath + 'pedestal_sc')
		check_status(status)
		if not status:
			self.pedestal_sc = ret_pedestal_sc
		status, ret_helium_sc = ull.getString(self.idx, path, cpopath + 'helium_sc')
		check_status(status)
		if not status:
			self.helium_sc = ret_helium_sc
		status, ret_impurity_sc = ull.getString(self.idx, path, cpopath + 'impurity_sc')
		check_status(status)
		if not status:
			self.impurity_sc = ret_impurity_sc
		status, ret_l2h_sc = ull.getString(self.idx, path, cpopath + 'l2h_sc')
		check_status(status)
		if not status:
			self.l2h_sc = ret_l2h_sc
		status, ret_tor_rot_sc = ull.getString(self.idx, path, cpopath + 'tor_rot_sc')
		check_status(status)
		if not status:
			self.tor_rot_sc = ret_tor_rot_sc
		status, ret_wall_mat = ull.getString(self.idx, path, cpopath + 'wall_mat')
		check_status(status)
		if not status:
			self.wall_mat = ret_wall_mat
		status, ret_evap_mat = ull.getString(self.idx, path, cpopath + 'evap_mat')
		check_status(status)
		if not status:
			self.evap_mat = ret_evap_mat
		status, ret_lim_mat = ull.getString(self.idx, path, cpopath + 'lim_mat')
		check_status(status)
		if not status:
			self.lim_mat = ret_lim_mat
		status, ret_div_mat = ull.getString(self.idx, path, cpopath + 'div_mat')
		check_status(status)
		if not status:
			self.div_mat = ret_div_mat
		status, ret_coordinate = ull.getString(self.idx, path, cpopath + 'coordinate')
		check_status(status)
		if not status:
			self.coordinate = ret_coordinate
		self.ecrh_freq.getSlice(path, cpopath, inTime, interpolMode)
		self.ecrh_loc.getSlice(path, cpopath, inTime, interpolMode)
		self.ecrh_mode.getSlice(path, cpopath, inTime, interpolMode)
		self.ecrh_tor_ang.getSlice(path, cpopath, inTime, interpolMode)
		self.ecrh_pol_ang.getSlice(path, cpopath, inTime, interpolMode)
		self.ecrh_harm.getSlice(path, cpopath, inTime, interpolMode)
		self.enbi.getSlice(path, cpopath, inTime, interpolMode)
		self.r_nbi.getSlice(path, cpopath, inTime, interpolMode)
		self.grad_b_drift.getSlice(path, cpopath, inTime, interpolMode)
		self.icrh_freq.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_icrh_scheme = ull.getString(self.idx, path, cpopath + 'icrh_scheme')
		check_status(status)
		if not status:
			self.icrh_scheme = ret_icrh_scheme
		self.icrh_phase.getSlice(path, cpopath, inTime, interpolMode)
		self.LH_freq.getSlice(path, cpopath, inTime, interpolMode)
		self.LH_npar.getSlice(path, cpopath, inTime, interpolMode)
		self.pellet_ang.getSlice(path, cpopath, inTime, interpolMode)
		self.pellet_v.getSlice(path, cpopath, inTime, interpolMode)
		self.pellet_nba.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type configsstructurescenario_configuration, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			configList = self.config.build_non_resampled_data(path, cpopath, nbslice)
			status, lmode_scVal = ull.getString(self.idx, path, cpopath + 'lmode_sc')
			check_status(status)
			status, hmode_scVal = ull.getString(self.idx, path, cpopath + 'hmode_sc')
			check_status(status)
			status, core_scVal = ull.getString(self.idx, path, cpopath + 'core_sc')
			check_status(status)
			status, pedestal_scVal = ull.getString(self.idx, path, cpopath + 'pedestal_sc')
			check_status(status)
			status, helium_scVal = ull.getString(self.idx, path, cpopath + 'helium_sc')
			check_status(status)
			status, impurity_scVal = ull.getString(self.idx, path, cpopath + 'impurity_sc')
			check_status(status)
			status, l2h_scVal = ull.getString(self.idx, path, cpopath + 'l2h_sc')
			check_status(status)
			status, tor_rot_scVal = ull.getString(self.idx, path, cpopath + 'tor_rot_sc')
			check_status(status)
			status, wall_matVal = ull.getString(self.idx, path, cpopath + 'wall_mat')
			check_status(status)
			status, evap_matVal = ull.getString(self.idx, path, cpopath + 'evap_mat')
			check_status(status)
			status, lim_matVal = ull.getString(self.idx, path, cpopath + 'lim_mat')
			check_status(status)
			status, div_matVal = ull.getString(self.idx, path, cpopath + 'div_mat')
			check_status(status)
			status, coordinateVal = ull.getString(self.idx, path, cpopath + 'coordinate')
			check_status(status)
			ecrh_freqList = self.ecrh_freq.build_non_resampled_data(path, cpopath, nbslice)
			ecrh_locList = self.ecrh_loc.build_non_resampled_data(path, cpopath, nbslice)
			ecrh_modeList = self.ecrh_mode.build_non_resampled_data(path, cpopath, nbslice)
			ecrh_tor_angList = self.ecrh_tor_ang.build_non_resampled_data(path, cpopath, nbslice)
			ecrh_pol_angList = self.ecrh_pol_ang.build_non_resampled_data(path, cpopath, nbslice)
			ecrh_harmList = self.ecrh_harm.build_non_resampled_data(path, cpopath, nbslice)
			enbiList = self.enbi.build_non_resampled_data(path, cpopath, nbslice)
			r_nbiList = self.r_nbi.build_non_resampled_data(path, cpopath, nbslice)
			grad_b_driftList = self.grad_b_drift.build_non_resampled_data(path, cpopath, nbslice)
			icrh_freqList = self.icrh_freq.build_non_resampled_data(path, cpopath, nbslice)
			status, icrh_schemeVal = ull.getString(self.idx, path, cpopath + 'icrh_scheme')
			check_status(status)
			icrh_phaseList = self.icrh_phase.build_non_resampled_data(path, cpopath, nbslice)
			LH_freqList = self.LH_freq.build_non_resampled_data(path, cpopath, nbslice)
			LH_nparList = self.LH_npar.build_non_resampled_data(path, cpopath, nbslice)
			pellet_angList = self.pellet_ang.build_non_resampled_data(path, cpopath, nbslice)
			pellet_vList = self.pellet_v.build_non_resampled_data(path, cpopath, nbslice)
			pellet_nbaList = self.pellet_nba.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = configsstructurescenario_configuration(self.base_path)
				slice.setExpIdx(self.idx)
				slice.config = configList[i]
				slice.lmode_sc = lmode_scVal
				slice.hmode_sc = hmode_scVal
				slice.core_sc = core_scVal
				slice.pedestal_sc = pedestal_scVal
				slice.helium_sc = helium_scVal
				slice.impurity_sc = impurity_scVal
				slice.l2h_sc = l2h_scVal
				slice.tor_rot_sc = tor_rot_scVal
				slice.wall_mat = wall_matVal
				slice.evap_mat = evap_matVal
				slice.lim_mat = lim_matVal
				slice.div_mat = div_matVal
				slice.coordinate = coordinateVal
				slice.ecrh_freq = ecrh_freqList[i]
				slice.ecrh_loc = ecrh_locList[i]
				slice.ecrh_mode = ecrh_modeList[i]
				slice.ecrh_tor_ang = ecrh_tor_angList[i]
				slice.ecrh_pol_ang = ecrh_pol_angList[i]
				slice.ecrh_harm = ecrh_harmList[i]
				slice.enbi = enbiList[i]
				slice.r_nbi = r_nbiList[i]
				slice.grad_b_drift = grad_b_driftList[i]
				slice.icrh_freq = icrh_freqList[i]
				slice.icrh_scheme = icrh_schemeVal
				slice.icrh_phase = icrh_phaseList[i]
				slice.LH_freq = LH_freqList[i]
				slice.LH_npar = LH_nparList[i]
				slice.pellet_ang = pellet_angList[i]
				slice.pellet_v = pellet_vList[i]
				slice.pellet_nba = pellet_nbaList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configsstructurescenario_configurationObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.config.putTimedElt(path, cpopath + 'config', i, obj)
		obj = self.ecrh_freq.putTimedElt(path, cpopath + 'ecrh_freq', i, obj)
		obj = self.ecrh_loc.putTimedElt(path, cpopath + 'ecrh_loc', i, obj)
		obj = self.ecrh_mode.putTimedElt(path, cpopath + 'ecrh_mode', i, obj)
		obj = self.ecrh_tor_ang.putTimedElt(path, cpopath + 'ecrh_tor_ang', i, obj)
		obj = self.ecrh_pol_ang.putTimedElt(path, cpopath + 'ecrh_pol_ang', i, obj)
		obj = self.ecrh_harm.putTimedElt(path, cpopath + 'ecrh_harm', i, obj)
		obj = self.enbi.putTimedElt(path, cpopath + 'enbi', i, obj)
		obj = self.r_nbi.putTimedElt(path, cpopath + 'r_nbi', i, obj)
		obj = self.grad_b_drift.putTimedElt(path, cpopath + 'grad_b_drift', i, obj)
		obj = self.icrh_freq.putTimedElt(path, cpopath + 'icrh_freq', i, obj)
		obj = self.icrh_phase.putTimedElt(path, cpopath + 'icrh_phase', i, obj)
		obj = self.LH_freq.putTimedElt(path, cpopath + 'LH_freq', i, obj)
		obj = self.LH_npar.putTimedElt(path, cpopath + 'LH_npar', i, obj)
		obj = self.pellet_ang.putTimedElt(path, cpopath + 'pellet_ang', i, obj)
		obj = self.pellet_v.putTimedElt(path, cpopath + 'pellet_v', i, obj)
		obj = self.pellet_nba.putTimedElt(path, cpopath + 'pellet_nba', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configsstructurescenario_configurationObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.config.getTimedElt(path, cpopath + 'config', i, obj)
		self.ecrh_freq.getTimedElt(path, cpopath + 'ecrh_freq', i, obj)
		self.ecrh_loc.getTimedElt(path, cpopath + 'ecrh_loc', i, obj)
		self.ecrh_mode.getTimedElt(path, cpopath + 'ecrh_mode', i, obj)
		self.ecrh_tor_ang.getTimedElt(path, cpopath + 'ecrh_tor_ang', i, obj)
		self.ecrh_pol_ang.getTimedElt(path, cpopath + 'ecrh_pol_ang', i, obj)
		self.ecrh_harm.getTimedElt(path, cpopath + 'ecrh_harm', i, obj)
		self.enbi.getTimedElt(path, cpopath + 'enbi', i, obj)
		self.r_nbi.getTimedElt(path, cpopath + 'r_nbi', i, obj)
		self.grad_b_drift.getTimedElt(path, cpopath + 'grad_b_drift', i, obj)
		self.icrh_freq.getTimedElt(path, cpopath + 'icrh_freq', i, obj)
		self.icrh_phase.getTimedElt(path, cpopath + 'icrh_phase', i, obj)
		self.LH_freq.getTimedElt(path, cpopath + 'LH_freq', i, obj)
		self.LH_npar.getTimedElt(path, cpopath + 'LH_npar', i, obj)
		self.pellet_ang.getTimedElt(path, cpopath + 'pellet_ang', i, obj)
		self.pellet_v.getTimedElt(path, cpopath + 'pellet_v', i, obj)
		self.pellet_nba.getTimedElt(path, cpopath + 'pellet_nba', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configsstructurescenario_configurationObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.config.putNonTimedElt(path, cpopath + 'config', i, obj)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'lmode_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'lmode_sc', i, self.lmode_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'hmode_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'hmode_sc', i, self.hmode_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'core_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'core_sc', i, self.core_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'pedestal_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'pedestal_sc', i, self.pedestal_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'helium_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'helium_sc', i, self.helium_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'impurity_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'impurity_sc', i, self.impurity_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'l2h_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'l2h_sc', i, self.l2h_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'tor_rot_sc') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'tor_rot_sc', i, self.tor_rot_sc)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'wall_mat') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'wall_mat', i, self.wall_mat)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'evap_mat') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'evap_mat', i, self.evap_mat)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'lim_mat') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'lim_mat', i, self.lim_mat)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'div_mat') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'div_mat', i, self.div_mat)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'coordinate') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'coordinate', i, self.coordinate)
		obj = self.ecrh_freq.putNonTimedElt(path, cpopath + 'ecrh_freq', i, obj)
		obj = self.ecrh_loc.putNonTimedElt(path, cpopath + 'ecrh_loc', i, obj)
		obj = self.ecrh_mode.putNonTimedElt(path, cpopath + 'ecrh_mode', i, obj)
		obj = self.ecrh_tor_ang.putNonTimedElt(path, cpopath + 'ecrh_tor_ang', i, obj)
		obj = self.ecrh_pol_ang.putNonTimedElt(path, cpopath + 'ecrh_pol_ang', i, obj)
		obj = self.ecrh_harm.putNonTimedElt(path, cpopath + 'ecrh_harm', i, obj)
		obj = self.enbi.putNonTimedElt(path, cpopath + 'enbi', i, obj)
		obj = self.r_nbi.putNonTimedElt(path, cpopath + 'r_nbi', i, obj)
		obj = self.grad_b_drift.putNonTimedElt(path, cpopath + 'grad_b_drift', i, obj)
		obj = self.icrh_freq.putNonTimedElt(path, cpopath + 'icrh_freq', i, obj)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'icrh_scheme') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'icrh_scheme', i, self.icrh_scheme)
		obj = self.icrh_phase.putNonTimedElt(path, cpopath + 'icrh_phase', i, obj)
		obj = self.LH_freq.putNonTimedElt(path, cpopath + 'LH_freq', i, obj)
		obj = self.LH_npar.putNonTimedElt(path, cpopath + 'LH_npar', i, obj)
		obj = self.pellet_ang.putNonTimedElt(path, cpopath + 'pellet_ang', i, obj)
		obj = self.pellet_v.putNonTimedElt(path, cpopath + 'pellet_v', i, obj)
		obj = self.pellet_nba.putNonTimedElt(path, cpopath + 'pellet_nba', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configsstructurescenario_configurationObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.config.getNonTimedElt(path, cpopath + 'config', i, obj)
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'lmode_sc') 
			print ('obj = ' + str(obj))
		status, ret_lmode_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'lmode_sc', i)
		check_status(status)
		if not status:
			self.lmode_sc = ret_lmode_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'hmode_sc') 
			print ('obj = ' + str(obj))
		status, ret_hmode_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'hmode_sc', i)
		check_status(status)
		if not status:
			self.hmode_sc = ret_hmode_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'core_sc') 
			print ('obj = ' + str(obj))
		status, ret_core_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'core_sc', i)
		check_status(status)
		if not status:
			self.core_sc = ret_core_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'pedestal_sc') 
			print ('obj = ' + str(obj))
		status, ret_pedestal_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'pedestal_sc', i)
		check_status(status)
		if not status:
			self.pedestal_sc = ret_pedestal_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'helium_sc') 
			print ('obj = ' + str(obj))
		status, ret_helium_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'helium_sc', i)
		check_status(status)
		if not status:
			self.helium_sc = ret_helium_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'impurity_sc') 
			print ('obj = ' + str(obj))
		status, ret_impurity_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'impurity_sc', i)
		check_status(status)
		if not status:
			self.impurity_sc = ret_impurity_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'l2h_sc') 
			print ('obj = ' + str(obj))
		status, ret_l2h_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'l2h_sc', i)
		check_status(status)
		if not status:
			self.l2h_sc = ret_l2h_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'tor_rot_sc') 
			print ('obj = ' + str(obj))
		status, ret_tor_rot_sc = ull.getStringFromObject(self.idx, obj, cpopath + 'tor_rot_sc', i)
		check_status(status)
		if not status:
			self.tor_rot_sc = ret_tor_rot_sc
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'wall_mat') 
			print ('obj = ' + str(obj))
		status, ret_wall_mat = ull.getStringFromObject(self.idx, obj, cpopath + 'wall_mat', i)
		check_status(status)
		if not status:
			self.wall_mat = ret_wall_mat
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'evap_mat') 
			print ('obj = ' + str(obj))
		status, ret_evap_mat = ull.getStringFromObject(self.idx, obj, cpopath + 'evap_mat', i)
		check_status(status)
		if not status:
			self.evap_mat = ret_evap_mat
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'lim_mat') 
			print ('obj = ' + str(obj))
		status, ret_lim_mat = ull.getStringFromObject(self.idx, obj, cpopath + 'lim_mat', i)
		check_status(status)
		if not status:
			self.lim_mat = ret_lim_mat
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'div_mat') 
			print ('obj = ' + str(obj))
		status, ret_div_mat = ull.getStringFromObject(self.idx, obj, cpopath + 'div_mat', i)
		check_status(status)
		if not status:
			self.div_mat = ret_div_mat
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'coordinate') 
			print ('obj = ' + str(obj))
		status, ret_coordinate = ull.getStringFromObject(self.idx, obj, cpopath + 'coordinate', i)
		check_status(status)
		if not status:
			self.coordinate = ret_coordinate
		self.ecrh_freq.getNonTimedElt(path, cpopath + 'ecrh_freq', i, obj)
		self.ecrh_loc.getNonTimedElt(path, cpopath + 'ecrh_loc', i, obj)
		self.ecrh_mode.getNonTimedElt(path, cpopath + 'ecrh_mode', i, obj)
		self.ecrh_tor_ang.getNonTimedElt(path, cpopath + 'ecrh_tor_ang', i, obj)
		self.ecrh_pol_ang.getNonTimedElt(path, cpopath + 'ecrh_pol_ang', i, obj)
		self.ecrh_harm.getNonTimedElt(path, cpopath + 'ecrh_harm', i, obj)
		self.enbi.getNonTimedElt(path, cpopath + 'enbi', i, obj)
		self.r_nbi.getNonTimedElt(path, cpopath + 'r_nbi', i, obj)
		self.grad_b_drift.getNonTimedElt(path, cpopath + 'grad_b_drift', i, obj)
		self.icrh_freq.getNonTimedElt(path, cpopath + 'icrh_freq', i, obj)
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'icrh_scheme') 
			print ('obj = ' + str(obj))
		status, ret_icrh_scheme = ull.getStringFromObject(self.idx, obj, cpopath + 'icrh_scheme', i)
		check_status(status)
		if not status:
			self.icrh_scheme = ret_icrh_scheme
		self.icrh_phase.getNonTimedElt(path, cpopath + 'icrh_phase', i, obj)
		self.LH_freq.getNonTimedElt(path, cpopath + 'LH_freq', i, obj)
		self.LH_npar.getNonTimedElt(path, cpopath + 'LH_npar', i, obj)
		self.pellet_ang.getNonTimedElt(path, cpopath + 'pellet_ang', i, obj)
		self.pellet_v.getNonTimedElt(path, cpopath + 'pellet_v', i, obj)
		self.pellet_nba.getNonTimedElt(path, cpopath + 'pellet_nba', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.config.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'lmode_sc')
		ull.deleteData(self.idx, path, cpopath + 'hmode_sc')
		ull.deleteData(self.idx, path, cpopath + 'core_sc')
		ull.deleteData(self.idx, path, cpopath + 'pedestal_sc')
		ull.deleteData(self.idx, path, cpopath + 'helium_sc')
		ull.deleteData(self.idx, path, cpopath + 'impurity_sc')
		ull.deleteData(self.idx, path, cpopath + 'l2h_sc')
		ull.deleteData(self.idx, path, cpopath + 'tor_rot_sc')
		ull.deleteData(self.idx, path, cpopath + 'wall_mat')
		ull.deleteData(self.idx, path, cpopath + 'evap_mat')
		ull.deleteData(self.idx, path, cpopath + 'lim_mat')
		ull.deleteData(self.idx, path, cpopath + 'div_mat')
		ull.deleteData(self.idx, path, cpopath + 'coordinate')
		self.ecrh_freq.deleteData(path, cpopath)
		self.ecrh_loc.deleteData(path, cpopath)
		self.ecrh_mode.deleteData(path, cpopath)
		self.ecrh_tor_ang.deleteData(path, cpopath)
		self.ecrh_pol_ang.deleteData(path, cpopath)
		self.ecrh_harm.deleteData(path, cpopath)
		self.enbi.deleteData(path, cpopath)
		self.r_nbi.deleteData(path, cpopath)
		self.grad_b_drift.deleteData(path, cpopath)
		self.icrh_freq.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'icrh_scheme')
		self.icrh_phase.deleteData(path, cpopath)
		self.LH_freq.deleteData(path, cpopath)
		self.LH_npar.deleteData(path, cpopath)
		self.pellet_ang.deleteData(path, cpopath)
		self.pellet_v.deleteData(path, cpopath)
		self.pellet_nba.deleteData(path, cpopath)


class configstructurescenario_int:
	'''
	class configstructurescenario_int
	plasma configuration (limiter/divertor ...) []. Time-dependent. Possible values : 0 = undetermined; 1 = poloidal limiter (ring); 2 = poloidal limiter (LFS); 3 = poloidal limiter (HFS); 4 = toroidal limiter (ring); 5 = toroidal limiter (segment); 6 = poloidal divertor; 7 = toroidal divertor (single null, ion drift in direction of divertor); 8 = toroidal divertor (single null, ion drift in oposite direction of divertor); 9 = toroidal divertor (double null).

	Attributes:
	- value : int
	   Signal value; Time-dependent; Scalar Integer.
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='config'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_INT
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class configstructurescenario_int\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type configstructurescenario_int, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type configstructurescenario_int, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type configstructurescenario_int, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type configstructurescenario_int, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getIntSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type configstructurescenario_int, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DInt(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = configstructurescenario_int(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = int(valueList[i].copy())
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configstructurescenario_intObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configstructurescenario_intObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getIntFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configstructurescenario_intObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type configstructurescenario_intObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ecrh_freqstructurescenario_ref:
	'''
	class ecrh_freqstructurescenario_ref
	ECRH frequency [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ecrh_freq'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ecrh_freqstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_freqstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_freqstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_freqstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_freqstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_freqstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ecrh_freqstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_freqstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_freqstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_freqstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_freqstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ecrh_locstructurescenario_ref:
	'''
	class ecrh_locstructurescenario_ref
	position of maximum ECRH deposition on scale of rho [rho]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ecrh_loc'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ecrh_locstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_locstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_locstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_locstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_locstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_locstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ecrh_locstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_locstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_locstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_locstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_locstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ecrh_modestructurescenario_int:
	'''
	class ecrh_modestructurescenario_int
	polarisation of ecrh wave (0 = O mode, 1 = X mode) []. Time-dependent.

	Attributes:
	- value : int
	   Signal value; Time-dependent; Scalar Integer.
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ecrh_mode'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_INT
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ecrh_modestructurescenario_int\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_modestructurescenario_int, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_modestructurescenario_int, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_modestructurescenario_int, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_modestructurescenario_int, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getIntSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_modestructurescenario_int, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DInt(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ecrh_modestructurescenario_int(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = int(valueList[i].copy())
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_modestructurescenario_intObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_modestructurescenario_intObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getIntFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_modestructurescenario_intObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_modestructurescenario_intObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ecrh_tor_angstructurescenario_ref:
	'''
	class ecrh_tor_angstructurescenario_ref
	toroidal angle of ECRH at resonance  [rad] Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ecrh_tor_ang'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ecrh_tor_angstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_tor_angstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_tor_angstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_tor_angstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_tor_angstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_tor_angstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ecrh_tor_angstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_tor_angstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_tor_angstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_tor_angstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_tor_angstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ecrh_pol_angstructurescenario_ref:
	'''
	class ecrh_pol_angstructurescenario_ref
	poloidal angle of ECRH resonance positon (0= LFS, pi/2 = top, -pi/2 = down, pi = HFS)  [rad]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ecrh_pol_ang'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ecrh_pol_angstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_pol_angstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_pol_angstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_pol_angstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_pol_angstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_pol_angstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ecrh_pol_angstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_pol_angstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_pol_angstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_pol_angstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_pol_angstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ecrh_harmstructurescenario_int:
	'''
	class ecrh_harmstructurescenario_int
	harmonic number of the apsorbed ecrh wave []. Time-dependent.

	Attributes:
	- value : int
	   Signal value; Time-dependent; Scalar Integer.
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ecrh_harm'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_INT
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ecrh_harmstructurescenario_int\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_harmstructurescenario_int, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_harmstructurescenario_int, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_harmstructurescenario_int, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_harmstructurescenario_int, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getIntSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ecrh_harmstructurescenario_int, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DInt(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ecrh_harmstructurescenario_int(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = int(valueList[i].copy())
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_harmstructurescenario_intObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_harmstructurescenario_intObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getIntFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_harmstructurescenario_intObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ecrh_harmstructurescenario_intObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class enbistructurescenario_ref:
	'''
	class enbistructurescenario_ref
	energy of the neutral beam [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='enbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class enbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type enbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type enbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type enbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type enbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type enbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = enbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class r_nbistructurescenario_ref:
	'''
	class r_nbistructurescenario_ref
	Major radius of tengance of NBI [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='r_nbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class r_nbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type r_nbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type r_nbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type r_nbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type r_nbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type r_nbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = r_nbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type r_nbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type r_nbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type r_nbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type r_nbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class grad_b_driftstructurescenario_int:
	'''
	class grad_b_driftstructurescenario_int
	direction of ion grad-B drift (1= to lower divertor, -1 = from lower divertor)  []. Time-dependent.

	Attributes:
	- value : int
	   Signal value; Time-dependent; Scalar Integer.
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='grad_b_drift'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_INT
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class grad_b_driftstructurescenario_int\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type grad_b_driftstructurescenario_int, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type grad_b_driftstructurescenario_int, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type grad_b_driftstructurescenario_int, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type grad_b_driftstructurescenario_int, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getIntSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type grad_b_driftstructurescenario_int, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DInt(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = grad_b_driftstructurescenario_int(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = int(valueList[i].copy())
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type grad_b_driftstructurescenario_intObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type grad_b_driftstructurescenario_intObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getIntFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type grad_b_driftstructurescenario_intObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type grad_b_driftstructurescenario_intObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class icrh_freqstructurescenario_ref:
	'''
	class icrh_freqstructurescenario_ref
	ICRH frequency [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='icrh_freq'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class icrh_freqstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_freqstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_freqstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_freqstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_freqstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_freqstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = icrh_freqstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_freqstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_freqstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_freqstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_freqstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class icrh_phasestructurescenario_ref:
	'''
	class icrh_phasestructurescenario_ref
	ICRH antenna phasing [rad]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='icrh_phase'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class icrh_phasestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_phasestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_phasestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_phasestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_phasestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type icrh_phasestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = icrh_phasestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_phasestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_phasestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_phasestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type icrh_phasestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class LH_freqstructurescenario_ref:
	'''
	class LH_freqstructurescenario_ref
	LHCD frequency [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='LH_freq'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class LH_freqstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type LH_freqstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type LH_freqstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type LH_freqstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type LH_freqstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type LH_freqstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = LH_freqstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_freqstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_freqstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_freqstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_freqstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class LH_nparstructurescenario_ref:
	'''
	class LH_nparstructurescenario_ref
	LHCD parallel indice []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='LH_npar'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class LH_nparstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type LH_nparstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type LH_nparstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type LH_nparstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type LH_nparstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type LH_nparstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = LH_nparstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_nparstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_nparstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_nparstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type LH_nparstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pellet_angstructurescenario_ref:
	'''
	class pellet_angstructurescenario_ref
	pellet injection positon (0= LFS, pi/2 = top, -pi/2 = down, pi = HFS)  [rad]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pellet_ang'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pellet_angstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_angstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_angstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_angstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_angstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_angstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pellet_angstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_angstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_angstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_angstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_angstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pellet_vstructurescenario_ref:
	'''
	class pellet_vstructurescenario_ref
	pellet injection velocity [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pellet_v'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pellet_vstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_vstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_vstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_vstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_vstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_vstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pellet_vstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_vstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_vstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_vstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_vstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pellet_nbastructurescenario_ref:
	'''
	class pellet_nbastructurescenario_ref
	initial number of atoms in pellet  []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pellet_nba'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pellet_nbastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_nbastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_nbastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_nbastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_nbastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_nbastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pellet_nbastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_nbastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_nbastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_nbastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_nbastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class confinementstructurescenario_confinement:
	'''
	class confinementstructurescenario_confinement
	characteristic confinement times

	Attributes:
	- tau_e : class tau_estructurescenario_ref
	   thermal energy confinement time [s]. Time-dependent.
	- tau_l_sc : class tau_l_scstructurescenario_ref
	   confinement time given by the selected L-mode scaling law [s]. Time-dependent.
	- tau_h_sc : class tau_h_scstructurescenario_ref
	   confinement time given by the selected H-mode scaling law [s]. Time-dependent.
	- tau_he : class tau_hestructurescenario_ref
	   Helium ashes confinement time [s]. Time-dependent.
	- tau_e_ee : class tau_e_eestructurescenario_ref
	   electron energy confimenent time [s]. Time-dependent.
	- tau_e_ii : class tau_e_iistructurescenario_ref
	   ion energy confinement time [s]. Time-dependent.
	- tau_e_ei : class tau_e_eistructurescenario_ref
	   energy equipartition characteristic time [s]. Time-dependent.
	- tau_cur_diff : class tau_cur_diffstructurescenario_ref
	   characteristic time for current diffusion  [s]. Time-dependent.
	- tau_i_rol : class tau_i_rolstructurescenario_ref
	   characteristic time for current decrease in tokamak equivalent R/L circuit [s]. Time-dependent.
	'''

	def __init__(self, base_path_in='confinement'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.tau_e = tau_estructurescenario_ref('tau_e')
		self.tau_l_sc = tau_l_scstructurescenario_ref('tau_l_sc')
		self.tau_h_sc = tau_h_scstructurescenario_ref('tau_h_sc')
		self.tau_he = tau_hestructurescenario_ref('tau_he')
		self.tau_e_ee = tau_e_eestructurescenario_ref('tau_e_ee')
		self.tau_e_ii = tau_e_iistructurescenario_ref('tau_e_ii')
		self.tau_e_ei = tau_e_eistructurescenario_ref('tau_e_ei')
		self.tau_cur_diff = tau_cur_diffstructurescenario_ref('tau_cur_diff')
		self.tau_i_rol = tau_i_rolstructurescenario_ref('tau_i_rol')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class confinementstructurescenario_confinement\n'
		ret = ret + space + 'Attribute tau_e\n ' + self.tau_e.__str__(depth+1)
		ret = ret + space + 'Attribute tau_l_sc\n ' + self.tau_l_sc.__str__(depth+1)
		ret = ret + space + 'Attribute tau_h_sc\n ' + self.tau_h_sc.__str__(depth+1)
		ret = ret + space + 'Attribute tau_he\n ' + self.tau_he.__str__(depth+1)
		ret = ret + space + 'Attribute tau_e_ee\n ' + self.tau_e_ee.__str__(depth+1)
		ret = ret + space + 'Attribute tau_e_ii\n ' + self.tau_e_ii.__str__(depth+1)
		ret = ret + space + 'Attribute tau_e_ei\n ' + self.tau_e_ei.__str__(depth+1)
		ret = ret + space + 'Attribute tau_cur_diff\n ' + self.tau_cur_diff.__str__(depth+1)
		ret = ret + space + 'Attribute tau_i_rol\n ' + self.tau_i_rol.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.tau_e.setExpIdx(idx)
		self.tau_l_sc.setExpIdx(idx)
		self.tau_h_sc.setExpIdx(idx)
		self.tau_he.setExpIdx(idx)
		self.tau_e_ee.setExpIdx(idx)
		self.tau_e_ii.setExpIdx(idx)
		self.tau_e_ei.setExpIdx(idx)
		self.tau_cur_diff.setExpIdx(idx)
		self.tau_i_rol.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type confinementstructurescenario_confinement, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.tau_e.cpoTime = self.cpoTime
		self.tau_e.putSlice(path, cpopath)
		self.tau_l_sc.cpoTime = self.cpoTime
		self.tau_l_sc.putSlice(path, cpopath)
		self.tau_h_sc.cpoTime = self.cpoTime
		self.tau_h_sc.putSlice(path, cpopath)
		self.tau_he.cpoTime = self.cpoTime
		self.tau_he.putSlice(path, cpopath)
		self.tau_e_ee.cpoTime = self.cpoTime
		self.tau_e_ee.putSlice(path, cpopath)
		self.tau_e_ii.cpoTime = self.cpoTime
		self.tau_e_ii.putSlice(path, cpopath)
		self.tau_e_ei.cpoTime = self.cpoTime
		self.tau_e_ei.putSlice(path, cpopath)
		self.tau_cur_diff.cpoTime = self.cpoTime
		self.tau_cur_diff.putSlice(path, cpopath)
		self.tau_i_rol.cpoTime = self.cpoTime
		self.tau_i_rol.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type confinementstructurescenario_confinement, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.tau_e.replaceLastSlice(path, cpopath)
		self.tau_l_sc.replaceLastSlice(path, cpopath)
		self.tau_h_sc.replaceLastSlice(path, cpopath)
		self.tau_he.replaceLastSlice(path, cpopath)
		self.tau_e_ee.replaceLastSlice(path, cpopath)
		self.tau_e_ii.replaceLastSlice(path, cpopath)
		self.tau_e_ei.replaceLastSlice(path, cpopath)
		self.tau_cur_diff.replaceLastSlice(path, cpopath)
		self.tau_i_rol.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type confinementstructurescenario_confinement, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.tau_e.putNonTimed(path, cpopath)
		self.tau_l_sc.putNonTimed(path, cpopath)
		self.tau_h_sc.putNonTimed(path, cpopath)
		self.tau_he.putNonTimed(path, cpopath)
		self.tau_e_ee.putNonTimed(path, cpopath)
		self.tau_e_ii.putNonTimed(path, cpopath)
		self.tau_e_ei.putNonTimed(path, cpopath)
		self.tau_cur_diff.putNonTimed(path, cpopath)
		self.tau_i_rol.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type confinementstructurescenario_confinement, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.tau_e.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_l_sc.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_h_sc.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_he.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_e_ee.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_e_ii.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_e_ei.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_cur_diff.getSlice(path, cpopath, inTime, interpolMode)
		self.tau_i_rol.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type confinementstructurescenario_confinement, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			tau_eList = self.tau_e.build_non_resampled_data(path, cpopath, nbslice)
			tau_l_scList = self.tau_l_sc.build_non_resampled_data(path, cpopath, nbslice)
			tau_h_scList = self.tau_h_sc.build_non_resampled_data(path, cpopath, nbslice)
			tau_heList = self.tau_he.build_non_resampled_data(path, cpopath, nbslice)
			tau_e_eeList = self.tau_e_ee.build_non_resampled_data(path, cpopath, nbslice)
			tau_e_iiList = self.tau_e_ii.build_non_resampled_data(path, cpopath, nbslice)
			tau_e_eiList = self.tau_e_ei.build_non_resampled_data(path, cpopath, nbslice)
			tau_cur_diffList = self.tau_cur_diff.build_non_resampled_data(path, cpopath, nbslice)
			tau_i_rolList = self.tau_i_rol.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = confinementstructurescenario_confinement(self.base_path)
				slice.setExpIdx(self.idx)
				slice.tau_e = tau_eList[i]
				slice.tau_l_sc = tau_l_scList[i]
				slice.tau_h_sc = tau_h_scList[i]
				slice.tau_he = tau_heList[i]
				slice.tau_e_ee = tau_e_eeList[i]
				slice.tau_e_ii = tau_e_iiList[i]
				slice.tau_e_ei = tau_e_eiList[i]
				slice.tau_cur_diff = tau_cur_diffList[i]
				slice.tau_i_rol = tau_i_rolList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type confinementstructurescenario_confinementObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.tau_e.putTimedElt(path, cpopath + 'tau_e', i, obj)
		obj = self.tau_l_sc.putTimedElt(path, cpopath + 'tau_l_sc', i, obj)
		obj = self.tau_h_sc.putTimedElt(path, cpopath + 'tau_h_sc', i, obj)
		obj = self.tau_he.putTimedElt(path, cpopath + 'tau_he', i, obj)
		obj = self.tau_e_ee.putTimedElt(path, cpopath + 'tau_e_ee', i, obj)
		obj = self.tau_e_ii.putTimedElt(path, cpopath + 'tau_e_ii', i, obj)
		obj = self.tau_e_ei.putTimedElt(path, cpopath + 'tau_e_ei', i, obj)
		obj = self.tau_cur_diff.putTimedElt(path, cpopath + 'tau_cur_diff', i, obj)
		obj = self.tau_i_rol.putTimedElt(path, cpopath + 'tau_i_rol', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type confinementstructurescenario_confinementObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.tau_e.getTimedElt(path, cpopath + 'tau_e', i, obj)
		self.tau_l_sc.getTimedElt(path, cpopath + 'tau_l_sc', i, obj)
		self.tau_h_sc.getTimedElt(path, cpopath + 'tau_h_sc', i, obj)
		self.tau_he.getTimedElt(path, cpopath + 'tau_he', i, obj)
		self.tau_e_ee.getTimedElt(path, cpopath + 'tau_e_ee', i, obj)
		self.tau_e_ii.getTimedElt(path, cpopath + 'tau_e_ii', i, obj)
		self.tau_e_ei.getTimedElt(path, cpopath + 'tau_e_ei', i, obj)
		self.tau_cur_diff.getTimedElt(path, cpopath + 'tau_cur_diff', i, obj)
		self.tau_i_rol.getTimedElt(path, cpopath + 'tau_i_rol', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type confinementstructurescenario_confinementObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.tau_e.putNonTimedElt(path, cpopath + 'tau_e', i, obj)
		obj = self.tau_l_sc.putNonTimedElt(path, cpopath + 'tau_l_sc', i, obj)
		obj = self.tau_h_sc.putNonTimedElt(path, cpopath + 'tau_h_sc', i, obj)
		obj = self.tau_he.putNonTimedElt(path, cpopath + 'tau_he', i, obj)
		obj = self.tau_e_ee.putNonTimedElt(path, cpopath + 'tau_e_ee', i, obj)
		obj = self.tau_e_ii.putNonTimedElt(path, cpopath + 'tau_e_ii', i, obj)
		obj = self.tau_e_ei.putNonTimedElt(path, cpopath + 'tau_e_ei', i, obj)
		obj = self.tau_cur_diff.putNonTimedElt(path, cpopath + 'tau_cur_diff', i, obj)
		obj = self.tau_i_rol.putNonTimedElt(path, cpopath + 'tau_i_rol', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type confinementstructurescenario_confinementObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.tau_e.getNonTimedElt(path, cpopath + 'tau_e', i, obj)
		self.tau_l_sc.getNonTimedElt(path, cpopath + 'tau_l_sc', i, obj)
		self.tau_h_sc.getNonTimedElt(path, cpopath + 'tau_h_sc', i, obj)
		self.tau_he.getNonTimedElt(path, cpopath + 'tau_he', i, obj)
		self.tau_e_ee.getNonTimedElt(path, cpopath + 'tau_e_ee', i, obj)
		self.tau_e_ii.getNonTimedElt(path, cpopath + 'tau_e_ii', i, obj)
		self.tau_e_ei.getNonTimedElt(path, cpopath + 'tau_e_ei', i, obj)
		self.tau_cur_diff.getNonTimedElt(path, cpopath + 'tau_cur_diff', i, obj)
		self.tau_i_rol.getNonTimedElt(path, cpopath + 'tau_i_rol', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.tau_e.deleteData(path, cpopath)
		self.tau_l_sc.deleteData(path, cpopath)
		self.tau_h_sc.deleteData(path, cpopath)
		self.tau_he.deleteData(path, cpopath)
		self.tau_e_ee.deleteData(path, cpopath)
		self.tau_e_ii.deleteData(path, cpopath)
		self.tau_e_ei.deleteData(path, cpopath)
		self.tau_cur_diff.deleteData(path, cpopath)
		self.tau_i_rol.deleteData(path, cpopath)


class tau_estructurescenario_ref:
	'''
	class tau_estructurescenario_ref
	thermal energy confinement time [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_e'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_estructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_estructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_estructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_estructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_estructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_estructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_estructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_estructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_estructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_estructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_estructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_l_scstructurescenario_ref:
	'''
	class tau_l_scstructurescenario_ref
	confinement time given by the selected L-mode scaling law [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_l_sc'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_l_scstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_l_scstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_l_scstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_l_scstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_l_scstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_l_scstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_l_scstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_l_scstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_l_scstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_l_scstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_l_scstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_h_scstructurescenario_ref:
	'''
	class tau_h_scstructurescenario_ref
	confinement time given by the selected H-mode scaling law [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_h_sc'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_h_scstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_h_scstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_h_scstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_h_scstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_h_scstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_h_scstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_h_scstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_h_scstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_h_scstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_h_scstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_h_scstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_hestructurescenario_ref:
	'''
	class tau_hestructurescenario_ref
	Helium ashes confinement time [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_he'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_hestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_hestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_hestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_hestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_hestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_hestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_hestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_hestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_hestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_hestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_hestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_e_eestructurescenario_ref:
	'''
	class tau_e_eestructurescenario_ref
	electron energy confimenent time [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_e_ee'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_e_eestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_e_eestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_e_iistructurescenario_ref:
	'''
	class tau_e_iistructurescenario_ref
	ion energy confinement time [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_e_ii'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_e_iistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_iistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_iistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_iistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_iistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_iistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_e_iistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_iistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_iistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_iistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_iistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_e_eistructurescenario_ref:
	'''
	class tau_e_eistructurescenario_ref
	energy equipartition characteristic time [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_e_ei'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_e_eistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_e_eistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_e_eistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_e_eistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_cur_diffstructurescenario_ref:
	'''
	class tau_cur_diffstructurescenario_ref
	characteristic time for current diffusion  [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_cur_diff'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_cur_diffstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_cur_diffstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_cur_diffstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_cur_diffstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_cur_diffstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_cur_diffstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_cur_diffstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_cur_diffstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_cur_diffstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_cur_diffstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_cur_diffstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tau_i_rolstructurescenario_ref:
	'''
	class tau_i_rolstructurescenario_ref
	characteristic time for current decrease in tokamak equivalent R/L circuit [s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tau_i_rol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tau_i_rolstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_i_rolstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_i_rolstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tau_i_rolstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tau_i_rolstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tau_i_rolstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tau_i_rolstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_i_rolstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_i_rolstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_i_rolstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tau_i_rolstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class currentsstructurescenario_currents:
	'''
	class currentsstructurescenario_currents
	data related to current sources and current diffusion

	Attributes:
	- RR : class RRstructurescenario_ref
	   plasma resistivity [ohm]. Time-dependent.
	- i_align : class i_alignstructurescenario_ref
	   current drive alignment quality parameter (1 = good , 0 = bad). Time-dependent.
	- i_boot : class i_bootstructurescenario_ref
	   bootstrap current [A]. Time-dependent.
	- i_cd_tot : class i_cd_totstructurescenario_ref
	   total current drive [A]. Time-dependent.
	- i_eccd : class i_eccdstructurescenario_ref
	   Electron Cyclotron current drive [A]. Time-dependent.
	- i_fast_ion : class i_fast_ionstructurescenario_ref
	   fast ions bootstrap like current drive  (i.e. fast alpha) [A]. Time-dependent.
	- i_fwcd : class i_fwcdstructurescenario_ref
	   Fast Wave current drive [A]. Time-dependent.
	- i_lhcd : class i_lhcdstructurescenario_ref
	   Lower Hybrid current drive [A]. Time-dependent.
	- i_nbicd : class i_nbicdstructurescenario_ref
	   Neutral Beam Injection current drive  [A]. Time-dependent.
	- i_ni_tot : class i_ni_totstructurescenario_ref
	   total non inductive current  [A]. Time-dependent.
	- i_ohm : class i_ohmstructurescenario_ref
	   ohmic current  [A]. Time-dependent.
	- i_par : class i_parstructurescenario_ref
	   total plasma current (projected on B : <J.B>/B0)   [A]. Time-dependent.
	- i_runaway : class i_runawaystructurescenario_ref
	   runaway current  [A]. Time-dependent.
	- v_loop : class v_loopstructurescenario_ref
	   loop voltage @ LCMS / LFS , equatorial point  [V]. Time-dependent.
	- v_meas : class v_measstructurescenario_ref
	   loop voltage measured on a  coil   [V]. Time-dependent.
	'''

	def __init__(self, base_path_in='currents'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.RR = RRstructurescenario_ref('RR')
		self.i_align = i_alignstructurescenario_ref('i_align')
		self.i_boot = i_bootstructurescenario_ref('i_boot')
		self.i_cd_tot = i_cd_totstructurescenario_ref('i_cd_tot')
		self.i_eccd = i_eccdstructurescenario_ref('i_eccd')
		self.i_fast_ion = i_fast_ionstructurescenario_ref('i_fast_ion')
		self.i_fwcd = i_fwcdstructurescenario_ref('i_fwcd')
		self.i_lhcd = i_lhcdstructurescenario_ref('i_lhcd')
		self.i_nbicd = i_nbicdstructurescenario_ref('i_nbicd')
		self.i_ni_tot = i_ni_totstructurescenario_ref('i_ni_tot')
		self.i_ohm = i_ohmstructurescenario_ref('i_ohm')
		self.i_par = i_parstructurescenario_ref('i_par')
		self.i_runaway = i_runawaystructurescenario_ref('i_runaway')
		self.v_loop = v_loopstructurescenario_ref('v_loop')
		self.v_meas = v_measstructurescenario_ref('v_meas')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class currentsstructurescenario_currents\n'
		ret = ret + space + 'Attribute RR\n ' + self.RR.__str__(depth+1)
		ret = ret + space + 'Attribute i_align\n ' + self.i_align.__str__(depth+1)
		ret = ret + space + 'Attribute i_boot\n ' + self.i_boot.__str__(depth+1)
		ret = ret + space + 'Attribute i_cd_tot\n ' + self.i_cd_tot.__str__(depth+1)
		ret = ret + space + 'Attribute i_eccd\n ' + self.i_eccd.__str__(depth+1)
		ret = ret + space + 'Attribute i_fast_ion\n ' + self.i_fast_ion.__str__(depth+1)
		ret = ret + space + 'Attribute i_fwcd\n ' + self.i_fwcd.__str__(depth+1)
		ret = ret + space + 'Attribute i_lhcd\n ' + self.i_lhcd.__str__(depth+1)
		ret = ret + space + 'Attribute i_nbicd\n ' + self.i_nbicd.__str__(depth+1)
		ret = ret + space + 'Attribute i_ni_tot\n ' + self.i_ni_tot.__str__(depth+1)
		ret = ret + space + 'Attribute i_ohm\n ' + self.i_ohm.__str__(depth+1)
		ret = ret + space + 'Attribute i_par\n ' + self.i_par.__str__(depth+1)
		ret = ret + space + 'Attribute i_runaway\n ' + self.i_runaway.__str__(depth+1)
		ret = ret + space + 'Attribute v_loop\n ' + self.v_loop.__str__(depth+1)
		ret = ret + space + 'Attribute v_meas\n ' + self.v_meas.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.RR.setExpIdx(idx)
		self.i_align.setExpIdx(idx)
		self.i_boot.setExpIdx(idx)
		self.i_cd_tot.setExpIdx(idx)
		self.i_eccd.setExpIdx(idx)
		self.i_fast_ion.setExpIdx(idx)
		self.i_fwcd.setExpIdx(idx)
		self.i_lhcd.setExpIdx(idx)
		self.i_nbicd.setExpIdx(idx)
		self.i_ni_tot.setExpIdx(idx)
		self.i_ohm.setExpIdx(idx)
		self.i_par.setExpIdx(idx)
		self.i_runaway.setExpIdx(idx)
		self.v_loop.setExpIdx(idx)
		self.v_meas.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type currentsstructurescenario_currents, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.RR.cpoTime = self.cpoTime
		self.RR.putSlice(path, cpopath)
		self.i_align.cpoTime = self.cpoTime
		self.i_align.putSlice(path, cpopath)
		self.i_boot.cpoTime = self.cpoTime
		self.i_boot.putSlice(path, cpopath)
		self.i_cd_tot.cpoTime = self.cpoTime
		self.i_cd_tot.putSlice(path, cpopath)
		self.i_eccd.cpoTime = self.cpoTime
		self.i_eccd.putSlice(path, cpopath)
		self.i_fast_ion.cpoTime = self.cpoTime
		self.i_fast_ion.putSlice(path, cpopath)
		self.i_fwcd.cpoTime = self.cpoTime
		self.i_fwcd.putSlice(path, cpopath)
		self.i_lhcd.cpoTime = self.cpoTime
		self.i_lhcd.putSlice(path, cpopath)
		self.i_nbicd.cpoTime = self.cpoTime
		self.i_nbicd.putSlice(path, cpopath)
		self.i_ni_tot.cpoTime = self.cpoTime
		self.i_ni_tot.putSlice(path, cpopath)
		self.i_ohm.cpoTime = self.cpoTime
		self.i_ohm.putSlice(path, cpopath)
		self.i_par.cpoTime = self.cpoTime
		self.i_par.putSlice(path, cpopath)
		self.i_runaway.cpoTime = self.cpoTime
		self.i_runaway.putSlice(path, cpopath)
		self.v_loop.cpoTime = self.cpoTime
		self.v_loop.putSlice(path, cpopath)
		self.v_meas.cpoTime = self.cpoTime
		self.v_meas.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type currentsstructurescenario_currents, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.RR.replaceLastSlice(path, cpopath)
		self.i_align.replaceLastSlice(path, cpopath)
		self.i_boot.replaceLastSlice(path, cpopath)
		self.i_cd_tot.replaceLastSlice(path, cpopath)
		self.i_eccd.replaceLastSlice(path, cpopath)
		self.i_fast_ion.replaceLastSlice(path, cpopath)
		self.i_fwcd.replaceLastSlice(path, cpopath)
		self.i_lhcd.replaceLastSlice(path, cpopath)
		self.i_nbicd.replaceLastSlice(path, cpopath)
		self.i_ni_tot.replaceLastSlice(path, cpopath)
		self.i_ohm.replaceLastSlice(path, cpopath)
		self.i_par.replaceLastSlice(path, cpopath)
		self.i_runaway.replaceLastSlice(path, cpopath)
		self.v_loop.replaceLastSlice(path, cpopath)
		self.v_meas.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type currentsstructurescenario_currents, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.RR.putNonTimed(path, cpopath)
		self.i_align.putNonTimed(path, cpopath)
		self.i_boot.putNonTimed(path, cpopath)
		self.i_cd_tot.putNonTimed(path, cpopath)
		self.i_eccd.putNonTimed(path, cpopath)
		self.i_fast_ion.putNonTimed(path, cpopath)
		self.i_fwcd.putNonTimed(path, cpopath)
		self.i_lhcd.putNonTimed(path, cpopath)
		self.i_nbicd.putNonTimed(path, cpopath)
		self.i_ni_tot.putNonTimed(path, cpopath)
		self.i_ohm.putNonTimed(path, cpopath)
		self.i_par.putNonTimed(path, cpopath)
		self.i_runaway.putNonTimed(path, cpopath)
		self.v_loop.putNonTimed(path, cpopath)
		self.v_meas.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type currentsstructurescenario_currents, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.RR.getSlice(path, cpopath, inTime, interpolMode)
		self.i_align.getSlice(path, cpopath, inTime, interpolMode)
		self.i_boot.getSlice(path, cpopath, inTime, interpolMode)
		self.i_cd_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.i_eccd.getSlice(path, cpopath, inTime, interpolMode)
		self.i_fast_ion.getSlice(path, cpopath, inTime, interpolMode)
		self.i_fwcd.getSlice(path, cpopath, inTime, interpolMode)
		self.i_lhcd.getSlice(path, cpopath, inTime, interpolMode)
		self.i_nbicd.getSlice(path, cpopath, inTime, interpolMode)
		self.i_ni_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.i_ohm.getSlice(path, cpopath, inTime, interpolMode)
		self.i_par.getSlice(path, cpopath, inTime, interpolMode)
		self.i_runaway.getSlice(path, cpopath, inTime, interpolMode)
		self.v_loop.getSlice(path, cpopath, inTime, interpolMode)
		self.v_meas.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type currentsstructurescenario_currents, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			RRList = self.RR.build_non_resampled_data(path, cpopath, nbslice)
			i_alignList = self.i_align.build_non_resampled_data(path, cpopath, nbslice)
			i_bootList = self.i_boot.build_non_resampled_data(path, cpopath, nbslice)
			i_cd_totList = self.i_cd_tot.build_non_resampled_data(path, cpopath, nbslice)
			i_eccdList = self.i_eccd.build_non_resampled_data(path, cpopath, nbslice)
			i_fast_ionList = self.i_fast_ion.build_non_resampled_data(path, cpopath, nbslice)
			i_fwcdList = self.i_fwcd.build_non_resampled_data(path, cpopath, nbslice)
			i_lhcdList = self.i_lhcd.build_non_resampled_data(path, cpopath, nbslice)
			i_nbicdList = self.i_nbicd.build_non_resampled_data(path, cpopath, nbslice)
			i_ni_totList = self.i_ni_tot.build_non_resampled_data(path, cpopath, nbslice)
			i_ohmList = self.i_ohm.build_non_resampled_data(path, cpopath, nbslice)
			i_parList = self.i_par.build_non_resampled_data(path, cpopath, nbslice)
			i_runawayList = self.i_runaway.build_non_resampled_data(path, cpopath, nbslice)
			v_loopList = self.v_loop.build_non_resampled_data(path, cpopath, nbslice)
			v_measList = self.v_meas.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = currentsstructurescenario_currents(self.base_path)
				slice.setExpIdx(self.idx)
				slice.RR = RRList[i]
				slice.i_align = i_alignList[i]
				slice.i_boot = i_bootList[i]
				slice.i_cd_tot = i_cd_totList[i]
				slice.i_eccd = i_eccdList[i]
				slice.i_fast_ion = i_fast_ionList[i]
				slice.i_fwcd = i_fwcdList[i]
				slice.i_lhcd = i_lhcdList[i]
				slice.i_nbicd = i_nbicdList[i]
				slice.i_ni_tot = i_ni_totList[i]
				slice.i_ohm = i_ohmList[i]
				slice.i_par = i_parList[i]
				slice.i_runaway = i_runawayList[i]
				slice.v_loop = v_loopList[i]
				slice.v_meas = v_measList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type currentsstructurescenario_currentsObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.RR.putTimedElt(path, cpopath + 'RR', i, obj)
		obj = self.i_align.putTimedElt(path, cpopath + 'i_align', i, obj)
		obj = self.i_boot.putTimedElt(path, cpopath + 'i_boot', i, obj)
		obj = self.i_cd_tot.putTimedElt(path, cpopath + 'i_cd_tot', i, obj)
		obj = self.i_eccd.putTimedElt(path, cpopath + 'i_eccd', i, obj)
		obj = self.i_fast_ion.putTimedElt(path, cpopath + 'i_fast_ion', i, obj)
		obj = self.i_fwcd.putTimedElt(path, cpopath + 'i_fwcd', i, obj)
		obj = self.i_lhcd.putTimedElt(path, cpopath + 'i_lhcd', i, obj)
		obj = self.i_nbicd.putTimedElt(path, cpopath + 'i_nbicd', i, obj)
		obj = self.i_ni_tot.putTimedElt(path, cpopath + 'i_ni_tot', i, obj)
		obj = self.i_ohm.putTimedElt(path, cpopath + 'i_ohm', i, obj)
		obj = self.i_par.putTimedElt(path, cpopath + 'i_par', i, obj)
		obj = self.i_runaway.putTimedElt(path, cpopath + 'i_runaway', i, obj)
		obj = self.v_loop.putTimedElt(path, cpopath + 'v_loop', i, obj)
		obj = self.v_meas.putTimedElt(path, cpopath + 'v_meas', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type currentsstructurescenario_currentsObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.RR.getTimedElt(path, cpopath + 'RR', i, obj)
		self.i_align.getTimedElt(path, cpopath + 'i_align', i, obj)
		self.i_boot.getTimedElt(path, cpopath + 'i_boot', i, obj)
		self.i_cd_tot.getTimedElt(path, cpopath + 'i_cd_tot', i, obj)
		self.i_eccd.getTimedElt(path, cpopath + 'i_eccd', i, obj)
		self.i_fast_ion.getTimedElt(path, cpopath + 'i_fast_ion', i, obj)
		self.i_fwcd.getTimedElt(path, cpopath + 'i_fwcd', i, obj)
		self.i_lhcd.getTimedElt(path, cpopath + 'i_lhcd', i, obj)
		self.i_nbicd.getTimedElt(path, cpopath + 'i_nbicd', i, obj)
		self.i_ni_tot.getTimedElt(path, cpopath + 'i_ni_tot', i, obj)
		self.i_ohm.getTimedElt(path, cpopath + 'i_ohm', i, obj)
		self.i_par.getTimedElt(path, cpopath + 'i_par', i, obj)
		self.i_runaway.getTimedElt(path, cpopath + 'i_runaway', i, obj)
		self.v_loop.getTimedElt(path, cpopath + 'v_loop', i, obj)
		self.v_meas.getTimedElt(path, cpopath + 'v_meas', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type currentsstructurescenario_currentsObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.RR.putNonTimedElt(path, cpopath + 'RR', i, obj)
		obj = self.i_align.putNonTimedElt(path, cpopath + 'i_align', i, obj)
		obj = self.i_boot.putNonTimedElt(path, cpopath + 'i_boot', i, obj)
		obj = self.i_cd_tot.putNonTimedElt(path, cpopath + 'i_cd_tot', i, obj)
		obj = self.i_eccd.putNonTimedElt(path, cpopath + 'i_eccd', i, obj)
		obj = self.i_fast_ion.putNonTimedElt(path, cpopath + 'i_fast_ion', i, obj)
		obj = self.i_fwcd.putNonTimedElt(path, cpopath + 'i_fwcd', i, obj)
		obj = self.i_lhcd.putNonTimedElt(path, cpopath + 'i_lhcd', i, obj)
		obj = self.i_nbicd.putNonTimedElt(path, cpopath + 'i_nbicd', i, obj)
		obj = self.i_ni_tot.putNonTimedElt(path, cpopath + 'i_ni_tot', i, obj)
		obj = self.i_ohm.putNonTimedElt(path, cpopath + 'i_ohm', i, obj)
		obj = self.i_par.putNonTimedElt(path, cpopath + 'i_par', i, obj)
		obj = self.i_runaway.putNonTimedElt(path, cpopath + 'i_runaway', i, obj)
		obj = self.v_loop.putNonTimedElt(path, cpopath + 'v_loop', i, obj)
		obj = self.v_meas.putNonTimedElt(path, cpopath + 'v_meas', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type currentsstructurescenario_currentsObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.RR.getNonTimedElt(path, cpopath + 'RR', i, obj)
		self.i_align.getNonTimedElt(path, cpopath + 'i_align', i, obj)
		self.i_boot.getNonTimedElt(path, cpopath + 'i_boot', i, obj)
		self.i_cd_tot.getNonTimedElt(path, cpopath + 'i_cd_tot', i, obj)
		self.i_eccd.getNonTimedElt(path, cpopath + 'i_eccd', i, obj)
		self.i_fast_ion.getNonTimedElt(path, cpopath + 'i_fast_ion', i, obj)
		self.i_fwcd.getNonTimedElt(path, cpopath + 'i_fwcd', i, obj)
		self.i_lhcd.getNonTimedElt(path, cpopath + 'i_lhcd', i, obj)
		self.i_nbicd.getNonTimedElt(path, cpopath + 'i_nbicd', i, obj)
		self.i_ni_tot.getNonTimedElt(path, cpopath + 'i_ni_tot', i, obj)
		self.i_ohm.getNonTimedElt(path, cpopath + 'i_ohm', i, obj)
		self.i_par.getNonTimedElt(path, cpopath + 'i_par', i, obj)
		self.i_runaway.getNonTimedElt(path, cpopath + 'i_runaway', i, obj)
		self.v_loop.getNonTimedElt(path, cpopath + 'v_loop', i, obj)
		self.v_meas.getNonTimedElt(path, cpopath + 'v_meas', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.RR.deleteData(path, cpopath)
		self.i_align.deleteData(path, cpopath)
		self.i_boot.deleteData(path, cpopath)
		self.i_cd_tot.deleteData(path, cpopath)
		self.i_eccd.deleteData(path, cpopath)
		self.i_fast_ion.deleteData(path, cpopath)
		self.i_fwcd.deleteData(path, cpopath)
		self.i_lhcd.deleteData(path, cpopath)
		self.i_nbicd.deleteData(path, cpopath)
		self.i_ni_tot.deleteData(path, cpopath)
		self.i_ohm.deleteData(path, cpopath)
		self.i_par.deleteData(path, cpopath)
		self.i_runaway.deleteData(path, cpopath)
		self.v_loop.deleteData(path, cpopath)
		self.v_meas.deleteData(path, cpopath)


class RRstructurescenario_ref:
	'''
	class RRstructurescenario_ref
	plasma resistivity [ohm]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='RR'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class RRstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type RRstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type RRstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type RRstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type RRstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type RRstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = RRstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type RRstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type RRstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type RRstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type RRstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_alignstructurescenario_ref:
	'''
	class i_alignstructurescenario_ref
	current drive alignment quality parameter (1 = good , 0 = bad). Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_align'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_alignstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_alignstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_alignstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_alignstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_alignstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_alignstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_alignstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_alignstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_alignstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_alignstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_alignstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_bootstructurescenario_ref:
	'''
	class i_bootstructurescenario_ref
	bootstrap current [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_boot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_bootstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_bootstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_bootstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_bootstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_bootstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_bootstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_bootstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_bootstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_bootstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_bootstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_bootstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_cd_totstructurescenario_ref:
	'''
	class i_cd_totstructurescenario_ref
	total current drive [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_cd_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_cd_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_cd_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_cd_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_cd_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_cd_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_cd_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_cd_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_cd_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_cd_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_cd_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_cd_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_eccdstructurescenario_ref:
	'''
	class i_eccdstructurescenario_ref
	Electron Cyclotron current drive [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_eccd'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_eccdstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_eccdstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_eccdstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_eccdstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_eccdstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_eccdstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_eccdstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_eccdstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_eccdstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_eccdstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_eccdstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_fast_ionstructurescenario_ref:
	'''
	class i_fast_ionstructurescenario_ref
	fast ions bootstrap like current drive  (i.e. fast alpha) [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_fast_ion'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_fast_ionstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_fast_ionstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_fast_ionstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_fast_ionstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_fast_ionstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_fast_ionstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_fast_ionstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fast_ionstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fast_ionstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fast_ionstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fast_ionstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_fwcdstructurescenario_ref:
	'''
	class i_fwcdstructurescenario_ref
	Fast Wave current drive [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_fwcd'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_fwcdstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_fwcdstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_fwcdstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_fwcdstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_fwcdstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_fwcdstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_fwcdstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fwcdstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fwcdstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fwcdstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_fwcdstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_lhcdstructurescenario_ref:
	'''
	class i_lhcdstructurescenario_ref
	Lower Hybrid current drive [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_lhcd'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_lhcdstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_lhcdstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_lhcdstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_lhcdstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_lhcdstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_lhcdstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_lhcdstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_lhcdstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_lhcdstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_lhcdstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_lhcdstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_nbicdstructurescenario_ref:
	'''
	class i_nbicdstructurescenario_ref
	Neutral Beam Injection current drive  [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_nbicd'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_nbicdstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_nbicdstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_nbicdstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_nbicdstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_nbicdstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_nbicdstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_nbicdstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_nbicdstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_nbicdstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_nbicdstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_nbicdstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_ni_totstructurescenario_ref:
	'''
	class i_ni_totstructurescenario_ref
	total non inductive current  [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_ni_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_ni_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_ni_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_ni_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_ni_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_ni_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_ni_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_ni_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ni_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ni_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ni_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ni_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_ohmstructurescenario_ref:
	'''
	class i_ohmstructurescenario_ref
	ohmic current  [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_ohm'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_ohmstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_ohmstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_ohmstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_ohmstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_ohmstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_ohmstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_ohmstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ohmstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ohmstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ohmstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_ohmstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_parstructurescenario_ref:
	'''
	class i_parstructurescenario_ref
	total plasma current (projected on B : <J.B>/B0)   [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_par'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_parstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_parstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_parstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_parstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_parstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_parstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_parstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_parstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_parstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_parstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_parstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class i_runawaystructurescenario_ref:
	'''
	class i_runawaystructurescenario_ref
	runaway current  [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='i_runaway'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class i_runawaystructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_runawaystructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_runawaystructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type i_runawaystructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type i_runawaystructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type i_runawaystructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = i_runawaystructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_runawaystructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_runawaystructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_runawaystructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type i_runawaystructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class v_loopstructurescenario_ref:
	'''
	class v_loopstructurescenario_ref
	loop voltage @ LCMS / LFS , equatorial point  [V]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='v_loop'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class v_loopstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type v_loopstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type v_loopstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type v_loopstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type v_loopstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type v_loopstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = v_loopstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_loopstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_loopstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_loopstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_loopstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class v_measstructurescenario_ref:
	'''
	class v_measstructurescenario_ref
	loop voltage measured on a  coil   [V]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='v_meas'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class v_measstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type v_measstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type v_measstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type v_measstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type v_measstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type v_measstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = v_measstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_measstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_measstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_measstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type v_measstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class edgestructurescenario_edge:
	'''
	class edgestructurescenario_edge
	edge value (@ LCMS)

	Attributes:
	- te_edge : class te_edgestructurescenario_ref
	   edge electron temperature [eV]. Time-dependent.
	- ti_edge : class ti_edgestructurescenario_ref
	   edge ion temperature [eV]. Time-dependent.
	- ne_edge : class ne_edgestructurescenario_ref
	   edge electron density [m^-3]. Time-dependent.
	- ni_edge : class ni_edgestructurescenario_ref
	   edge ion density [m^-3]. Time-dependent.
	- psi_edge : class psi_edgestructurescenario_ref
	   edge  poloidal flux [Wb]. Time-dependent.
	- phi_edge : class phi_edgestructurescenario_ref
	   edge  toroidal flux [Wb]. Time-dependent.
	- rho_edge : class rho_edgestructurescenario_ref
	   edge value of internal simulator coordinate [m]. Time-dependent.
	- drho_edge_dt : class drho_edge_dtstructurescenario_ref
	   time derivative of edge value of internal simulator coordinate [m/s]. Time-dependent.
	- q_edge : class q_edgestructurescenario_ref
	   edge or effective  safety factor value []. Time-dependent.
	- neutral_flux : class neutral_fluxstructurescenario_ref
	   number of cold neutral (in equivalent electron for Z >1) that input in  plasma at the edge every second coming from recycling and gaz puff [s^-1]. Time-dependent.
	- phi_plasma : class phi_plasmastructurescenario_ref
	   contribution of the plasma to the toroidal flux (used for toroidal coils heat load computation) [Wb]. Time-dependent.
	- vtor_edge : class vtor_edgestructurescenario_ref
	   rotation velocity of selected impurity on the separatrix [m/s]. Time-dependent.
	'''

	def __init__(self, base_path_in='edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.te_edge = te_edgestructurescenario_ref('te_edge')
		self.ti_edge = ti_edgestructurescenario_ref('ti_edge')
		self.ne_edge = ne_edgestructurescenario_ref('ne_edge')
		self.ni_edge = ni_edgestructurescenario_ref('ni_edge')
		self.psi_edge = psi_edgestructurescenario_ref('psi_edge')
		self.phi_edge = phi_edgestructurescenario_ref('phi_edge')
		self.rho_edge = rho_edgestructurescenario_ref('rho_edge')
		self.drho_edge_dt = drho_edge_dtstructurescenario_ref('drho_edge_dt')
		self.q_edge = q_edgestructurescenario_ref('q_edge')
		self.neutral_flux = neutral_fluxstructurescenario_ref('neutral_flux')
		self.phi_plasma = phi_plasmastructurescenario_ref('phi_plasma')
		self.vtor_edge = vtor_edgestructurescenario_ref('vtor_edge')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class edgestructurescenario_edge\n'
		ret = ret + space + 'Attribute te_edge\n ' + self.te_edge.__str__(depth+1)
		ret = ret + space + 'Attribute ti_edge\n ' + self.ti_edge.__str__(depth+1)
		ret = ret + space + 'Attribute ne_edge\n ' + self.ne_edge.__str__(depth+1)
		ret = ret + space + 'Attribute ni_edge\n ' + self.ni_edge.__str__(depth+1)
		ret = ret + space + 'Attribute psi_edge\n ' + self.psi_edge.__str__(depth+1)
		ret = ret + space + 'Attribute phi_edge\n ' + self.phi_edge.__str__(depth+1)
		ret = ret + space + 'Attribute rho_edge\n ' + self.rho_edge.__str__(depth+1)
		ret = ret + space + 'Attribute drho_edge_dt\n ' + self.drho_edge_dt.__str__(depth+1)
		ret = ret + space + 'Attribute q_edge\n ' + self.q_edge.__str__(depth+1)
		ret = ret + space + 'Attribute neutral_flux\n ' + self.neutral_flux.__str__(depth+1)
		ret = ret + space + 'Attribute phi_plasma\n ' + self.phi_plasma.__str__(depth+1)
		ret = ret + space + 'Attribute vtor_edge\n ' + self.vtor_edge.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.te_edge.setExpIdx(idx)
		self.ti_edge.setExpIdx(idx)
		self.ne_edge.setExpIdx(idx)
		self.ni_edge.setExpIdx(idx)
		self.psi_edge.setExpIdx(idx)
		self.phi_edge.setExpIdx(idx)
		self.rho_edge.setExpIdx(idx)
		self.drho_edge_dt.setExpIdx(idx)
		self.q_edge.setExpIdx(idx)
		self.neutral_flux.setExpIdx(idx)
		self.phi_plasma.setExpIdx(idx)
		self.vtor_edge.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type edgestructurescenario_edge, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_edge.cpoTime = self.cpoTime
		self.te_edge.putSlice(path, cpopath)
		self.ti_edge.cpoTime = self.cpoTime
		self.ti_edge.putSlice(path, cpopath)
		self.ne_edge.cpoTime = self.cpoTime
		self.ne_edge.putSlice(path, cpopath)
		self.ni_edge.cpoTime = self.cpoTime
		self.ni_edge.putSlice(path, cpopath)
		self.psi_edge.cpoTime = self.cpoTime
		self.psi_edge.putSlice(path, cpopath)
		self.phi_edge.cpoTime = self.cpoTime
		self.phi_edge.putSlice(path, cpopath)
		self.rho_edge.cpoTime = self.cpoTime
		self.rho_edge.putSlice(path, cpopath)
		self.drho_edge_dt.cpoTime = self.cpoTime
		self.drho_edge_dt.putSlice(path, cpopath)
		self.q_edge.cpoTime = self.cpoTime
		self.q_edge.putSlice(path, cpopath)
		self.neutral_flux.cpoTime = self.cpoTime
		self.neutral_flux.putSlice(path, cpopath)
		self.phi_plasma.cpoTime = self.cpoTime
		self.phi_plasma.putSlice(path, cpopath)
		self.vtor_edge.cpoTime = self.cpoTime
		self.vtor_edge.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type edgestructurescenario_edge, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_edge.replaceLastSlice(path, cpopath)
		self.ti_edge.replaceLastSlice(path, cpopath)
		self.ne_edge.replaceLastSlice(path, cpopath)
		self.ni_edge.replaceLastSlice(path, cpopath)
		self.psi_edge.replaceLastSlice(path, cpopath)
		self.phi_edge.replaceLastSlice(path, cpopath)
		self.rho_edge.replaceLastSlice(path, cpopath)
		self.drho_edge_dt.replaceLastSlice(path, cpopath)
		self.q_edge.replaceLastSlice(path, cpopath)
		self.neutral_flux.replaceLastSlice(path, cpopath)
		self.phi_plasma.replaceLastSlice(path, cpopath)
		self.vtor_edge.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type edgestructurescenario_edge, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_edge.putNonTimed(path, cpopath)
		self.ti_edge.putNonTimed(path, cpopath)
		self.ne_edge.putNonTimed(path, cpopath)
		self.ni_edge.putNonTimed(path, cpopath)
		self.psi_edge.putNonTimed(path, cpopath)
		self.phi_edge.putNonTimed(path, cpopath)
		self.rho_edge.putNonTimed(path, cpopath)
		self.drho_edge_dt.putNonTimed(path, cpopath)
		self.q_edge.putNonTimed(path, cpopath)
		self.neutral_flux.putNonTimed(path, cpopath)
		self.phi_plasma.putNonTimed(path, cpopath)
		self.vtor_edge.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type edgestructurescenario_edge, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.ni_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.psi_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.phi_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.rho_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.drho_edge_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.q_edge.getSlice(path, cpopath, inTime, interpolMode)
		self.neutral_flux.getSlice(path, cpopath, inTime, interpolMode)
		self.phi_plasma.getSlice(path, cpopath, inTime, interpolMode)
		self.vtor_edge.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type edgestructurescenario_edge, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			te_edgeList = self.te_edge.build_non_resampled_data(path, cpopath, nbslice)
			ti_edgeList = self.ti_edge.build_non_resampled_data(path, cpopath, nbslice)
			ne_edgeList = self.ne_edge.build_non_resampled_data(path, cpopath, nbslice)
			ni_edgeList = self.ni_edge.build_non_resampled_data(path, cpopath, nbslice)
			psi_edgeList = self.psi_edge.build_non_resampled_data(path, cpopath, nbslice)
			phi_edgeList = self.phi_edge.build_non_resampled_data(path, cpopath, nbslice)
			rho_edgeList = self.rho_edge.build_non_resampled_data(path, cpopath, nbslice)
			drho_edge_dtList = self.drho_edge_dt.build_non_resampled_data(path, cpopath, nbslice)
			q_edgeList = self.q_edge.build_non_resampled_data(path, cpopath, nbslice)
			neutral_fluxList = self.neutral_flux.build_non_resampled_data(path, cpopath, nbslice)
			phi_plasmaList = self.phi_plasma.build_non_resampled_data(path, cpopath, nbslice)
			vtor_edgeList = self.vtor_edge.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = edgestructurescenario_edge(self.base_path)
				slice.setExpIdx(self.idx)
				slice.te_edge = te_edgeList[i]
				slice.ti_edge = ti_edgeList[i]
				slice.ne_edge = ne_edgeList[i]
				slice.ni_edge = ni_edgeList[i]
				slice.psi_edge = psi_edgeList[i]
				slice.phi_edge = phi_edgeList[i]
				slice.rho_edge = rho_edgeList[i]
				slice.drho_edge_dt = drho_edge_dtList[i]
				slice.q_edge = q_edgeList[i]
				slice.neutral_flux = neutral_fluxList[i]
				slice.phi_plasma = phi_plasmaList[i]
				slice.vtor_edge = vtor_edgeList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type edgestructurescenario_edgeObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_edge.putTimedElt(path, cpopath + 'te_edge', i, obj)
		obj = self.ti_edge.putTimedElt(path, cpopath + 'ti_edge', i, obj)
		obj = self.ne_edge.putTimedElt(path, cpopath + 'ne_edge', i, obj)
		obj = self.ni_edge.putTimedElt(path, cpopath + 'ni_edge', i, obj)
		obj = self.psi_edge.putTimedElt(path, cpopath + 'psi_edge', i, obj)
		obj = self.phi_edge.putTimedElt(path, cpopath + 'phi_edge', i, obj)
		obj = self.rho_edge.putTimedElt(path, cpopath + 'rho_edge', i, obj)
		obj = self.drho_edge_dt.putTimedElt(path, cpopath + 'drho_edge_dt', i, obj)
		obj = self.q_edge.putTimedElt(path, cpopath + 'q_edge', i, obj)
		obj = self.neutral_flux.putTimedElt(path, cpopath + 'neutral_flux', i, obj)
		obj = self.phi_plasma.putTimedElt(path, cpopath + 'phi_plasma', i, obj)
		obj = self.vtor_edge.putTimedElt(path, cpopath + 'vtor_edge', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type edgestructurescenario_edgeObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.te_edge.getTimedElt(path, cpopath + 'te_edge', i, obj)
		self.ti_edge.getTimedElt(path, cpopath + 'ti_edge', i, obj)
		self.ne_edge.getTimedElt(path, cpopath + 'ne_edge', i, obj)
		self.ni_edge.getTimedElt(path, cpopath + 'ni_edge', i, obj)
		self.psi_edge.getTimedElt(path, cpopath + 'psi_edge', i, obj)
		self.phi_edge.getTimedElt(path, cpopath + 'phi_edge', i, obj)
		self.rho_edge.getTimedElt(path, cpopath + 'rho_edge', i, obj)
		self.drho_edge_dt.getTimedElt(path, cpopath + 'drho_edge_dt', i, obj)
		self.q_edge.getTimedElt(path, cpopath + 'q_edge', i, obj)
		self.neutral_flux.getTimedElt(path, cpopath + 'neutral_flux', i, obj)
		self.phi_plasma.getTimedElt(path, cpopath + 'phi_plasma', i, obj)
		self.vtor_edge.getTimedElt(path, cpopath + 'vtor_edge', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type edgestructurescenario_edgeObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_edge.putNonTimedElt(path, cpopath + 'te_edge', i, obj)
		obj = self.ti_edge.putNonTimedElt(path, cpopath + 'ti_edge', i, obj)
		obj = self.ne_edge.putNonTimedElt(path, cpopath + 'ne_edge', i, obj)
		obj = self.ni_edge.putNonTimedElt(path, cpopath + 'ni_edge', i, obj)
		obj = self.psi_edge.putNonTimedElt(path, cpopath + 'psi_edge', i, obj)
		obj = self.phi_edge.putNonTimedElt(path, cpopath + 'phi_edge', i, obj)
		obj = self.rho_edge.putNonTimedElt(path, cpopath + 'rho_edge', i, obj)
		obj = self.drho_edge_dt.putNonTimedElt(path, cpopath + 'drho_edge_dt', i, obj)
		obj = self.q_edge.putNonTimedElt(path, cpopath + 'q_edge', i, obj)
		obj = self.neutral_flux.putNonTimedElt(path, cpopath + 'neutral_flux', i, obj)
		obj = self.phi_plasma.putNonTimedElt(path, cpopath + 'phi_plasma', i, obj)
		obj = self.vtor_edge.putNonTimedElt(path, cpopath + 'vtor_edge', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type edgestructurescenario_edgeObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.te_edge.getNonTimedElt(path, cpopath + 'te_edge', i, obj)
		self.ti_edge.getNonTimedElt(path, cpopath + 'ti_edge', i, obj)
		self.ne_edge.getNonTimedElt(path, cpopath + 'ne_edge', i, obj)
		self.ni_edge.getNonTimedElt(path, cpopath + 'ni_edge', i, obj)
		self.psi_edge.getNonTimedElt(path, cpopath + 'psi_edge', i, obj)
		self.phi_edge.getNonTimedElt(path, cpopath + 'phi_edge', i, obj)
		self.rho_edge.getNonTimedElt(path, cpopath + 'rho_edge', i, obj)
		self.drho_edge_dt.getNonTimedElt(path, cpopath + 'drho_edge_dt', i, obj)
		self.q_edge.getNonTimedElt(path, cpopath + 'q_edge', i, obj)
		self.neutral_flux.getNonTimedElt(path, cpopath + 'neutral_flux', i, obj)
		self.phi_plasma.getNonTimedElt(path, cpopath + 'phi_plasma', i, obj)
		self.vtor_edge.getNonTimedElt(path, cpopath + 'vtor_edge', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_edge.deleteData(path, cpopath)
		self.ti_edge.deleteData(path, cpopath)
		self.ne_edge.deleteData(path, cpopath)
		self.ni_edge.deleteData(path, cpopath)
		self.psi_edge.deleteData(path, cpopath)
		self.phi_edge.deleteData(path, cpopath)
		self.rho_edge.deleteData(path, cpopath)
		self.drho_edge_dt.deleteData(path, cpopath)
		self.q_edge.deleteData(path, cpopath)
		self.neutral_flux.deleteData(path, cpopath)
		self.phi_plasma.deleteData(path, cpopath)
		self.vtor_edge.deleteData(path, cpopath)


class te_edgestructurescenario_ref:
	'''
	class te_edgestructurescenario_ref
	edge electron temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_edgestructurescenario_ref:
	'''
	class ti_edgestructurescenario_ref
	edge ion temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_edgestructurescenario_ref:
	'''
	class ne_edgestructurescenario_ref
	edge electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni_edgestructurescenario_ref:
	'''
	class ni_edgestructurescenario_ref
	edge ion density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class psi_edgestructurescenario_ref:
	'''
	class psi_edgestructurescenario_ref
	edge  poloidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='psi_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class psi_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type psi_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type psi_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = psi_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class phi_edgestructurescenario_ref:
	'''
	class phi_edgestructurescenario_ref
	edge  toroidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='phi_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class phi_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type phi_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type phi_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = phi_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class rho_edgestructurescenario_ref:
	'''
	class rho_edgestructurescenario_ref
	edge value of internal simulator coordinate [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='rho_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class rho_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type rho_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type rho_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = rho_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class drho_edge_dtstructurescenario_ref:
	'''
	class drho_edge_dtstructurescenario_ref
	time derivative of edge value of internal simulator coordinate [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='drho_edge_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class drho_edge_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type drho_edge_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type drho_edge_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type drho_edge_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type drho_edge_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type drho_edge_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = drho_edge_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type drho_edge_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type drho_edge_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type drho_edge_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type drho_edge_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class q_edgestructurescenario_ref:
	'''
	class q_edgestructurescenario_ref
	edge or effective  safety factor value []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class neutral_fluxstructurescenario_ref:
	'''
	class neutral_fluxstructurescenario_ref
	number of cold neutral (in equivalent electron for Z >1) that input in  plasma at the edge every second coming from recycling and gaz puff [s^-1]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='neutral_flux'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class neutral_fluxstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type neutral_fluxstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type neutral_fluxstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type neutral_fluxstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type neutral_fluxstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type neutral_fluxstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = neutral_fluxstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutral_fluxstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutral_fluxstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutral_fluxstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutral_fluxstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class phi_plasmastructurescenario_ref:
	'''
	class phi_plasmastructurescenario_ref
	contribution of the plasma to the toroidal flux (used for toroidal coils heat load computation) [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='phi_plasma'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class phi_plasmastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_plasmastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_plasmastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_plasmastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type phi_plasmastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type phi_plasmastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = phi_plasmastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_plasmastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_plasmastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_plasmastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_plasmastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class vtor_edgestructurescenario_ref:
	'''
	class vtor_edgestructurescenario_ref
	rotation velocity of selected impurity on the separatrix [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='vtor_edge'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class vtor_edgestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_edgestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_edgestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_edgestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_edgestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_edgestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = vtor_edgestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_edgestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_edgestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_edgestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_edgestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class energystructurescenario_energy:
	'''
	class energystructurescenario_energy
	plasma energy content

	Attributes:
	- w_tot : class w_totstructurescenario_ref
	   total plasma energy [J]. Time-dependent.
	- w_b_pol : class w_b_polstructurescenario_ref
	   poloidal field energy of  the plasma [J]. Time-dependent.
	- w_dia : class w_diastructurescenario_ref
	   3/2 perpendicular plasma energy [J]. Time-dependent.
	- dwdia_dt : class dwdia_dtstructurescenario_ref
	   time derivative of Wdia [W]. Time-dependent.
	- w_b_tor_pla : class w_b_tor_plastructurescenario_ref
	   toroidal magnetic plasma energy  [J]. Time-dependent.
	- w_th : class w_thstructurescenario_ref
	   thermal plasma energy [J]. Time-dependent.
	- dwtot_dt : class dwtot_dtstructurescenario_ref
	   time derivative of total plasma energy [W]. Time-dependent.
	- dwbpol_dt : class dwbpol_dtstructurescenario_ref
	   time derivative of plasma poloidal field energy [W]. Time-dependent.
	- dwbtorpla_dt : class dwbtorpla_dtstructurescenario_ref
	   time derivative of toroidal magnetic plasma energy  [W]. Time-dependent.
	- dwth_dt : class dwth_dtstructurescenario_ref
	   time derivative of thermal plasma energy [W]. Time-dependent.
	- esup_icrhtot : class esup_icrhtotstructurescenario_ref
	   total suprathermal energy of fast ions accelerated  by ICRH [J]. Time-dependent.
	- esup_icrhper : class esup_icrhperstructurescenario_ref
	   perpendicular part of suprathermal energy of fast ions accelerated  by ICRH [J]. Time-dependent.
	- esup_nbitot : class esup_nbitotstructurescenario_ref
	   total suprathermal energy of fast ions from NBI ionisation [J]. Time-dependent.
	- esup_nbiperp : class esup_nbiperpstructurescenario_ref
	   perpendicular part of suprathermal energy of fast ions from NBI ionisation [J]. Time-dependent.
	- esup_lhcd : class esup_lhcdstructurescenario_ref
	   total suprathermal energy of fast electron from LHCD [J]. Time-dependent.
	- esup_alpha : class esup_alphastructurescenario_ref
	   total suprathermal energy of fast alpha particules [J]. Time-dependent.
	'''

	def __init__(self, base_path_in='energy'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.w_tot = w_totstructurescenario_ref('w_tot')
		self.w_b_pol = w_b_polstructurescenario_ref('w_b_pol')
		self.w_dia = w_diastructurescenario_ref('w_dia')
		self.dwdia_dt = dwdia_dtstructurescenario_ref('dwdia_dt')
		self.w_b_tor_pla = w_b_tor_plastructurescenario_ref('w_b_tor_pla')
		self.w_th = w_thstructurescenario_ref('w_th')
		self.dwtot_dt = dwtot_dtstructurescenario_ref('dwtot_dt')
		self.dwbpol_dt = dwbpol_dtstructurescenario_ref('dwbpol_dt')
		self.dwbtorpla_dt = dwbtorpla_dtstructurescenario_ref('dwbtorpla_dt')
		self.dwth_dt = dwth_dtstructurescenario_ref('dwth_dt')
		self.esup_icrhtot = esup_icrhtotstructurescenario_ref('esup_icrhtot')
		self.esup_icrhper = esup_icrhperstructurescenario_ref('esup_icrhper')
		self.esup_nbitot = esup_nbitotstructurescenario_ref('esup_nbitot')
		self.esup_nbiperp = esup_nbiperpstructurescenario_ref('esup_nbiperp')
		self.esup_lhcd = esup_lhcdstructurescenario_ref('esup_lhcd')
		self.esup_alpha = esup_alphastructurescenario_ref('esup_alpha')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class energystructurescenario_energy\n'
		ret = ret + space + 'Attribute w_tot\n ' + self.w_tot.__str__(depth+1)
		ret = ret + space + 'Attribute w_b_pol\n ' + self.w_b_pol.__str__(depth+1)
		ret = ret + space + 'Attribute w_dia\n ' + self.w_dia.__str__(depth+1)
		ret = ret + space + 'Attribute dwdia_dt\n ' + self.dwdia_dt.__str__(depth+1)
		ret = ret + space + 'Attribute w_b_tor_pla\n ' + self.w_b_tor_pla.__str__(depth+1)
		ret = ret + space + 'Attribute w_th\n ' + self.w_th.__str__(depth+1)
		ret = ret + space + 'Attribute dwtot_dt\n ' + self.dwtot_dt.__str__(depth+1)
		ret = ret + space + 'Attribute dwbpol_dt\n ' + self.dwbpol_dt.__str__(depth+1)
		ret = ret + space + 'Attribute dwbtorpla_dt\n ' + self.dwbtorpla_dt.__str__(depth+1)
		ret = ret + space + 'Attribute dwth_dt\n ' + self.dwth_dt.__str__(depth+1)
		ret = ret + space + 'Attribute esup_icrhtot\n ' + self.esup_icrhtot.__str__(depth+1)
		ret = ret + space + 'Attribute esup_icrhper\n ' + self.esup_icrhper.__str__(depth+1)
		ret = ret + space + 'Attribute esup_nbitot\n ' + self.esup_nbitot.__str__(depth+1)
		ret = ret + space + 'Attribute esup_nbiperp\n ' + self.esup_nbiperp.__str__(depth+1)
		ret = ret + space + 'Attribute esup_lhcd\n ' + self.esup_lhcd.__str__(depth+1)
		ret = ret + space + 'Attribute esup_alpha\n ' + self.esup_alpha.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.w_tot.setExpIdx(idx)
		self.w_b_pol.setExpIdx(idx)
		self.w_dia.setExpIdx(idx)
		self.dwdia_dt.setExpIdx(idx)
		self.w_b_tor_pla.setExpIdx(idx)
		self.w_th.setExpIdx(idx)
		self.dwtot_dt.setExpIdx(idx)
		self.dwbpol_dt.setExpIdx(idx)
		self.dwbtorpla_dt.setExpIdx(idx)
		self.dwth_dt.setExpIdx(idx)
		self.esup_icrhtot.setExpIdx(idx)
		self.esup_icrhper.setExpIdx(idx)
		self.esup_nbitot.setExpIdx(idx)
		self.esup_nbiperp.setExpIdx(idx)
		self.esup_lhcd.setExpIdx(idx)
		self.esup_alpha.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type energystructurescenario_energy, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.w_tot.cpoTime = self.cpoTime
		self.w_tot.putSlice(path, cpopath)
		self.w_b_pol.cpoTime = self.cpoTime
		self.w_b_pol.putSlice(path, cpopath)
		self.w_dia.cpoTime = self.cpoTime
		self.w_dia.putSlice(path, cpopath)
		self.dwdia_dt.cpoTime = self.cpoTime
		self.dwdia_dt.putSlice(path, cpopath)
		self.w_b_tor_pla.cpoTime = self.cpoTime
		self.w_b_tor_pla.putSlice(path, cpopath)
		self.w_th.cpoTime = self.cpoTime
		self.w_th.putSlice(path, cpopath)
		self.dwtot_dt.cpoTime = self.cpoTime
		self.dwtot_dt.putSlice(path, cpopath)
		self.dwbpol_dt.cpoTime = self.cpoTime
		self.dwbpol_dt.putSlice(path, cpopath)
		self.dwbtorpla_dt.cpoTime = self.cpoTime
		self.dwbtorpla_dt.putSlice(path, cpopath)
		self.dwth_dt.cpoTime = self.cpoTime
		self.dwth_dt.putSlice(path, cpopath)
		self.esup_icrhtot.cpoTime = self.cpoTime
		self.esup_icrhtot.putSlice(path, cpopath)
		self.esup_icrhper.cpoTime = self.cpoTime
		self.esup_icrhper.putSlice(path, cpopath)
		self.esup_nbitot.cpoTime = self.cpoTime
		self.esup_nbitot.putSlice(path, cpopath)
		self.esup_nbiperp.cpoTime = self.cpoTime
		self.esup_nbiperp.putSlice(path, cpopath)
		self.esup_lhcd.cpoTime = self.cpoTime
		self.esup_lhcd.putSlice(path, cpopath)
		self.esup_alpha.cpoTime = self.cpoTime
		self.esup_alpha.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type energystructurescenario_energy, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.w_tot.replaceLastSlice(path, cpopath)
		self.w_b_pol.replaceLastSlice(path, cpopath)
		self.w_dia.replaceLastSlice(path, cpopath)
		self.dwdia_dt.replaceLastSlice(path, cpopath)
		self.w_b_tor_pla.replaceLastSlice(path, cpopath)
		self.w_th.replaceLastSlice(path, cpopath)
		self.dwtot_dt.replaceLastSlice(path, cpopath)
		self.dwbpol_dt.replaceLastSlice(path, cpopath)
		self.dwbtorpla_dt.replaceLastSlice(path, cpopath)
		self.dwth_dt.replaceLastSlice(path, cpopath)
		self.esup_icrhtot.replaceLastSlice(path, cpopath)
		self.esup_icrhper.replaceLastSlice(path, cpopath)
		self.esup_nbitot.replaceLastSlice(path, cpopath)
		self.esup_nbiperp.replaceLastSlice(path, cpopath)
		self.esup_lhcd.replaceLastSlice(path, cpopath)
		self.esup_alpha.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type energystructurescenario_energy, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.w_tot.putNonTimed(path, cpopath)
		self.w_b_pol.putNonTimed(path, cpopath)
		self.w_dia.putNonTimed(path, cpopath)
		self.dwdia_dt.putNonTimed(path, cpopath)
		self.w_b_tor_pla.putNonTimed(path, cpopath)
		self.w_th.putNonTimed(path, cpopath)
		self.dwtot_dt.putNonTimed(path, cpopath)
		self.dwbpol_dt.putNonTimed(path, cpopath)
		self.dwbtorpla_dt.putNonTimed(path, cpopath)
		self.dwth_dt.putNonTimed(path, cpopath)
		self.esup_icrhtot.putNonTimed(path, cpopath)
		self.esup_icrhper.putNonTimed(path, cpopath)
		self.esup_nbitot.putNonTimed(path, cpopath)
		self.esup_nbiperp.putNonTimed(path, cpopath)
		self.esup_lhcd.putNonTimed(path, cpopath)
		self.esup_alpha.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type energystructurescenario_energy, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.w_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.w_b_pol.getSlice(path, cpopath, inTime, interpolMode)
		self.w_dia.getSlice(path, cpopath, inTime, interpolMode)
		self.dwdia_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.w_b_tor_pla.getSlice(path, cpopath, inTime, interpolMode)
		self.w_th.getSlice(path, cpopath, inTime, interpolMode)
		self.dwtot_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.dwbpol_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.dwbtorpla_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.dwth_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.esup_icrhtot.getSlice(path, cpopath, inTime, interpolMode)
		self.esup_icrhper.getSlice(path, cpopath, inTime, interpolMode)
		self.esup_nbitot.getSlice(path, cpopath, inTime, interpolMode)
		self.esup_nbiperp.getSlice(path, cpopath, inTime, interpolMode)
		self.esup_lhcd.getSlice(path, cpopath, inTime, interpolMode)
		self.esup_alpha.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type energystructurescenario_energy, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			w_totList = self.w_tot.build_non_resampled_data(path, cpopath, nbslice)
			w_b_polList = self.w_b_pol.build_non_resampled_data(path, cpopath, nbslice)
			w_diaList = self.w_dia.build_non_resampled_data(path, cpopath, nbslice)
			dwdia_dtList = self.dwdia_dt.build_non_resampled_data(path, cpopath, nbslice)
			w_b_tor_plaList = self.w_b_tor_pla.build_non_resampled_data(path, cpopath, nbslice)
			w_thList = self.w_th.build_non_resampled_data(path, cpopath, nbslice)
			dwtot_dtList = self.dwtot_dt.build_non_resampled_data(path, cpopath, nbslice)
			dwbpol_dtList = self.dwbpol_dt.build_non_resampled_data(path, cpopath, nbslice)
			dwbtorpla_dtList = self.dwbtorpla_dt.build_non_resampled_data(path, cpopath, nbslice)
			dwth_dtList = self.dwth_dt.build_non_resampled_data(path, cpopath, nbslice)
			esup_icrhtotList = self.esup_icrhtot.build_non_resampled_data(path, cpopath, nbslice)
			esup_icrhperList = self.esup_icrhper.build_non_resampled_data(path, cpopath, nbslice)
			esup_nbitotList = self.esup_nbitot.build_non_resampled_data(path, cpopath, nbslice)
			esup_nbiperpList = self.esup_nbiperp.build_non_resampled_data(path, cpopath, nbslice)
			esup_lhcdList = self.esup_lhcd.build_non_resampled_data(path, cpopath, nbslice)
			esup_alphaList = self.esup_alpha.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = energystructurescenario_energy(self.base_path)
				slice.setExpIdx(self.idx)
				slice.w_tot = w_totList[i]
				slice.w_b_pol = w_b_polList[i]
				slice.w_dia = w_diaList[i]
				slice.dwdia_dt = dwdia_dtList[i]
				slice.w_b_tor_pla = w_b_tor_plaList[i]
				slice.w_th = w_thList[i]
				slice.dwtot_dt = dwtot_dtList[i]
				slice.dwbpol_dt = dwbpol_dtList[i]
				slice.dwbtorpla_dt = dwbtorpla_dtList[i]
				slice.dwth_dt = dwth_dtList[i]
				slice.esup_icrhtot = esup_icrhtotList[i]
				slice.esup_icrhper = esup_icrhperList[i]
				slice.esup_nbitot = esup_nbitotList[i]
				slice.esup_nbiperp = esup_nbiperpList[i]
				slice.esup_lhcd = esup_lhcdList[i]
				slice.esup_alpha = esup_alphaList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type energystructurescenario_energyObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.w_tot.putTimedElt(path, cpopath + 'w_tot', i, obj)
		obj = self.w_b_pol.putTimedElt(path, cpopath + 'w_b_pol', i, obj)
		obj = self.w_dia.putTimedElt(path, cpopath + 'w_dia', i, obj)
		obj = self.dwdia_dt.putTimedElt(path, cpopath + 'dwdia_dt', i, obj)
		obj = self.w_b_tor_pla.putTimedElt(path, cpopath + 'w_b_tor_pla', i, obj)
		obj = self.w_th.putTimedElt(path, cpopath + 'w_th', i, obj)
		obj = self.dwtot_dt.putTimedElt(path, cpopath + 'dwtot_dt', i, obj)
		obj = self.dwbpol_dt.putTimedElt(path, cpopath + 'dwbpol_dt', i, obj)
		obj = self.dwbtorpla_dt.putTimedElt(path, cpopath + 'dwbtorpla_dt', i, obj)
		obj = self.dwth_dt.putTimedElt(path, cpopath + 'dwth_dt', i, obj)
		obj = self.esup_icrhtot.putTimedElt(path, cpopath + 'esup_icrhtot', i, obj)
		obj = self.esup_icrhper.putTimedElt(path, cpopath + 'esup_icrhper', i, obj)
		obj = self.esup_nbitot.putTimedElt(path, cpopath + 'esup_nbitot', i, obj)
		obj = self.esup_nbiperp.putTimedElt(path, cpopath + 'esup_nbiperp', i, obj)
		obj = self.esup_lhcd.putTimedElt(path, cpopath + 'esup_lhcd', i, obj)
		obj = self.esup_alpha.putTimedElt(path, cpopath + 'esup_alpha', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type energystructurescenario_energyObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.w_tot.getTimedElt(path, cpopath + 'w_tot', i, obj)
		self.w_b_pol.getTimedElt(path, cpopath + 'w_b_pol', i, obj)
		self.w_dia.getTimedElt(path, cpopath + 'w_dia', i, obj)
		self.dwdia_dt.getTimedElt(path, cpopath + 'dwdia_dt', i, obj)
		self.w_b_tor_pla.getTimedElt(path, cpopath + 'w_b_tor_pla', i, obj)
		self.w_th.getTimedElt(path, cpopath + 'w_th', i, obj)
		self.dwtot_dt.getTimedElt(path, cpopath + 'dwtot_dt', i, obj)
		self.dwbpol_dt.getTimedElt(path, cpopath + 'dwbpol_dt', i, obj)
		self.dwbtorpla_dt.getTimedElt(path, cpopath + 'dwbtorpla_dt', i, obj)
		self.dwth_dt.getTimedElt(path, cpopath + 'dwth_dt', i, obj)
		self.esup_icrhtot.getTimedElt(path, cpopath + 'esup_icrhtot', i, obj)
		self.esup_icrhper.getTimedElt(path, cpopath + 'esup_icrhper', i, obj)
		self.esup_nbitot.getTimedElt(path, cpopath + 'esup_nbitot', i, obj)
		self.esup_nbiperp.getTimedElt(path, cpopath + 'esup_nbiperp', i, obj)
		self.esup_lhcd.getTimedElt(path, cpopath + 'esup_lhcd', i, obj)
		self.esup_alpha.getTimedElt(path, cpopath + 'esup_alpha', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type energystructurescenario_energyObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.w_tot.putNonTimedElt(path, cpopath + 'w_tot', i, obj)
		obj = self.w_b_pol.putNonTimedElt(path, cpopath + 'w_b_pol', i, obj)
		obj = self.w_dia.putNonTimedElt(path, cpopath + 'w_dia', i, obj)
		obj = self.dwdia_dt.putNonTimedElt(path, cpopath + 'dwdia_dt', i, obj)
		obj = self.w_b_tor_pla.putNonTimedElt(path, cpopath + 'w_b_tor_pla', i, obj)
		obj = self.w_th.putNonTimedElt(path, cpopath + 'w_th', i, obj)
		obj = self.dwtot_dt.putNonTimedElt(path, cpopath + 'dwtot_dt', i, obj)
		obj = self.dwbpol_dt.putNonTimedElt(path, cpopath + 'dwbpol_dt', i, obj)
		obj = self.dwbtorpla_dt.putNonTimedElt(path, cpopath + 'dwbtorpla_dt', i, obj)
		obj = self.dwth_dt.putNonTimedElt(path, cpopath + 'dwth_dt', i, obj)
		obj = self.esup_icrhtot.putNonTimedElt(path, cpopath + 'esup_icrhtot', i, obj)
		obj = self.esup_icrhper.putNonTimedElt(path, cpopath + 'esup_icrhper', i, obj)
		obj = self.esup_nbitot.putNonTimedElt(path, cpopath + 'esup_nbitot', i, obj)
		obj = self.esup_nbiperp.putNonTimedElt(path, cpopath + 'esup_nbiperp', i, obj)
		obj = self.esup_lhcd.putNonTimedElt(path, cpopath + 'esup_lhcd', i, obj)
		obj = self.esup_alpha.putNonTimedElt(path, cpopath + 'esup_alpha', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type energystructurescenario_energyObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.w_tot.getNonTimedElt(path, cpopath + 'w_tot', i, obj)
		self.w_b_pol.getNonTimedElt(path, cpopath + 'w_b_pol', i, obj)
		self.w_dia.getNonTimedElt(path, cpopath + 'w_dia', i, obj)
		self.dwdia_dt.getNonTimedElt(path, cpopath + 'dwdia_dt', i, obj)
		self.w_b_tor_pla.getNonTimedElt(path, cpopath + 'w_b_tor_pla', i, obj)
		self.w_th.getNonTimedElt(path, cpopath + 'w_th', i, obj)
		self.dwtot_dt.getNonTimedElt(path, cpopath + 'dwtot_dt', i, obj)
		self.dwbpol_dt.getNonTimedElt(path, cpopath + 'dwbpol_dt', i, obj)
		self.dwbtorpla_dt.getNonTimedElt(path, cpopath + 'dwbtorpla_dt', i, obj)
		self.dwth_dt.getNonTimedElt(path, cpopath + 'dwth_dt', i, obj)
		self.esup_icrhtot.getNonTimedElt(path, cpopath + 'esup_icrhtot', i, obj)
		self.esup_icrhper.getNonTimedElt(path, cpopath + 'esup_icrhper', i, obj)
		self.esup_nbitot.getNonTimedElt(path, cpopath + 'esup_nbitot', i, obj)
		self.esup_nbiperp.getNonTimedElt(path, cpopath + 'esup_nbiperp', i, obj)
		self.esup_lhcd.getNonTimedElt(path, cpopath + 'esup_lhcd', i, obj)
		self.esup_alpha.getNonTimedElt(path, cpopath + 'esup_alpha', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.w_tot.deleteData(path, cpopath)
		self.w_b_pol.deleteData(path, cpopath)
		self.w_dia.deleteData(path, cpopath)
		self.dwdia_dt.deleteData(path, cpopath)
		self.w_b_tor_pla.deleteData(path, cpopath)
		self.w_th.deleteData(path, cpopath)
		self.dwtot_dt.deleteData(path, cpopath)
		self.dwbpol_dt.deleteData(path, cpopath)
		self.dwbtorpla_dt.deleteData(path, cpopath)
		self.dwth_dt.deleteData(path, cpopath)
		self.esup_icrhtot.deleteData(path, cpopath)
		self.esup_icrhper.deleteData(path, cpopath)
		self.esup_nbitot.deleteData(path, cpopath)
		self.esup_nbiperp.deleteData(path, cpopath)
		self.esup_lhcd.deleteData(path, cpopath)
		self.esup_alpha.deleteData(path, cpopath)


class w_totstructurescenario_ref:
	'''
	class w_totstructurescenario_ref
	total plasma energy [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='w_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class w_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type w_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type w_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = w_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class w_b_polstructurescenario_ref:
	'''
	class w_b_polstructurescenario_ref
	poloidal field energy of  the plasma [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='w_b_pol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class w_b_polstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_polstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_polstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_polstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_polstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_polstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = w_b_polstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_polstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_polstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_polstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_polstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class w_diastructurescenario_ref:
	'''
	class w_diastructurescenario_ref
	3/2 perpendicular plasma energy [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='w_dia'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class w_diastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_diastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_diastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_diastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type w_diastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type w_diastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = w_diastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_diastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_diastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_diastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_diastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dwdia_dtstructurescenario_ref:
	'''
	class dwdia_dtstructurescenario_ref
	time derivative of Wdia [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dwdia_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dwdia_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwdia_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwdia_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwdia_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dwdia_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dwdia_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dwdia_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwdia_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwdia_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwdia_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwdia_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class w_b_tor_plastructurescenario_ref:
	'''
	class w_b_tor_plastructurescenario_ref
	toroidal magnetic plasma energy  [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='w_b_tor_pla'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class w_b_tor_plastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_tor_plastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_tor_plastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_tor_plastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_tor_plastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type w_b_tor_plastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = w_b_tor_plastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_tor_plastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_tor_plastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_tor_plastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_b_tor_plastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class w_thstructurescenario_ref:
	'''
	class w_thstructurescenario_ref
	thermal plasma energy [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='w_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class w_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type w_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type w_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type w_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = w_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type w_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dwtot_dtstructurescenario_ref:
	'''
	class dwtot_dtstructurescenario_ref
	time derivative of total plasma energy [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dwtot_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dwtot_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwtot_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwtot_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwtot_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dwtot_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dwtot_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dwtot_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwtot_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwtot_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwtot_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwtot_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dwbpol_dtstructurescenario_ref:
	'''
	class dwbpol_dtstructurescenario_ref
	time derivative of plasma poloidal field energy [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dwbpol_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dwbpol_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwbpol_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwbpol_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwbpol_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dwbpol_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dwbpol_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dwbpol_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbpol_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbpol_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbpol_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbpol_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dwbtorpla_dtstructurescenario_ref:
	'''
	class dwbtorpla_dtstructurescenario_ref
	time derivative of toroidal magnetic plasma energy  [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dwbtorpla_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dwbtorpla_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwbtorpla_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwbtorpla_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwbtorpla_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dwbtorpla_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dwbtorpla_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dwbtorpla_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbtorpla_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbtorpla_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbtorpla_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwbtorpla_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dwth_dtstructurescenario_ref:
	'''
	class dwth_dtstructurescenario_ref
	time derivative of thermal plasma energy [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dwth_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dwth_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwth_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwth_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dwth_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dwth_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dwth_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dwth_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwth_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwth_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwth_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dwth_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class esup_icrhtotstructurescenario_ref:
	'''
	class esup_icrhtotstructurescenario_ref
	total suprathermal energy of fast ions accelerated  by ICRH [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='esup_icrhtot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class esup_icrhtotstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhtotstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhtotstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhtotstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhtotstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhtotstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = esup_icrhtotstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhtotstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhtotstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhtotstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhtotstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class esup_icrhperstructurescenario_ref:
	'''
	class esup_icrhperstructurescenario_ref
	perpendicular part of suprathermal energy of fast ions accelerated  by ICRH [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='esup_icrhper'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class esup_icrhperstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhperstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhperstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhperstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhperstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type esup_icrhperstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = esup_icrhperstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhperstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhperstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhperstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_icrhperstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class esup_nbitotstructurescenario_ref:
	'''
	class esup_nbitotstructurescenario_ref
	total suprathermal energy of fast ions from NBI ionisation [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='esup_nbitot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class esup_nbitotstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbitotstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbitotstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbitotstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbitotstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbitotstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = esup_nbitotstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbitotstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbitotstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbitotstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbitotstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class esup_nbiperpstructurescenario_ref:
	'''
	class esup_nbiperpstructurescenario_ref
	perpendicular part of suprathermal energy of fast ions from NBI ionisation [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='esup_nbiperp'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class esup_nbiperpstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbiperpstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbiperpstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbiperpstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbiperpstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type esup_nbiperpstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = esup_nbiperpstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbiperpstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbiperpstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbiperpstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_nbiperpstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class esup_lhcdstructurescenario_ref:
	'''
	class esup_lhcdstructurescenario_ref
	total suprathermal energy of fast electron from LHCD [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='esup_lhcd'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class esup_lhcdstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_lhcdstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_lhcdstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_lhcdstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type esup_lhcdstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type esup_lhcdstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = esup_lhcdstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_lhcdstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_lhcdstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_lhcdstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_lhcdstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class esup_alphastructurescenario_ref:
	'''
	class esup_alphastructurescenario_ref
	total suprathermal energy of fast alpha particules [J]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='esup_alpha'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class esup_alphastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_alphastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_alphastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type esup_alphastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type esup_alphastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type esup_alphastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = esup_alphastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_alphastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_alphastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_alphastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type esup_alphastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class eqgeometrystructureeqgeometry:
	'''
	class eqgeometrystructureeqgeometry
	Geometry of the plasma boundary

	Attributes:
	- source : str
	   Comment describing the origin of the eqgeometry data; String
	- boundarytype : int
	   0 (limiter) or 1 (separatrix); Integer; Time-dependent
	- boundary : class boundarystruct_arrayrz1Dexp: array of boundarystruct_arrayrz1DexpObj objects
	   RZ description of the plasma boundary; This is formally declared as an array of structure to allow for time-dependent size of the R and Z vectors in the sub-structure below. However, boundary must be allocated to size 1. Time-dependent;
	- geom_axis : class geom_axisstructurerz0D
	   RZ position of the geometric axis (defined as (Rmin+Rmax) / 2 and (Zmin+Zmax) / 2 of the boundary) [m]; Time-dependent; Scalar
	- a_minor : float
	   Minor radius of the plasma boundary [m]; Time-dependent; Scalar
	- elongation : float
	   Elongation of the plasma boundary; Time-dependent; Scalar
	- elong_upper : float
	   Elongation upper of the plasma boundary; Time-dependent; Scalar
	- elong_lower : float
	   Elongation lower of the plasma boundary; Time-dependent; Scalar
	- tria_upper : float
	   Upper triangularity of the plasma boundary; Time-dependent; Scalar
	- tria_lower : float
	   Lower triangularity of the plasma boundary; Time-dependent; Scalar
	- xpts : class xptsstruct_arrayrz1Dexp: array of xptsstruct_arrayrz1DexpObj objects
	   Position of the Xpoints, first is the active xpoint if diverted [m]; This is formally declared as an array of structure to allow for time-dependent size of the R and Z vectors in the sub-structure below. However, xpts must be allocated to size 1. Time-dependent;
	- left_low_st : class left_low_ststructurerz0D
	   Position of the lower left strike point [m]; Time-dependent; Scalar
	- right_low_st : class right_low_ststructurerz0D
	   Position of the lower right strike point [m]; Time-dependent; Scalar
	- left_up_st : class left_up_ststructurerz0D
	   Position of the upper left strike point [m]; Time-dependent; Scalar
	- right_up_st : class right_up_ststructurerz0D
	   Position of the upper right strike point [m]; Time-dependent; Scalar
	- active_limit : class active_limitstructurerz0D
	   Position of the active limiter point (point of the plasma boundary in contact with the limiter) [m]; Set R = 0 for X-point plasma; Time-dependent; Scalar
	- ang_lcms_upo : float
	   Angle at the LMCS X point upper outer; Time-dependent; Scalar
	- ang_lcms_upi : float
	   Angle at the LMCS X point upper inner; Time-dependent; Scalar
	- ang_lcms_lwo : float
	   Angle at the LMCS X point lower outer; Time-dependent; Scalar 
	- ang_lcms_lwi : float
	   Angle at the LMCS X point lower inner; Time-dependent; Scalar
	'''

	def __init__(self, base_path_in='eqgeometry'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.source = ''
		self.boundarytype = EMPTY_INT
		self.boundary = boundarystruct_arrayrz1Dexp('boundary')
		self.geom_axis = geom_axisstructurerz0D('geom_axis')
		self.a_minor = EMPTY_DOUBLE
		self.elongation = EMPTY_DOUBLE
		self.elong_upper = EMPTY_DOUBLE
		self.elong_lower = EMPTY_DOUBLE
		self.tria_upper = EMPTY_DOUBLE
		self.tria_lower = EMPTY_DOUBLE
		self.xpts = xptsstruct_arrayrz1Dexp('xpts')
		self.left_low_st = left_low_ststructurerz0D('left_low_st')
		self.right_low_st = right_low_ststructurerz0D('right_low_st')
		self.left_up_st = left_up_ststructurerz0D('left_up_st')
		self.right_up_st = right_up_ststructurerz0D('right_up_st')
		self.active_limit = active_limitstructurerz0D('active_limit')
		self.ang_lcms_upo = EMPTY_DOUBLE
		self.ang_lcms_upi = EMPTY_DOUBLE
		self.ang_lcms_lwo = EMPTY_DOUBLE
		self.ang_lcms_lwi = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class eqgeometrystructureeqgeometry\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		ret = ret + space + 'Attribute boundarytype: ' + str(self.boundarytype) + '\n'
		ret = ret + space + 'Attribute boundary\n ' + self.boundary.__str__(depth+1)
		ret = ret + space + 'Attribute geom_axis\n ' + self.geom_axis.__str__(depth+1)
		ret = ret + space + 'Attribute a_minor: ' + str(self.a_minor) + '\n'
		ret = ret + space + 'Attribute elongation: ' + str(self.elongation) + '\n'
		ret = ret + space + 'Attribute elong_upper: ' + str(self.elong_upper) + '\n'
		ret = ret + space + 'Attribute elong_lower: ' + str(self.elong_lower) + '\n'
		ret = ret + space + 'Attribute tria_upper: ' + str(self.tria_upper) + '\n'
		ret = ret + space + 'Attribute tria_lower: ' + str(self.tria_lower) + '\n'
		ret = ret + space + 'Attribute xpts\n ' + self.xpts.__str__(depth+1)
		ret = ret + space + 'Attribute left_low_st\n ' + self.left_low_st.__str__(depth+1)
		ret = ret + space + 'Attribute right_low_st\n ' + self.right_low_st.__str__(depth+1)
		ret = ret + space + 'Attribute left_up_st\n ' + self.left_up_st.__str__(depth+1)
		ret = ret + space + 'Attribute right_up_st\n ' + self.right_up_st.__str__(depth+1)
		ret = ret + space + 'Attribute active_limit\n ' + self.active_limit.__str__(depth+1)
		ret = ret + space + 'Attribute ang_lcms_upo: ' + str(self.ang_lcms_upo) + '\n'
		ret = ret + space + 'Attribute ang_lcms_upi: ' + str(self.ang_lcms_upi) + '\n'
		ret = ret + space + 'Attribute ang_lcms_lwo: ' + str(self.ang_lcms_lwo) + '\n'
		ret = ret + space + 'Attribute ang_lcms_lwi: ' + str(self.ang_lcms_lwi) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.boundary.setExpIdx(idx)
		self.geom_axis.setExpIdx(idx)
		self.xpts.setExpIdx(idx)
		self.left_low_st.setExpIdx(idx)
		self.right_low_st.setExpIdx(idx)
		self.left_up_st.setExpIdx(idx)
		self.right_up_st.setExpIdx(idx)
		self.active_limit.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type eqgeometrystructureeqgeometry, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'boundarytype', self.boundarytype, self.cpoTime)
		check_status(status)
		self.boundary.cpoTime = self.cpoTime
		self.boundary.putSlice(path, cpopath)
		self.geom_axis.cpoTime = self.cpoTime
		self.geom_axis.putSlice(path, cpopath)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'a_minor', self.a_minor, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'elongation', self.elongation, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'elong_upper', self.elong_upper, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'elong_lower', self.elong_lower, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'tria_upper', self.tria_upper, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'tria_lower', self.tria_lower, self.cpoTime)
		check_status(status)
		self.xpts.cpoTime = self.cpoTime
		self.xpts.putSlice(path, cpopath)
		self.left_low_st.cpoTime = self.cpoTime
		self.left_low_st.putSlice(path, cpopath)
		self.right_low_st.cpoTime = self.cpoTime
		self.right_low_st.putSlice(path, cpopath)
		self.left_up_st.cpoTime = self.cpoTime
		self.left_up_st.putSlice(path, cpopath)
		self.right_up_st.cpoTime = self.cpoTime
		self.right_up_st.putSlice(path, cpopath)
		self.active_limit.cpoTime = self.cpoTime
		self.active_limit.putSlice(path, cpopath)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'ang_lcms_upo', self.ang_lcms_upo, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'ang_lcms_upi', self.ang_lcms_upi, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'ang_lcms_lwo', self.ang_lcms_lwo, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'ang_lcms_lwi', self.ang_lcms_lwi, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type eqgeometrystructureeqgeometry, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'boundarytype', self.boundarytype)
		check_status(status)
		self.boundary.replaceLastSlice(path, cpopath)
		self.geom_axis.replaceLastSlice(path, cpopath)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'a_minor', self.a_minor)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'elongation', self.elongation)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'elong_upper', self.elong_upper)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'elong_lower', self.elong_lower)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'tria_upper', self.tria_upper)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'tria_lower', self.tria_lower)
		check_status(status)
		self.xpts.replaceLastSlice(path, cpopath)
		self.left_low_st.replaceLastSlice(path, cpopath)
		self.right_low_st.replaceLastSlice(path, cpopath)
		self.left_up_st.replaceLastSlice(path, cpopath)
		self.right_up_st.replaceLastSlice(path, cpopath)
		self.active_limit.replaceLastSlice(path, cpopath)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'ang_lcms_upo', self.ang_lcms_upo)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'ang_lcms_upi', self.ang_lcms_upi)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'ang_lcms_lwo', self.ang_lcms_lwo)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'ang_lcms_lwi', self.ang_lcms_lwi)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type eqgeometrystructureeqgeometry, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)
		self.boundary.putNonTimed(path, cpopath)
		self.geom_axis.putNonTimed(path, cpopath)
		self.xpts.putNonTimed(path, cpopath)
		self.left_low_st.putNonTimed(path, cpopath)
		self.right_low_st.putNonTimed(path, cpopath)
		self.left_up_st.putNonTimed(path, cpopath)
		self.right_up_st.putNonTimed(path, cpopath)
		self.active_limit.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type eqgeometrystructureeqgeometry, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source
		status, ret_boundarytype, retTime = ull.getIntSlice(self.idx, path, cpopath + 'boundarytype', inTime, interpolMode)
		check_status(status)
		if not status:
			self.boundarytype = ret_boundarytype
			self.cpoTime = retTime
		self.boundary.getSlice(path, cpopath, inTime, interpolMode)
		self.geom_axis.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_a_minor, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'a_minor', inTime, interpolMode)
		check_status(status)
		if not status:
			self.a_minor = ret_a_minor
			self.cpoTime = retTime
		status, ret_elongation, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'elongation', inTime, interpolMode)
		check_status(status)
		if not status:
			self.elongation = ret_elongation
			self.cpoTime = retTime
		status, ret_elong_upper, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'elong_upper', inTime, interpolMode)
		check_status(status)
		if not status:
			self.elong_upper = ret_elong_upper
			self.cpoTime = retTime
		status, ret_elong_lower, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'elong_lower', inTime, interpolMode)
		check_status(status)
		if not status:
			self.elong_lower = ret_elong_lower
			self.cpoTime = retTime
		status, ret_tria_upper, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'tria_upper', inTime, interpolMode)
		check_status(status)
		if not status:
			self.tria_upper = ret_tria_upper
			self.cpoTime = retTime
		status, ret_tria_lower, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'tria_lower', inTime, interpolMode)
		check_status(status)
		if not status:
			self.tria_lower = ret_tria_lower
			self.cpoTime = retTime
		self.xpts.getSlice(path, cpopath, inTime, interpolMode)
		self.left_low_st.getSlice(path, cpopath, inTime, interpolMode)
		self.right_low_st.getSlice(path, cpopath, inTime, interpolMode)
		self.left_up_st.getSlice(path, cpopath, inTime, interpolMode)
		self.right_up_st.getSlice(path, cpopath, inTime, interpolMode)
		self.active_limit.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_ang_lcms_upo, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'ang_lcms_upo', inTime, interpolMode)
		check_status(status)
		if not status:
			self.ang_lcms_upo = ret_ang_lcms_upo
			self.cpoTime = retTime
		status, ret_ang_lcms_upi, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'ang_lcms_upi', inTime, interpolMode)
		check_status(status)
		if not status:
			self.ang_lcms_upi = ret_ang_lcms_upi
			self.cpoTime = retTime
		status, ret_ang_lcms_lwo, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'ang_lcms_lwo', inTime, interpolMode)
		check_status(status)
		if not status:
			self.ang_lcms_lwo = ret_ang_lcms_lwo
			self.cpoTime = retTime
		status, ret_ang_lcms_lwi, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'ang_lcms_lwi', inTime, interpolMode)
		check_status(status)
		if not status:
			self.ang_lcms_lwi = ret_ang_lcms_lwi
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type eqgeometrystructureeqgeometry, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			status, boundarytypeList = ull.getVect1DInt(self.idx, path, cpopath + 'boundarytype')
			if len(boundarytypeList) == 0:
				boundarytypeList = numpy.resize(boundarytypeList, (nbslice))
			check_status(status)
			boundaryList = self.boundary.build_non_resampled_data(path, cpopath, nbslice)
			geom_axisList = self.geom_axis.build_non_resampled_data(path, cpopath, nbslice)
			status, a_minorList = ull.getVect1DDouble(self.idx, path, cpopath + 'a_minor')
			if len(a_minorList) == 0:
				a_minorList = numpy.resize(a_minorList, (nbslice))
			check_status(status)
			status, elongationList = ull.getVect1DDouble(self.idx, path, cpopath + 'elongation')
			if len(elongationList) == 0:
				elongationList = numpy.resize(elongationList, (nbslice))
			check_status(status)
			status, elong_upperList = ull.getVect1DDouble(self.idx, path, cpopath + 'elong_upper')
			if len(elong_upperList) == 0:
				elong_upperList = numpy.resize(elong_upperList, (nbslice))
			check_status(status)
			status, elong_lowerList = ull.getVect1DDouble(self.idx, path, cpopath + 'elong_lower')
			if len(elong_lowerList) == 0:
				elong_lowerList = numpy.resize(elong_lowerList, (nbslice))
			check_status(status)
			status, tria_upperList = ull.getVect1DDouble(self.idx, path, cpopath + 'tria_upper')
			if len(tria_upperList) == 0:
				tria_upperList = numpy.resize(tria_upperList, (nbslice))
			check_status(status)
			status, tria_lowerList = ull.getVect1DDouble(self.idx, path, cpopath + 'tria_lower')
			if len(tria_lowerList) == 0:
				tria_lowerList = numpy.resize(tria_lowerList, (nbslice))
			check_status(status)
			xptsList = self.xpts.build_non_resampled_data(path, cpopath, nbslice)
			left_low_stList = self.left_low_st.build_non_resampled_data(path, cpopath, nbslice)
			right_low_stList = self.right_low_st.build_non_resampled_data(path, cpopath, nbslice)
			left_up_stList = self.left_up_st.build_non_resampled_data(path, cpopath, nbslice)
			right_up_stList = self.right_up_st.build_non_resampled_data(path, cpopath, nbslice)
			active_limitList = self.active_limit.build_non_resampled_data(path, cpopath, nbslice)
			status, ang_lcms_upoList = ull.getVect1DDouble(self.idx, path, cpopath + 'ang_lcms_upo')
			if len(ang_lcms_upoList) == 0:
				ang_lcms_upoList = numpy.resize(ang_lcms_upoList, (nbslice))
			check_status(status)
			status, ang_lcms_upiList = ull.getVect1DDouble(self.idx, path, cpopath + 'ang_lcms_upi')
			if len(ang_lcms_upiList) == 0:
				ang_lcms_upiList = numpy.resize(ang_lcms_upiList, (nbslice))
			check_status(status)
			status, ang_lcms_lwoList = ull.getVect1DDouble(self.idx, path, cpopath + 'ang_lcms_lwo')
			if len(ang_lcms_lwoList) == 0:
				ang_lcms_lwoList = numpy.resize(ang_lcms_lwoList, (nbslice))
			check_status(status)
			status, ang_lcms_lwiList = ull.getVect1DDouble(self.idx, path, cpopath + 'ang_lcms_lwi')
			if len(ang_lcms_lwiList) == 0:
				ang_lcms_lwiList = numpy.resize(ang_lcms_lwiList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = eqgeometrystructureeqgeometry(self.base_path)
				slice.setExpIdx(self.idx)
				slice.source = sourceVal
				slice.boundarytype = int(boundarytypeList[i].copy())
				slice.boundary = boundaryList[i]
				slice.geom_axis = geom_axisList[i]
				slice.a_minor = a_minorList[i].copy().astype(float)
				slice.elongation = elongationList[i].copy().astype(float)
				slice.elong_upper = elong_upperList[i].copy().astype(float)
				slice.elong_lower = elong_lowerList[i].copy().astype(float)
				slice.tria_upper = tria_upperList[i].copy().astype(float)
				slice.tria_lower = tria_lowerList[i].copy().astype(float)
				slice.xpts = xptsList[i]
				slice.left_low_st = left_low_stList[i]
				slice.right_low_st = right_low_stList[i]
				slice.left_up_st = left_up_stList[i]
				slice.right_up_st = right_up_stList[i]
				slice.active_limit = active_limitList[i]
				slice.ang_lcms_upo = ang_lcms_upoList[i].copy().astype(float)
				slice.ang_lcms_upi = ang_lcms_upiList[i].copy().astype(float)
				slice.ang_lcms_lwo = ang_lcms_lwoList[i].copy().astype(float)
				slice.ang_lcms_lwi = ang_lcms_lwiList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type eqgeometrystructureeqgeometryObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'boundarytype') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'boundarytype', i, self.boundarytype)
		obj = self.boundary.putTimedElt(path, cpopath + 'boundary', i, obj)
		obj = self.geom_axis.putTimedElt(path, cpopath + 'geom_axis', i, obj)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'a_minor') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'a_minor', i, self.a_minor)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'elongation') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'elongation', i, self.elongation)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'elong_upper') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'elong_upper', i, self.elong_upper)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'elong_lower') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'elong_lower', i, self.elong_lower)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'tria_upper') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'tria_upper', i, self.tria_upper)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'tria_lower') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'tria_lower', i, self.tria_lower)
		obj = self.xpts.putTimedElt(path, cpopath + 'xpts', i, obj)
		obj = self.left_low_st.putTimedElt(path, cpopath + 'left_low_st', i, obj)
		obj = self.right_low_st.putTimedElt(path, cpopath + 'right_low_st', i, obj)
		obj = self.left_up_st.putTimedElt(path, cpopath + 'left_up_st', i, obj)
		obj = self.right_up_st.putTimedElt(path, cpopath + 'right_up_st', i, obj)
		obj = self.active_limit.putTimedElt(path, cpopath + 'active_limit', i, obj)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'ang_lcms_upo') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'ang_lcms_upo', i, self.ang_lcms_upo)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'ang_lcms_upi') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'ang_lcms_upi', i, self.ang_lcms_upi)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'ang_lcms_lwo') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'ang_lcms_lwo', i, self.ang_lcms_lwo)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'ang_lcms_lwi') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'ang_lcms_lwi', i, self.ang_lcms_lwi)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type eqgeometrystructureeqgeometryObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'boundarytype') 
			print ('obj = ' + str(obj))
		status, ret_boundarytype = ull.getIntFromObject(self.idx, obj, cpopath + 'boundarytype', i)
		check_status(status)
		if not status:
			self.boundarytype = ret_boundarytype
		self.boundary.getTimedElt(path, cpopath + 'boundary', i, obj)
		self.geom_axis.getTimedElt(path, cpopath + 'geom_axis', i, obj)
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'a_minor') 
			print ('obj = ' + str(obj))
		status, ret_a_minor = ull.getDoubleFromObject(self.idx, obj, cpopath + 'a_minor', i)
		check_status(status)
		if not status:
			self.a_minor = ret_a_minor
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'elongation') 
			print ('obj = ' + str(obj))
		status, ret_elongation = ull.getDoubleFromObject(self.idx, obj, cpopath + 'elongation', i)
		check_status(status)
		if not status:
			self.elongation = ret_elongation
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'elong_upper') 
			print ('obj = ' + str(obj))
		status, ret_elong_upper = ull.getDoubleFromObject(self.idx, obj, cpopath + 'elong_upper', i)
		check_status(status)
		if not status:
			self.elong_upper = ret_elong_upper
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'elong_lower') 
			print ('obj = ' + str(obj))
		status, ret_elong_lower = ull.getDoubleFromObject(self.idx, obj, cpopath + 'elong_lower', i)
		check_status(status)
		if not status:
			self.elong_lower = ret_elong_lower
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'tria_upper') 
			print ('obj = ' + str(obj))
		status, ret_tria_upper = ull.getDoubleFromObject(self.idx, obj, cpopath + 'tria_upper', i)
		check_status(status)
		if not status:
			self.tria_upper = ret_tria_upper
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'tria_lower') 
			print ('obj = ' + str(obj))
		status, ret_tria_lower = ull.getDoubleFromObject(self.idx, obj, cpopath + 'tria_lower', i)
		check_status(status)
		if not status:
			self.tria_lower = ret_tria_lower
		self.xpts.getTimedElt(path, cpopath + 'xpts', i, obj)
		self.left_low_st.getTimedElt(path, cpopath + 'left_low_st', i, obj)
		self.right_low_st.getTimedElt(path, cpopath + 'right_low_st', i, obj)
		self.left_up_st.getTimedElt(path, cpopath + 'left_up_st', i, obj)
		self.right_up_st.getTimedElt(path, cpopath + 'right_up_st', i, obj)
		self.active_limit.getTimedElt(path, cpopath + 'active_limit', i, obj)
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'ang_lcms_upo') 
			print ('obj = ' + str(obj))
		status, ret_ang_lcms_upo = ull.getDoubleFromObject(self.idx, obj, cpopath + 'ang_lcms_upo', i)
		check_status(status)
		if not status:
			self.ang_lcms_upo = ret_ang_lcms_upo
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'ang_lcms_upi') 
			print ('obj = ' + str(obj))
		status, ret_ang_lcms_upi = ull.getDoubleFromObject(self.idx, obj, cpopath + 'ang_lcms_upi', i)
		check_status(status)
		if not status:
			self.ang_lcms_upi = ret_ang_lcms_upi
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'ang_lcms_lwo') 
			print ('obj = ' + str(obj))
		status, ret_ang_lcms_lwo = ull.getDoubleFromObject(self.idx, obj, cpopath + 'ang_lcms_lwo', i)
		check_status(status)
		if not status:
			self.ang_lcms_lwo = ret_ang_lcms_lwo
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'ang_lcms_lwi') 
			print ('obj = ' + str(obj))
		status, ret_ang_lcms_lwi = ull.getDoubleFromObject(self.idx, obj, cpopath + 'ang_lcms_lwi', i)
		check_status(status)
		if not status:
			self.ang_lcms_lwi = ret_ang_lcms_lwi

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type eqgeometrystructureeqgeometryObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		obj = self.boundary.putNonTimedElt(path, cpopath + 'boundary', i, obj)
		obj = self.geom_axis.putNonTimedElt(path, cpopath + 'geom_axis', i, obj)
		obj = self.xpts.putNonTimedElt(path, cpopath + 'xpts', i, obj)
		obj = self.left_low_st.putNonTimedElt(path, cpopath + 'left_low_st', i, obj)
		obj = self.right_low_st.putNonTimedElt(path, cpopath + 'right_low_st', i, obj)
		obj = self.left_up_st.putNonTimedElt(path, cpopath + 'left_up_st', i, obj)
		obj = self.right_up_st.putNonTimedElt(path, cpopath + 'right_up_st', i, obj)
		obj = self.active_limit.putNonTimedElt(path, cpopath + 'active_limit', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type eqgeometrystructureeqgeometryObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source
		self.boundary.getNonTimedElt(path, cpopath + 'boundary', i, obj)
		self.geom_axis.getNonTimedElt(path, cpopath + 'geom_axis', i, obj)
		self.xpts.getNonTimedElt(path, cpopath + 'xpts', i, obj)
		self.left_low_st.getNonTimedElt(path, cpopath + 'left_low_st', i, obj)
		self.right_low_st.getNonTimedElt(path, cpopath + 'right_low_st', i, obj)
		self.left_up_st.getNonTimedElt(path, cpopath + 'left_up_st', i, obj)
		self.right_up_st.getNonTimedElt(path, cpopath + 'right_up_st', i, obj)
		self.active_limit.getNonTimedElt(path, cpopath + 'active_limit', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'source')
		ull.deleteData(self.idx, path, cpopath + 'boundarytype')
		ull.deleteData(self.idx, path, cpopath + 'boundary')
		self.geom_axis.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'a_minor')
		ull.deleteData(self.idx, path, cpopath + 'elongation')
		ull.deleteData(self.idx, path, cpopath + 'elong_upper')
		ull.deleteData(self.idx, path, cpopath + 'elong_lower')
		ull.deleteData(self.idx, path, cpopath + 'tria_upper')
		ull.deleteData(self.idx, path, cpopath + 'tria_lower')
		ull.deleteData(self.idx, path, cpopath + 'xpts')
		self.left_low_st.deleteData(path, cpopath)
		self.right_low_st.deleteData(path, cpopath)
		self.left_up_st.deleteData(path, cpopath)
		self.right_up_st.deleteData(path, cpopath)
		self.active_limit.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'ang_lcms_upo')
		ull.deleteData(self.idx, path, cpopath + 'ang_lcms_upi')
		ull.deleteData(self.idx, path, cpopath + 'ang_lcms_lwo')
		ull.deleteData(self.idx, path, cpopath + 'ang_lcms_lwi')


class boundarystruct_arrayrz1Dexp:
	'''
	class boundarystruct_arrayrz1Dexp
	RZ description of the plasma boundary; This is formally declared as an array of structure to allow for time-dependent size of the R and Z vectors in the sub-structure below. However, boundary must be allocated to size 1. Time-dependent;

	Attributes:
	- array : list of boundarystruct_arrayrz1DexpObj 
	'''

	def __init__(self, base_path_in='boundary'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.array = []
	def __getitem__(self, key):
		return self.array[key]
	def __len__(self):
		return len(self.array)
	def __iter__(self):
		return self.array.__iter__()

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class boundarystruct_arrayrz1Dexp\n'
		for i in range(len(self.array)):
			ret = ret + space + 'boundarystruct_arrayrz1Dexp[%d] = \n' %(i) + self.array[i].__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		for i in range(len(self.array)):
			self.array[i].setExpIdx(idx)

	def resize(self, nbelt):
		self.array = []
		for i in range(nbelt):
			self.array.append(boundarystruct_arrayrz1DexpObj(self.base_path))
			self.array[i].setExpIdx(self.idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function putSlice') 
		if (dev()):
			print ('beginObject(None, 0, '+path+'/'+cpopath+self.base_path+', TIMED)')
		obj_time = ull.beginObject(self.idx, None, 0, path + '/' + cpopath + self.base_path, TIMED)
		obj = ull.beginObject(self.idx, obj_time, 0, 'ALLTIMES', TIMED)
		for i in range(len(self.array)):
			obj = self.array[i].putTimedElt(path, self.base_path, i, obj)
		obj_time = ull.putObjectInObject(self.idx, obj_time, 'ALLTIMES', 0, obj)
		if (dev()):
			print ('putObjectSlice('+path+', '+cpopath+self.base_path+', '+str(self.cpoTime)+', '+str(obj_time)+')')
		status = ull.putObjectSlice(self.idx, path, cpopath + self.base_path, self.cpoTime, obj_time)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function replaceLastSlice') 
		if (dev()):
			print ('beginObject(None, 0, '+path+'/'+cpopath+self.base_path+', TIMED)')
		obj = ull.beginObject(self.idx, None, 0, path + '/' + cpopath + self.base_path, TIMED)
		for i in range(len(self.array)):
			obj = self.array[i].putTimedElt(path, self.base_path, i, obj)
		if (dev()):
			print ('replaceLastObjectSlice('+path+', '+cpopath+self.base_path+', '+str(obj)+')')
		status = ull.replaceLastObjectSlice(self.idx, path, cpopath + self.base_path, obj)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function putNonTimed') 
		if (dev()):
			print ('beginObject(None, 0, '+path+'/'+cpopath+self.base_path+', NON_TIMED)')
		obj = ull.beginObject(self.idx, None, 0, path + '/' + cpopath + self.base_path, NON_TIMED)
		for i in range(len(self.array)):
			obj = self.array[i].putNonTimedElt(path, self.base_path, i, obj)
		if (dev()):
			print ('putObject('+path+', '+cpopath+self.base_path+', '+str(obj)+', NON_TIMED)')
		status = ull.putObject(self.idx, path, cpopath + self.base_path, obj, NON_TIMED)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function getSlice') 
		if (dev()):
			print ('getObjectSlice('+path+', '+cpopath+self.base_path+', '+str(inTime)+')')
		status, obj_time = ull.getObjectSlice(self.idx, path, cpopath + self.base_path, inTime)
		if status:
			print ('Failed to get slice: ' + path + '/' + cpopath + self.base_path + ' (time = ' + str(inTime) + ')')
			return
		status, obj = ull.getObjectFromObject(self.idx, obj_time, 'ALLTIMES', 0)
		if status:
			print ('No data found for slice: ' + path + '/' + cpopath + self.base_path + ' (time = ' + str(inTime) + ', object = ALLTIMES)')
			return
		obj_size = ull.getObjectDim(self.idx, obj)
		self.resize(obj_size)
		for i in range(obj_size):
			self.array[i].getTimedElt(path, self.base_path, i, obj)
		ull.releaseObject(self.idx, obj_time)
		if (dev()):
			print ('getObject('+path+', '+cpopath+self.base_path+', NON_TIMED)')
		status, obj = ull.getObject(self.idx, path, cpopath + self.base_path, NON_TIMED)
		if status:
			print ('Failed to get data: ' + path + '/' + cpopath + self.base_path + ' (NON_TIMED)')
			return
		obj_size = ull.getObjectDim(self.idx, obj)
		if (obj_size != 0):
			if (len(self.array) == 0):
				self.resize(obj_size)
			if (obj_size != len(self.array)):
				print ('error in getSlice: wrong size of object '+ path + '/' + cpopath +self.base_path + ', (NON-TIMED part size =  ' + str(obj_size) + ') != (TIMED part size = ' + str(len(self.array)) +')')
			else:
				for i in range(obj_size):
					self.array[i].getNonTimedElt(path, self.base_path, i, obj)
		ull.releaseObject(self.idx, obj)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function build_non_resampled_data') 
		list=[]
		if nbslice > 0:
			if (dev()):
				print ('getObject('+path+', '+cpopath+self.base_path+', TIMED)')
			status, obj_time = ull.getObject(self.idx, path, cpopath + self.base_path, TIMED)
			if status:
				print ('Failed to get data: ' + path + '/' + cpopath + self.base_path + ' (TIMED)')
				for i in range(nbslice):
					list.append(boundarystruct_arrayrz1Dexp(self.base_path))
				return list
			for n in range(nbslice):
				status, obj = ull.getObjectFromObject(self.idx, obj_time, 'ALLTIMES', n)
				if status:
					print ('Failed to get object[' + n + '] from timed array of structures: ' + path + '/' + cpopath + self.base_path + ' (time = ' + str(inTime) + ', object = ALLTIMES)')
					list.append(boundarystruct_arrayrz1Dexp(self.base_path))
					continue
				obj_size = ull.getObjectDim(self.idx, obj)
				slice = boundarystruct_arrayrz1Dexp(self.base_path)
				slice.setExpIdx(self.idx)
				slice.resize(obj_size)
				for i in range(obj_size):
					slice.array[i].getTimedElt(path, self.base_path, i, obj)
				list.append(slice)
			ull.releaseObject(self.idx, obj_time)
			if (dev()):
				print ('getObject('+path+', '+cpopath+self.base_path+', NON_TIMED)')
			status, obj = ull.getObject(self.idx, path, cpopath + self.base_path, NON_TIMED)
			if status:
				print ('Failed to get data: ' + path + '/' + cpopath + self.base_path + ' (NON_TIMED)')
				return list
			obj_size = ull.getObjectDim(self.idx, obj)
			for n in range(nbslice):
				if (obj_size != 0):
					if (len(list[n].array) == 0):
						list[n].resize(obj_size)
					if (obj_size != len(list[n].array)):
						print ('error in get: wrong size of object at '+path+'/'+cpopath+self.base_path + ', (NON-TIMED part size =  ' + str(obj_size) + ') != (TIMED part size = ' + str(len(list[n].array)) +')')
					else:
						for i in range(obj_size):
							if list[n]:
								list[n].array[i].getNonTimedElt(path, self.base_path, i, obj)
			ull.releaseObject(self.idx, obj)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function putTimedElt') 
		if (dev()):
			print ('beginObject idx=%d' %(self.idx)) 
		if (dev()):
			print ('beginObject('+str(obj)+', '+str(i)+', '+path+'/'+cpopath+', TIMED)')
		obj2 = ull.beginObject(self.idx, obj, i, cpopath, TIMED)
		if (dev()):
			print ('obj = ' + str(obj)) 
		for j in range(len(self.array)):
			if (dev()):
				print ('struct_array loop elt %d' %(j)) 
			obj2 = self.array[j].putTimedElt(path, self.base_path, j, obj2)
		if (dev()):
			print ('putObjectInObject('+str(self.idx)+','+str(obj)+','+cpopath+','+str(i)+','+str(obj2)+')')
		if (dev()):
			print ('putObjectInObject('+str(obj)+', '+cpopath+', '+str(i)+', '+str(obj2)+')')
		obj = ull.putObjectInObject(self.idx, obj, cpopath, i, obj2)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function getTimedElt') 
		if (dev()):
			print ('getObjectFromObject('+str(obj)+', '+cpopath+', '+str(i)+')')
		status, obj2 = ull.getObjectFromObject(self.idx, obj, cpopath, i)
		if status:
			print ('No data found for timed array of structures: ' + path + '/' + cpopath)
			return
		obj_size = ull.getObjectDim(self.idx, obj2)
		if (len(self.array)>0):
			if (obj_size != 0) and (len(self.array) != obj_size) and (len(self.array) != 0):
				print ('error in getTimedElt: wrong size of object at '+path+'/'+cpopath+ ', (current part size =  ' + str(obj_size) + ') != (existing part size = ' + str(len(self.array)) +')')
		else:
			self.resize(obj_size)
		for j in range(obj_size):
			self.array[j].getTimedElt(path, self.base_path, j, obj2)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function putNonTimedElt') 
		if (dev()):
			print ('beginObject idx=%d' %(self.idx)) 
		if (dev()):
			print ('beginObject('+str(obj)+', '+str(i)+', '+path+'/'+cpopath+', NON_TIMED)')
		obj2 = ull.beginObject(self.idx, obj, i, cpopath, NON_TIMED)
		if (dev()):
			print ('obj = ' + str(obj)) 
		for j in range(len(self.array)):
			if (dev()):
				print ('struct_array loop elt %d' %(j) )
			obj2 = self.array[j].putNonTimedElt(path, self.base_path, j, obj2)
		if (dev()):
			print ('putObjectInObject('+str(self.idx)+','+str(obj)+','+cpopath+','+str(i)+','+str(obj2)+')')
		obj = ull.putObjectInObject(self.idx, obj, cpopath, i, obj2)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type boundarystruct_arrayrz1Dexp, run function getNonTimedElt') 
		if (dev()):
			print ('getObjectFromObject('+str(obj)+', '+cpopath+', '+str(i)+')')
		status, obj2 = ull.getObjectFromObject(self.idx, obj, cpopath, i)
		if status:
			print ('No data found for non-timed array of structures: ' + path + '/' + cpopath)
			return
		obj_size = ull.getObjectDim(self.idx, obj2)
		if (len(self.array)>0):
			if (obj_size != 0) and (len(self.array) != obj_size) and (len(self.array) != 0):
				print ('error in getNonTimedElt: wrong size of object at '+path+'/'+cpopath+ ', (NON-TIMED part size =  ' + str(obj_size) + ') != (TIMED part size = ' + str(len(self.array)) +')')
		else:
			self.resize(obj_size)
		for j in range(obj_size):
			self.array[j].getNonTimedElt(path, self.base_path, j, obj2)


class boundarystruct_arrayrz1DexpObj:
	'''
	class boundarystruct_arrayrz1DexpObj
	RZ description of the plasma boundary; This is formally declared as an array of structure to allow for time-dependent size of the R and Z vectors in the sub-structure below. However, boundary must be allocated to size 1. Time-dependent;

	Attributes:
	- r : numpy.ndarray 1D with float
	   Major radius [m]. Vector(npoints). Time-dependent
	- z : numpy.ndarray 1D with float
	   Altitude [m]. Vector(npoints). Time-dependent
	'''

	def __init__(self, base_path_in='boundary'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = numpy.zeros(0, numpy.float64, order='C')
		self.z = numpy.zeros(0, numpy.float64, order='C')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class boundarystruct_arrayrz1DexpObj\n'
		s = self.r.__str__()
		ret = ret + space + 'Attribute r\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.z.__str__()
		ret = ret + space + 'Attribute z\n' + space + s.replace('\n', '\n'+space) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type boundarystruct_arrayrz1DexpObj, run function putTimedElt') 
		cpopath = cpopath + '/'
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'r', i, numpy.array(self.r).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'z', i, numpy.array(self.z).astype(numpy.float64))
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type boundarystruct_arrayrz1DexpObj, run function getTimedElt') 
		cpopath = cpopath + '/'
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type boundarystruct_arrayrz1DexpObj, run function putNonTimedElt') 
		cpopath = cpopath + '/'
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type boundarystruct_arrayrz1DexpObj, run function getNonTimedElt') 
		cpopath = cpopath + '/'


class geom_axisstructurerz0D:
	'''
	class geom_axisstructurerz0D
	RZ position of the geometric axis (defined as (Rmin+Rmax) / 2 and (Zmin+Zmax) / 2 of the boundary) [m]; Time-dependent; Scalar

	Attributes:
	- r : float
	   Major radius [m]
	- z : float
	   Altitude [m]
	'''

	def __init__(self, base_path_in='geom_axis'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = EMPTY_DOUBLE
		self.z = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class geom_axisstructurerz0D\n'
		ret = ret + space + 'Attribute r: ' + str(self.r) + '\n'
		ret = ret + space + 'Attribute z: ' + str(self.z) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type geom_axisstructurerz0D, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'r', self.r, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'z', self.z, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type geom_axisstructurerz0D, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'r', self.r)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'z', self.z)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type geom_axisstructurerz0D, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type geom_axisstructurerz0D, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_r, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'r', inTime, interpolMode)
		check_status(status)
		if not status:
			self.r = ret_r
			self.cpoTime = retTime
		status, ret_z, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'z', inTime, interpolMode)
		check_status(status)
		if not status:
			self.z = ret_z
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type geom_axisstructurerz0D, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, rList = ull.getVect1DDouble(self.idx, path, cpopath + 'r')
			if len(rList) == 0:
				rList = numpy.resize(rList, (nbslice))
			check_status(status)
			status, zList = ull.getVect1DDouble(self.idx, path, cpopath + 'z')
			if len(zList) == 0:
				zList = numpy.resize(zList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = geom_axisstructurerz0D(self.base_path)
				slice.setExpIdx(self.idx)
				slice.r = rList[i].copy().astype(float)
				slice.z = zList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type geom_axisstructurerz0DObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r', i, self.r)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'z', i, self.z)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type geom_axisstructurerz0DObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type geom_axisstructurerz0DObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type geom_axisstructurerz0DObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'r')
		ull.deleteData(self.idx, path, cpopath + 'z')


class xptsstruct_arrayrz1Dexp:
	'''
	class xptsstruct_arrayrz1Dexp
	Position of the Xpoints, first is the active xpoint if diverted [m]; This is formally declared as an array of structure to allow for time-dependent size of the R and Z vectors in the sub-structure below. However, xpts must be allocated to size 1. Time-dependent;

	Attributes:
	- array : list of xptsstruct_arrayrz1DexpObj 
	'''

	def __init__(self, base_path_in='xpts'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.array = []
	def __getitem__(self, key):
		return self.array[key]
	def __len__(self):
		return len(self.array)
	def __iter__(self):
		return self.array.__iter__()

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class xptsstruct_arrayrz1Dexp\n'
		for i in range(len(self.array)):
			ret = ret + space + 'xptsstruct_arrayrz1Dexp[%d] = \n' %(i) + self.array[i].__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		for i in range(len(self.array)):
			self.array[i].setExpIdx(idx)

	def resize(self, nbelt):
		self.array = []
		for i in range(nbelt):
			self.array.append(xptsstruct_arrayrz1DexpObj(self.base_path))
			self.array[i].setExpIdx(self.idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function putSlice') 
		if (dev()):
			print ('beginObject(None, 0, '+path+'/'+cpopath+self.base_path+', TIMED)')
		obj_time = ull.beginObject(self.idx, None, 0, path + '/' + cpopath + self.base_path, TIMED)
		obj = ull.beginObject(self.idx, obj_time, 0, 'ALLTIMES', TIMED)
		for i in range(len(self.array)):
			obj = self.array[i].putTimedElt(path, self.base_path, i, obj)
		obj_time = ull.putObjectInObject(self.idx, obj_time, 'ALLTIMES', 0, obj)
		if (dev()):
			print ('putObjectSlice('+path+', '+cpopath+self.base_path+', '+str(self.cpoTime)+', '+str(obj_time)+')')
		status = ull.putObjectSlice(self.idx, path, cpopath + self.base_path, self.cpoTime, obj_time)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function replaceLastSlice') 
		if (dev()):
			print ('beginObject(None, 0, '+path+'/'+cpopath+self.base_path+', TIMED)')
		obj = ull.beginObject(self.idx, None, 0, path + '/' + cpopath + self.base_path, TIMED)
		for i in range(len(self.array)):
			obj = self.array[i].putTimedElt(path, self.base_path, i, obj)
		if (dev()):
			print ('replaceLastObjectSlice('+path+', '+cpopath+self.base_path+', '+str(obj)+')')
		status = ull.replaceLastObjectSlice(self.idx, path, cpopath + self.base_path, obj)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function putNonTimed') 
		if (dev()):
			print ('beginObject(None, 0, '+path+'/'+cpopath+self.base_path+', NON_TIMED)')
		obj = ull.beginObject(self.idx, None, 0, path + '/' + cpopath + self.base_path, NON_TIMED)
		for i in range(len(self.array)):
			obj = self.array[i].putNonTimedElt(path, self.base_path, i, obj)
		if (dev()):
			print ('putObject('+path+', '+cpopath+self.base_path+', '+str(obj)+', NON_TIMED)')
		status = ull.putObject(self.idx, path, cpopath + self.base_path, obj, NON_TIMED)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function getSlice') 
		if (dev()):
			print ('getObjectSlice('+path+', '+cpopath+self.base_path+', '+str(inTime)+')')
		status, obj_time = ull.getObjectSlice(self.idx, path, cpopath + self.base_path, inTime)
		if status:
			print ('Failed to get slice: ' + path + '/' + cpopath + self.base_path + ' (time = ' + str(inTime) + ')')
			return
		status, obj = ull.getObjectFromObject(self.idx, obj_time, 'ALLTIMES', 0)
		if status:
			print ('No data found for slice: ' + path + '/' + cpopath + self.base_path + ' (time = ' + str(inTime) + ', object = ALLTIMES)')
			return
		obj_size = ull.getObjectDim(self.idx, obj)
		self.resize(obj_size)
		for i in range(obj_size):
			self.array[i].getTimedElt(path, self.base_path, i, obj)
		ull.releaseObject(self.idx, obj_time)
		if (dev()):
			print ('getObject('+path+', '+cpopath+self.base_path+', NON_TIMED)')
		status, obj = ull.getObject(self.idx, path, cpopath + self.base_path, NON_TIMED)
		if status:
			print ('Failed to get data: ' + path + '/' + cpopath + self.base_path + ' (NON_TIMED)')
			return
		obj_size = ull.getObjectDim(self.idx, obj)
		if (obj_size != 0):
			if (len(self.array) == 0):
				self.resize(obj_size)
			if (obj_size != len(self.array)):
				print ('error in getSlice: wrong size of object '+ path + '/' + cpopath +self.base_path + ', (NON-TIMED part size =  ' + str(obj_size) + ') != (TIMED part size = ' + str(len(self.array)) +')')
			else:
				for i in range(obj_size):
					self.array[i].getNonTimedElt(path, self.base_path, i, obj)
		ull.releaseObject(self.idx, obj)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function build_non_resampled_data') 
		list=[]
		if nbslice > 0:
			if (dev()):
				print ('getObject('+path+', '+cpopath+self.base_path+', TIMED)')
			status, obj_time = ull.getObject(self.idx, path, cpopath + self.base_path, TIMED)
			if status:
				print ('Failed to get data: ' + path + '/' + cpopath + self.base_path + ' (TIMED)')
				for i in range(nbslice):
					list.append(xptsstruct_arrayrz1Dexp(self.base_path))
				return list
			for n in range(nbslice):
				status, obj = ull.getObjectFromObject(self.idx, obj_time, 'ALLTIMES', n)
				if status:
					print ('Failed to get object[' + n + '] from timed array of structures: ' + path + '/' + cpopath + self.base_path + ' (time = ' + str(inTime) + ', object = ALLTIMES)')
					list.append(xptsstruct_arrayrz1Dexp(self.base_path))
					continue
				obj_size = ull.getObjectDim(self.idx, obj)
				slice = xptsstruct_arrayrz1Dexp(self.base_path)
				slice.setExpIdx(self.idx)
				slice.resize(obj_size)
				for i in range(obj_size):
					slice.array[i].getTimedElt(path, self.base_path, i, obj)
				list.append(slice)
			ull.releaseObject(self.idx, obj_time)
			if (dev()):
				print ('getObject('+path+', '+cpopath+self.base_path+', NON_TIMED)')
			status, obj = ull.getObject(self.idx, path, cpopath + self.base_path, NON_TIMED)
			if status:
				print ('Failed to get data: ' + path + '/' + cpopath + self.base_path + ' (NON_TIMED)')
				return list
			obj_size = ull.getObjectDim(self.idx, obj)
			for n in range(nbslice):
				if (obj_size != 0):
					if (len(list[n].array) == 0):
						list[n].resize(obj_size)
					if (obj_size != len(list[n].array)):
						print ('error in get: wrong size of object at '+path+'/'+cpopath+self.base_path + ', (NON-TIMED part size =  ' + str(obj_size) + ') != (TIMED part size = ' + str(len(list[n].array)) +')')
					else:
						for i in range(obj_size):
							if list[n]:
								list[n].array[i].getNonTimedElt(path, self.base_path, i, obj)
			ull.releaseObject(self.idx, obj)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function putTimedElt') 
		if (dev()):
			print ('beginObject idx=%d' %(self.idx)) 
		if (dev()):
			print ('beginObject('+str(obj)+', '+str(i)+', '+path+'/'+cpopath+', TIMED)')
		obj2 = ull.beginObject(self.idx, obj, i, cpopath, TIMED)
		if (dev()):
			print ('obj = ' + str(obj)) 
		for j in range(len(self.array)):
			if (dev()):
				print ('struct_array loop elt %d' %(j)) 
			obj2 = self.array[j].putTimedElt(path, self.base_path, j, obj2)
		if (dev()):
			print ('putObjectInObject('+str(self.idx)+','+str(obj)+','+cpopath+','+str(i)+','+str(obj2)+')')
		if (dev()):
			print ('putObjectInObject('+str(obj)+', '+cpopath+', '+str(i)+', '+str(obj2)+')')
		obj = ull.putObjectInObject(self.idx, obj, cpopath, i, obj2)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function getTimedElt') 
		if (dev()):
			print ('getObjectFromObject('+str(obj)+', '+cpopath+', '+str(i)+')')
		status, obj2 = ull.getObjectFromObject(self.idx, obj, cpopath, i)
		if status:
			print ('No data found for timed array of structures: ' + path + '/' + cpopath)
			return
		obj_size = ull.getObjectDim(self.idx, obj2)
		if (len(self.array)>0):
			if (obj_size != 0) and (len(self.array) != obj_size) and (len(self.array) != 0):
				print ('error in getTimedElt: wrong size of object at '+path+'/'+cpopath+ ', (current part size =  ' + str(obj_size) + ') != (existing part size = ' + str(len(self.array)) +')')
		else:
			self.resize(obj_size)
		for j in range(obj_size):
			self.array[j].getTimedElt(path, self.base_path, j, obj2)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function putNonTimedElt') 
		if (dev()):
			print ('beginObject idx=%d' %(self.idx)) 
		if (dev()):
			print ('beginObject('+str(obj)+', '+str(i)+', '+path+'/'+cpopath+', NON_TIMED)')
		obj2 = ull.beginObject(self.idx, obj, i, cpopath, NON_TIMED)
		if (dev()):
			print ('obj = ' + str(obj)) 
		for j in range(len(self.array)):
			if (dev()):
				print ('struct_array loop elt %d' %(j) )
			obj2 = self.array[j].putNonTimedElt(path, self.base_path, j, obj2)
		if (dev()):
			print ('putObjectInObject('+str(self.idx)+','+str(obj)+','+cpopath+','+str(i)+','+str(obj2)+')')
		obj = ull.putObjectInObject(self.idx, obj, cpopath, i, obj2)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('field '+self.base_path+' of type xptsstruct_arrayrz1Dexp, run function getNonTimedElt') 
		if (dev()):
			print ('getObjectFromObject('+str(obj)+', '+cpopath+', '+str(i)+')')
		status, obj2 = ull.getObjectFromObject(self.idx, obj, cpopath, i)
		if status:
			print ('No data found for non-timed array of structures: ' + path + '/' + cpopath)
			return
		obj_size = ull.getObjectDim(self.idx, obj2)
		if (len(self.array)>0):
			if (obj_size != 0) and (len(self.array) != obj_size) and (len(self.array) != 0):
				print ('error in getNonTimedElt: wrong size of object at '+path+'/'+cpopath+ ', (NON-TIMED part size =  ' + str(obj_size) + ') != (TIMED part size = ' + str(len(self.array)) +')')
		else:
			self.resize(obj_size)
		for j in range(obj_size):
			self.array[j].getNonTimedElt(path, self.base_path, j, obj2)


class xptsstruct_arrayrz1DexpObj:
	'''
	class xptsstruct_arrayrz1DexpObj
	Position of the Xpoints, first is the active xpoint if diverted [m]; This is formally declared as an array of structure to allow for time-dependent size of the R and Z vectors in the sub-structure below. However, xpts must be allocated to size 1. Time-dependent;

	Attributes:
	- r : numpy.ndarray 1D with float
	   Major radius [m]. Vector(npoints). Time-dependent
	- z : numpy.ndarray 1D with float
	   Altitude [m]. Vector(npoints). Time-dependent
	'''

	def __init__(self, base_path_in='xpts'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = numpy.zeros(0, numpy.float64, order='C')
		self.z = numpy.zeros(0, numpy.float64, order='C')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class xptsstruct_arrayrz1DexpObj\n'
		s = self.r.__str__()
		ret = ret + space + 'Attribute r\n' + space + s.replace('\n', '\n'+space) + '\n'
		s = self.z.__str__()
		ret = ret + space + 'Attribute z\n' + space + s.replace('\n', '\n'+space) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xptsstruct_arrayrz1DexpObj, run function putTimedElt') 
		cpopath = cpopath + '/'
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'r', i, numpy.array(self.r).astype(numpy.float64))
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'z', i, numpy.array(self.z).astype(numpy.float64))
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xptsstruct_arrayrz1DexpObj, run function getTimedElt') 
		cpopath = cpopath + '/'
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xptsstruct_arrayrz1DexpObj, run function putNonTimedElt') 
		cpopath = cpopath + '/'
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xptsstruct_arrayrz1DexpObj, run function getNonTimedElt') 
		cpopath = cpopath + '/'


class left_low_ststructurerz0D:
	'''
	class left_low_ststructurerz0D
	Position of the lower left strike point [m]; Time-dependent; Scalar

	Attributes:
	- r : float
	   Major radius [m]
	- z : float
	   Altitude [m]
	'''

	def __init__(self, base_path_in='left_low_st'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = EMPTY_DOUBLE
		self.z = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class left_low_ststructurerz0D\n'
		ret = ret + space + 'Attribute r: ' + str(self.r) + '\n'
		ret = ret + space + 'Attribute z: ' + str(self.z) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type left_low_ststructurerz0D, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'r', self.r, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'z', self.z, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type left_low_ststructurerz0D, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'r', self.r)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'z', self.z)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type left_low_ststructurerz0D, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type left_low_ststructurerz0D, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_r, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'r', inTime, interpolMode)
		check_status(status)
		if not status:
			self.r = ret_r
			self.cpoTime = retTime
		status, ret_z, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'z', inTime, interpolMode)
		check_status(status)
		if not status:
			self.z = ret_z
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type left_low_ststructurerz0D, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, rList = ull.getVect1DDouble(self.idx, path, cpopath + 'r')
			if len(rList) == 0:
				rList = numpy.resize(rList, (nbslice))
			check_status(status)
			status, zList = ull.getVect1DDouble(self.idx, path, cpopath + 'z')
			if len(zList) == 0:
				zList = numpy.resize(zList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = left_low_ststructurerz0D(self.base_path)
				slice.setExpIdx(self.idx)
				slice.r = rList[i].copy().astype(float)
				slice.z = zList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_low_ststructurerz0DObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r', i, self.r)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'z', i, self.z)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_low_ststructurerz0DObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_low_ststructurerz0DObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_low_ststructurerz0DObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'r')
		ull.deleteData(self.idx, path, cpopath + 'z')


class right_low_ststructurerz0D:
	'''
	class right_low_ststructurerz0D
	Position of the lower right strike point [m]; Time-dependent; Scalar

	Attributes:
	- r : float
	   Major radius [m]
	- z : float
	   Altitude [m]
	'''

	def __init__(self, base_path_in='right_low_st'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = EMPTY_DOUBLE
		self.z = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class right_low_ststructurerz0D\n'
		ret = ret + space + 'Attribute r: ' + str(self.r) + '\n'
		ret = ret + space + 'Attribute z: ' + str(self.z) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type right_low_ststructurerz0D, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'r', self.r, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'z', self.z, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type right_low_ststructurerz0D, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'r', self.r)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'z', self.z)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type right_low_ststructurerz0D, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type right_low_ststructurerz0D, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_r, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'r', inTime, interpolMode)
		check_status(status)
		if not status:
			self.r = ret_r
			self.cpoTime = retTime
		status, ret_z, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'z', inTime, interpolMode)
		check_status(status)
		if not status:
			self.z = ret_z
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type right_low_ststructurerz0D, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, rList = ull.getVect1DDouble(self.idx, path, cpopath + 'r')
			if len(rList) == 0:
				rList = numpy.resize(rList, (nbslice))
			check_status(status)
			status, zList = ull.getVect1DDouble(self.idx, path, cpopath + 'z')
			if len(zList) == 0:
				zList = numpy.resize(zList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = right_low_ststructurerz0D(self.base_path)
				slice.setExpIdx(self.idx)
				slice.r = rList[i].copy().astype(float)
				slice.z = zList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_low_ststructurerz0DObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r', i, self.r)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'z', i, self.z)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_low_ststructurerz0DObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_low_ststructurerz0DObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_low_ststructurerz0DObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'r')
		ull.deleteData(self.idx, path, cpopath + 'z')


class left_up_ststructurerz0D:
	'''
	class left_up_ststructurerz0D
	Position of the upper left strike point [m]; Time-dependent; Scalar

	Attributes:
	- r : float
	   Major radius [m]
	- z : float
	   Altitude [m]
	'''

	def __init__(self, base_path_in='left_up_st'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = EMPTY_DOUBLE
		self.z = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class left_up_ststructurerz0D\n'
		ret = ret + space + 'Attribute r: ' + str(self.r) + '\n'
		ret = ret + space + 'Attribute z: ' + str(self.z) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type left_up_ststructurerz0D, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'r', self.r, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'z', self.z, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type left_up_ststructurerz0D, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'r', self.r)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'z', self.z)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type left_up_ststructurerz0D, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type left_up_ststructurerz0D, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_r, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'r', inTime, interpolMode)
		check_status(status)
		if not status:
			self.r = ret_r
			self.cpoTime = retTime
		status, ret_z, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'z', inTime, interpolMode)
		check_status(status)
		if not status:
			self.z = ret_z
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type left_up_ststructurerz0D, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, rList = ull.getVect1DDouble(self.idx, path, cpopath + 'r')
			if len(rList) == 0:
				rList = numpy.resize(rList, (nbslice))
			check_status(status)
			status, zList = ull.getVect1DDouble(self.idx, path, cpopath + 'z')
			if len(zList) == 0:
				zList = numpy.resize(zList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = left_up_ststructurerz0D(self.base_path)
				slice.setExpIdx(self.idx)
				slice.r = rList[i].copy().astype(float)
				slice.z = zList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_up_ststructurerz0DObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r', i, self.r)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'z', i, self.z)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_up_ststructurerz0DObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_up_ststructurerz0DObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type left_up_ststructurerz0DObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'r')
		ull.deleteData(self.idx, path, cpopath + 'z')


class right_up_ststructurerz0D:
	'''
	class right_up_ststructurerz0D
	Position of the upper right strike point [m]; Time-dependent; Scalar

	Attributes:
	- r : float
	   Major radius [m]
	- z : float
	   Altitude [m]
	'''

	def __init__(self, base_path_in='right_up_st'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = EMPTY_DOUBLE
		self.z = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class right_up_ststructurerz0D\n'
		ret = ret + space + 'Attribute r: ' + str(self.r) + '\n'
		ret = ret + space + 'Attribute z: ' + str(self.z) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type right_up_ststructurerz0D, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'r', self.r, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'z', self.z, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type right_up_ststructurerz0D, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'r', self.r)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'z', self.z)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type right_up_ststructurerz0D, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type right_up_ststructurerz0D, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_r, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'r', inTime, interpolMode)
		check_status(status)
		if not status:
			self.r = ret_r
			self.cpoTime = retTime
		status, ret_z, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'z', inTime, interpolMode)
		check_status(status)
		if not status:
			self.z = ret_z
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type right_up_ststructurerz0D, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, rList = ull.getVect1DDouble(self.idx, path, cpopath + 'r')
			if len(rList) == 0:
				rList = numpy.resize(rList, (nbslice))
			check_status(status)
			status, zList = ull.getVect1DDouble(self.idx, path, cpopath + 'z')
			if len(zList) == 0:
				zList = numpy.resize(zList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = right_up_ststructurerz0D(self.base_path)
				slice.setExpIdx(self.idx)
				slice.r = rList[i].copy().astype(float)
				slice.z = zList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_up_ststructurerz0DObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r', i, self.r)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'z', i, self.z)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_up_ststructurerz0DObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_up_ststructurerz0DObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type right_up_ststructurerz0DObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'r')
		ull.deleteData(self.idx, path, cpopath + 'z')


class active_limitstructurerz0D:
	'''
	class active_limitstructurerz0D
	Position of the active limiter point (point of the plasma boundary in contact with the limiter) [m]; Set R = 0 for X-point plasma; Time-dependent; Scalar

	Attributes:
	- r : float
	   Major radius [m]
	- z : float
	   Altitude [m]
	'''

	def __init__(self, base_path_in='active_limit'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.r = EMPTY_DOUBLE
		self.z = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class active_limitstructurerz0D\n'
		ret = ret + space + 'Attribute r: ' + str(self.r) + '\n'
		ret = ret + space + 'Attribute z: ' + str(self.z) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type active_limitstructurerz0D, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'r', self.r, self.cpoTime)
		check_status(status)
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'z', self.z, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type active_limitstructurerz0D, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'r', self.r)
		check_status(status)
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'z', self.z)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type active_limitstructurerz0D, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type active_limitstructurerz0D, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_r, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'r', inTime, interpolMode)
		check_status(status)
		if not status:
			self.r = ret_r
			self.cpoTime = retTime
		status, ret_z, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'z', inTime, interpolMode)
		check_status(status)
		if not status:
			self.z = ret_z
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type active_limitstructurerz0D, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, rList = ull.getVect1DDouble(self.idx, path, cpopath + 'r')
			if len(rList) == 0:
				rList = numpy.resize(rList, (nbslice))
			check_status(status)
			status, zList = ull.getVect1DDouble(self.idx, path, cpopath + 'z')
			if len(zList) == 0:
				zList = numpy.resize(zList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = active_limitstructurerz0D(self.base_path)
				slice.setExpIdx(self.idx)
				slice.r = rList[i].copy().astype(float)
				slice.z = zList[i].copy().astype(float)
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type active_limitstructurerz0DObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r', i, self.r)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'z', i, self.z)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type active_limitstructurerz0DObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r') 
			print ('obj = ' + str(obj))
		status, ret_r = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r', i)
		check_status(status)
		if not status:
			self.r = ret_r
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'z') 
			print ('obj = ' + str(obj))
		status, ret_z = ull.getDoubleFromObject(self.idx, obj, cpopath + 'z', i)
		check_status(status)
		if not status:
			self.z = ret_z

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type active_limitstructurerz0DObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type active_limitstructurerz0DObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'r')
		ull.deleteData(self.idx, path, cpopath + 'z')


class global_paramstructurescenario_global:
	'''
	class global_paramstructurescenario_global
	Global scalar values

	Attributes:
	- ip : class ipstructurescenario_ref
	   Plasma current [A]. Time-dependent.
	- dip_dt : class dip_dtstructurescenario_ref
	   time derivative of plasma current [A/s]. Time-dependent.
	- beta_pol : class beta_polstructurescenario_ref
	   poloidal beta []. Time-dependent.
	- beta_tor : class beta_torstructurescenario_ref
	   toroidal beta []. Time-dependent.
	- beta_normal : class beta_normalstructurescenario_ref
	   normalised beta []. Time-dependent.
	- li : class listructurescenario_ref
	   internal inductance (definition 3). Time-dependent.
	- volume : class volumestructurescenario_ref
	   total plasma volume [m^3]. Time-dependent.
	- area_pol : class area_polstructurescenario_ref
	   area poloidal cross section [m^2]. Time-dependent.
	- area_ext : class area_extstructurescenario_ref
	   external plasma surface [m^2]. Time-dependent.
	- len_sepa : class len_sepastructurescenario_ref
	   length of the separatrix [m]. Time-dependent.
	- beta_pol_th : class beta_pol_thstructurescenario_ref
	   poloidal beta, thermal contribution []. Time-dependent.
	- beta_tor_th : class beta_tor_thstructurescenario_ref
	   toroidal beta, thermal contribution []. Time-dependent.
	- beta_n_th : class beta_n_thstructurescenario_ref
	   normalised beta, thermal contribution []. Time-dependent.
	- disruption : class disruptionstructurescenario_ref
	   flag for disruption (set to 1 for disruption, oterwise equal 0) []. Time-dependent.
	- mode_h : class mode_hstructurescenario_ref
	   confinement mode verus time:  0 = L-mode et 1 = H-mode []. Time-dependent.
	- s_alpha : class s_alphastructurescenario_ref
	   total number of alpha fusion  particules from D-T ractions  per second [s^-1]. Time-dependent.
	'''

	def __init__(self, base_path_in='global_param'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.ip = ipstructurescenario_ref('ip')
		self.dip_dt = dip_dtstructurescenario_ref('dip_dt')
		self.beta_pol = beta_polstructurescenario_ref('beta_pol')
		self.beta_tor = beta_torstructurescenario_ref('beta_tor')
		self.beta_normal = beta_normalstructurescenario_ref('beta_normal')
		self.li = listructurescenario_ref('li')
		self.volume = volumestructurescenario_ref('volume')
		self.area_pol = area_polstructurescenario_ref('area_pol')
		self.area_ext = area_extstructurescenario_ref('area_ext')
		self.len_sepa = len_sepastructurescenario_ref('len_sepa')
		self.beta_pol_th = beta_pol_thstructurescenario_ref('beta_pol_th')
		self.beta_tor_th = beta_tor_thstructurescenario_ref('beta_tor_th')
		self.beta_n_th = beta_n_thstructurescenario_ref('beta_n_th')
		self.disruption = disruptionstructurescenario_ref('disruption')
		self.mode_h = mode_hstructurescenario_ref('mode_h')
		self.s_alpha = s_alphastructurescenario_ref('s_alpha')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class global_paramstructurescenario_global\n'
		ret = ret + space + 'Attribute ip\n ' + self.ip.__str__(depth+1)
		ret = ret + space + 'Attribute dip_dt\n ' + self.dip_dt.__str__(depth+1)
		ret = ret + space + 'Attribute beta_pol\n ' + self.beta_pol.__str__(depth+1)
		ret = ret + space + 'Attribute beta_tor\n ' + self.beta_tor.__str__(depth+1)
		ret = ret + space + 'Attribute beta_normal\n ' + self.beta_normal.__str__(depth+1)
		ret = ret + space + 'Attribute li\n ' + self.li.__str__(depth+1)
		ret = ret + space + 'Attribute volume\n ' + self.volume.__str__(depth+1)
		ret = ret + space + 'Attribute area_pol\n ' + self.area_pol.__str__(depth+1)
		ret = ret + space + 'Attribute area_ext\n ' + self.area_ext.__str__(depth+1)
		ret = ret + space + 'Attribute len_sepa\n ' + self.len_sepa.__str__(depth+1)
		ret = ret + space + 'Attribute beta_pol_th\n ' + self.beta_pol_th.__str__(depth+1)
		ret = ret + space + 'Attribute beta_tor_th\n ' + self.beta_tor_th.__str__(depth+1)
		ret = ret + space + 'Attribute beta_n_th\n ' + self.beta_n_th.__str__(depth+1)
		ret = ret + space + 'Attribute disruption\n ' + self.disruption.__str__(depth+1)
		ret = ret + space + 'Attribute mode_h\n ' + self.mode_h.__str__(depth+1)
		ret = ret + space + 'Attribute s_alpha\n ' + self.s_alpha.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.ip.setExpIdx(idx)
		self.dip_dt.setExpIdx(idx)
		self.beta_pol.setExpIdx(idx)
		self.beta_tor.setExpIdx(idx)
		self.beta_normal.setExpIdx(idx)
		self.li.setExpIdx(idx)
		self.volume.setExpIdx(idx)
		self.area_pol.setExpIdx(idx)
		self.area_ext.setExpIdx(idx)
		self.len_sepa.setExpIdx(idx)
		self.beta_pol_th.setExpIdx(idx)
		self.beta_tor_th.setExpIdx(idx)
		self.beta_n_th.setExpIdx(idx)
		self.disruption.setExpIdx(idx)
		self.mode_h.setExpIdx(idx)
		self.s_alpha.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type global_paramstructurescenario_global, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ip.cpoTime = self.cpoTime
		self.ip.putSlice(path, cpopath)
		self.dip_dt.cpoTime = self.cpoTime
		self.dip_dt.putSlice(path, cpopath)
		self.beta_pol.cpoTime = self.cpoTime
		self.beta_pol.putSlice(path, cpopath)
		self.beta_tor.cpoTime = self.cpoTime
		self.beta_tor.putSlice(path, cpopath)
		self.beta_normal.cpoTime = self.cpoTime
		self.beta_normal.putSlice(path, cpopath)
		self.li.cpoTime = self.cpoTime
		self.li.putSlice(path, cpopath)
		self.volume.cpoTime = self.cpoTime
		self.volume.putSlice(path, cpopath)
		self.area_pol.cpoTime = self.cpoTime
		self.area_pol.putSlice(path, cpopath)
		self.area_ext.cpoTime = self.cpoTime
		self.area_ext.putSlice(path, cpopath)
		self.len_sepa.cpoTime = self.cpoTime
		self.len_sepa.putSlice(path, cpopath)
		self.beta_pol_th.cpoTime = self.cpoTime
		self.beta_pol_th.putSlice(path, cpopath)
		self.beta_tor_th.cpoTime = self.cpoTime
		self.beta_tor_th.putSlice(path, cpopath)
		self.beta_n_th.cpoTime = self.cpoTime
		self.beta_n_th.putSlice(path, cpopath)
		self.disruption.cpoTime = self.cpoTime
		self.disruption.putSlice(path, cpopath)
		self.mode_h.cpoTime = self.cpoTime
		self.mode_h.putSlice(path, cpopath)
		self.s_alpha.cpoTime = self.cpoTime
		self.s_alpha.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type global_paramstructurescenario_global, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ip.replaceLastSlice(path, cpopath)
		self.dip_dt.replaceLastSlice(path, cpopath)
		self.beta_pol.replaceLastSlice(path, cpopath)
		self.beta_tor.replaceLastSlice(path, cpopath)
		self.beta_normal.replaceLastSlice(path, cpopath)
		self.li.replaceLastSlice(path, cpopath)
		self.volume.replaceLastSlice(path, cpopath)
		self.area_pol.replaceLastSlice(path, cpopath)
		self.area_ext.replaceLastSlice(path, cpopath)
		self.len_sepa.replaceLastSlice(path, cpopath)
		self.beta_pol_th.replaceLastSlice(path, cpopath)
		self.beta_tor_th.replaceLastSlice(path, cpopath)
		self.beta_n_th.replaceLastSlice(path, cpopath)
		self.disruption.replaceLastSlice(path, cpopath)
		self.mode_h.replaceLastSlice(path, cpopath)
		self.s_alpha.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type global_paramstructurescenario_global, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ip.putNonTimed(path, cpopath)
		self.dip_dt.putNonTimed(path, cpopath)
		self.beta_pol.putNonTimed(path, cpopath)
		self.beta_tor.putNonTimed(path, cpopath)
		self.beta_normal.putNonTimed(path, cpopath)
		self.li.putNonTimed(path, cpopath)
		self.volume.putNonTimed(path, cpopath)
		self.area_pol.putNonTimed(path, cpopath)
		self.area_ext.putNonTimed(path, cpopath)
		self.len_sepa.putNonTimed(path, cpopath)
		self.beta_pol_th.putNonTimed(path, cpopath)
		self.beta_tor_th.putNonTimed(path, cpopath)
		self.beta_n_th.putNonTimed(path, cpopath)
		self.disruption.putNonTimed(path, cpopath)
		self.mode_h.putNonTimed(path, cpopath)
		self.s_alpha.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type global_paramstructurescenario_global, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ip.getSlice(path, cpopath, inTime, interpolMode)
		self.dip_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.beta_pol.getSlice(path, cpopath, inTime, interpolMode)
		self.beta_tor.getSlice(path, cpopath, inTime, interpolMode)
		self.beta_normal.getSlice(path, cpopath, inTime, interpolMode)
		self.li.getSlice(path, cpopath, inTime, interpolMode)
		self.volume.getSlice(path, cpopath, inTime, interpolMode)
		self.area_pol.getSlice(path, cpopath, inTime, interpolMode)
		self.area_ext.getSlice(path, cpopath, inTime, interpolMode)
		self.len_sepa.getSlice(path, cpopath, inTime, interpolMode)
		self.beta_pol_th.getSlice(path, cpopath, inTime, interpolMode)
		self.beta_tor_th.getSlice(path, cpopath, inTime, interpolMode)
		self.beta_n_th.getSlice(path, cpopath, inTime, interpolMode)
		self.disruption.getSlice(path, cpopath, inTime, interpolMode)
		self.mode_h.getSlice(path, cpopath, inTime, interpolMode)
		self.s_alpha.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type global_paramstructurescenario_global, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			ipList = self.ip.build_non_resampled_data(path, cpopath, nbslice)
			dip_dtList = self.dip_dt.build_non_resampled_data(path, cpopath, nbslice)
			beta_polList = self.beta_pol.build_non_resampled_data(path, cpopath, nbslice)
			beta_torList = self.beta_tor.build_non_resampled_data(path, cpopath, nbslice)
			beta_normalList = self.beta_normal.build_non_resampled_data(path, cpopath, nbslice)
			liList = self.li.build_non_resampled_data(path, cpopath, nbslice)
			volumeList = self.volume.build_non_resampled_data(path, cpopath, nbslice)
			area_polList = self.area_pol.build_non_resampled_data(path, cpopath, nbslice)
			area_extList = self.area_ext.build_non_resampled_data(path, cpopath, nbslice)
			len_sepaList = self.len_sepa.build_non_resampled_data(path, cpopath, nbslice)
			beta_pol_thList = self.beta_pol_th.build_non_resampled_data(path, cpopath, nbslice)
			beta_tor_thList = self.beta_tor_th.build_non_resampled_data(path, cpopath, nbslice)
			beta_n_thList = self.beta_n_th.build_non_resampled_data(path, cpopath, nbslice)
			disruptionList = self.disruption.build_non_resampled_data(path, cpopath, nbslice)
			mode_hList = self.mode_h.build_non_resampled_data(path, cpopath, nbslice)
			s_alphaList = self.s_alpha.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = global_paramstructurescenario_global(self.base_path)
				slice.setExpIdx(self.idx)
				slice.ip = ipList[i]
				slice.dip_dt = dip_dtList[i]
				slice.beta_pol = beta_polList[i]
				slice.beta_tor = beta_torList[i]
				slice.beta_normal = beta_normalList[i]
				slice.li = liList[i]
				slice.volume = volumeList[i]
				slice.area_pol = area_polList[i]
				slice.area_ext = area_extList[i]
				slice.len_sepa = len_sepaList[i]
				slice.beta_pol_th = beta_pol_thList[i]
				slice.beta_tor_th = beta_tor_thList[i]
				slice.beta_n_th = beta_n_thList[i]
				slice.disruption = disruptionList[i]
				slice.mode_h = mode_hList[i]
				slice.s_alpha = s_alphaList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type global_paramstructurescenario_globalObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.ip.putTimedElt(path, cpopath + 'ip', i, obj)
		obj = self.dip_dt.putTimedElt(path, cpopath + 'dip_dt', i, obj)
		obj = self.beta_pol.putTimedElt(path, cpopath + 'beta_pol', i, obj)
		obj = self.beta_tor.putTimedElt(path, cpopath + 'beta_tor', i, obj)
		obj = self.beta_normal.putTimedElt(path, cpopath + 'beta_normal', i, obj)
		obj = self.li.putTimedElt(path, cpopath + 'li', i, obj)
		obj = self.volume.putTimedElt(path, cpopath + 'volume', i, obj)
		obj = self.area_pol.putTimedElt(path, cpopath + 'area_pol', i, obj)
		obj = self.area_ext.putTimedElt(path, cpopath + 'area_ext', i, obj)
		obj = self.len_sepa.putTimedElt(path, cpopath + 'len_sepa', i, obj)
		obj = self.beta_pol_th.putTimedElt(path, cpopath + 'beta_pol_th', i, obj)
		obj = self.beta_tor_th.putTimedElt(path, cpopath + 'beta_tor_th', i, obj)
		obj = self.beta_n_th.putTimedElt(path, cpopath + 'beta_n_th', i, obj)
		obj = self.disruption.putTimedElt(path, cpopath + 'disruption', i, obj)
		obj = self.mode_h.putTimedElt(path, cpopath + 'mode_h', i, obj)
		obj = self.s_alpha.putTimedElt(path, cpopath + 's_alpha', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type global_paramstructurescenario_globalObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.ip.getTimedElt(path, cpopath + 'ip', i, obj)
		self.dip_dt.getTimedElt(path, cpopath + 'dip_dt', i, obj)
		self.beta_pol.getTimedElt(path, cpopath + 'beta_pol', i, obj)
		self.beta_tor.getTimedElt(path, cpopath + 'beta_tor', i, obj)
		self.beta_normal.getTimedElt(path, cpopath + 'beta_normal', i, obj)
		self.li.getTimedElt(path, cpopath + 'li', i, obj)
		self.volume.getTimedElt(path, cpopath + 'volume', i, obj)
		self.area_pol.getTimedElt(path, cpopath + 'area_pol', i, obj)
		self.area_ext.getTimedElt(path, cpopath + 'area_ext', i, obj)
		self.len_sepa.getTimedElt(path, cpopath + 'len_sepa', i, obj)
		self.beta_pol_th.getTimedElt(path, cpopath + 'beta_pol_th', i, obj)
		self.beta_tor_th.getTimedElt(path, cpopath + 'beta_tor_th', i, obj)
		self.beta_n_th.getTimedElt(path, cpopath + 'beta_n_th', i, obj)
		self.disruption.getTimedElt(path, cpopath + 'disruption', i, obj)
		self.mode_h.getTimedElt(path, cpopath + 'mode_h', i, obj)
		self.s_alpha.getTimedElt(path, cpopath + 's_alpha', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type global_paramstructurescenario_globalObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.ip.putNonTimedElt(path, cpopath + 'ip', i, obj)
		obj = self.dip_dt.putNonTimedElt(path, cpopath + 'dip_dt', i, obj)
		obj = self.beta_pol.putNonTimedElt(path, cpopath + 'beta_pol', i, obj)
		obj = self.beta_tor.putNonTimedElt(path, cpopath + 'beta_tor', i, obj)
		obj = self.beta_normal.putNonTimedElt(path, cpopath + 'beta_normal', i, obj)
		obj = self.li.putNonTimedElt(path, cpopath + 'li', i, obj)
		obj = self.volume.putNonTimedElt(path, cpopath + 'volume', i, obj)
		obj = self.area_pol.putNonTimedElt(path, cpopath + 'area_pol', i, obj)
		obj = self.area_ext.putNonTimedElt(path, cpopath + 'area_ext', i, obj)
		obj = self.len_sepa.putNonTimedElt(path, cpopath + 'len_sepa', i, obj)
		obj = self.beta_pol_th.putNonTimedElt(path, cpopath + 'beta_pol_th', i, obj)
		obj = self.beta_tor_th.putNonTimedElt(path, cpopath + 'beta_tor_th', i, obj)
		obj = self.beta_n_th.putNonTimedElt(path, cpopath + 'beta_n_th', i, obj)
		obj = self.disruption.putNonTimedElt(path, cpopath + 'disruption', i, obj)
		obj = self.mode_h.putNonTimedElt(path, cpopath + 'mode_h', i, obj)
		obj = self.s_alpha.putNonTimedElt(path, cpopath + 's_alpha', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type global_paramstructurescenario_globalObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.ip.getNonTimedElt(path, cpopath + 'ip', i, obj)
		self.dip_dt.getNonTimedElt(path, cpopath + 'dip_dt', i, obj)
		self.beta_pol.getNonTimedElt(path, cpopath + 'beta_pol', i, obj)
		self.beta_tor.getNonTimedElt(path, cpopath + 'beta_tor', i, obj)
		self.beta_normal.getNonTimedElt(path, cpopath + 'beta_normal', i, obj)
		self.li.getNonTimedElt(path, cpopath + 'li', i, obj)
		self.volume.getNonTimedElt(path, cpopath + 'volume', i, obj)
		self.area_pol.getNonTimedElt(path, cpopath + 'area_pol', i, obj)
		self.area_ext.getNonTimedElt(path, cpopath + 'area_ext', i, obj)
		self.len_sepa.getNonTimedElt(path, cpopath + 'len_sepa', i, obj)
		self.beta_pol_th.getNonTimedElt(path, cpopath + 'beta_pol_th', i, obj)
		self.beta_tor_th.getNonTimedElt(path, cpopath + 'beta_tor_th', i, obj)
		self.beta_n_th.getNonTimedElt(path, cpopath + 'beta_n_th', i, obj)
		self.disruption.getNonTimedElt(path, cpopath + 'disruption', i, obj)
		self.mode_h.getNonTimedElt(path, cpopath + 'mode_h', i, obj)
		self.s_alpha.getNonTimedElt(path, cpopath + 's_alpha', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ip.deleteData(path, cpopath)
		self.dip_dt.deleteData(path, cpopath)
		self.beta_pol.deleteData(path, cpopath)
		self.beta_tor.deleteData(path, cpopath)
		self.beta_normal.deleteData(path, cpopath)
		self.li.deleteData(path, cpopath)
		self.volume.deleteData(path, cpopath)
		self.area_pol.deleteData(path, cpopath)
		self.area_ext.deleteData(path, cpopath)
		self.len_sepa.deleteData(path, cpopath)
		self.beta_pol_th.deleteData(path, cpopath)
		self.beta_tor_th.deleteData(path, cpopath)
		self.beta_n_th.deleteData(path, cpopath)
		self.disruption.deleteData(path, cpopath)
		self.mode_h.deleteData(path, cpopath)
		self.s_alpha.deleteData(path, cpopath)


class ipstructurescenario_ref:
	'''
	class ipstructurescenario_ref
	Plasma current [A]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ip'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ipstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ipstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ipstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ipstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ipstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ipstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ipstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ipstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ipstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ipstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ipstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dip_dtstructurescenario_ref:
	'''
	class dip_dtstructurescenario_ref
	time derivative of plasma current [A/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dip_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dip_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dip_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dip_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dip_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dip_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dip_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dip_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dip_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dip_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dip_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dip_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class beta_polstructurescenario_ref:
	'''
	class beta_polstructurescenario_ref
	poloidal beta []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='beta_pol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class beta_polstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_polstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_polstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_polstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type beta_polstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type beta_polstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = beta_polstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_polstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_polstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_polstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_polstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class beta_torstructurescenario_ref:
	'''
	class beta_torstructurescenario_ref
	toroidal beta []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='beta_tor'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class beta_torstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_torstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_torstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_torstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type beta_torstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type beta_torstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = beta_torstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_torstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_torstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_torstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_torstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class beta_normalstructurescenario_ref:
	'''
	class beta_normalstructurescenario_ref
	normalised beta []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='beta_normal'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class beta_normalstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_normalstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_normalstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_normalstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type beta_normalstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type beta_normalstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = beta_normalstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_normalstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_normalstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_normalstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_normalstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class listructurescenario_ref:
	'''
	class listructurescenario_ref
	internal inductance (definition 3). Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='li'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class listructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type listructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type listructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type listructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type listructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type listructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = listructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type listructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type listructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type listructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type listructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class volumestructurescenario_ref:
	'''
	class volumestructurescenario_ref
	total plasma volume [m^3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='volume'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class volumestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type volumestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type volumestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type volumestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type volumestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type volumestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = volumestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type volumestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type volumestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type volumestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type volumestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class area_polstructurescenario_ref:
	'''
	class area_polstructurescenario_ref
	area poloidal cross section [m^2]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='area_pol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class area_polstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type area_polstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type area_polstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type area_polstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type area_polstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type area_polstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = area_polstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_polstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_polstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_polstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_polstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class area_extstructurescenario_ref:
	'''
	class area_extstructurescenario_ref
	external plasma surface [m^2]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='area_ext'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class area_extstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type area_extstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type area_extstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type area_extstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type area_extstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type area_extstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = area_extstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_extstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_extstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_extstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type area_extstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class len_sepastructurescenario_ref:
	'''
	class len_sepastructurescenario_ref
	length of the separatrix [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='len_sepa'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class len_sepastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type len_sepastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type len_sepastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type len_sepastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type len_sepastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type len_sepastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = len_sepastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type len_sepastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type len_sepastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type len_sepastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type len_sepastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class beta_pol_thstructurescenario_ref:
	'''
	class beta_pol_thstructurescenario_ref
	poloidal beta, thermal contribution []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='beta_pol_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class beta_pol_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_pol_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_pol_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_pol_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type beta_pol_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type beta_pol_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = beta_pol_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_pol_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_pol_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_pol_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_pol_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class beta_tor_thstructurescenario_ref:
	'''
	class beta_tor_thstructurescenario_ref
	toroidal beta, thermal contribution []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='beta_tor_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class beta_tor_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_tor_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_tor_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_tor_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type beta_tor_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type beta_tor_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = beta_tor_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_tor_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_tor_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_tor_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_tor_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class beta_n_thstructurescenario_ref:
	'''
	class beta_n_thstructurescenario_ref
	normalised beta, thermal contribution []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='beta_n_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class beta_n_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_n_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_n_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type beta_n_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type beta_n_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type beta_n_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = beta_n_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_n_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_n_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_n_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type beta_n_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class disruptionstructurescenario_ref:
	'''
	class disruptionstructurescenario_ref
	flag for disruption (set to 1 for disruption, oterwise equal 0) []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='disruption'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class disruptionstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type disruptionstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type disruptionstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type disruptionstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type disruptionstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type disruptionstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = disruptionstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type disruptionstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type disruptionstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type disruptionstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type disruptionstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class mode_hstructurescenario_ref:
	'''
	class mode_hstructurescenario_ref
	confinement mode verus time:  0 = L-mode et 1 = H-mode []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='mode_h'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class mode_hstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type mode_hstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type mode_hstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type mode_hstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type mode_hstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type mode_hstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = mode_hstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type mode_hstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type mode_hstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type mode_hstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type mode_hstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class s_alphastructurescenario_ref:
	'''
	class s_alphastructurescenario_ref
	total number of alpha fusion  particules from D-T ractions  per second [s^-1]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='s_alpha'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class s_alphastructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type s_alphastructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type s_alphastructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type s_alphastructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type s_alphastructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type s_alphastructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = s_alphastructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type s_alphastructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type s_alphastructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type s_alphastructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type s_alphastructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class heat_powerstructurescenario_heat_power:
	'''
	class heat_powerstructurescenario_heat_power
	Power delivred to plasma (thermal and non thermal)

	Attributes:
	- plh : class plhstructurescenario_ref
	   Lower hybrid power [W]. Time-dependent.
	- pohmic : class pohmicstructurescenario_ref
	   ohmic power (thermal species contribution only) [W]. Time-dependent.
	- picrh : class picrhstructurescenario_ref
	   Ion cyclotron resonnance heating power [W]. Time-dependent.
	- pecrh : class pecrhstructurescenario_ref
	   electron cyclotron resonnance heating power [W]. Time-dependent.
	- pnbi : class pnbistructurescenario_ref
	   neutral beam injection power [W]. Time-dependent.
	- pnbi_co_cur : class pnbi_co_curstructurescenario_ref
	   neutral beam injection power injeted in co-current direction [W]. Time-dependent.
	- pnbi_counter : class pnbi_counterstructurescenario_ref
	   neutral beam injection power injeted in counter-current direction [W]. Time-dependent.
	- plh_th : class plh_thstructurescenario_ref
	   lower hybrid power deposited on thermal electrons [W]. Time-dependent.
	- picrh_th : class picrh_thstructurescenario_ref
	   ion cyclotron resonnance heating power deposited on thermal species [W]. Time-dependent.
	- pecrh_th : class pecrh_thstructurescenario_ref
	   electron cyclotron resonnance heating power deposited on thermal electrons [W]. Time-dependent.
	- pnbi_th : class pnbi_thstructurescenario_ref
	   neutral beam injection power deposited on thermal species [W]. Time-dependent.
	- ploss_icrh : class ploss_icrhstructurescenario_ref
	   Ion cyclotron resonnance heating power losses [W]. Time-dependent.
	- ploss_nbi : class ploss_nbistructurescenario_ref
	   neutral beam injection power losses (including shine-through) [W]. Time-dependent.
	- pbrem : class pbremstructurescenario_ref
	   Bremsstrahlung radition losses [W]. Time-dependent.
	- pcyclo : class pcyclostructurescenario_ref
	   cyclotron radiation losses [W]. Time-dependent.
	- prad : class pradstructurescenario_ref
	   impurity radition losses in core plamsa , without Bremsstrahlung [W]. Time-dependent.
	- pdd_fus : class pdd_fusstructurescenario_ref
	   fusion power due to DD reactions [W]. Time-dependent.
	- pei : class peistructurescenario_ref
	   power exchange between eletron and ion (equipartition) [W]. Time-dependent.
	- pel_tot : class pel_totstructurescenario_ref
	   total thermal electron power deposition without equipartition [W]. Time-dependent.
	- pel_fus : class pel_fusstructurescenario_ref
	   fusion electron power deposition [W]. Time-dependent.
	- pel_icrh : class pel_icrhstructurescenario_ref
	   ICRH  electron power deposition [W]. Time-dependent.
	- pel_nbi : class pel_nbistructurescenario_ref
	   NBI electron power deposition [W]. Time-dependent.
	- pfus_dt : class pfus_dtstructurescenario_ref
	   total D-T fusion power of alpha [W]. Time-dependent.
	- ploss_fus : class ploss_fusstructurescenario_ref
	   D-T fusion power of alpha losses  [W]. Time-dependent.
	- pfus_nbi : class pfus_nbistructurescenario_ref
	   NBI induce D-T fusion power of alpha  [W]. Time-dependent.
	- pfus_th : class pfus_thstructurescenario_ref
	   alpha (from DT fusion reaction)  power deposited on thermal species [W]. Time-dependent.
	- padd_tot : class padd_totstructurescenario_ref
	   total additional power input including ohmic power  [W]. Time-dependent.
	- pion_tot : class pion_totstructurescenario_ref
	   total thermal ion power deposition without equipartition [W]. Time-dependent.
	- pion_fus : class pion_fusstructurescenario_ref
	   fusion ion power deposition [W]. Time-dependent.
	- pion_icrh : class pion_icrhstructurescenario_ref
	   ICRH  ion power deposition [W]. Time-dependent.
	- pion_nbi : class pion_nbistructurescenario_ref
	   NBI  ion power deposition [W]. Time-dependent.
	- pioniz : class pionizstructurescenario_ref
	   power losses due to cold neutral ionization [W]. Time-dependent.
	- ploss : class plossstructurescenario_ref
	   plasma losses power, as define in ITER basis [W]. Time-dependent.
	- p_wth : class p_wthstructurescenario_ref
	   thermal power input, define as tau_E * P_th = Wth [W]. Time-dependent.
	- p_w : class p_wstructurescenario_ref
	   effective power define as tau_E  * P_w = W_tot [W]. Time-dependent.
	- p_l2h_thr : class p_l2h_thrstructurescenario_ref
	   additionnal power crossing the LCMS; must be compare to  L->H threshold power (Ryter PPCF 2002) [W]. Time-dependent.
	- p_l2h_sc : class p_l2h_scstructurescenario_ref
	   threshold power given by the choosen scaling law for transition from L-mode to H-mode  [W]. Time-dependent.
	- p_nbi_icrh : class p_nbi_icrhstructurescenario_ref
	   beam power increase due to  ICRH effects  [W]. Time-dependent.
	'''

	def __init__(self, base_path_in='heat_power'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.plh = plhstructurescenario_ref('plh')
		self.pohmic = pohmicstructurescenario_ref('pohmic')
		self.picrh = picrhstructurescenario_ref('picrh')
		self.pecrh = pecrhstructurescenario_ref('pecrh')
		self.pnbi = pnbistructurescenario_ref('pnbi')
		self.pnbi_co_cur = pnbi_co_curstructurescenario_ref('pnbi_co_cur')
		self.pnbi_counter = pnbi_counterstructurescenario_ref('pnbi_counter')
		self.plh_th = plh_thstructurescenario_ref('plh_th')
		self.picrh_th = picrh_thstructurescenario_ref('picrh_th')
		self.pecrh_th = pecrh_thstructurescenario_ref('pecrh_th')
		self.pnbi_th = pnbi_thstructurescenario_ref('pnbi_th')
		self.ploss_icrh = ploss_icrhstructurescenario_ref('ploss_icrh')
		self.ploss_nbi = ploss_nbistructurescenario_ref('ploss_nbi')
		self.pbrem = pbremstructurescenario_ref('pbrem')
		self.pcyclo = pcyclostructurescenario_ref('pcyclo')
		self.prad = pradstructurescenario_ref('prad')
		self.pdd_fus = pdd_fusstructurescenario_ref('pdd_fus')
		self.pei = peistructurescenario_ref('pei')
		self.pel_tot = pel_totstructurescenario_ref('pel_tot')
		self.pel_fus = pel_fusstructurescenario_ref('pel_fus')
		self.pel_icrh = pel_icrhstructurescenario_ref('pel_icrh')
		self.pel_nbi = pel_nbistructurescenario_ref('pel_nbi')
		self.pfus_dt = pfus_dtstructurescenario_ref('pfus_dt')
		self.ploss_fus = ploss_fusstructurescenario_ref('ploss_fus')
		self.pfus_nbi = pfus_nbistructurescenario_ref('pfus_nbi')
		self.pfus_th = pfus_thstructurescenario_ref('pfus_th')
		self.padd_tot = padd_totstructurescenario_ref('padd_tot')
		self.pion_tot = pion_totstructurescenario_ref('pion_tot')
		self.pion_fus = pion_fusstructurescenario_ref('pion_fus')
		self.pion_icrh = pion_icrhstructurescenario_ref('pion_icrh')
		self.pion_nbi = pion_nbistructurescenario_ref('pion_nbi')
		self.pioniz = pionizstructurescenario_ref('pioniz')
		self.ploss = plossstructurescenario_ref('ploss')
		self.p_wth = p_wthstructurescenario_ref('p_wth')
		self.p_w = p_wstructurescenario_ref('p_w')
		self.p_l2h_thr = p_l2h_thrstructurescenario_ref('p_l2h_thr')
		self.p_l2h_sc = p_l2h_scstructurescenario_ref('p_l2h_sc')
		self.p_nbi_icrh = p_nbi_icrhstructurescenario_ref('p_nbi_icrh')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class heat_powerstructurescenario_heat_power\n'
		ret = ret + space + 'Attribute plh\n ' + self.plh.__str__(depth+1)
		ret = ret + space + 'Attribute pohmic\n ' + self.pohmic.__str__(depth+1)
		ret = ret + space + 'Attribute picrh\n ' + self.picrh.__str__(depth+1)
		ret = ret + space + 'Attribute pecrh\n ' + self.pecrh.__str__(depth+1)
		ret = ret + space + 'Attribute pnbi\n ' + self.pnbi.__str__(depth+1)
		ret = ret + space + 'Attribute pnbi_co_cur\n ' + self.pnbi_co_cur.__str__(depth+1)
		ret = ret + space + 'Attribute pnbi_counter\n ' + self.pnbi_counter.__str__(depth+1)
		ret = ret + space + 'Attribute plh_th\n ' + self.plh_th.__str__(depth+1)
		ret = ret + space + 'Attribute picrh_th\n ' + self.picrh_th.__str__(depth+1)
		ret = ret + space + 'Attribute pecrh_th\n ' + self.pecrh_th.__str__(depth+1)
		ret = ret + space + 'Attribute pnbi_th\n ' + self.pnbi_th.__str__(depth+1)
		ret = ret + space + 'Attribute ploss_icrh\n ' + self.ploss_icrh.__str__(depth+1)
		ret = ret + space + 'Attribute ploss_nbi\n ' + self.ploss_nbi.__str__(depth+1)
		ret = ret + space + 'Attribute pbrem\n ' + self.pbrem.__str__(depth+1)
		ret = ret + space + 'Attribute pcyclo\n ' + self.pcyclo.__str__(depth+1)
		ret = ret + space + 'Attribute prad\n ' + self.prad.__str__(depth+1)
		ret = ret + space + 'Attribute pdd_fus\n ' + self.pdd_fus.__str__(depth+1)
		ret = ret + space + 'Attribute pei\n ' + self.pei.__str__(depth+1)
		ret = ret + space + 'Attribute pel_tot\n ' + self.pel_tot.__str__(depth+1)
		ret = ret + space + 'Attribute pel_fus\n ' + self.pel_fus.__str__(depth+1)
		ret = ret + space + 'Attribute pel_icrh\n ' + self.pel_icrh.__str__(depth+1)
		ret = ret + space + 'Attribute pel_nbi\n ' + self.pel_nbi.__str__(depth+1)
		ret = ret + space + 'Attribute pfus_dt\n ' + self.pfus_dt.__str__(depth+1)
		ret = ret + space + 'Attribute ploss_fus\n ' + self.ploss_fus.__str__(depth+1)
		ret = ret + space + 'Attribute pfus_nbi\n ' + self.pfus_nbi.__str__(depth+1)
		ret = ret + space + 'Attribute pfus_th\n ' + self.pfus_th.__str__(depth+1)
		ret = ret + space + 'Attribute padd_tot\n ' + self.padd_tot.__str__(depth+1)
		ret = ret + space + 'Attribute pion_tot\n ' + self.pion_tot.__str__(depth+1)
		ret = ret + space + 'Attribute pion_fus\n ' + self.pion_fus.__str__(depth+1)
		ret = ret + space + 'Attribute pion_icrh\n ' + self.pion_icrh.__str__(depth+1)
		ret = ret + space + 'Attribute pion_nbi\n ' + self.pion_nbi.__str__(depth+1)
		ret = ret + space + 'Attribute pioniz\n ' + self.pioniz.__str__(depth+1)
		ret = ret + space + 'Attribute ploss\n ' + self.ploss.__str__(depth+1)
		ret = ret + space + 'Attribute p_wth\n ' + self.p_wth.__str__(depth+1)
		ret = ret + space + 'Attribute p_w\n ' + self.p_w.__str__(depth+1)
		ret = ret + space + 'Attribute p_l2h_thr\n ' + self.p_l2h_thr.__str__(depth+1)
		ret = ret + space + 'Attribute p_l2h_sc\n ' + self.p_l2h_sc.__str__(depth+1)
		ret = ret + space + 'Attribute p_nbi_icrh\n ' + self.p_nbi_icrh.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.plh.setExpIdx(idx)
		self.pohmic.setExpIdx(idx)
		self.picrh.setExpIdx(idx)
		self.pecrh.setExpIdx(idx)
		self.pnbi.setExpIdx(idx)
		self.pnbi_co_cur.setExpIdx(idx)
		self.pnbi_counter.setExpIdx(idx)
		self.plh_th.setExpIdx(idx)
		self.picrh_th.setExpIdx(idx)
		self.pecrh_th.setExpIdx(idx)
		self.pnbi_th.setExpIdx(idx)
		self.ploss_icrh.setExpIdx(idx)
		self.ploss_nbi.setExpIdx(idx)
		self.pbrem.setExpIdx(idx)
		self.pcyclo.setExpIdx(idx)
		self.prad.setExpIdx(idx)
		self.pdd_fus.setExpIdx(idx)
		self.pei.setExpIdx(idx)
		self.pel_tot.setExpIdx(idx)
		self.pel_fus.setExpIdx(idx)
		self.pel_icrh.setExpIdx(idx)
		self.pel_nbi.setExpIdx(idx)
		self.pfus_dt.setExpIdx(idx)
		self.ploss_fus.setExpIdx(idx)
		self.pfus_nbi.setExpIdx(idx)
		self.pfus_th.setExpIdx(idx)
		self.padd_tot.setExpIdx(idx)
		self.pion_tot.setExpIdx(idx)
		self.pion_fus.setExpIdx(idx)
		self.pion_icrh.setExpIdx(idx)
		self.pion_nbi.setExpIdx(idx)
		self.pioniz.setExpIdx(idx)
		self.ploss.setExpIdx(idx)
		self.p_wth.setExpIdx(idx)
		self.p_w.setExpIdx(idx)
		self.p_l2h_thr.setExpIdx(idx)
		self.p_l2h_sc.setExpIdx(idx)
		self.p_nbi_icrh.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type heat_powerstructurescenario_heat_power, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.cpoTime = self.cpoTime
		self.plh.putSlice(path, cpopath)
		self.pohmic.cpoTime = self.cpoTime
		self.pohmic.putSlice(path, cpopath)
		self.picrh.cpoTime = self.cpoTime
		self.picrh.putSlice(path, cpopath)
		self.pecrh.cpoTime = self.cpoTime
		self.pecrh.putSlice(path, cpopath)
		self.pnbi.cpoTime = self.cpoTime
		self.pnbi.putSlice(path, cpopath)
		self.pnbi_co_cur.cpoTime = self.cpoTime
		self.pnbi_co_cur.putSlice(path, cpopath)
		self.pnbi_counter.cpoTime = self.cpoTime
		self.pnbi_counter.putSlice(path, cpopath)
		self.plh_th.cpoTime = self.cpoTime
		self.plh_th.putSlice(path, cpopath)
		self.picrh_th.cpoTime = self.cpoTime
		self.picrh_th.putSlice(path, cpopath)
		self.pecrh_th.cpoTime = self.cpoTime
		self.pecrh_th.putSlice(path, cpopath)
		self.pnbi_th.cpoTime = self.cpoTime
		self.pnbi_th.putSlice(path, cpopath)
		self.ploss_icrh.cpoTime = self.cpoTime
		self.ploss_icrh.putSlice(path, cpopath)
		self.ploss_nbi.cpoTime = self.cpoTime
		self.ploss_nbi.putSlice(path, cpopath)
		self.pbrem.cpoTime = self.cpoTime
		self.pbrem.putSlice(path, cpopath)
		self.pcyclo.cpoTime = self.cpoTime
		self.pcyclo.putSlice(path, cpopath)
		self.prad.cpoTime = self.cpoTime
		self.prad.putSlice(path, cpopath)
		self.pdd_fus.cpoTime = self.cpoTime
		self.pdd_fus.putSlice(path, cpopath)
		self.pei.cpoTime = self.cpoTime
		self.pei.putSlice(path, cpopath)
		self.pel_tot.cpoTime = self.cpoTime
		self.pel_tot.putSlice(path, cpopath)
		self.pel_fus.cpoTime = self.cpoTime
		self.pel_fus.putSlice(path, cpopath)
		self.pel_icrh.cpoTime = self.cpoTime
		self.pel_icrh.putSlice(path, cpopath)
		self.pel_nbi.cpoTime = self.cpoTime
		self.pel_nbi.putSlice(path, cpopath)
		self.pfus_dt.cpoTime = self.cpoTime
		self.pfus_dt.putSlice(path, cpopath)
		self.ploss_fus.cpoTime = self.cpoTime
		self.ploss_fus.putSlice(path, cpopath)
		self.pfus_nbi.cpoTime = self.cpoTime
		self.pfus_nbi.putSlice(path, cpopath)
		self.pfus_th.cpoTime = self.cpoTime
		self.pfus_th.putSlice(path, cpopath)
		self.padd_tot.cpoTime = self.cpoTime
		self.padd_tot.putSlice(path, cpopath)
		self.pion_tot.cpoTime = self.cpoTime
		self.pion_tot.putSlice(path, cpopath)
		self.pion_fus.cpoTime = self.cpoTime
		self.pion_fus.putSlice(path, cpopath)
		self.pion_icrh.cpoTime = self.cpoTime
		self.pion_icrh.putSlice(path, cpopath)
		self.pion_nbi.cpoTime = self.cpoTime
		self.pion_nbi.putSlice(path, cpopath)
		self.pioniz.cpoTime = self.cpoTime
		self.pioniz.putSlice(path, cpopath)
		self.ploss.cpoTime = self.cpoTime
		self.ploss.putSlice(path, cpopath)
		self.p_wth.cpoTime = self.cpoTime
		self.p_wth.putSlice(path, cpopath)
		self.p_w.cpoTime = self.cpoTime
		self.p_w.putSlice(path, cpopath)
		self.p_l2h_thr.cpoTime = self.cpoTime
		self.p_l2h_thr.putSlice(path, cpopath)
		self.p_l2h_sc.cpoTime = self.cpoTime
		self.p_l2h_sc.putSlice(path, cpopath)
		self.p_nbi_icrh.cpoTime = self.cpoTime
		self.p_nbi_icrh.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type heat_powerstructurescenario_heat_power, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.replaceLastSlice(path, cpopath)
		self.pohmic.replaceLastSlice(path, cpopath)
		self.picrh.replaceLastSlice(path, cpopath)
		self.pecrh.replaceLastSlice(path, cpopath)
		self.pnbi.replaceLastSlice(path, cpopath)
		self.pnbi_co_cur.replaceLastSlice(path, cpopath)
		self.pnbi_counter.replaceLastSlice(path, cpopath)
		self.plh_th.replaceLastSlice(path, cpopath)
		self.picrh_th.replaceLastSlice(path, cpopath)
		self.pecrh_th.replaceLastSlice(path, cpopath)
		self.pnbi_th.replaceLastSlice(path, cpopath)
		self.ploss_icrh.replaceLastSlice(path, cpopath)
		self.ploss_nbi.replaceLastSlice(path, cpopath)
		self.pbrem.replaceLastSlice(path, cpopath)
		self.pcyclo.replaceLastSlice(path, cpopath)
		self.prad.replaceLastSlice(path, cpopath)
		self.pdd_fus.replaceLastSlice(path, cpopath)
		self.pei.replaceLastSlice(path, cpopath)
		self.pel_tot.replaceLastSlice(path, cpopath)
		self.pel_fus.replaceLastSlice(path, cpopath)
		self.pel_icrh.replaceLastSlice(path, cpopath)
		self.pel_nbi.replaceLastSlice(path, cpopath)
		self.pfus_dt.replaceLastSlice(path, cpopath)
		self.ploss_fus.replaceLastSlice(path, cpopath)
		self.pfus_nbi.replaceLastSlice(path, cpopath)
		self.pfus_th.replaceLastSlice(path, cpopath)
		self.padd_tot.replaceLastSlice(path, cpopath)
		self.pion_tot.replaceLastSlice(path, cpopath)
		self.pion_fus.replaceLastSlice(path, cpopath)
		self.pion_icrh.replaceLastSlice(path, cpopath)
		self.pion_nbi.replaceLastSlice(path, cpopath)
		self.pioniz.replaceLastSlice(path, cpopath)
		self.ploss.replaceLastSlice(path, cpopath)
		self.p_wth.replaceLastSlice(path, cpopath)
		self.p_w.replaceLastSlice(path, cpopath)
		self.p_l2h_thr.replaceLastSlice(path, cpopath)
		self.p_l2h_sc.replaceLastSlice(path, cpopath)
		self.p_nbi_icrh.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type heat_powerstructurescenario_heat_power, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.putNonTimed(path, cpopath)
		self.pohmic.putNonTimed(path, cpopath)
		self.picrh.putNonTimed(path, cpopath)
		self.pecrh.putNonTimed(path, cpopath)
		self.pnbi.putNonTimed(path, cpopath)
		self.pnbi_co_cur.putNonTimed(path, cpopath)
		self.pnbi_counter.putNonTimed(path, cpopath)
		self.plh_th.putNonTimed(path, cpopath)
		self.picrh_th.putNonTimed(path, cpopath)
		self.pecrh_th.putNonTimed(path, cpopath)
		self.pnbi_th.putNonTimed(path, cpopath)
		self.ploss_icrh.putNonTimed(path, cpopath)
		self.ploss_nbi.putNonTimed(path, cpopath)
		self.pbrem.putNonTimed(path, cpopath)
		self.pcyclo.putNonTimed(path, cpopath)
		self.prad.putNonTimed(path, cpopath)
		self.pdd_fus.putNonTimed(path, cpopath)
		self.pei.putNonTimed(path, cpopath)
		self.pel_tot.putNonTimed(path, cpopath)
		self.pel_fus.putNonTimed(path, cpopath)
		self.pel_icrh.putNonTimed(path, cpopath)
		self.pel_nbi.putNonTimed(path, cpopath)
		self.pfus_dt.putNonTimed(path, cpopath)
		self.ploss_fus.putNonTimed(path, cpopath)
		self.pfus_nbi.putNonTimed(path, cpopath)
		self.pfus_th.putNonTimed(path, cpopath)
		self.padd_tot.putNonTimed(path, cpopath)
		self.pion_tot.putNonTimed(path, cpopath)
		self.pion_fus.putNonTimed(path, cpopath)
		self.pion_icrh.putNonTimed(path, cpopath)
		self.pion_nbi.putNonTimed(path, cpopath)
		self.pioniz.putNonTimed(path, cpopath)
		self.ploss.putNonTimed(path, cpopath)
		self.p_wth.putNonTimed(path, cpopath)
		self.p_w.putNonTimed(path, cpopath)
		self.p_l2h_thr.putNonTimed(path, cpopath)
		self.p_l2h_sc.putNonTimed(path, cpopath)
		self.p_nbi_icrh.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type heat_powerstructurescenario_heat_power, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.getSlice(path, cpopath, inTime, interpolMode)
		self.pohmic.getSlice(path, cpopath, inTime, interpolMode)
		self.picrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pecrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pnbi.getSlice(path, cpopath, inTime, interpolMode)
		self.pnbi_co_cur.getSlice(path, cpopath, inTime, interpolMode)
		self.pnbi_counter.getSlice(path, cpopath, inTime, interpolMode)
		self.plh_th.getSlice(path, cpopath, inTime, interpolMode)
		self.picrh_th.getSlice(path, cpopath, inTime, interpolMode)
		self.pecrh_th.getSlice(path, cpopath, inTime, interpolMode)
		self.pnbi_th.getSlice(path, cpopath, inTime, interpolMode)
		self.ploss_icrh.getSlice(path, cpopath, inTime, interpolMode)
		self.ploss_nbi.getSlice(path, cpopath, inTime, interpolMode)
		self.pbrem.getSlice(path, cpopath, inTime, interpolMode)
		self.pcyclo.getSlice(path, cpopath, inTime, interpolMode)
		self.prad.getSlice(path, cpopath, inTime, interpolMode)
		self.pdd_fus.getSlice(path, cpopath, inTime, interpolMode)
		self.pei.getSlice(path, cpopath, inTime, interpolMode)
		self.pel_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.pel_fus.getSlice(path, cpopath, inTime, interpolMode)
		self.pel_icrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pel_nbi.getSlice(path, cpopath, inTime, interpolMode)
		self.pfus_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.ploss_fus.getSlice(path, cpopath, inTime, interpolMode)
		self.pfus_nbi.getSlice(path, cpopath, inTime, interpolMode)
		self.pfus_th.getSlice(path, cpopath, inTime, interpolMode)
		self.padd_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.pion_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.pion_fus.getSlice(path, cpopath, inTime, interpolMode)
		self.pion_icrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pion_nbi.getSlice(path, cpopath, inTime, interpolMode)
		self.pioniz.getSlice(path, cpopath, inTime, interpolMode)
		self.ploss.getSlice(path, cpopath, inTime, interpolMode)
		self.p_wth.getSlice(path, cpopath, inTime, interpolMode)
		self.p_w.getSlice(path, cpopath, inTime, interpolMode)
		self.p_l2h_thr.getSlice(path, cpopath, inTime, interpolMode)
		self.p_l2h_sc.getSlice(path, cpopath, inTime, interpolMode)
		self.p_nbi_icrh.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type heat_powerstructurescenario_heat_power, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			plhList = self.plh.build_non_resampled_data(path, cpopath, nbslice)
			pohmicList = self.pohmic.build_non_resampled_data(path, cpopath, nbslice)
			picrhList = self.picrh.build_non_resampled_data(path, cpopath, nbslice)
			pecrhList = self.pecrh.build_non_resampled_data(path, cpopath, nbslice)
			pnbiList = self.pnbi.build_non_resampled_data(path, cpopath, nbslice)
			pnbi_co_curList = self.pnbi_co_cur.build_non_resampled_data(path, cpopath, nbslice)
			pnbi_counterList = self.pnbi_counter.build_non_resampled_data(path, cpopath, nbslice)
			plh_thList = self.plh_th.build_non_resampled_data(path, cpopath, nbslice)
			picrh_thList = self.picrh_th.build_non_resampled_data(path, cpopath, nbslice)
			pecrh_thList = self.pecrh_th.build_non_resampled_data(path, cpopath, nbslice)
			pnbi_thList = self.pnbi_th.build_non_resampled_data(path, cpopath, nbslice)
			ploss_icrhList = self.ploss_icrh.build_non_resampled_data(path, cpopath, nbslice)
			ploss_nbiList = self.ploss_nbi.build_non_resampled_data(path, cpopath, nbslice)
			pbremList = self.pbrem.build_non_resampled_data(path, cpopath, nbslice)
			pcycloList = self.pcyclo.build_non_resampled_data(path, cpopath, nbslice)
			pradList = self.prad.build_non_resampled_data(path, cpopath, nbslice)
			pdd_fusList = self.pdd_fus.build_non_resampled_data(path, cpopath, nbslice)
			peiList = self.pei.build_non_resampled_data(path, cpopath, nbslice)
			pel_totList = self.pel_tot.build_non_resampled_data(path, cpopath, nbslice)
			pel_fusList = self.pel_fus.build_non_resampled_data(path, cpopath, nbslice)
			pel_icrhList = self.pel_icrh.build_non_resampled_data(path, cpopath, nbslice)
			pel_nbiList = self.pel_nbi.build_non_resampled_data(path, cpopath, nbslice)
			pfus_dtList = self.pfus_dt.build_non_resampled_data(path, cpopath, nbslice)
			ploss_fusList = self.ploss_fus.build_non_resampled_data(path, cpopath, nbslice)
			pfus_nbiList = self.pfus_nbi.build_non_resampled_data(path, cpopath, nbslice)
			pfus_thList = self.pfus_th.build_non_resampled_data(path, cpopath, nbslice)
			padd_totList = self.padd_tot.build_non_resampled_data(path, cpopath, nbslice)
			pion_totList = self.pion_tot.build_non_resampled_data(path, cpopath, nbslice)
			pion_fusList = self.pion_fus.build_non_resampled_data(path, cpopath, nbslice)
			pion_icrhList = self.pion_icrh.build_non_resampled_data(path, cpopath, nbslice)
			pion_nbiList = self.pion_nbi.build_non_resampled_data(path, cpopath, nbslice)
			pionizList = self.pioniz.build_non_resampled_data(path, cpopath, nbslice)
			plossList = self.ploss.build_non_resampled_data(path, cpopath, nbslice)
			p_wthList = self.p_wth.build_non_resampled_data(path, cpopath, nbslice)
			p_wList = self.p_w.build_non_resampled_data(path, cpopath, nbslice)
			p_l2h_thrList = self.p_l2h_thr.build_non_resampled_data(path, cpopath, nbslice)
			p_l2h_scList = self.p_l2h_sc.build_non_resampled_data(path, cpopath, nbslice)
			p_nbi_icrhList = self.p_nbi_icrh.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = heat_powerstructurescenario_heat_power(self.base_path)
				slice.setExpIdx(self.idx)
				slice.plh = plhList[i]
				slice.pohmic = pohmicList[i]
				slice.picrh = picrhList[i]
				slice.pecrh = pecrhList[i]
				slice.pnbi = pnbiList[i]
				slice.pnbi_co_cur = pnbi_co_curList[i]
				slice.pnbi_counter = pnbi_counterList[i]
				slice.plh_th = plh_thList[i]
				slice.picrh_th = picrh_thList[i]
				slice.pecrh_th = pecrh_thList[i]
				slice.pnbi_th = pnbi_thList[i]
				slice.ploss_icrh = ploss_icrhList[i]
				slice.ploss_nbi = ploss_nbiList[i]
				slice.pbrem = pbremList[i]
				slice.pcyclo = pcycloList[i]
				slice.prad = pradList[i]
				slice.pdd_fus = pdd_fusList[i]
				slice.pei = peiList[i]
				slice.pel_tot = pel_totList[i]
				slice.pel_fus = pel_fusList[i]
				slice.pel_icrh = pel_icrhList[i]
				slice.pel_nbi = pel_nbiList[i]
				slice.pfus_dt = pfus_dtList[i]
				slice.ploss_fus = ploss_fusList[i]
				slice.pfus_nbi = pfus_nbiList[i]
				slice.pfus_th = pfus_thList[i]
				slice.padd_tot = padd_totList[i]
				slice.pion_tot = pion_totList[i]
				slice.pion_fus = pion_fusList[i]
				slice.pion_icrh = pion_icrhList[i]
				slice.pion_nbi = pion_nbiList[i]
				slice.pioniz = pionizList[i]
				slice.ploss = plossList[i]
				slice.p_wth = p_wthList[i]
				slice.p_w = p_wList[i]
				slice.p_l2h_thr = p_l2h_thrList[i]
				slice.p_l2h_sc = p_l2h_scList[i]
				slice.p_nbi_icrh = p_nbi_icrhList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type heat_powerstructurescenario_heat_powerObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.plh.putTimedElt(path, cpopath + 'plh', i, obj)
		obj = self.pohmic.putTimedElt(path, cpopath + 'pohmic', i, obj)
		obj = self.picrh.putTimedElt(path, cpopath + 'picrh', i, obj)
		obj = self.pecrh.putTimedElt(path, cpopath + 'pecrh', i, obj)
		obj = self.pnbi.putTimedElt(path, cpopath + 'pnbi', i, obj)
		obj = self.pnbi_co_cur.putTimedElt(path, cpopath + 'pnbi_co_cur', i, obj)
		obj = self.pnbi_counter.putTimedElt(path, cpopath + 'pnbi_counter', i, obj)
		obj = self.plh_th.putTimedElt(path, cpopath + 'plh_th', i, obj)
		obj = self.picrh_th.putTimedElt(path, cpopath + 'picrh_th', i, obj)
		obj = self.pecrh_th.putTimedElt(path, cpopath + 'pecrh_th', i, obj)
		obj = self.pnbi_th.putTimedElt(path, cpopath + 'pnbi_th', i, obj)
		obj = self.ploss_icrh.putTimedElt(path, cpopath + 'ploss_icrh', i, obj)
		obj = self.ploss_nbi.putTimedElt(path, cpopath + 'ploss_nbi', i, obj)
		obj = self.pbrem.putTimedElt(path, cpopath + 'pbrem', i, obj)
		obj = self.pcyclo.putTimedElt(path, cpopath + 'pcyclo', i, obj)
		obj = self.prad.putTimedElt(path, cpopath + 'prad', i, obj)
		obj = self.pdd_fus.putTimedElt(path, cpopath + 'pdd_fus', i, obj)
		obj = self.pei.putTimedElt(path, cpopath + 'pei', i, obj)
		obj = self.pel_tot.putTimedElt(path, cpopath + 'pel_tot', i, obj)
		obj = self.pel_fus.putTimedElt(path, cpopath + 'pel_fus', i, obj)
		obj = self.pel_icrh.putTimedElt(path, cpopath + 'pel_icrh', i, obj)
		obj = self.pel_nbi.putTimedElt(path, cpopath + 'pel_nbi', i, obj)
		obj = self.pfus_dt.putTimedElt(path, cpopath + 'pfus_dt', i, obj)
		obj = self.ploss_fus.putTimedElt(path, cpopath + 'ploss_fus', i, obj)
		obj = self.pfus_nbi.putTimedElt(path, cpopath + 'pfus_nbi', i, obj)
		obj = self.pfus_th.putTimedElt(path, cpopath + 'pfus_th', i, obj)
		obj = self.padd_tot.putTimedElt(path, cpopath + 'padd_tot', i, obj)
		obj = self.pion_tot.putTimedElt(path, cpopath + 'pion_tot', i, obj)
		obj = self.pion_fus.putTimedElt(path, cpopath + 'pion_fus', i, obj)
		obj = self.pion_icrh.putTimedElt(path, cpopath + 'pion_icrh', i, obj)
		obj = self.pion_nbi.putTimedElt(path, cpopath + 'pion_nbi', i, obj)
		obj = self.pioniz.putTimedElt(path, cpopath + 'pioniz', i, obj)
		obj = self.ploss.putTimedElt(path, cpopath + 'ploss', i, obj)
		obj = self.p_wth.putTimedElt(path, cpopath + 'p_wth', i, obj)
		obj = self.p_w.putTimedElt(path, cpopath + 'p_w', i, obj)
		obj = self.p_l2h_thr.putTimedElt(path, cpopath + 'p_l2h_thr', i, obj)
		obj = self.p_l2h_sc.putTimedElt(path, cpopath + 'p_l2h_sc', i, obj)
		obj = self.p_nbi_icrh.putTimedElt(path, cpopath + 'p_nbi_icrh', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type heat_powerstructurescenario_heat_powerObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.plh.getTimedElt(path, cpopath + 'plh', i, obj)
		self.pohmic.getTimedElt(path, cpopath + 'pohmic', i, obj)
		self.picrh.getTimedElt(path, cpopath + 'picrh', i, obj)
		self.pecrh.getTimedElt(path, cpopath + 'pecrh', i, obj)
		self.pnbi.getTimedElt(path, cpopath + 'pnbi', i, obj)
		self.pnbi_co_cur.getTimedElt(path, cpopath + 'pnbi_co_cur', i, obj)
		self.pnbi_counter.getTimedElt(path, cpopath + 'pnbi_counter', i, obj)
		self.plh_th.getTimedElt(path, cpopath + 'plh_th', i, obj)
		self.picrh_th.getTimedElt(path, cpopath + 'picrh_th', i, obj)
		self.pecrh_th.getTimedElt(path, cpopath + 'pecrh_th', i, obj)
		self.pnbi_th.getTimedElt(path, cpopath + 'pnbi_th', i, obj)
		self.ploss_icrh.getTimedElt(path, cpopath + 'ploss_icrh', i, obj)
		self.ploss_nbi.getTimedElt(path, cpopath + 'ploss_nbi', i, obj)
		self.pbrem.getTimedElt(path, cpopath + 'pbrem', i, obj)
		self.pcyclo.getTimedElt(path, cpopath + 'pcyclo', i, obj)
		self.prad.getTimedElt(path, cpopath + 'prad', i, obj)
		self.pdd_fus.getTimedElt(path, cpopath + 'pdd_fus', i, obj)
		self.pei.getTimedElt(path, cpopath + 'pei', i, obj)
		self.pel_tot.getTimedElt(path, cpopath + 'pel_tot', i, obj)
		self.pel_fus.getTimedElt(path, cpopath + 'pel_fus', i, obj)
		self.pel_icrh.getTimedElt(path, cpopath + 'pel_icrh', i, obj)
		self.pel_nbi.getTimedElt(path, cpopath + 'pel_nbi', i, obj)
		self.pfus_dt.getTimedElt(path, cpopath + 'pfus_dt', i, obj)
		self.ploss_fus.getTimedElt(path, cpopath + 'ploss_fus', i, obj)
		self.pfus_nbi.getTimedElt(path, cpopath + 'pfus_nbi', i, obj)
		self.pfus_th.getTimedElt(path, cpopath + 'pfus_th', i, obj)
		self.padd_tot.getTimedElt(path, cpopath + 'padd_tot', i, obj)
		self.pion_tot.getTimedElt(path, cpopath + 'pion_tot', i, obj)
		self.pion_fus.getTimedElt(path, cpopath + 'pion_fus', i, obj)
		self.pion_icrh.getTimedElt(path, cpopath + 'pion_icrh', i, obj)
		self.pion_nbi.getTimedElt(path, cpopath + 'pion_nbi', i, obj)
		self.pioniz.getTimedElt(path, cpopath + 'pioniz', i, obj)
		self.ploss.getTimedElt(path, cpopath + 'ploss', i, obj)
		self.p_wth.getTimedElt(path, cpopath + 'p_wth', i, obj)
		self.p_w.getTimedElt(path, cpopath + 'p_w', i, obj)
		self.p_l2h_thr.getTimedElt(path, cpopath + 'p_l2h_thr', i, obj)
		self.p_l2h_sc.getTimedElt(path, cpopath + 'p_l2h_sc', i, obj)
		self.p_nbi_icrh.getTimedElt(path, cpopath + 'p_nbi_icrh', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type heat_powerstructurescenario_heat_powerObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.plh.putNonTimedElt(path, cpopath + 'plh', i, obj)
		obj = self.pohmic.putNonTimedElt(path, cpopath + 'pohmic', i, obj)
		obj = self.picrh.putNonTimedElt(path, cpopath + 'picrh', i, obj)
		obj = self.pecrh.putNonTimedElt(path, cpopath + 'pecrh', i, obj)
		obj = self.pnbi.putNonTimedElt(path, cpopath + 'pnbi', i, obj)
		obj = self.pnbi_co_cur.putNonTimedElt(path, cpopath + 'pnbi_co_cur', i, obj)
		obj = self.pnbi_counter.putNonTimedElt(path, cpopath + 'pnbi_counter', i, obj)
		obj = self.plh_th.putNonTimedElt(path, cpopath + 'plh_th', i, obj)
		obj = self.picrh_th.putNonTimedElt(path, cpopath + 'picrh_th', i, obj)
		obj = self.pecrh_th.putNonTimedElt(path, cpopath + 'pecrh_th', i, obj)
		obj = self.pnbi_th.putNonTimedElt(path, cpopath + 'pnbi_th', i, obj)
		obj = self.ploss_icrh.putNonTimedElt(path, cpopath + 'ploss_icrh', i, obj)
		obj = self.ploss_nbi.putNonTimedElt(path, cpopath + 'ploss_nbi', i, obj)
		obj = self.pbrem.putNonTimedElt(path, cpopath + 'pbrem', i, obj)
		obj = self.pcyclo.putNonTimedElt(path, cpopath + 'pcyclo', i, obj)
		obj = self.prad.putNonTimedElt(path, cpopath + 'prad', i, obj)
		obj = self.pdd_fus.putNonTimedElt(path, cpopath + 'pdd_fus', i, obj)
		obj = self.pei.putNonTimedElt(path, cpopath + 'pei', i, obj)
		obj = self.pel_tot.putNonTimedElt(path, cpopath + 'pel_tot', i, obj)
		obj = self.pel_fus.putNonTimedElt(path, cpopath + 'pel_fus', i, obj)
		obj = self.pel_icrh.putNonTimedElt(path, cpopath + 'pel_icrh', i, obj)
		obj = self.pel_nbi.putNonTimedElt(path, cpopath + 'pel_nbi', i, obj)
		obj = self.pfus_dt.putNonTimedElt(path, cpopath + 'pfus_dt', i, obj)
		obj = self.ploss_fus.putNonTimedElt(path, cpopath + 'ploss_fus', i, obj)
		obj = self.pfus_nbi.putNonTimedElt(path, cpopath + 'pfus_nbi', i, obj)
		obj = self.pfus_th.putNonTimedElt(path, cpopath + 'pfus_th', i, obj)
		obj = self.padd_tot.putNonTimedElt(path, cpopath + 'padd_tot', i, obj)
		obj = self.pion_tot.putNonTimedElt(path, cpopath + 'pion_tot', i, obj)
		obj = self.pion_fus.putNonTimedElt(path, cpopath + 'pion_fus', i, obj)
		obj = self.pion_icrh.putNonTimedElt(path, cpopath + 'pion_icrh', i, obj)
		obj = self.pion_nbi.putNonTimedElt(path, cpopath + 'pion_nbi', i, obj)
		obj = self.pioniz.putNonTimedElt(path, cpopath + 'pioniz', i, obj)
		obj = self.ploss.putNonTimedElt(path, cpopath + 'ploss', i, obj)
		obj = self.p_wth.putNonTimedElt(path, cpopath + 'p_wth', i, obj)
		obj = self.p_w.putNonTimedElt(path, cpopath + 'p_w', i, obj)
		obj = self.p_l2h_thr.putNonTimedElt(path, cpopath + 'p_l2h_thr', i, obj)
		obj = self.p_l2h_sc.putNonTimedElt(path, cpopath + 'p_l2h_sc', i, obj)
		obj = self.p_nbi_icrh.putNonTimedElt(path, cpopath + 'p_nbi_icrh', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type heat_powerstructurescenario_heat_powerObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.plh.getNonTimedElt(path, cpopath + 'plh', i, obj)
		self.pohmic.getNonTimedElt(path, cpopath + 'pohmic', i, obj)
		self.picrh.getNonTimedElt(path, cpopath + 'picrh', i, obj)
		self.pecrh.getNonTimedElt(path, cpopath + 'pecrh', i, obj)
		self.pnbi.getNonTimedElt(path, cpopath + 'pnbi', i, obj)
		self.pnbi_co_cur.getNonTimedElt(path, cpopath + 'pnbi_co_cur', i, obj)
		self.pnbi_counter.getNonTimedElt(path, cpopath + 'pnbi_counter', i, obj)
		self.plh_th.getNonTimedElt(path, cpopath + 'plh_th', i, obj)
		self.picrh_th.getNonTimedElt(path, cpopath + 'picrh_th', i, obj)
		self.pecrh_th.getNonTimedElt(path, cpopath + 'pecrh_th', i, obj)
		self.pnbi_th.getNonTimedElt(path, cpopath + 'pnbi_th', i, obj)
		self.ploss_icrh.getNonTimedElt(path, cpopath + 'ploss_icrh', i, obj)
		self.ploss_nbi.getNonTimedElt(path, cpopath + 'ploss_nbi', i, obj)
		self.pbrem.getNonTimedElt(path, cpopath + 'pbrem', i, obj)
		self.pcyclo.getNonTimedElt(path, cpopath + 'pcyclo', i, obj)
		self.prad.getNonTimedElt(path, cpopath + 'prad', i, obj)
		self.pdd_fus.getNonTimedElt(path, cpopath + 'pdd_fus', i, obj)
		self.pei.getNonTimedElt(path, cpopath + 'pei', i, obj)
		self.pel_tot.getNonTimedElt(path, cpopath + 'pel_tot', i, obj)
		self.pel_fus.getNonTimedElt(path, cpopath + 'pel_fus', i, obj)
		self.pel_icrh.getNonTimedElt(path, cpopath + 'pel_icrh', i, obj)
		self.pel_nbi.getNonTimedElt(path, cpopath + 'pel_nbi', i, obj)
		self.pfus_dt.getNonTimedElt(path, cpopath + 'pfus_dt', i, obj)
		self.ploss_fus.getNonTimedElt(path, cpopath + 'ploss_fus', i, obj)
		self.pfus_nbi.getNonTimedElt(path, cpopath + 'pfus_nbi', i, obj)
		self.pfus_th.getNonTimedElt(path, cpopath + 'pfus_th', i, obj)
		self.padd_tot.getNonTimedElt(path, cpopath + 'padd_tot', i, obj)
		self.pion_tot.getNonTimedElt(path, cpopath + 'pion_tot', i, obj)
		self.pion_fus.getNonTimedElt(path, cpopath + 'pion_fus', i, obj)
		self.pion_icrh.getNonTimedElt(path, cpopath + 'pion_icrh', i, obj)
		self.pion_nbi.getNonTimedElt(path, cpopath + 'pion_nbi', i, obj)
		self.pioniz.getNonTimedElt(path, cpopath + 'pioniz', i, obj)
		self.ploss.getNonTimedElt(path, cpopath + 'ploss', i, obj)
		self.p_wth.getNonTimedElt(path, cpopath + 'p_wth', i, obj)
		self.p_w.getNonTimedElt(path, cpopath + 'p_w', i, obj)
		self.p_l2h_thr.getNonTimedElt(path, cpopath + 'p_l2h_thr', i, obj)
		self.p_l2h_sc.getNonTimedElt(path, cpopath + 'p_l2h_sc', i, obj)
		self.p_nbi_icrh.getNonTimedElt(path, cpopath + 'p_nbi_icrh', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.deleteData(path, cpopath)
		self.pohmic.deleteData(path, cpopath)
		self.picrh.deleteData(path, cpopath)
		self.pecrh.deleteData(path, cpopath)
		self.pnbi.deleteData(path, cpopath)
		self.pnbi_co_cur.deleteData(path, cpopath)
		self.pnbi_counter.deleteData(path, cpopath)
		self.plh_th.deleteData(path, cpopath)
		self.picrh_th.deleteData(path, cpopath)
		self.pecrh_th.deleteData(path, cpopath)
		self.pnbi_th.deleteData(path, cpopath)
		self.ploss_icrh.deleteData(path, cpopath)
		self.ploss_nbi.deleteData(path, cpopath)
		self.pbrem.deleteData(path, cpopath)
		self.pcyclo.deleteData(path, cpopath)
		self.prad.deleteData(path, cpopath)
		self.pdd_fus.deleteData(path, cpopath)
		self.pei.deleteData(path, cpopath)
		self.pel_tot.deleteData(path, cpopath)
		self.pel_fus.deleteData(path, cpopath)
		self.pel_icrh.deleteData(path, cpopath)
		self.pel_nbi.deleteData(path, cpopath)
		self.pfus_dt.deleteData(path, cpopath)
		self.ploss_fus.deleteData(path, cpopath)
		self.pfus_nbi.deleteData(path, cpopath)
		self.pfus_th.deleteData(path, cpopath)
		self.padd_tot.deleteData(path, cpopath)
		self.pion_tot.deleteData(path, cpopath)
		self.pion_fus.deleteData(path, cpopath)
		self.pion_icrh.deleteData(path, cpopath)
		self.pion_nbi.deleteData(path, cpopath)
		self.pioniz.deleteData(path, cpopath)
		self.ploss.deleteData(path, cpopath)
		self.p_wth.deleteData(path, cpopath)
		self.p_w.deleteData(path, cpopath)
		self.p_l2h_thr.deleteData(path, cpopath)
		self.p_l2h_sc.deleteData(path, cpopath)
		self.p_nbi_icrh.deleteData(path, cpopath)


class plhstructurescenario_ref:
	'''
	class plhstructurescenario_ref
	Lower hybrid power [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='plh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class plhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type plhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type plhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = plhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pohmicstructurescenario_ref:
	'''
	class pohmicstructurescenario_ref
	ohmic power (thermal species contribution only) [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pohmic'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pohmicstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pohmicstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pohmicstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pohmicstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pohmicstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pohmicstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pohmicstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pohmicstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pohmicstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pohmicstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pohmicstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class picrhstructurescenario_ref:
	'''
	class picrhstructurescenario_ref
	Ion cyclotron resonnance heating power [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='picrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class picrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type picrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type picrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type picrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type picrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type picrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = picrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pecrhstructurescenario_ref:
	'''
	class pecrhstructurescenario_ref
	electron cyclotron resonnance heating power [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pecrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pecrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pecrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pecrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pecrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pecrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pecrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pecrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pnbistructurescenario_ref:
	'''
	class pnbistructurescenario_ref
	neutral beam injection power [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pnbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pnbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pnbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pnbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pnbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pnbi_co_curstructurescenario_ref:
	'''
	class pnbi_co_curstructurescenario_ref
	neutral beam injection power injeted in co-current direction [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pnbi_co_cur'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pnbi_co_curstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_co_curstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_co_curstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_co_curstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_co_curstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_co_curstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pnbi_co_curstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_co_curstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_co_curstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_co_curstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_co_curstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pnbi_counterstructurescenario_ref:
	'''
	class pnbi_counterstructurescenario_ref
	neutral beam injection power injeted in counter-current direction [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pnbi_counter'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pnbi_counterstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_counterstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_counterstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_counterstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_counterstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_counterstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pnbi_counterstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_counterstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_counterstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_counterstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_counterstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class plh_thstructurescenario_ref:
	'''
	class plh_thstructurescenario_ref
	lower hybrid power deposited on thermal electrons [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='plh_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class plh_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plh_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plh_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plh_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type plh_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type plh_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = plh_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plh_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plh_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plh_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plh_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class picrh_thstructurescenario_ref:
	'''
	class picrh_thstructurescenario_ref
	ion cyclotron resonnance heating power deposited on thermal species [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='picrh_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class picrh_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type picrh_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type picrh_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type picrh_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type picrh_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type picrh_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = picrh_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrh_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrh_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrh_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type picrh_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pecrh_thstructurescenario_ref:
	'''
	class pecrh_thstructurescenario_ref
	electron cyclotron resonnance heating power deposited on thermal electrons [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pecrh_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pecrh_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pecrh_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pecrh_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pecrh_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pecrh_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pecrh_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pecrh_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrh_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrh_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrh_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pecrh_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pnbi_thstructurescenario_ref:
	'''
	class pnbi_thstructurescenario_ref
	neutral beam injection power deposited on thermal species [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pnbi_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pnbi_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pnbi_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pnbi_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pnbi_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ploss_icrhstructurescenario_ref:
	'''
	class ploss_icrhstructurescenario_ref
	Ion cyclotron resonnance heating power losses [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ploss_icrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ploss_icrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_icrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_icrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_icrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_icrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_icrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ploss_icrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_icrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_icrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_icrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_icrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ploss_nbistructurescenario_ref:
	'''
	class ploss_nbistructurescenario_ref
	neutral beam injection power losses (including shine-through) [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ploss_nbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ploss_nbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_nbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_nbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_nbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_nbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_nbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ploss_nbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_nbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_nbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_nbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_nbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pbremstructurescenario_ref:
	'''
	class pbremstructurescenario_ref
	Bremsstrahlung radition losses [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pbrem'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pbremstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pbremstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pbremstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pbremstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pbremstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pbremstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pbremstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pbremstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pbremstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pbremstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pbremstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pcyclostructurescenario_ref:
	'''
	class pcyclostructurescenario_ref
	cyclotron radiation losses [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pcyclo'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pcyclostructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pcyclostructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pcyclostructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pcyclostructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pcyclostructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pcyclostructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pcyclostructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pcyclostructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pcyclostructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pcyclostructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pcyclostructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pradstructurescenario_ref:
	'''
	class pradstructurescenario_ref
	impurity radition losses in core plamsa , without Bremsstrahlung [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='prad'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pradstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pradstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pradstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pradstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pradstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pradstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pradstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pradstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pradstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pradstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pradstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pdd_fusstructurescenario_ref:
	'''
	class pdd_fusstructurescenario_ref
	fusion power due to DD reactions [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pdd_fus'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pdd_fusstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pdd_fusstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pdd_fusstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pdd_fusstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pdd_fusstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pdd_fusstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pdd_fusstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pdd_fusstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pdd_fusstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pdd_fusstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pdd_fusstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class peistructurescenario_ref:
	'''
	class peistructurescenario_ref
	power exchange between eletron and ion (equipartition) [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pei'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class peistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type peistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type peistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type peistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type peistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type peistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = peistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type peistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type peistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type peistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type peistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pel_totstructurescenario_ref:
	'''
	class pel_totstructurescenario_ref
	total thermal electron power deposition without equipartition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pel_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pel_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pel_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pel_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pel_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pel_fusstructurescenario_ref:
	'''
	class pel_fusstructurescenario_ref
	fusion electron power deposition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pel_fus'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pel_fusstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_fusstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_fusstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_fusstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pel_fusstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pel_fusstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pel_fusstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_fusstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_fusstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_fusstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_fusstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pel_icrhstructurescenario_ref:
	'''
	class pel_icrhstructurescenario_ref
	ICRH  electron power deposition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pel_icrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pel_icrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_icrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_icrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_icrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pel_icrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pel_icrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pel_icrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_icrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_icrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_icrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_icrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pel_nbistructurescenario_ref:
	'''
	class pel_nbistructurescenario_ref
	NBI electron power deposition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pel_nbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pel_nbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_nbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_nbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pel_nbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pel_nbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pel_nbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pel_nbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_nbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_nbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_nbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pel_nbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pfus_dtstructurescenario_ref:
	'''
	class pfus_dtstructurescenario_ref
	total D-T fusion power of alpha [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pfus_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pfus_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pfus_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ploss_fusstructurescenario_ref:
	'''
	class ploss_fusstructurescenario_ref
	D-T fusion power of alpha losses  [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ploss_fus'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ploss_fusstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_fusstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_fusstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_fusstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_fusstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ploss_fusstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ploss_fusstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_fusstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_fusstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_fusstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ploss_fusstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pfus_nbistructurescenario_ref:
	'''
	class pfus_nbistructurescenario_ref
	NBI induce D-T fusion power of alpha  [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pfus_nbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pfus_nbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_nbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_nbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_nbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_nbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_nbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pfus_nbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_nbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_nbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_nbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_nbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pfus_thstructurescenario_ref:
	'''
	class pfus_thstructurescenario_ref
	alpha (from DT fusion reaction)  power deposited on thermal species [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pfus_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pfus_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pfus_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pfus_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pfus_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class padd_totstructurescenario_ref:
	'''
	class padd_totstructurescenario_ref
	total additional power input including ohmic power  [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='padd_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class padd_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type padd_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type padd_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type padd_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type padd_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type padd_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = padd_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type padd_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type padd_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type padd_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type padd_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pion_totstructurescenario_ref:
	'''
	class pion_totstructurescenario_ref
	total thermal ion power deposition without equipartition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pion_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pion_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pion_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pion_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pion_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pion_fusstructurescenario_ref:
	'''
	class pion_fusstructurescenario_ref
	fusion ion power deposition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pion_fus'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pion_fusstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_fusstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_fusstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_fusstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pion_fusstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pion_fusstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pion_fusstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_fusstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_fusstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_fusstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_fusstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pion_icrhstructurescenario_ref:
	'''
	class pion_icrhstructurescenario_ref
	ICRH  ion power deposition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pion_icrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pion_icrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_icrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_icrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_icrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pion_icrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pion_icrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pion_icrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_icrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_icrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_icrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_icrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pion_nbistructurescenario_ref:
	'''
	class pion_nbistructurescenario_ref
	NBI  ion power deposition [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pion_nbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pion_nbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_nbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_nbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pion_nbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pion_nbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pion_nbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pion_nbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_nbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_nbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_nbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pion_nbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pionizstructurescenario_ref:
	'''
	class pionizstructurescenario_ref
	power losses due to cold neutral ionization [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pioniz'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pionizstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pionizstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pionizstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pionizstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pionizstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pionizstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pionizstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pionizstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pionizstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pionizstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pionizstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class plossstructurescenario_ref:
	'''
	class plossstructurescenario_ref
	plasma losses power, as define in ITER basis [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ploss'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class plossstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plossstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plossstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type plossstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type plossstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type plossstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = plossstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plossstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plossstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plossstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type plossstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_wthstructurescenario_ref:
	'''
	class p_wthstructurescenario_ref
	thermal power input, define as tau_E * P_th = Wth [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_wth'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_wthstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wthstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wthstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wthstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_wthstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_wthstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_wthstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wthstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wthstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wthstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wthstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_wstructurescenario_ref:
	'''
	class p_wstructurescenario_ref
	effective power define as tau_E  * P_w = W_tot [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_w'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_wstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_wstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_wstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_wstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_l2h_thrstructurescenario_ref:
	'''
	class p_l2h_thrstructurescenario_ref
	additionnal power crossing the LCMS; must be compare to  L->H threshold power (Ryter PPCF 2002) [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_l2h_thr'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_l2h_thrstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_thrstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_thrstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_thrstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_thrstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_thrstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_l2h_thrstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_thrstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_thrstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_thrstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_thrstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_l2h_scstructurescenario_ref:
	'''
	class p_l2h_scstructurescenario_ref
	threshold power given by the choosen scaling law for transition from L-mode to H-mode  [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_l2h_sc'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_l2h_scstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_scstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_scstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_scstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_scstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_l2h_scstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_l2h_scstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_scstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_scstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_scstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_l2h_scstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_nbi_icrhstructurescenario_ref:
	'''
	class p_nbi_icrhstructurescenario_ref
	beam power increase due to  ICRH effects  [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_nbi_icrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_nbi_icrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_nbi_icrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_nbi_icrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_nbi_icrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_nbi_icrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_nbi_icrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_nbi_icrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nbi_icrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nbi_icrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nbi_icrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nbi_icrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class itbstructurescenario_itb:
	'''
	class itbstructurescenario_itb
	Values characteristics of the Internal Transport Barrier

	Attributes:
	- q_min : class q_minstructurescenario_ref
	   minimal value of safety factor []. Time-dependent.
	- te_itb : class te_itbstructurescenario_ref
	   electron temperature @ q = q_min [eV]. Time-dependent.
	- ti_itb : class ti_itbstructurescenario_ref
	   ion temperature @ q = q_min [eV]. Time-dependent.
	- ne_itb : class ne_itbstructurescenario_ref
	   electron density  @ q = q_min [m^-3]. Time-dependent.
	- ni_itb : class ni_itbstructurescenario_ref
	   ion density  @ q = q_min [m^-3]. Time-dependent.
	- psi_itb : class psi_itbstructurescenario_ref
	   poloidal flux @ q = q_min [Wb]. Time-dependent.
	- phi_itb : class phi_itbstructurescenario_ref
	   toroidal flux @ q = q_min [Wb]. Time-dependent.
	- rho_itb : class rho_itbstructurescenario_ref
	   value of internal simulator coordinate @ q = q_min [m]. Time-dependent.
	- h_itb : class h_itbstructurescenario_ref
	   energy enhancement ITB factor [m]. Time-dependent.
	- width_itb : class width_itbstructurescenario_ref
	   width of the high pressure gradient region (on scale of rho_itb) [m]. Time-dependent.
	- vtor_itb : class vtor_itbstructurescenario_ref
	   rotation velocity of selected impurity @ rho_itb [m/s]. Time-dependent.
	- itb_type : class itb_typestructurescenario_int
	   itb type []. Time-dependent. Any combinaison of :0 = none; 1 = on T_i; 2 = on T_e; 4  = on n_e; 8 = reverse shear triggered; 16 = toroidal rotation triggered; 32 = alpha stabilisation triggered; 64 = T_i /T_e triggered; 128 = radiation triggered; 256 = rationnal q triggered
	'''

	def __init__(self, base_path_in='itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.q_min = q_minstructurescenario_ref('q_min')
		self.te_itb = te_itbstructurescenario_ref('te_itb')
		self.ti_itb = ti_itbstructurescenario_ref('ti_itb')
		self.ne_itb = ne_itbstructurescenario_ref('ne_itb')
		self.ni_itb = ni_itbstructurescenario_ref('ni_itb')
		self.psi_itb = psi_itbstructurescenario_ref('psi_itb')
		self.phi_itb = phi_itbstructurescenario_ref('phi_itb')
		self.rho_itb = rho_itbstructurescenario_ref('rho_itb')
		self.h_itb = h_itbstructurescenario_ref('h_itb')
		self.width_itb = width_itbstructurescenario_ref('width_itb')
		self.vtor_itb = vtor_itbstructurescenario_ref('vtor_itb')
		self.itb_type = itb_typestructurescenario_int('itb_type')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class itbstructurescenario_itb\n'
		ret = ret + space + 'Attribute q_min\n ' + self.q_min.__str__(depth+1)
		ret = ret + space + 'Attribute te_itb\n ' + self.te_itb.__str__(depth+1)
		ret = ret + space + 'Attribute ti_itb\n ' + self.ti_itb.__str__(depth+1)
		ret = ret + space + 'Attribute ne_itb\n ' + self.ne_itb.__str__(depth+1)
		ret = ret + space + 'Attribute ni_itb\n ' + self.ni_itb.__str__(depth+1)
		ret = ret + space + 'Attribute psi_itb\n ' + self.psi_itb.__str__(depth+1)
		ret = ret + space + 'Attribute phi_itb\n ' + self.phi_itb.__str__(depth+1)
		ret = ret + space + 'Attribute rho_itb\n ' + self.rho_itb.__str__(depth+1)
		ret = ret + space + 'Attribute h_itb\n ' + self.h_itb.__str__(depth+1)
		ret = ret + space + 'Attribute width_itb\n ' + self.width_itb.__str__(depth+1)
		ret = ret + space + 'Attribute vtor_itb\n ' + self.vtor_itb.__str__(depth+1)
		ret = ret + space + 'Attribute itb_type\n ' + self.itb_type.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.q_min.setExpIdx(idx)
		self.te_itb.setExpIdx(idx)
		self.ti_itb.setExpIdx(idx)
		self.ne_itb.setExpIdx(idx)
		self.ni_itb.setExpIdx(idx)
		self.psi_itb.setExpIdx(idx)
		self.phi_itb.setExpIdx(idx)
		self.rho_itb.setExpIdx(idx)
		self.h_itb.setExpIdx(idx)
		self.width_itb.setExpIdx(idx)
		self.vtor_itb.setExpIdx(idx)
		self.itb_type.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type itbstructurescenario_itb, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_min.cpoTime = self.cpoTime
		self.q_min.putSlice(path, cpopath)
		self.te_itb.cpoTime = self.cpoTime
		self.te_itb.putSlice(path, cpopath)
		self.ti_itb.cpoTime = self.cpoTime
		self.ti_itb.putSlice(path, cpopath)
		self.ne_itb.cpoTime = self.cpoTime
		self.ne_itb.putSlice(path, cpopath)
		self.ni_itb.cpoTime = self.cpoTime
		self.ni_itb.putSlice(path, cpopath)
		self.psi_itb.cpoTime = self.cpoTime
		self.psi_itb.putSlice(path, cpopath)
		self.phi_itb.cpoTime = self.cpoTime
		self.phi_itb.putSlice(path, cpopath)
		self.rho_itb.cpoTime = self.cpoTime
		self.rho_itb.putSlice(path, cpopath)
		self.h_itb.cpoTime = self.cpoTime
		self.h_itb.putSlice(path, cpopath)
		self.width_itb.cpoTime = self.cpoTime
		self.width_itb.putSlice(path, cpopath)
		self.vtor_itb.cpoTime = self.cpoTime
		self.vtor_itb.putSlice(path, cpopath)
		self.itb_type.cpoTime = self.cpoTime
		self.itb_type.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type itbstructurescenario_itb, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_min.replaceLastSlice(path, cpopath)
		self.te_itb.replaceLastSlice(path, cpopath)
		self.ti_itb.replaceLastSlice(path, cpopath)
		self.ne_itb.replaceLastSlice(path, cpopath)
		self.ni_itb.replaceLastSlice(path, cpopath)
		self.psi_itb.replaceLastSlice(path, cpopath)
		self.phi_itb.replaceLastSlice(path, cpopath)
		self.rho_itb.replaceLastSlice(path, cpopath)
		self.h_itb.replaceLastSlice(path, cpopath)
		self.width_itb.replaceLastSlice(path, cpopath)
		self.vtor_itb.replaceLastSlice(path, cpopath)
		self.itb_type.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type itbstructurescenario_itb, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_min.putNonTimed(path, cpopath)
		self.te_itb.putNonTimed(path, cpopath)
		self.ti_itb.putNonTimed(path, cpopath)
		self.ne_itb.putNonTimed(path, cpopath)
		self.ni_itb.putNonTimed(path, cpopath)
		self.psi_itb.putNonTimed(path, cpopath)
		self.phi_itb.putNonTimed(path, cpopath)
		self.rho_itb.putNonTimed(path, cpopath)
		self.h_itb.putNonTimed(path, cpopath)
		self.width_itb.putNonTimed(path, cpopath)
		self.vtor_itb.putNonTimed(path, cpopath)
		self.itb_type.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type itbstructurescenario_itb, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_min.getSlice(path, cpopath, inTime, interpolMode)
		self.te_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.ni_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.psi_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.phi_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.rho_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.h_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.width_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.vtor_itb.getSlice(path, cpopath, inTime, interpolMode)
		self.itb_type.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type itbstructurescenario_itb, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			q_minList = self.q_min.build_non_resampled_data(path, cpopath, nbslice)
			te_itbList = self.te_itb.build_non_resampled_data(path, cpopath, nbslice)
			ti_itbList = self.ti_itb.build_non_resampled_data(path, cpopath, nbslice)
			ne_itbList = self.ne_itb.build_non_resampled_data(path, cpopath, nbslice)
			ni_itbList = self.ni_itb.build_non_resampled_data(path, cpopath, nbslice)
			psi_itbList = self.psi_itb.build_non_resampled_data(path, cpopath, nbslice)
			phi_itbList = self.phi_itb.build_non_resampled_data(path, cpopath, nbslice)
			rho_itbList = self.rho_itb.build_non_resampled_data(path, cpopath, nbslice)
			h_itbList = self.h_itb.build_non_resampled_data(path, cpopath, nbslice)
			width_itbList = self.width_itb.build_non_resampled_data(path, cpopath, nbslice)
			vtor_itbList = self.vtor_itb.build_non_resampled_data(path, cpopath, nbslice)
			itb_typeList = self.itb_type.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = itbstructurescenario_itb(self.base_path)
				slice.setExpIdx(self.idx)
				slice.q_min = q_minList[i]
				slice.te_itb = te_itbList[i]
				slice.ti_itb = ti_itbList[i]
				slice.ne_itb = ne_itbList[i]
				slice.ni_itb = ni_itbList[i]
				slice.psi_itb = psi_itbList[i]
				slice.phi_itb = phi_itbList[i]
				slice.rho_itb = rho_itbList[i]
				slice.h_itb = h_itbList[i]
				slice.width_itb = width_itbList[i]
				slice.vtor_itb = vtor_itbList[i]
				slice.itb_type = itb_typeList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itbstructurescenario_itbObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.q_min.putTimedElt(path, cpopath + 'q_min', i, obj)
		obj = self.te_itb.putTimedElt(path, cpopath + 'te_itb', i, obj)
		obj = self.ti_itb.putTimedElt(path, cpopath + 'ti_itb', i, obj)
		obj = self.ne_itb.putTimedElt(path, cpopath + 'ne_itb', i, obj)
		obj = self.ni_itb.putTimedElt(path, cpopath + 'ni_itb', i, obj)
		obj = self.psi_itb.putTimedElt(path, cpopath + 'psi_itb', i, obj)
		obj = self.phi_itb.putTimedElt(path, cpopath + 'phi_itb', i, obj)
		obj = self.rho_itb.putTimedElt(path, cpopath + 'rho_itb', i, obj)
		obj = self.h_itb.putTimedElt(path, cpopath + 'h_itb', i, obj)
		obj = self.width_itb.putTimedElt(path, cpopath + 'width_itb', i, obj)
		obj = self.vtor_itb.putTimedElt(path, cpopath + 'vtor_itb', i, obj)
		obj = self.itb_type.putTimedElt(path, cpopath + 'itb_type', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itbstructurescenario_itbObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.q_min.getTimedElt(path, cpopath + 'q_min', i, obj)
		self.te_itb.getTimedElt(path, cpopath + 'te_itb', i, obj)
		self.ti_itb.getTimedElt(path, cpopath + 'ti_itb', i, obj)
		self.ne_itb.getTimedElt(path, cpopath + 'ne_itb', i, obj)
		self.ni_itb.getTimedElt(path, cpopath + 'ni_itb', i, obj)
		self.psi_itb.getTimedElt(path, cpopath + 'psi_itb', i, obj)
		self.phi_itb.getTimedElt(path, cpopath + 'phi_itb', i, obj)
		self.rho_itb.getTimedElt(path, cpopath + 'rho_itb', i, obj)
		self.h_itb.getTimedElt(path, cpopath + 'h_itb', i, obj)
		self.width_itb.getTimedElt(path, cpopath + 'width_itb', i, obj)
		self.vtor_itb.getTimedElt(path, cpopath + 'vtor_itb', i, obj)
		self.itb_type.getTimedElt(path, cpopath + 'itb_type', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itbstructurescenario_itbObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.q_min.putNonTimedElt(path, cpopath + 'q_min', i, obj)
		obj = self.te_itb.putNonTimedElt(path, cpopath + 'te_itb', i, obj)
		obj = self.ti_itb.putNonTimedElt(path, cpopath + 'ti_itb', i, obj)
		obj = self.ne_itb.putNonTimedElt(path, cpopath + 'ne_itb', i, obj)
		obj = self.ni_itb.putNonTimedElt(path, cpopath + 'ni_itb', i, obj)
		obj = self.psi_itb.putNonTimedElt(path, cpopath + 'psi_itb', i, obj)
		obj = self.phi_itb.putNonTimedElt(path, cpopath + 'phi_itb', i, obj)
		obj = self.rho_itb.putNonTimedElt(path, cpopath + 'rho_itb', i, obj)
		obj = self.h_itb.putNonTimedElt(path, cpopath + 'h_itb', i, obj)
		obj = self.width_itb.putNonTimedElt(path, cpopath + 'width_itb', i, obj)
		obj = self.vtor_itb.putNonTimedElt(path, cpopath + 'vtor_itb', i, obj)
		obj = self.itb_type.putNonTimedElt(path, cpopath + 'itb_type', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itbstructurescenario_itbObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.q_min.getNonTimedElt(path, cpopath + 'q_min', i, obj)
		self.te_itb.getNonTimedElt(path, cpopath + 'te_itb', i, obj)
		self.ti_itb.getNonTimedElt(path, cpopath + 'ti_itb', i, obj)
		self.ne_itb.getNonTimedElt(path, cpopath + 'ne_itb', i, obj)
		self.ni_itb.getNonTimedElt(path, cpopath + 'ni_itb', i, obj)
		self.psi_itb.getNonTimedElt(path, cpopath + 'psi_itb', i, obj)
		self.phi_itb.getNonTimedElt(path, cpopath + 'phi_itb', i, obj)
		self.rho_itb.getNonTimedElt(path, cpopath + 'rho_itb', i, obj)
		self.h_itb.getNonTimedElt(path, cpopath + 'h_itb', i, obj)
		self.width_itb.getNonTimedElt(path, cpopath + 'width_itb', i, obj)
		self.vtor_itb.getNonTimedElt(path, cpopath + 'vtor_itb', i, obj)
		self.itb_type.getNonTimedElt(path, cpopath + 'itb_type', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_min.deleteData(path, cpopath)
		self.te_itb.deleteData(path, cpopath)
		self.ti_itb.deleteData(path, cpopath)
		self.ne_itb.deleteData(path, cpopath)
		self.ni_itb.deleteData(path, cpopath)
		self.psi_itb.deleteData(path, cpopath)
		self.phi_itb.deleteData(path, cpopath)
		self.rho_itb.deleteData(path, cpopath)
		self.h_itb.deleteData(path, cpopath)
		self.width_itb.deleteData(path, cpopath)
		self.vtor_itb.deleteData(path, cpopath)
		self.itb_type.deleteData(path, cpopath)


class q_minstructurescenario_ref:
	'''
	class q_minstructurescenario_ref
	minimal value of safety factor []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q_min'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q_minstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_minstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_minstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_minstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q_minstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q_minstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q_minstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_minstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_minstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_minstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_minstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class te_itbstructurescenario_ref:
	'''
	class te_itbstructurescenario_ref
	electron temperature @ q = q_min [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_itbstructurescenario_ref:
	'''
	class ti_itbstructurescenario_ref
	ion temperature @ q = q_min [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_itbstructurescenario_ref:
	'''
	class ne_itbstructurescenario_ref
	electron density  @ q = q_min [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni_itbstructurescenario_ref:
	'''
	class ni_itbstructurescenario_ref
	ion density  @ q = q_min [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class psi_itbstructurescenario_ref:
	'''
	class psi_itbstructurescenario_ref
	poloidal flux @ q = q_min [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='psi_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class psi_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type psi_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type psi_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = psi_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class phi_itbstructurescenario_ref:
	'''
	class phi_itbstructurescenario_ref
	toroidal flux @ q = q_min [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='phi_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class phi_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type phi_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type phi_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = phi_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class rho_itbstructurescenario_ref:
	'''
	class rho_itbstructurescenario_ref
	value of internal simulator coordinate @ q = q_min [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='rho_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class rho_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type rho_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type rho_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = rho_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class h_itbstructurescenario_ref:
	'''
	class h_itbstructurescenario_ref
	energy enhancement ITB factor [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='h_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class h_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type h_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type h_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type h_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type h_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type h_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = h_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type h_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type h_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type h_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type h_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class width_itbstructurescenario_ref:
	'''
	class width_itbstructurescenario_ref
	width of the high pressure gradient region (on scale of rho_itb) [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='width_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class width_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type width_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type width_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type width_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type width_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type width_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = width_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type width_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type width_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type width_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type width_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class vtor_itbstructurescenario_ref:
	'''
	class vtor_itbstructurescenario_ref
	rotation velocity of selected impurity @ rho_itb [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='vtor_itb'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class vtor_itbstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_itbstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_itbstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_itbstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_itbstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_itbstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = vtor_itbstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_itbstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_itbstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_itbstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_itbstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class itb_typestructurescenario_int:
	'''
	class itb_typestructurescenario_int
	itb type []. Time-dependent. Any combinaison of :0 = none; 1 = on T_i; 2 = on T_e; 4  = on n_e; 8 = reverse shear triggered; 16 = toroidal rotation triggered; 32 = alpha stabilisation triggered; 64 = T_i /T_e triggered; 128 = radiation triggered; 256 = rationnal q triggered

	Attributes:
	- value : int
	   Signal value; Time-dependent; Scalar Integer.
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='itb_type'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_INT
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class itb_typestructurescenario_int\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type itb_typestructurescenario_int, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type itb_typestructurescenario_int, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type itb_typestructurescenario_int, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type itb_typestructurescenario_int, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getIntSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type itb_typestructurescenario_int, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DInt(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = itb_typestructurescenario_int(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = int(valueList[i].copy())
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itb_typestructurescenario_intObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itb_typestructurescenario_intObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getIntFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itb_typestructurescenario_intObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type itb_typestructurescenario_intObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class lim_div_wallstructurescenario_lim_div_wall:
	'''
	class lim_div_wallstructurescenario_lim_div_wall
	values on the plate of divertor or on the limitor or on the wall (@ LCMS)

	Attributes:
	- te_lim_div : class te_lim_divstructurescenario_ref
	   limiter/divertor electron temperature [eV]. Time-dependent.
	- ti_lim_div : class ti_lim_divstructurescenario_ref
	   limiter/divertor ion temperature [eV]. Time-dependent.
	- ne_lim_div : class ne_lim_divstructurescenario_ref
	   limiter/divertor electron density [m^-3]. Time-dependent.
	- ni_lim_div : class ni_lim_divstructurescenario_ref
	   limiter/divertor ion density [m^-3]. Time-dependent.
	- q_peak_div : class q_peak_divstructurescenario_ref
	   Peak power flux on limiter or divertor plate [W.m^-2]. Time-dependent.
	- q_peak_wall : class q_peak_wallstructurescenario_ref
	   Peak power flux on the wall [W.m^-2]. Time-dependent.
	- surf_temp : class surf_tempstructurescenario_ref
	   limiter surface or divertor plate temperature [K]. Time-dependent.
	- p_lim_div : class p_lim_divstructurescenario_ref
	   Total power on limiter or divertor plate [W]. Time-dependent.
	- p_rad_div : class p_rad_divstructurescenario_ref
	   radiative power in the divertor zone [W]. Time-dependent.
	- p_neut_div : class p_neut_divstructurescenario_ref
	   Neutral pressure in the divertor zone [Pa]; Time-dependent.
	- p_wall : class p_wallstructurescenario_ref
	   Total power on the wall [W]. Time-dependent.
	- wall_temp : class wall_tempstructurescenario_ref
	   wall temperature [K]. Time-dependent.
	- wall_state : class wall_statestructurescenario_ref
	   saturation state of the wall (0 = completly pumping wall, 1 = competely saturate wall) []. Time-dependent.
	- detach_state : class detach_statestructurescenario_ref
	   plasma detachement state (0= attach plasma, 1 = completely detach plasma) []. Time-dependent.
	- pump_flux : class pump_fluxstructurescenario_ref
	   flux pump out for each ion species [s^-1]. Time-dependent.
	- p_rad_fw : class p_rad_fwstructurescenario_ref
	   Radiated power on the first wall [W]; Time-dependent
	- p_cond_fw : class p_cond_fwstructurescenario_ref
	   Conducted/convected power  on the first wall [W]; Time-dependent
	- div_wetted : class div_wettedstructurescenario_ref
	   Divertor wetted area [m^2]; Time-dependent
	- gas_puff : class gas_puffstructurescenario_ref
	   Gas puff (D/T) in the divertor (PFR) [Pa.m^3.s^-1]; Time-dependent
	- ar_concentr : class ar_concentrstructurescenario_ref
	   Argon concentration in the divertor; Time-dependent
	- part_exhaust : class part_exhauststructurescenario_ref
	   Assuming a pumping speed [Pa.m^3.s^-1]; Time-dependent
	- f_inner : class f_innerstructurescenario_ref
	   Fraction of power to the inner divertor; Time-dependent
	- f_outer : class f_outerstructurescenario_ref
	   Fraction of power to the outer divertor; Time-dependent
	- f_pfr : class f_pfrstructurescenario_ref
	   Fraction of power flowing into the private flux region; Time-dependent
	- f_rad_fw : class f_rad_fwstructurescenario_ref
	   Fraction of the divertor radiated power deposited in the main chamber; Time-dependent
	- q_div : numpy.ndarray 1D with float
	   Heat flux on divertor plate [W/m^2]; Vector(theta). Time-dependent
	- p_cond_div : class p_cond_divstructurescenario_ref
	   Conducted/convected power on divertor plate  [W]; Time-dependent
	- pol_ext : float
	   Poloidal extension of the divertor or outer major radius of the divertor region (and inner major radius) [rad]; Scalar
	- flux_exp : float
	   Flux expansion at the divertor plate ((B_theta/B)midplane)/((B_theta/B)target); Scalar
	- tilt_angle : float
	   Tilt angle between the field lines and the divertor plate in a poloidal plane [rad]; Scalar
	- n_div : float
	   Number of divertor, assuming symmetric configuration; Scalar
	- div_dz : float
	   Divertor extension in z direction from the x-point [m]; Scalar
	- div_dro : float
	   Divertor extension in r outward direction from the x-point [m]; Scalar
	- div_dri : float
	   Divertor extension in r intward direction from the x-point [m]; Scalar
	- p_nh_div : class p_nh_divstructurescenario_ref
	   Total nuclear heating in divertor [W]. Time-dependent.
	'''

	def __init__(self, base_path_in='lim_div_wall'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.te_lim_div = te_lim_divstructurescenario_ref('te_lim_div')
		self.ti_lim_div = ti_lim_divstructurescenario_ref('ti_lim_div')
		self.ne_lim_div = ne_lim_divstructurescenario_ref('ne_lim_div')
		self.ni_lim_div = ni_lim_divstructurescenario_ref('ni_lim_div')
		self.q_peak_div = q_peak_divstructurescenario_ref('q_peak_div')
		self.q_peak_wall = q_peak_wallstructurescenario_ref('q_peak_wall')
		self.surf_temp = surf_tempstructurescenario_ref('surf_temp')
		self.p_lim_div = p_lim_divstructurescenario_ref('p_lim_div')
		self.p_rad_div = p_rad_divstructurescenario_ref('p_rad_div')
		self.p_neut_div = p_neut_divstructurescenario_ref('p_neut_div')
		self.p_wall = p_wallstructurescenario_ref('p_wall')
		self.wall_temp = wall_tempstructurescenario_ref('wall_temp')
		self.wall_state = wall_statestructurescenario_ref('wall_state')
		self.detach_state = detach_statestructurescenario_ref('detach_state')
		self.pump_flux = pump_fluxstructurescenario_ref('pump_flux')
		self.p_rad_fw = p_rad_fwstructurescenario_ref('p_rad_fw')
		self.p_cond_fw = p_cond_fwstructurescenario_ref('p_cond_fw')
		self.div_wetted = div_wettedstructurescenario_ref('div_wetted')
		self.gas_puff = gas_puffstructurescenario_ref('gas_puff')
		self.ar_concentr = ar_concentrstructurescenario_ref('ar_concentr')
		self.part_exhaust = part_exhauststructurescenario_ref('part_exhaust')
		self.f_inner = f_innerstructurescenario_ref('f_inner')
		self.f_outer = f_outerstructurescenario_ref('f_outer')
		self.f_pfr = f_pfrstructurescenario_ref('f_pfr')
		self.f_rad_fw = f_rad_fwstructurescenario_ref('f_rad_fw')
		self.q_div = numpy.zeros(0, numpy.float64, order='C')
		self.p_cond_div = p_cond_divstructurescenario_ref('p_cond_div')
		self.pol_ext = EMPTY_DOUBLE
		self.flux_exp = EMPTY_DOUBLE
		self.tilt_angle = EMPTY_DOUBLE
		self.n_div = EMPTY_DOUBLE
		self.div_dz = EMPTY_DOUBLE
		self.div_dro = EMPTY_DOUBLE
		self.div_dri = EMPTY_DOUBLE
		self.p_nh_div = p_nh_divstructurescenario_ref('p_nh_div')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class lim_div_wallstructurescenario_lim_div_wall\n'
		ret = ret + space + 'Attribute te_lim_div\n ' + self.te_lim_div.__str__(depth+1)
		ret = ret + space + 'Attribute ti_lim_div\n ' + self.ti_lim_div.__str__(depth+1)
		ret = ret + space + 'Attribute ne_lim_div\n ' + self.ne_lim_div.__str__(depth+1)
		ret = ret + space + 'Attribute ni_lim_div\n ' + self.ni_lim_div.__str__(depth+1)
		ret = ret + space + 'Attribute q_peak_div\n ' + self.q_peak_div.__str__(depth+1)
		ret = ret + space + 'Attribute q_peak_wall\n ' + self.q_peak_wall.__str__(depth+1)
		ret = ret + space + 'Attribute surf_temp\n ' + self.surf_temp.__str__(depth+1)
		ret = ret + space + 'Attribute p_lim_div\n ' + self.p_lim_div.__str__(depth+1)
		ret = ret + space + 'Attribute p_rad_div\n ' + self.p_rad_div.__str__(depth+1)
		ret = ret + space + 'Attribute p_neut_div\n ' + self.p_neut_div.__str__(depth+1)
		ret = ret + space + 'Attribute p_wall\n ' + self.p_wall.__str__(depth+1)
		ret = ret + space + 'Attribute wall_temp\n ' + self.wall_temp.__str__(depth+1)
		ret = ret + space + 'Attribute wall_state\n ' + self.wall_state.__str__(depth+1)
		ret = ret + space + 'Attribute detach_state\n ' + self.detach_state.__str__(depth+1)
		ret = ret + space + 'Attribute pump_flux\n ' + self.pump_flux.__str__(depth+1)
		ret = ret + space + 'Attribute p_rad_fw\n ' + self.p_rad_fw.__str__(depth+1)
		ret = ret + space + 'Attribute p_cond_fw\n ' + self.p_cond_fw.__str__(depth+1)
		ret = ret + space + 'Attribute div_wetted\n ' + self.div_wetted.__str__(depth+1)
		ret = ret + space + 'Attribute gas_puff\n ' + self.gas_puff.__str__(depth+1)
		ret = ret + space + 'Attribute ar_concentr\n ' + self.ar_concentr.__str__(depth+1)
		ret = ret + space + 'Attribute part_exhaust\n ' + self.part_exhaust.__str__(depth+1)
		ret = ret + space + 'Attribute f_inner\n ' + self.f_inner.__str__(depth+1)
		ret = ret + space + 'Attribute f_outer\n ' + self.f_outer.__str__(depth+1)
		ret = ret + space + 'Attribute f_pfr\n ' + self.f_pfr.__str__(depth+1)
		ret = ret + space + 'Attribute f_rad_fw\n ' + self.f_rad_fw.__str__(depth+1)
		s = self.q_div.__str__()
		ret = ret + space + 'Attribute q_div\n' + space + s.replace('\n', '\n'+space) + '\n'
		ret = ret + space + 'Attribute p_cond_div\n ' + self.p_cond_div.__str__(depth+1)
		ret = ret + space + 'Attribute pol_ext: ' + str(self.pol_ext) + '\n'
		ret = ret + space + 'Attribute flux_exp: ' + str(self.flux_exp) + '\n'
		ret = ret + space + 'Attribute tilt_angle: ' + str(self.tilt_angle) + '\n'
		ret = ret + space + 'Attribute n_div: ' + str(self.n_div) + '\n'
		ret = ret + space + 'Attribute div_dz: ' + str(self.div_dz) + '\n'
		ret = ret + space + 'Attribute div_dro: ' + str(self.div_dro) + '\n'
		ret = ret + space + 'Attribute div_dri: ' + str(self.div_dri) + '\n'
		ret = ret + space + 'Attribute p_nh_div\n ' + self.p_nh_div.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.te_lim_div.setExpIdx(idx)
		self.ti_lim_div.setExpIdx(idx)
		self.ne_lim_div.setExpIdx(idx)
		self.ni_lim_div.setExpIdx(idx)
		self.q_peak_div.setExpIdx(idx)
		self.q_peak_wall.setExpIdx(idx)
		self.surf_temp.setExpIdx(idx)
		self.p_lim_div.setExpIdx(idx)
		self.p_rad_div.setExpIdx(idx)
		self.p_neut_div.setExpIdx(idx)
		self.p_wall.setExpIdx(idx)
		self.wall_temp.setExpIdx(idx)
		self.wall_state.setExpIdx(idx)
		self.detach_state.setExpIdx(idx)
		self.pump_flux.setExpIdx(idx)
		self.p_rad_fw.setExpIdx(idx)
		self.p_cond_fw.setExpIdx(idx)
		self.div_wetted.setExpIdx(idx)
		self.gas_puff.setExpIdx(idx)
		self.ar_concentr.setExpIdx(idx)
		self.part_exhaust.setExpIdx(idx)
		self.f_inner.setExpIdx(idx)
		self.f_outer.setExpIdx(idx)
		self.f_pfr.setExpIdx(idx)
		self.f_rad_fw.setExpIdx(idx)
		self.p_cond_div.setExpIdx(idx)
		self.p_nh_div.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type lim_div_wallstructurescenario_lim_div_wall, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_lim_div.cpoTime = self.cpoTime
		self.te_lim_div.putSlice(path, cpopath)
		self.ti_lim_div.cpoTime = self.cpoTime
		self.ti_lim_div.putSlice(path, cpopath)
		self.ne_lim_div.cpoTime = self.cpoTime
		self.ne_lim_div.putSlice(path, cpopath)
		self.ni_lim_div.cpoTime = self.cpoTime
		self.ni_lim_div.putSlice(path, cpopath)
		self.q_peak_div.cpoTime = self.cpoTime
		self.q_peak_div.putSlice(path, cpopath)
		self.q_peak_wall.cpoTime = self.cpoTime
		self.q_peak_wall.putSlice(path, cpopath)
		self.surf_temp.cpoTime = self.cpoTime
		self.surf_temp.putSlice(path, cpopath)
		self.p_lim_div.cpoTime = self.cpoTime
		self.p_lim_div.putSlice(path, cpopath)
		self.p_rad_div.cpoTime = self.cpoTime
		self.p_rad_div.putSlice(path, cpopath)
		self.p_neut_div.cpoTime = self.cpoTime
		self.p_neut_div.putSlice(path, cpopath)
		self.p_wall.cpoTime = self.cpoTime
		self.p_wall.putSlice(path, cpopath)
		self.wall_temp.cpoTime = self.cpoTime
		self.wall_temp.putSlice(path, cpopath)
		self.wall_state.cpoTime = self.cpoTime
		self.wall_state.putSlice(path, cpopath)
		self.detach_state.cpoTime = self.cpoTime
		self.detach_state.putSlice(path, cpopath)
		self.pump_flux.cpoTime = self.cpoTime
		self.pump_flux.putSlice(path, cpopath)
		self.p_rad_fw.cpoTime = self.cpoTime
		self.p_rad_fw.putSlice(path, cpopath)
		self.p_cond_fw.cpoTime = self.cpoTime
		self.p_cond_fw.putSlice(path, cpopath)
		self.div_wetted.cpoTime = self.cpoTime
		self.div_wetted.putSlice(path, cpopath)
		self.gas_puff.cpoTime = self.cpoTime
		self.gas_puff.putSlice(path, cpopath)
		self.ar_concentr.cpoTime = self.cpoTime
		self.ar_concentr.putSlice(path, cpopath)
		self.part_exhaust.cpoTime = self.cpoTime
		self.part_exhaust.putSlice(path, cpopath)
		self.f_inner.cpoTime = self.cpoTime
		self.f_inner.putSlice(path, cpopath)
		self.f_outer.cpoTime = self.cpoTime
		self.f_outer.putSlice(path, cpopath)
		self.f_pfr.cpoTime = self.cpoTime
		self.f_pfr.putSlice(path, cpopath)
		self.f_rad_fw.cpoTime = self.cpoTime
		self.f_rad_fw.putSlice(path, cpopath)
		status = ull.putVect1DDoubleSlice(self.idx, path, cpopath + 'q_div', numpy.array(self.q_div).astype(numpy.float64), self.cpoTime)
		check_status(status)
		self.p_cond_div.cpoTime = self.cpoTime
		self.p_cond_div.putSlice(path, cpopath)
		self.p_nh_div.cpoTime = self.cpoTime
		self.p_nh_div.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type lim_div_wallstructurescenario_lim_div_wall, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_lim_div.replaceLastSlice(path, cpopath)
		self.ti_lim_div.replaceLastSlice(path, cpopath)
		self.ne_lim_div.replaceLastSlice(path, cpopath)
		self.ni_lim_div.replaceLastSlice(path, cpopath)
		self.q_peak_div.replaceLastSlice(path, cpopath)
		self.q_peak_wall.replaceLastSlice(path, cpopath)
		self.surf_temp.replaceLastSlice(path, cpopath)
		self.p_lim_div.replaceLastSlice(path, cpopath)
		self.p_rad_div.replaceLastSlice(path, cpopath)
		self.p_neut_div.replaceLastSlice(path, cpopath)
		self.p_wall.replaceLastSlice(path, cpopath)
		self.wall_temp.replaceLastSlice(path, cpopath)
		self.wall_state.replaceLastSlice(path, cpopath)
		self.detach_state.replaceLastSlice(path, cpopath)
		self.pump_flux.replaceLastSlice(path, cpopath)
		self.p_rad_fw.replaceLastSlice(path, cpopath)
		self.p_cond_fw.replaceLastSlice(path, cpopath)
		self.div_wetted.replaceLastSlice(path, cpopath)
		self.gas_puff.replaceLastSlice(path, cpopath)
		self.ar_concentr.replaceLastSlice(path, cpopath)
		self.part_exhaust.replaceLastSlice(path, cpopath)
		self.f_inner.replaceLastSlice(path, cpopath)
		self.f_outer.replaceLastSlice(path, cpopath)
		self.f_pfr.replaceLastSlice(path, cpopath)
		self.f_rad_fw.replaceLastSlice(path, cpopath)
		status = ull.replaceLastVect1DDoubleSlice(self.idx, path, cpopath + 'q_div', numpy.array(self.q_div).astype(numpy.float64))
		check_status(status)
		self.p_cond_div.replaceLastSlice(path, cpopath)
		self.p_nh_div.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type lim_div_wallstructurescenario_lim_div_wall, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_lim_div.putNonTimed(path, cpopath)
		self.ti_lim_div.putNonTimed(path, cpopath)
		self.ne_lim_div.putNonTimed(path, cpopath)
		self.ni_lim_div.putNonTimed(path, cpopath)
		self.q_peak_div.putNonTimed(path, cpopath)
		self.q_peak_wall.putNonTimed(path, cpopath)
		self.surf_temp.putNonTimed(path, cpopath)
		self.p_lim_div.putNonTimed(path, cpopath)
		self.p_rad_div.putNonTimed(path, cpopath)
		self.p_neut_div.putNonTimed(path, cpopath)
		self.p_wall.putNonTimed(path, cpopath)
		self.wall_temp.putNonTimed(path, cpopath)
		self.wall_state.putNonTimed(path, cpopath)
		self.detach_state.putNonTimed(path, cpopath)
		self.pump_flux.putNonTimed(path, cpopath)
		self.p_rad_fw.putNonTimed(path, cpopath)
		self.p_cond_fw.putNonTimed(path, cpopath)
		self.div_wetted.putNonTimed(path, cpopath)
		self.gas_puff.putNonTimed(path, cpopath)
		self.ar_concentr.putNonTimed(path, cpopath)
		self.part_exhaust.putNonTimed(path, cpopath)
		self.f_inner.putNonTimed(path, cpopath)
		self.f_outer.putNonTimed(path, cpopath)
		self.f_pfr.putNonTimed(path, cpopath)
		self.f_rad_fw.putNonTimed(path, cpopath)
		self.p_cond_div.putNonTimed(path, cpopath)
		status = ull.putDouble(self.idx, path, cpopath + 'pol_ext', self.pol_ext)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'flux_exp', self.flux_exp)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'tilt_angle', self.tilt_angle)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'n_div', self.n_div)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'div_dz', self.div_dz)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'div_dro', self.div_dro)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'div_dri', self.div_dri)
		check_status(status)
		self.p_nh_div.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type lim_div_wallstructurescenario_lim_div_wall, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_lim_div.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_lim_div.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_lim_div.getSlice(path, cpopath, inTime, interpolMode)
		self.ni_lim_div.getSlice(path, cpopath, inTime, interpolMode)
		self.q_peak_div.getSlice(path, cpopath, inTime, interpolMode)
		self.q_peak_wall.getSlice(path, cpopath, inTime, interpolMode)
		self.surf_temp.getSlice(path, cpopath, inTime, interpolMode)
		self.p_lim_div.getSlice(path, cpopath, inTime, interpolMode)
		self.p_rad_div.getSlice(path, cpopath, inTime, interpolMode)
		self.p_neut_div.getSlice(path, cpopath, inTime, interpolMode)
		self.p_wall.getSlice(path, cpopath, inTime, interpolMode)
		self.wall_temp.getSlice(path, cpopath, inTime, interpolMode)
		self.wall_state.getSlice(path, cpopath, inTime, interpolMode)
		self.detach_state.getSlice(path, cpopath, inTime, interpolMode)
		self.pump_flux.getSlice(path, cpopath, inTime, interpolMode)
		self.p_rad_fw.getSlice(path, cpopath, inTime, interpolMode)
		self.p_cond_fw.getSlice(path, cpopath, inTime, interpolMode)
		self.div_wetted.getSlice(path, cpopath, inTime, interpolMode)
		self.gas_puff.getSlice(path, cpopath, inTime, interpolMode)
		self.ar_concentr.getSlice(path, cpopath, inTime, interpolMode)
		self.part_exhaust.getSlice(path, cpopath, inTime, interpolMode)
		self.f_inner.getSlice(path, cpopath, inTime, interpolMode)
		self.f_outer.getSlice(path, cpopath, inTime, interpolMode)
		self.f_pfr.getSlice(path, cpopath, inTime, interpolMode)
		self.f_rad_fw.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_q_div, retTime = ull.getVect1DDoubleSlice(self.idx, path, cpopath + 'q_div', inTime, interpolMode)
		check_status(status)
		if not status:
			self.q_div = ret_q_div
			self.cpoTime = retTime
		self.p_cond_div.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_pol_ext = ull.getDouble(self.idx, path, cpopath + 'pol_ext')
		check_status(status)
		if not status:
			self.pol_ext = ret_pol_ext
		status, ret_flux_exp = ull.getDouble(self.idx, path, cpopath + 'flux_exp')
		check_status(status)
		if not status:
			self.flux_exp = ret_flux_exp
		status, ret_tilt_angle = ull.getDouble(self.idx, path, cpopath + 'tilt_angle')
		check_status(status)
		if not status:
			self.tilt_angle = ret_tilt_angle
		status, ret_n_div = ull.getDouble(self.idx, path, cpopath + 'n_div')
		check_status(status)
		if not status:
			self.n_div = ret_n_div
		status, ret_div_dz = ull.getDouble(self.idx, path, cpopath + 'div_dz')
		check_status(status)
		if not status:
			self.div_dz = ret_div_dz
		status, ret_div_dro = ull.getDouble(self.idx, path, cpopath + 'div_dro')
		check_status(status)
		if not status:
			self.div_dro = ret_div_dro
		status, ret_div_dri = ull.getDouble(self.idx, path, cpopath + 'div_dri')
		check_status(status)
		if not status:
			self.div_dri = ret_div_dri
		self.p_nh_div.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type lim_div_wallstructurescenario_lim_div_wall, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			te_lim_divList = self.te_lim_div.build_non_resampled_data(path, cpopath, nbslice)
			ti_lim_divList = self.ti_lim_div.build_non_resampled_data(path, cpopath, nbslice)
			ne_lim_divList = self.ne_lim_div.build_non_resampled_data(path, cpopath, nbslice)
			ni_lim_divList = self.ni_lim_div.build_non_resampled_data(path, cpopath, nbslice)
			q_peak_divList = self.q_peak_div.build_non_resampled_data(path, cpopath, nbslice)
			q_peak_wallList = self.q_peak_wall.build_non_resampled_data(path, cpopath, nbslice)
			surf_tempList = self.surf_temp.build_non_resampled_data(path, cpopath, nbslice)
			p_lim_divList = self.p_lim_div.build_non_resampled_data(path, cpopath, nbslice)
			p_rad_divList = self.p_rad_div.build_non_resampled_data(path, cpopath, nbslice)
			p_neut_divList = self.p_neut_div.build_non_resampled_data(path, cpopath, nbslice)
			p_wallList = self.p_wall.build_non_resampled_data(path, cpopath, nbslice)
			wall_tempList = self.wall_temp.build_non_resampled_data(path, cpopath, nbslice)
			wall_stateList = self.wall_state.build_non_resampled_data(path, cpopath, nbslice)
			detach_stateList = self.detach_state.build_non_resampled_data(path, cpopath, nbslice)
			pump_fluxList = self.pump_flux.build_non_resampled_data(path, cpopath, nbslice)
			p_rad_fwList = self.p_rad_fw.build_non_resampled_data(path, cpopath, nbslice)
			p_cond_fwList = self.p_cond_fw.build_non_resampled_data(path, cpopath, nbslice)
			div_wettedList = self.div_wetted.build_non_resampled_data(path, cpopath, nbslice)
			gas_puffList = self.gas_puff.build_non_resampled_data(path, cpopath, nbslice)
			ar_concentrList = self.ar_concentr.build_non_resampled_data(path, cpopath, nbslice)
			part_exhaustList = self.part_exhaust.build_non_resampled_data(path, cpopath, nbslice)
			f_innerList = self.f_inner.build_non_resampled_data(path, cpopath, nbslice)
			f_outerList = self.f_outer.build_non_resampled_data(path, cpopath, nbslice)
			f_pfrList = self.f_pfr.build_non_resampled_data(path, cpopath, nbslice)
			f_rad_fwList = self.f_rad_fw.build_non_resampled_data(path, cpopath, nbslice)
			status, q_divList = ull.getVect2DDouble(self.idx, path, cpopath + 'q_div')
			if len(q_divList) == 0:
				q_divList = numpy.resize(q_divList, (0,nbslice))
			check_status(status)
			p_cond_divList = self.p_cond_div.build_non_resampled_data(path, cpopath, nbslice)
			status, pol_extVal = ull.getDouble(self.idx, path, cpopath + 'pol_ext')
			check_status(status)
			status, flux_expVal = ull.getDouble(self.idx, path, cpopath + 'flux_exp')
			check_status(status)
			status, tilt_angleVal = ull.getDouble(self.idx, path, cpopath + 'tilt_angle')
			check_status(status)
			status, n_divVal = ull.getDouble(self.idx, path, cpopath + 'n_div')
			check_status(status)
			status, div_dzVal = ull.getDouble(self.idx, path, cpopath + 'div_dz')
			check_status(status)
			status, div_droVal = ull.getDouble(self.idx, path, cpopath + 'div_dro')
			check_status(status)
			status, div_driVal = ull.getDouble(self.idx, path, cpopath + 'div_dri')
			check_status(status)
			p_nh_divList = self.p_nh_div.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = lim_div_wallstructurescenario_lim_div_wall(self.base_path)
				slice.setExpIdx(self.idx)
				slice.te_lim_div = te_lim_divList[i]
				slice.ti_lim_div = ti_lim_divList[i]
				slice.ne_lim_div = ne_lim_divList[i]
				slice.ni_lim_div = ni_lim_divList[i]
				slice.q_peak_div = q_peak_divList[i]
				slice.q_peak_wall = q_peak_wallList[i]
				slice.surf_temp = surf_tempList[i]
				slice.p_lim_div = p_lim_divList[i]
				slice.p_rad_div = p_rad_divList[i]
				slice.p_neut_div = p_neut_divList[i]
				slice.p_wall = p_wallList[i]
				slice.wall_temp = wall_tempList[i]
				slice.wall_state = wall_stateList[i]
				slice.detach_state = detach_stateList[i]
				slice.pump_flux = pump_fluxList[i]
				slice.p_rad_fw = p_rad_fwList[i]
				slice.p_cond_fw = p_cond_fwList[i]
				slice.div_wetted = div_wettedList[i]
				slice.gas_puff = gas_puffList[i]
				slice.ar_concentr = ar_concentrList[i]
				slice.part_exhaust = part_exhaustList[i]
				slice.f_inner = f_innerList[i]
				slice.f_outer = f_outerList[i]
				slice.f_pfr = f_pfrList[i]
				slice.f_rad_fw = f_rad_fwList[i]
				slice.q_div = q_divList[:,i]
				slice.p_cond_div = p_cond_divList[i]
				slice.pol_ext = pol_extVal
				slice.flux_exp = flux_expVal
				slice.tilt_angle = tilt_angleVal
				slice.n_div = n_divVal
				slice.div_dz = div_dzVal
				slice.div_dro = div_droVal
				slice.div_dri = div_driVal
				slice.p_nh_div = p_nh_divList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type lim_div_wallstructurescenario_lim_div_wallObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_lim_div.putTimedElt(path, cpopath + 'te_lim_div', i, obj)
		obj = self.ti_lim_div.putTimedElt(path, cpopath + 'ti_lim_div', i, obj)
		obj = self.ne_lim_div.putTimedElt(path, cpopath + 'ne_lim_div', i, obj)
		obj = self.ni_lim_div.putTimedElt(path, cpopath + 'ni_lim_div', i, obj)
		obj = self.q_peak_div.putTimedElt(path, cpopath + 'q_peak_div', i, obj)
		obj = self.q_peak_wall.putTimedElt(path, cpopath + 'q_peak_wall', i, obj)
		obj = self.surf_temp.putTimedElt(path, cpopath + 'surf_temp', i, obj)
		obj = self.p_lim_div.putTimedElt(path, cpopath + 'p_lim_div', i, obj)
		obj = self.p_rad_div.putTimedElt(path, cpopath + 'p_rad_div', i, obj)
		obj = self.p_neut_div.putTimedElt(path, cpopath + 'p_neut_div', i, obj)
		obj = self.p_wall.putTimedElt(path, cpopath + 'p_wall', i, obj)
		obj = self.wall_temp.putTimedElt(path, cpopath + 'wall_temp', i, obj)
		obj = self.wall_state.putTimedElt(path, cpopath + 'wall_state', i, obj)
		obj = self.detach_state.putTimedElt(path, cpopath + 'detach_state', i, obj)
		obj = self.pump_flux.putTimedElt(path, cpopath + 'pump_flux', i, obj)
		obj = self.p_rad_fw.putTimedElt(path, cpopath + 'p_rad_fw', i, obj)
		obj = self.p_cond_fw.putTimedElt(path, cpopath + 'p_cond_fw', i, obj)
		obj = self.div_wetted.putTimedElt(path, cpopath + 'div_wetted', i, obj)
		obj = self.gas_puff.putTimedElt(path, cpopath + 'gas_puff', i, obj)
		obj = self.ar_concentr.putTimedElt(path, cpopath + 'ar_concentr', i, obj)
		obj = self.part_exhaust.putTimedElt(path, cpopath + 'part_exhaust', i, obj)
		obj = self.f_inner.putTimedElt(path, cpopath + 'f_inner', i, obj)
		obj = self.f_outer.putTimedElt(path, cpopath + 'f_outer', i, obj)
		obj = self.f_pfr.putTimedElt(path, cpopath + 'f_pfr', i, obj)
		obj = self.f_rad_fw.putTimedElt(path, cpopath + 'f_rad_fw', i, obj)
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'q_div') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'q_div', i, numpy.array(self.q_div).astype(numpy.float64))
		obj = self.p_cond_div.putTimedElt(path, cpopath + 'p_cond_div', i, obj)
		obj = self.p_nh_div.putTimedElt(path, cpopath + 'p_nh_div', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type lim_div_wallstructurescenario_lim_div_wallObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.te_lim_div.getTimedElt(path, cpopath + 'te_lim_div', i, obj)
		self.ti_lim_div.getTimedElt(path, cpopath + 'ti_lim_div', i, obj)
		self.ne_lim_div.getTimedElt(path, cpopath + 'ne_lim_div', i, obj)
		self.ni_lim_div.getTimedElt(path, cpopath + 'ni_lim_div', i, obj)
		self.q_peak_div.getTimedElt(path, cpopath + 'q_peak_div', i, obj)
		self.q_peak_wall.getTimedElt(path, cpopath + 'q_peak_wall', i, obj)
		self.surf_temp.getTimedElt(path, cpopath + 'surf_temp', i, obj)
		self.p_lim_div.getTimedElt(path, cpopath + 'p_lim_div', i, obj)
		self.p_rad_div.getTimedElt(path, cpopath + 'p_rad_div', i, obj)
		self.p_neut_div.getTimedElt(path, cpopath + 'p_neut_div', i, obj)
		self.p_wall.getTimedElt(path, cpopath + 'p_wall', i, obj)
		self.wall_temp.getTimedElt(path, cpopath + 'wall_temp', i, obj)
		self.wall_state.getTimedElt(path, cpopath + 'wall_state', i, obj)
		self.detach_state.getTimedElt(path, cpopath + 'detach_state', i, obj)
		self.pump_flux.getTimedElt(path, cpopath + 'pump_flux', i, obj)
		self.p_rad_fw.getTimedElt(path, cpopath + 'p_rad_fw', i, obj)
		self.p_cond_fw.getTimedElt(path, cpopath + 'p_cond_fw', i, obj)
		self.div_wetted.getTimedElt(path, cpopath + 'div_wetted', i, obj)
		self.gas_puff.getTimedElt(path, cpopath + 'gas_puff', i, obj)
		self.ar_concentr.getTimedElt(path, cpopath + 'ar_concentr', i, obj)
		self.part_exhaust.getTimedElt(path, cpopath + 'part_exhaust', i, obj)
		self.f_inner.getTimedElt(path, cpopath + 'f_inner', i, obj)
		self.f_outer.getTimedElt(path, cpopath + 'f_outer', i, obj)
		self.f_pfr.getTimedElt(path, cpopath + 'f_pfr', i, obj)
		self.f_rad_fw.getTimedElt(path, cpopath + 'f_rad_fw', i, obj)
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'q_div') 
			print ('obj = ' + str(obj))
		status, ret_q_div = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'q_div', i)
		check_status(status)
		if not status:
			self.q_div = ret_q_div
		self.p_cond_div.getTimedElt(path, cpopath + 'p_cond_div', i, obj)
		self.p_nh_div.getTimedElt(path, cpopath + 'p_nh_div', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type lim_div_wallstructurescenario_lim_div_wallObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_lim_div.putNonTimedElt(path, cpopath + 'te_lim_div', i, obj)
		obj = self.ti_lim_div.putNonTimedElt(path, cpopath + 'ti_lim_div', i, obj)
		obj = self.ne_lim_div.putNonTimedElt(path, cpopath + 'ne_lim_div', i, obj)
		obj = self.ni_lim_div.putNonTimedElt(path, cpopath + 'ni_lim_div', i, obj)
		obj = self.q_peak_div.putNonTimedElt(path, cpopath + 'q_peak_div', i, obj)
		obj = self.q_peak_wall.putNonTimedElt(path, cpopath + 'q_peak_wall', i, obj)
		obj = self.surf_temp.putNonTimedElt(path, cpopath + 'surf_temp', i, obj)
		obj = self.p_lim_div.putNonTimedElt(path, cpopath + 'p_lim_div', i, obj)
		obj = self.p_rad_div.putNonTimedElt(path, cpopath + 'p_rad_div', i, obj)
		obj = self.p_neut_div.putNonTimedElt(path, cpopath + 'p_neut_div', i, obj)
		obj = self.p_wall.putNonTimedElt(path, cpopath + 'p_wall', i, obj)
		obj = self.wall_temp.putNonTimedElt(path, cpopath + 'wall_temp', i, obj)
		obj = self.wall_state.putNonTimedElt(path, cpopath + 'wall_state', i, obj)
		obj = self.detach_state.putNonTimedElt(path, cpopath + 'detach_state', i, obj)
		obj = self.pump_flux.putNonTimedElt(path, cpopath + 'pump_flux', i, obj)
		obj = self.p_rad_fw.putNonTimedElt(path, cpopath + 'p_rad_fw', i, obj)
		obj = self.p_cond_fw.putNonTimedElt(path, cpopath + 'p_cond_fw', i, obj)
		obj = self.div_wetted.putNonTimedElt(path, cpopath + 'div_wetted', i, obj)
		obj = self.gas_puff.putNonTimedElt(path, cpopath + 'gas_puff', i, obj)
		obj = self.ar_concentr.putNonTimedElt(path, cpopath + 'ar_concentr', i, obj)
		obj = self.part_exhaust.putNonTimedElt(path, cpopath + 'part_exhaust', i, obj)
		obj = self.f_inner.putNonTimedElt(path, cpopath + 'f_inner', i, obj)
		obj = self.f_outer.putNonTimedElt(path, cpopath + 'f_outer', i, obj)
		obj = self.f_pfr.putNonTimedElt(path, cpopath + 'f_pfr', i, obj)
		obj = self.f_rad_fw.putNonTimedElt(path, cpopath + 'f_rad_fw', i, obj)
		obj = self.p_cond_div.putNonTimedElt(path, cpopath + 'p_cond_div', i, obj)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'pol_ext') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'pol_ext', i, self.pol_ext)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'flux_exp') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'flux_exp', i, self.flux_exp)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'tilt_angle') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'tilt_angle', i, self.tilt_angle)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'n_div') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'n_div', i, self.n_div)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'div_dz') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'div_dz', i, self.div_dz)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'div_dro') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'div_dro', i, self.div_dro)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'div_dri') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'div_dri', i, self.div_dri)
		obj = self.p_nh_div.putNonTimedElt(path, cpopath + 'p_nh_div', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type lim_div_wallstructurescenario_lim_div_wallObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.te_lim_div.getNonTimedElt(path, cpopath + 'te_lim_div', i, obj)
		self.ti_lim_div.getNonTimedElt(path, cpopath + 'ti_lim_div', i, obj)
		self.ne_lim_div.getNonTimedElt(path, cpopath + 'ne_lim_div', i, obj)
		self.ni_lim_div.getNonTimedElt(path, cpopath + 'ni_lim_div', i, obj)
		self.q_peak_div.getNonTimedElt(path, cpopath + 'q_peak_div', i, obj)
		self.q_peak_wall.getNonTimedElt(path, cpopath + 'q_peak_wall', i, obj)
		self.surf_temp.getNonTimedElt(path, cpopath + 'surf_temp', i, obj)
		self.p_lim_div.getNonTimedElt(path, cpopath + 'p_lim_div', i, obj)
		self.p_rad_div.getNonTimedElt(path, cpopath + 'p_rad_div', i, obj)
		self.p_neut_div.getNonTimedElt(path, cpopath + 'p_neut_div', i, obj)
		self.p_wall.getNonTimedElt(path, cpopath + 'p_wall', i, obj)
		self.wall_temp.getNonTimedElt(path, cpopath + 'wall_temp', i, obj)
		self.wall_state.getNonTimedElt(path, cpopath + 'wall_state', i, obj)
		self.detach_state.getNonTimedElt(path, cpopath + 'detach_state', i, obj)
		self.pump_flux.getNonTimedElt(path, cpopath + 'pump_flux', i, obj)
		self.p_rad_fw.getNonTimedElt(path, cpopath + 'p_rad_fw', i, obj)
		self.p_cond_fw.getNonTimedElt(path, cpopath + 'p_cond_fw', i, obj)
		self.div_wetted.getNonTimedElt(path, cpopath + 'div_wetted', i, obj)
		self.gas_puff.getNonTimedElt(path, cpopath + 'gas_puff', i, obj)
		self.ar_concentr.getNonTimedElt(path, cpopath + 'ar_concentr', i, obj)
		self.part_exhaust.getNonTimedElt(path, cpopath + 'part_exhaust', i, obj)
		self.f_inner.getNonTimedElt(path, cpopath + 'f_inner', i, obj)
		self.f_outer.getNonTimedElt(path, cpopath + 'f_outer', i, obj)
		self.f_pfr.getNonTimedElt(path, cpopath + 'f_pfr', i, obj)
		self.f_rad_fw.getNonTimedElt(path, cpopath + 'f_rad_fw', i, obj)
		self.p_cond_div.getNonTimedElt(path, cpopath + 'p_cond_div', i, obj)
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'pol_ext') 
			print ('obj = ' + str(obj))
		status, ret_pol_ext = ull.getDoubleFromObject(self.idx, obj, cpopath + 'pol_ext', i)
		check_status(status)
		if not status:
			self.pol_ext = ret_pol_ext
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'flux_exp') 
			print ('obj = ' + str(obj))
		status, ret_flux_exp = ull.getDoubleFromObject(self.idx, obj, cpopath + 'flux_exp', i)
		check_status(status)
		if not status:
			self.flux_exp = ret_flux_exp
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'tilt_angle') 
			print ('obj = ' + str(obj))
		status, ret_tilt_angle = ull.getDoubleFromObject(self.idx, obj, cpopath + 'tilt_angle', i)
		check_status(status)
		if not status:
			self.tilt_angle = ret_tilt_angle
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'n_div') 
			print ('obj = ' + str(obj))
		status, ret_n_div = ull.getDoubleFromObject(self.idx, obj, cpopath + 'n_div', i)
		check_status(status)
		if not status:
			self.n_div = ret_n_div
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'div_dz') 
			print ('obj = ' + str(obj))
		status, ret_div_dz = ull.getDoubleFromObject(self.idx, obj, cpopath + 'div_dz', i)
		check_status(status)
		if not status:
			self.div_dz = ret_div_dz
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'div_dro') 
			print ('obj = ' + str(obj))
		status, ret_div_dro = ull.getDoubleFromObject(self.idx, obj, cpopath + 'div_dro', i)
		check_status(status)
		if not status:
			self.div_dro = ret_div_dro
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'div_dri') 
			print ('obj = ' + str(obj))
		status, ret_div_dri = ull.getDoubleFromObject(self.idx, obj, cpopath + 'div_dri', i)
		check_status(status)
		if not status:
			self.div_dri = ret_div_dri
		self.p_nh_div.getNonTimedElt(path, cpopath + 'p_nh_div', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_lim_div.deleteData(path, cpopath)
		self.ti_lim_div.deleteData(path, cpopath)
		self.ne_lim_div.deleteData(path, cpopath)
		self.ni_lim_div.deleteData(path, cpopath)
		self.q_peak_div.deleteData(path, cpopath)
		self.q_peak_wall.deleteData(path, cpopath)
		self.surf_temp.deleteData(path, cpopath)
		self.p_lim_div.deleteData(path, cpopath)
		self.p_rad_div.deleteData(path, cpopath)
		self.p_neut_div.deleteData(path, cpopath)
		self.p_wall.deleteData(path, cpopath)
		self.wall_temp.deleteData(path, cpopath)
		self.wall_state.deleteData(path, cpopath)
		self.detach_state.deleteData(path, cpopath)
		self.pump_flux.deleteData(path, cpopath)
		self.p_rad_fw.deleteData(path, cpopath)
		self.p_cond_fw.deleteData(path, cpopath)
		self.div_wetted.deleteData(path, cpopath)
		self.gas_puff.deleteData(path, cpopath)
		self.ar_concentr.deleteData(path, cpopath)
		self.part_exhaust.deleteData(path, cpopath)
		self.f_inner.deleteData(path, cpopath)
		self.f_outer.deleteData(path, cpopath)
		self.f_pfr.deleteData(path, cpopath)
		self.f_rad_fw.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'q_div')
		self.p_cond_div.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'pol_ext')
		ull.deleteData(self.idx, path, cpopath + 'flux_exp')
		ull.deleteData(self.idx, path, cpopath + 'tilt_angle')
		ull.deleteData(self.idx, path, cpopath + 'n_div')
		ull.deleteData(self.idx, path, cpopath + 'div_dz')
		ull.deleteData(self.idx, path, cpopath + 'div_dro')
		ull.deleteData(self.idx, path, cpopath + 'div_dri')
		self.p_nh_div.deleteData(path, cpopath)


class te_lim_divstructurescenario_ref:
	'''
	class te_lim_divstructurescenario_ref
	limiter/divertor electron temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te_lim_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te_lim_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_lim_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_lim_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_lim_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te_lim_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te_lim_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te_lim_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_lim_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_lim_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_lim_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_lim_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_lim_divstructurescenario_ref:
	'''
	class ti_lim_divstructurescenario_ref
	limiter/divertor ion temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_lim_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_lim_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_lim_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_lim_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_lim_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_lim_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_lim_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_lim_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_lim_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_lim_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_lim_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_lim_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_lim_divstructurescenario_ref:
	'''
	class ne_lim_divstructurescenario_ref
	limiter/divertor electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_lim_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_lim_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_lim_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_lim_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_lim_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_lim_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_lim_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_lim_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_lim_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_lim_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_lim_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_lim_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni_lim_divstructurescenario_ref:
	'''
	class ni_lim_divstructurescenario_ref
	limiter/divertor ion density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni_lim_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni_lim_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_lim_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_lim_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_lim_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni_lim_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni_lim_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni_lim_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_lim_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_lim_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_lim_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_lim_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class q_peak_divstructurescenario_ref:
	'''
	class q_peak_divstructurescenario_ref
	Peak power flux on limiter or divertor plate [W.m^-2]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q_peak_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q_peak_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q_peak_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class q_peak_wallstructurescenario_ref:
	'''
	class q_peak_wallstructurescenario_ref
	Peak power flux on the wall [W.m^-2]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q_peak_wall'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q_peak_wallstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_wallstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_wallstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_wallstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_wallstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q_peak_wallstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q_peak_wallstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_wallstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_wallstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_wallstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_peak_wallstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class surf_tempstructurescenario_ref:
	'''
	class surf_tempstructurescenario_ref
	limiter surface or divertor plate temperature [K]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='surf_temp'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class surf_tempstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type surf_tempstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type surf_tempstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type surf_tempstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type surf_tempstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type surf_tempstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = surf_tempstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type surf_tempstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type surf_tempstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type surf_tempstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type surf_tempstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_lim_divstructurescenario_ref:
	'''
	class p_lim_divstructurescenario_ref
	Total power on limiter or divertor plate [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_lim_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_lim_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_lim_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_lim_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_lim_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_lim_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_lim_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_lim_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_lim_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_lim_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_lim_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_lim_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_rad_divstructurescenario_ref:
	'''
	class p_rad_divstructurescenario_ref
	radiative power in the divertor zone [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_rad_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_rad_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_rad_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_neut_divstructurescenario_ref:
	'''
	class p_neut_divstructurescenario_ref
	Neutral pressure in the divertor zone [Pa]; Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_neut_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_neut_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_neut_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_neut_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_neut_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_neut_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_neut_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_neut_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_neut_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_neut_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_neut_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_neut_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_wallstructurescenario_ref:
	'''
	class p_wallstructurescenario_ref
	Total power on the wall [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_wall'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_wallstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wallstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wallstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_wallstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_wallstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_wallstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_wallstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wallstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wallstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wallstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_wallstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class wall_tempstructurescenario_ref:
	'''
	class wall_tempstructurescenario_ref
	wall temperature [K]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='wall_temp'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class wall_tempstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type wall_tempstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type wall_tempstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type wall_tempstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type wall_tempstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type wall_tempstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = wall_tempstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_tempstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_tempstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_tempstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_tempstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class wall_statestructurescenario_ref:
	'''
	class wall_statestructurescenario_ref
	saturation state of the wall (0 = completly pumping wall, 1 = competely saturate wall) []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='wall_state'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class wall_statestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type wall_statestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type wall_statestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type wall_statestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type wall_statestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type wall_statestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = wall_statestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_statestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_statestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_statestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type wall_statestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class detach_statestructurescenario_ref:
	'''
	class detach_statestructurescenario_ref
	plasma detachement state (0= attach plasma, 1 = completely detach plasma) []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='detach_state'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class detach_statestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type detach_statestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type detach_statestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type detach_statestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type detach_statestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type detach_statestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = detach_statestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type detach_statestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type detach_statestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type detach_statestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type detach_statestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pump_fluxstructurescenario_ref:
	'''
	class pump_fluxstructurescenario_ref
	flux pump out for each ion species [s^-1]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pump_flux'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pump_fluxstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pump_fluxstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pump_fluxstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pump_fluxstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pump_fluxstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pump_fluxstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pump_fluxstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pump_fluxstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pump_fluxstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pump_fluxstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pump_fluxstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_rad_fwstructurescenario_ref:
	'''
	class p_rad_fwstructurescenario_ref
	Radiated power on the first wall [W]; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_rad_fw'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_rad_fwstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_fwstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_fwstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_fwstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_fwstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_fwstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_rad_fwstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_fwstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_fwstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_fwstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_fwstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_cond_fwstructurescenario_ref:
	'''
	class p_cond_fwstructurescenario_ref
	Conducted/convected power  on the first wall [W]; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_cond_fw'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_cond_fwstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_fwstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_fwstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_fwstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_fwstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_fwstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_cond_fwstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_fwstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_fwstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_fwstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_fwstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class div_wettedstructurescenario_ref:
	'''
	class div_wettedstructurescenario_ref
	Divertor wetted area [m^2]; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='div_wetted'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class div_wettedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type div_wettedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type div_wettedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type div_wettedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type div_wettedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type div_wettedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = div_wettedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type div_wettedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type div_wettedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type div_wettedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type div_wettedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class gas_puffstructurescenario_ref:
	'''
	class gas_puffstructurescenario_ref
	Gas puff (D/T) in the divertor (PFR) [Pa.m^3.s^-1]; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='gas_puff'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class gas_puffstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type gas_puffstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type gas_puffstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type gas_puffstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type gas_puffstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type gas_puffstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = gas_puffstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type gas_puffstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type gas_puffstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type gas_puffstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type gas_puffstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ar_concentrstructurescenario_ref:
	'''
	class ar_concentrstructurescenario_ref
	Argon concentration in the divertor; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ar_concentr'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ar_concentrstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ar_concentrstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ar_concentrstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ar_concentrstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ar_concentrstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ar_concentrstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ar_concentrstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ar_concentrstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ar_concentrstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ar_concentrstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ar_concentrstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class part_exhauststructurescenario_ref:
	'''
	class part_exhauststructurescenario_ref
	Assuming a pumping speed [Pa.m^3.s^-1]; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='part_exhaust'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class part_exhauststructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type part_exhauststructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type part_exhauststructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type part_exhauststructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type part_exhauststructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type part_exhauststructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = part_exhauststructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type part_exhauststructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type part_exhauststructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type part_exhauststructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type part_exhauststructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class f_innerstructurescenario_ref:
	'''
	class f_innerstructurescenario_ref
	Fraction of power to the inner divertor; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='f_inner'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class f_innerstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_innerstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_innerstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_innerstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type f_innerstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type f_innerstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = f_innerstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_innerstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_innerstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_innerstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_innerstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class f_outerstructurescenario_ref:
	'''
	class f_outerstructurescenario_ref
	Fraction of power to the outer divertor; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='f_outer'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class f_outerstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_outerstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_outerstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_outerstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type f_outerstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type f_outerstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = f_outerstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_outerstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_outerstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_outerstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_outerstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class f_pfrstructurescenario_ref:
	'''
	class f_pfrstructurescenario_ref
	Fraction of power flowing into the private flux region; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='f_pfr'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class f_pfrstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_pfrstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_pfrstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_pfrstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type f_pfrstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type f_pfrstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = f_pfrstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_pfrstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_pfrstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_pfrstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_pfrstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class f_rad_fwstructurescenario_ref:
	'''
	class f_rad_fwstructurescenario_ref
	Fraction of the divertor radiated power deposited in the main chamber; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='f_rad_fw'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class f_rad_fwstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_rad_fwstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_rad_fwstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type f_rad_fwstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type f_rad_fwstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type f_rad_fwstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = f_rad_fwstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_rad_fwstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_rad_fwstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_rad_fwstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type f_rad_fwstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_cond_divstructurescenario_ref:
	'''
	class p_cond_divstructurescenario_ref
	Conducted/convected power on divertor plate  [W]; Time-dependent

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_cond_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_cond_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_cond_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_cond_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_cond_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_nh_divstructurescenario_ref:
	'''
	class p_nh_divstructurescenario_ref
	Total nuclear heating in divertor [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_nh_div'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_nh_divstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_nh_divstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_nh_divstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_nh_divstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_nh_divstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_nh_divstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_nh_divstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nh_divstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nh_divstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nh_divstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_nh_divstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class line_avestructurescenario_line_ave:
	'''
	class line_avestructurescenario_line_ave
	line averaged value

	Attributes:
	- ne_line : class ne_linestructurescenario_ref
	   line averaged electron density [m^-3]. Time-dependent.
	- zeff_line : class zeff_linestructurescenario_ref
	   line averaged effective charge. Time-dependent.
	- ne_zeff_line : class ne_zeff_linestructurescenario_ref
	   line averaged electron density * Zeff . Time-dependent.
	- dne_line_dt : class dne_line_dtstructurescenario_ref
	   time derivative of line averaged electron density [m^-3/s]. Time-dependent.
	'''

	def __init__(self, base_path_in='line_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.ne_line = ne_linestructurescenario_ref('ne_line')
		self.zeff_line = zeff_linestructurescenario_ref('zeff_line')
		self.ne_zeff_line = ne_zeff_linestructurescenario_ref('ne_zeff_line')
		self.dne_line_dt = dne_line_dtstructurescenario_ref('dne_line_dt')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class line_avestructurescenario_line_ave\n'
		ret = ret + space + 'Attribute ne_line\n ' + self.ne_line.__str__(depth+1)
		ret = ret + space + 'Attribute zeff_line\n ' + self.zeff_line.__str__(depth+1)
		ret = ret + space + 'Attribute ne_zeff_line\n ' + self.ne_zeff_line.__str__(depth+1)
		ret = ret + space + 'Attribute dne_line_dt\n ' + self.dne_line_dt.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.ne_line.setExpIdx(idx)
		self.zeff_line.setExpIdx(idx)
		self.ne_zeff_line.setExpIdx(idx)
		self.dne_line_dt.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type line_avestructurescenario_line_ave, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ne_line.cpoTime = self.cpoTime
		self.ne_line.putSlice(path, cpopath)
		self.zeff_line.cpoTime = self.cpoTime
		self.zeff_line.putSlice(path, cpopath)
		self.ne_zeff_line.cpoTime = self.cpoTime
		self.ne_zeff_line.putSlice(path, cpopath)
		self.dne_line_dt.cpoTime = self.cpoTime
		self.dne_line_dt.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type line_avestructurescenario_line_ave, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ne_line.replaceLastSlice(path, cpopath)
		self.zeff_line.replaceLastSlice(path, cpopath)
		self.ne_zeff_line.replaceLastSlice(path, cpopath)
		self.dne_line_dt.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type line_avestructurescenario_line_ave, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ne_line.putNonTimed(path, cpopath)
		self.zeff_line.putNonTimed(path, cpopath)
		self.ne_zeff_line.putNonTimed(path, cpopath)
		self.dne_line_dt.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type line_avestructurescenario_line_ave, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ne_line.getSlice(path, cpopath, inTime, interpolMode)
		self.zeff_line.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_zeff_line.getSlice(path, cpopath, inTime, interpolMode)
		self.dne_line_dt.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type line_avestructurescenario_line_ave, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			ne_lineList = self.ne_line.build_non_resampled_data(path, cpopath, nbslice)
			zeff_lineList = self.zeff_line.build_non_resampled_data(path, cpopath, nbslice)
			ne_zeff_lineList = self.ne_zeff_line.build_non_resampled_data(path, cpopath, nbslice)
			dne_line_dtList = self.dne_line_dt.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = line_avestructurescenario_line_ave(self.base_path)
				slice.setExpIdx(self.idx)
				slice.ne_line = ne_lineList[i]
				slice.zeff_line = zeff_lineList[i]
				slice.ne_zeff_line = ne_zeff_lineList[i]
				slice.dne_line_dt = dne_line_dtList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type line_avestructurescenario_line_aveObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.ne_line.putTimedElt(path, cpopath + 'ne_line', i, obj)
		obj = self.zeff_line.putTimedElt(path, cpopath + 'zeff_line', i, obj)
		obj = self.ne_zeff_line.putTimedElt(path, cpopath + 'ne_zeff_line', i, obj)
		obj = self.dne_line_dt.putTimedElt(path, cpopath + 'dne_line_dt', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type line_avestructurescenario_line_aveObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.ne_line.getTimedElt(path, cpopath + 'ne_line', i, obj)
		self.zeff_line.getTimedElt(path, cpopath + 'zeff_line', i, obj)
		self.ne_zeff_line.getTimedElt(path, cpopath + 'ne_zeff_line', i, obj)
		self.dne_line_dt.getTimedElt(path, cpopath + 'dne_line_dt', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type line_avestructurescenario_line_aveObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.ne_line.putNonTimedElt(path, cpopath + 'ne_line', i, obj)
		obj = self.zeff_line.putNonTimedElt(path, cpopath + 'zeff_line', i, obj)
		obj = self.ne_zeff_line.putNonTimedElt(path, cpopath + 'ne_zeff_line', i, obj)
		obj = self.dne_line_dt.putNonTimedElt(path, cpopath + 'dne_line_dt', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type line_avestructurescenario_line_aveObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.ne_line.getNonTimedElt(path, cpopath + 'ne_line', i, obj)
		self.zeff_line.getNonTimedElt(path, cpopath + 'zeff_line', i, obj)
		self.ne_zeff_line.getNonTimedElt(path, cpopath + 'ne_zeff_line', i, obj)
		self.dne_line_dt.getNonTimedElt(path, cpopath + 'dne_line_dt', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ne_line.deleteData(path, cpopath)
		self.zeff_line.deleteData(path, cpopath)
		self.ne_zeff_line.deleteData(path, cpopath)
		self.dne_line_dt.deleteData(path, cpopath)


class ne_linestructurescenario_ref:
	'''
	class ne_linestructurescenario_ref
	line averaged electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_line'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_linestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_linestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_linestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_linestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_linestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_linestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_linestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_linestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_linestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_linestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_linestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class zeff_linestructurescenario_ref:
	'''
	class zeff_linestructurescenario_ref
	line averaged effective charge. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='zeff_line'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class zeff_linestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_linestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_linestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_linestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_linestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_linestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = zeff_linestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_linestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_linestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_linestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_linestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_zeff_linestructurescenario_ref:
	'''
	class ne_zeff_linestructurescenario_ref
	line averaged electron density * Zeff . Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_zeff_line'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_zeff_linestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_zeff_linestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_zeff_linestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_zeff_linestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_zeff_linestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_zeff_linestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_zeff_linestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_zeff_linestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_zeff_linestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_zeff_linestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_zeff_linestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dne_line_dtstructurescenario_ref:
	'''
	class dne_line_dtstructurescenario_ref
	time derivative of line averaged electron density [m^-3/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dne_line_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dne_line_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dne_line_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dne_line_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dne_line_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dne_line_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dne_line_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dne_line_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_line_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_line_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_line_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_line_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class neutronstructurescenario_neutron:
	'''
	class neutronstructurescenario_neutron
	neutron flux for DD and DT reactions

	Attributes:
	- ndd_tot : class ndd_totstructurescenario_ref
	   total neutron flux coming  from DD reactions [Hz]. Time-dependent.
	- ndd_th : class ndd_thstructurescenario_ref
	   neutron flux coming  from thermal  DD reactions [Hz]. Time-dependent.
	- ndd_nbi_th : class ndd_nbi_thstructurescenario_ref
	   neutron flux coming  from beam/plasma  DD reactions [Hz]. Time-dependent.
	- ndd_nbi_nbi : class ndd_nbi_nbistructurescenario_ref
	   neutron flux coming  from beam/beam  DD reactions [Hz]. Time-dependent.
	- ndt_tot : class ndt_totstructurescenario_ref
	   total neutron flux coming  from DT reactions [Hz]. Time-dependent.
	- ndt_th : class ndt_thstructurescenario_ref
	   neutron flux coming  from thermal DT reactions [Hz]. Time-dependent.
	'''

	def __init__(self, base_path_in='neutron'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.ndd_tot = ndd_totstructurescenario_ref('ndd_tot')
		self.ndd_th = ndd_thstructurescenario_ref('ndd_th')
		self.ndd_nbi_th = ndd_nbi_thstructurescenario_ref('ndd_nbi_th')
		self.ndd_nbi_nbi = ndd_nbi_nbistructurescenario_ref('ndd_nbi_nbi')
		self.ndt_tot = ndt_totstructurescenario_ref('ndt_tot')
		self.ndt_th = ndt_thstructurescenario_ref('ndt_th')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class neutronstructurescenario_neutron\n'
		ret = ret + space + 'Attribute ndd_tot\n ' + self.ndd_tot.__str__(depth+1)
		ret = ret + space + 'Attribute ndd_th\n ' + self.ndd_th.__str__(depth+1)
		ret = ret + space + 'Attribute ndd_nbi_th\n ' + self.ndd_nbi_th.__str__(depth+1)
		ret = ret + space + 'Attribute ndd_nbi_nbi\n ' + self.ndd_nbi_nbi.__str__(depth+1)
		ret = ret + space + 'Attribute ndt_tot\n ' + self.ndt_tot.__str__(depth+1)
		ret = ret + space + 'Attribute ndt_th\n ' + self.ndt_th.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.ndd_tot.setExpIdx(idx)
		self.ndd_th.setExpIdx(idx)
		self.ndd_nbi_th.setExpIdx(idx)
		self.ndd_nbi_nbi.setExpIdx(idx)
		self.ndt_tot.setExpIdx(idx)
		self.ndt_th.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type neutronstructurescenario_neutron, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ndd_tot.cpoTime = self.cpoTime
		self.ndd_tot.putSlice(path, cpopath)
		self.ndd_th.cpoTime = self.cpoTime
		self.ndd_th.putSlice(path, cpopath)
		self.ndd_nbi_th.cpoTime = self.cpoTime
		self.ndd_nbi_th.putSlice(path, cpopath)
		self.ndd_nbi_nbi.cpoTime = self.cpoTime
		self.ndd_nbi_nbi.putSlice(path, cpopath)
		self.ndt_tot.cpoTime = self.cpoTime
		self.ndt_tot.putSlice(path, cpopath)
		self.ndt_th.cpoTime = self.cpoTime
		self.ndt_th.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type neutronstructurescenario_neutron, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ndd_tot.replaceLastSlice(path, cpopath)
		self.ndd_th.replaceLastSlice(path, cpopath)
		self.ndd_nbi_th.replaceLastSlice(path, cpopath)
		self.ndd_nbi_nbi.replaceLastSlice(path, cpopath)
		self.ndt_tot.replaceLastSlice(path, cpopath)
		self.ndt_th.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type neutronstructurescenario_neutron, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ndd_tot.putNonTimed(path, cpopath)
		self.ndd_th.putNonTimed(path, cpopath)
		self.ndd_nbi_th.putNonTimed(path, cpopath)
		self.ndd_nbi_nbi.putNonTimed(path, cpopath)
		self.ndt_tot.putNonTimed(path, cpopath)
		self.ndt_th.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type neutronstructurescenario_neutron, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ndd_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.ndd_th.getSlice(path, cpopath, inTime, interpolMode)
		self.ndd_nbi_th.getSlice(path, cpopath, inTime, interpolMode)
		self.ndd_nbi_nbi.getSlice(path, cpopath, inTime, interpolMode)
		self.ndt_tot.getSlice(path, cpopath, inTime, interpolMode)
		self.ndt_th.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type neutronstructurescenario_neutron, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			ndd_totList = self.ndd_tot.build_non_resampled_data(path, cpopath, nbslice)
			ndd_thList = self.ndd_th.build_non_resampled_data(path, cpopath, nbslice)
			ndd_nbi_thList = self.ndd_nbi_th.build_non_resampled_data(path, cpopath, nbslice)
			ndd_nbi_nbiList = self.ndd_nbi_nbi.build_non_resampled_data(path, cpopath, nbslice)
			ndt_totList = self.ndt_tot.build_non_resampled_data(path, cpopath, nbslice)
			ndt_thList = self.ndt_th.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = neutronstructurescenario_neutron(self.base_path)
				slice.setExpIdx(self.idx)
				slice.ndd_tot = ndd_totList[i]
				slice.ndd_th = ndd_thList[i]
				slice.ndd_nbi_th = ndd_nbi_thList[i]
				slice.ndd_nbi_nbi = ndd_nbi_nbiList[i]
				slice.ndt_tot = ndt_totList[i]
				slice.ndt_th = ndt_thList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutronstructurescenario_neutronObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.ndd_tot.putTimedElt(path, cpopath + 'ndd_tot', i, obj)
		obj = self.ndd_th.putTimedElt(path, cpopath + 'ndd_th', i, obj)
		obj = self.ndd_nbi_th.putTimedElt(path, cpopath + 'ndd_nbi_th', i, obj)
		obj = self.ndd_nbi_nbi.putTimedElt(path, cpopath + 'ndd_nbi_nbi', i, obj)
		obj = self.ndt_tot.putTimedElt(path, cpopath + 'ndt_tot', i, obj)
		obj = self.ndt_th.putTimedElt(path, cpopath + 'ndt_th', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutronstructurescenario_neutronObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.ndd_tot.getTimedElt(path, cpopath + 'ndd_tot', i, obj)
		self.ndd_th.getTimedElt(path, cpopath + 'ndd_th', i, obj)
		self.ndd_nbi_th.getTimedElt(path, cpopath + 'ndd_nbi_th', i, obj)
		self.ndd_nbi_nbi.getTimedElt(path, cpopath + 'ndd_nbi_nbi', i, obj)
		self.ndt_tot.getTimedElt(path, cpopath + 'ndt_tot', i, obj)
		self.ndt_th.getTimedElt(path, cpopath + 'ndt_th', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutronstructurescenario_neutronObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.ndd_tot.putNonTimedElt(path, cpopath + 'ndd_tot', i, obj)
		obj = self.ndd_th.putNonTimedElt(path, cpopath + 'ndd_th', i, obj)
		obj = self.ndd_nbi_th.putNonTimedElt(path, cpopath + 'ndd_nbi_th', i, obj)
		obj = self.ndd_nbi_nbi.putNonTimedElt(path, cpopath + 'ndd_nbi_nbi', i, obj)
		obj = self.ndt_tot.putNonTimedElt(path, cpopath + 'ndt_tot', i, obj)
		obj = self.ndt_th.putNonTimedElt(path, cpopath + 'ndt_th', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type neutronstructurescenario_neutronObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.ndd_tot.getNonTimedElt(path, cpopath + 'ndd_tot', i, obj)
		self.ndd_th.getNonTimedElt(path, cpopath + 'ndd_th', i, obj)
		self.ndd_nbi_th.getNonTimedElt(path, cpopath + 'ndd_nbi_th', i, obj)
		self.ndd_nbi_nbi.getNonTimedElt(path, cpopath + 'ndd_nbi_nbi', i, obj)
		self.ndt_tot.getNonTimedElt(path, cpopath + 'ndt_tot', i, obj)
		self.ndt_th.getNonTimedElt(path, cpopath + 'ndt_th', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.ndd_tot.deleteData(path, cpopath)
		self.ndd_th.deleteData(path, cpopath)
		self.ndd_nbi_th.deleteData(path, cpopath)
		self.ndd_nbi_nbi.deleteData(path, cpopath)
		self.ndt_tot.deleteData(path, cpopath)
		self.ndt_th.deleteData(path, cpopath)


class ndd_totstructurescenario_ref:
	'''
	class ndd_totstructurescenario_ref
	total neutron flux coming  from DD reactions [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ndd_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ndd_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ndd_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ndd_thstructurescenario_ref:
	'''
	class ndd_thstructurescenario_ref
	neutron flux coming  from thermal  DD reactions [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ndd_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ndd_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ndd_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ndd_nbi_thstructurescenario_ref:
	'''
	class ndd_nbi_thstructurescenario_ref
	neutron flux coming  from beam/plasma  DD reactions [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ndd_nbi_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ndd_nbi_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ndd_nbi_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ndd_nbi_nbistructurescenario_ref:
	'''
	class ndd_nbi_nbistructurescenario_ref
	neutron flux coming  from beam/beam  DD reactions [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ndd_nbi_nbi'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ndd_nbi_nbistructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_nbistructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_nbistructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_nbistructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_nbistructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ndd_nbi_nbistructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ndd_nbi_nbistructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_nbistructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_nbistructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_nbistructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndd_nbi_nbistructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ndt_totstructurescenario_ref:
	'''
	class ndt_totstructurescenario_ref
	total neutron flux coming  from DT reactions [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ndt_tot'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ndt_totstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_totstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_totstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_totstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_totstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_totstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ndt_totstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_totstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_totstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_totstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_totstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ndt_thstructurescenario_ref:
	'''
	class ndt_thstructurescenario_ref
	neutron flux coming  from thermal DT reactions [Hz]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ndt_th'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ndt_thstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_thstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_thstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_thstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_thstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ndt_thstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ndt_thstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_thstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_thstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_thstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ndt_thstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ninety_fivestructurescenario_ninety_five:
	'''
	class ninety_fivestructurescenario_ninety_five
	values at 95% of poloidal flux

	Attributes:
	- q_95 : class q_95structurescenario_ref
	   safety factor value  @ 95 % of poloidal flux span []. Time-dependent.
	- elong_95 : class elong_95structurescenario_ref
	   plasma elongation  @ 95 % of poloidal flux span []. Time-dependent.
	- tria_95 : class tria_95structurescenario_ref
	   averaged plasma triangularity  @ 95 % of poloidal flux span []. Time-dependent.
	- tria_up_95 : class tria_up_95structurescenario_ref
	   upper plasma triangularity  @ 95 % of poloidal flux span []. Time-dependent.
	- tria_lo_95 : class tria_lo_95structurescenario_ref
	   lower plasma triangularity  @ 95 % of poloidal flux span []. Time-dependent.
	- te_95 : class te_95structurescenario_ref
	   electron temperature  @ 95 % of poloidal flux [eV]. Time-dependent.
	- ti_95 : class ti_95structurescenario_ref
	   ion temperature  @ 95 % of poloidal flux [eV]. Time-dependent.
	- ne_95 : class ne_95structurescenario_ref
	   electron density  @ 95 % of poloidal flux [m^-3]. Time-dependent.
	- ni_95 : class ni_95structurescenario_ref
	   ion density  @ 95 % of poloidal flux [m^-3]. Time-dependent.
	- phi_95 : class phi_95structurescenario_ref
	   toroidal flux  @ 95 % of poloidal flux [Wb]. Time-dependent.
	- rho_95 : class rho_95structurescenario_ref
	    value of internal simulator coordinate  @ 95 % of poloidal flux [m]. Time-dependent.
	- vtor_95 : class vtor_95structurescenario_ref
	   rotation velocity of selected impurity   @ 95 % of poloidal flux [m/s]. Time-dependent.
	'''

	def __init__(self, base_path_in='ninety_five'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.q_95 = q_95structurescenario_ref('q_95')
		self.elong_95 = elong_95structurescenario_ref('elong_95')
		self.tria_95 = tria_95structurescenario_ref('tria_95')
		self.tria_up_95 = tria_up_95structurescenario_ref('tria_up_95')
		self.tria_lo_95 = tria_lo_95structurescenario_ref('tria_lo_95')
		self.te_95 = te_95structurescenario_ref('te_95')
		self.ti_95 = ti_95structurescenario_ref('ti_95')
		self.ne_95 = ne_95structurescenario_ref('ne_95')
		self.ni_95 = ni_95structurescenario_ref('ni_95')
		self.phi_95 = phi_95structurescenario_ref('phi_95')
		self.rho_95 = rho_95structurescenario_ref('rho_95')
		self.vtor_95 = vtor_95structurescenario_ref('vtor_95')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ninety_fivestructurescenario_ninety_five\n'
		ret = ret + space + 'Attribute q_95\n ' + self.q_95.__str__(depth+1)
		ret = ret + space + 'Attribute elong_95\n ' + self.elong_95.__str__(depth+1)
		ret = ret + space + 'Attribute tria_95\n ' + self.tria_95.__str__(depth+1)
		ret = ret + space + 'Attribute tria_up_95\n ' + self.tria_up_95.__str__(depth+1)
		ret = ret + space + 'Attribute tria_lo_95\n ' + self.tria_lo_95.__str__(depth+1)
		ret = ret + space + 'Attribute te_95\n ' + self.te_95.__str__(depth+1)
		ret = ret + space + 'Attribute ti_95\n ' + self.ti_95.__str__(depth+1)
		ret = ret + space + 'Attribute ne_95\n ' + self.ne_95.__str__(depth+1)
		ret = ret + space + 'Attribute ni_95\n ' + self.ni_95.__str__(depth+1)
		ret = ret + space + 'Attribute phi_95\n ' + self.phi_95.__str__(depth+1)
		ret = ret + space + 'Attribute rho_95\n ' + self.rho_95.__str__(depth+1)
		ret = ret + space + 'Attribute vtor_95\n ' + self.vtor_95.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.q_95.setExpIdx(idx)
		self.elong_95.setExpIdx(idx)
		self.tria_95.setExpIdx(idx)
		self.tria_up_95.setExpIdx(idx)
		self.tria_lo_95.setExpIdx(idx)
		self.te_95.setExpIdx(idx)
		self.ti_95.setExpIdx(idx)
		self.ne_95.setExpIdx(idx)
		self.ni_95.setExpIdx(idx)
		self.phi_95.setExpIdx(idx)
		self.rho_95.setExpIdx(idx)
		self.vtor_95.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ninety_fivestructurescenario_ninety_five, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_95.cpoTime = self.cpoTime
		self.q_95.putSlice(path, cpopath)
		self.elong_95.cpoTime = self.cpoTime
		self.elong_95.putSlice(path, cpopath)
		self.tria_95.cpoTime = self.cpoTime
		self.tria_95.putSlice(path, cpopath)
		self.tria_up_95.cpoTime = self.cpoTime
		self.tria_up_95.putSlice(path, cpopath)
		self.tria_lo_95.cpoTime = self.cpoTime
		self.tria_lo_95.putSlice(path, cpopath)
		self.te_95.cpoTime = self.cpoTime
		self.te_95.putSlice(path, cpopath)
		self.ti_95.cpoTime = self.cpoTime
		self.ti_95.putSlice(path, cpopath)
		self.ne_95.cpoTime = self.cpoTime
		self.ne_95.putSlice(path, cpopath)
		self.ni_95.cpoTime = self.cpoTime
		self.ni_95.putSlice(path, cpopath)
		self.phi_95.cpoTime = self.cpoTime
		self.phi_95.putSlice(path, cpopath)
		self.rho_95.cpoTime = self.cpoTime
		self.rho_95.putSlice(path, cpopath)
		self.vtor_95.cpoTime = self.cpoTime
		self.vtor_95.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ninety_fivestructurescenario_ninety_five, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_95.replaceLastSlice(path, cpopath)
		self.elong_95.replaceLastSlice(path, cpopath)
		self.tria_95.replaceLastSlice(path, cpopath)
		self.tria_up_95.replaceLastSlice(path, cpopath)
		self.tria_lo_95.replaceLastSlice(path, cpopath)
		self.te_95.replaceLastSlice(path, cpopath)
		self.ti_95.replaceLastSlice(path, cpopath)
		self.ne_95.replaceLastSlice(path, cpopath)
		self.ni_95.replaceLastSlice(path, cpopath)
		self.phi_95.replaceLastSlice(path, cpopath)
		self.rho_95.replaceLastSlice(path, cpopath)
		self.vtor_95.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ninety_fivestructurescenario_ninety_five, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_95.putNonTimed(path, cpopath)
		self.elong_95.putNonTimed(path, cpopath)
		self.tria_95.putNonTimed(path, cpopath)
		self.tria_up_95.putNonTimed(path, cpopath)
		self.tria_lo_95.putNonTimed(path, cpopath)
		self.te_95.putNonTimed(path, cpopath)
		self.ti_95.putNonTimed(path, cpopath)
		self.ne_95.putNonTimed(path, cpopath)
		self.ni_95.putNonTimed(path, cpopath)
		self.phi_95.putNonTimed(path, cpopath)
		self.rho_95.putNonTimed(path, cpopath)
		self.vtor_95.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ninety_fivestructurescenario_ninety_five, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_95.getSlice(path, cpopath, inTime, interpolMode)
		self.elong_95.getSlice(path, cpopath, inTime, interpolMode)
		self.tria_95.getSlice(path, cpopath, inTime, interpolMode)
		self.tria_up_95.getSlice(path, cpopath, inTime, interpolMode)
		self.tria_lo_95.getSlice(path, cpopath, inTime, interpolMode)
		self.te_95.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_95.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_95.getSlice(path, cpopath, inTime, interpolMode)
		self.ni_95.getSlice(path, cpopath, inTime, interpolMode)
		self.phi_95.getSlice(path, cpopath, inTime, interpolMode)
		self.rho_95.getSlice(path, cpopath, inTime, interpolMode)
		self.vtor_95.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ninety_fivestructurescenario_ninety_five, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			q_95List = self.q_95.build_non_resampled_data(path, cpopath, nbslice)
			elong_95List = self.elong_95.build_non_resampled_data(path, cpopath, nbslice)
			tria_95List = self.tria_95.build_non_resampled_data(path, cpopath, nbslice)
			tria_up_95List = self.tria_up_95.build_non_resampled_data(path, cpopath, nbslice)
			tria_lo_95List = self.tria_lo_95.build_non_resampled_data(path, cpopath, nbslice)
			te_95List = self.te_95.build_non_resampled_data(path, cpopath, nbslice)
			ti_95List = self.ti_95.build_non_resampled_data(path, cpopath, nbslice)
			ne_95List = self.ne_95.build_non_resampled_data(path, cpopath, nbslice)
			ni_95List = self.ni_95.build_non_resampled_data(path, cpopath, nbslice)
			phi_95List = self.phi_95.build_non_resampled_data(path, cpopath, nbslice)
			rho_95List = self.rho_95.build_non_resampled_data(path, cpopath, nbslice)
			vtor_95List = self.vtor_95.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = ninety_fivestructurescenario_ninety_five(self.base_path)
				slice.setExpIdx(self.idx)
				slice.q_95 = q_95List[i]
				slice.elong_95 = elong_95List[i]
				slice.tria_95 = tria_95List[i]
				slice.tria_up_95 = tria_up_95List[i]
				slice.tria_lo_95 = tria_lo_95List[i]
				slice.te_95 = te_95List[i]
				slice.ti_95 = ti_95List[i]
				slice.ne_95 = ne_95List[i]
				slice.ni_95 = ni_95List[i]
				slice.phi_95 = phi_95List[i]
				slice.rho_95 = rho_95List[i]
				slice.vtor_95 = vtor_95List[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ninety_fivestructurescenario_ninety_fiveObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.q_95.putTimedElt(path, cpopath + 'q_95', i, obj)
		obj = self.elong_95.putTimedElt(path, cpopath + 'elong_95', i, obj)
		obj = self.tria_95.putTimedElt(path, cpopath + 'tria_95', i, obj)
		obj = self.tria_up_95.putTimedElt(path, cpopath + 'tria_up_95', i, obj)
		obj = self.tria_lo_95.putTimedElt(path, cpopath + 'tria_lo_95', i, obj)
		obj = self.te_95.putTimedElt(path, cpopath + 'te_95', i, obj)
		obj = self.ti_95.putTimedElt(path, cpopath + 'ti_95', i, obj)
		obj = self.ne_95.putTimedElt(path, cpopath + 'ne_95', i, obj)
		obj = self.ni_95.putTimedElt(path, cpopath + 'ni_95', i, obj)
		obj = self.phi_95.putTimedElt(path, cpopath + 'phi_95', i, obj)
		obj = self.rho_95.putTimedElt(path, cpopath + 'rho_95', i, obj)
		obj = self.vtor_95.putTimedElt(path, cpopath + 'vtor_95', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ninety_fivestructurescenario_ninety_fiveObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.q_95.getTimedElt(path, cpopath + 'q_95', i, obj)
		self.elong_95.getTimedElt(path, cpopath + 'elong_95', i, obj)
		self.tria_95.getTimedElt(path, cpopath + 'tria_95', i, obj)
		self.tria_up_95.getTimedElt(path, cpopath + 'tria_up_95', i, obj)
		self.tria_lo_95.getTimedElt(path, cpopath + 'tria_lo_95', i, obj)
		self.te_95.getTimedElt(path, cpopath + 'te_95', i, obj)
		self.ti_95.getTimedElt(path, cpopath + 'ti_95', i, obj)
		self.ne_95.getTimedElt(path, cpopath + 'ne_95', i, obj)
		self.ni_95.getTimedElt(path, cpopath + 'ni_95', i, obj)
		self.phi_95.getTimedElt(path, cpopath + 'phi_95', i, obj)
		self.rho_95.getTimedElt(path, cpopath + 'rho_95', i, obj)
		self.vtor_95.getTimedElt(path, cpopath + 'vtor_95', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ninety_fivestructurescenario_ninety_fiveObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.q_95.putNonTimedElt(path, cpopath + 'q_95', i, obj)
		obj = self.elong_95.putNonTimedElt(path, cpopath + 'elong_95', i, obj)
		obj = self.tria_95.putNonTimedElt(path, cpopath + 'tria_95', i, obj)
		obj = self.tria_up_95.putNonTimedElt(path, cpopath + 'tria_up_95', i, obj)
		obj = self.tria_lo_95.putNonTimedElt(path, cpopath + 'tria_lo_95', i, obj)
		obj = self.te_95.putNonTimedElt(path, cpopath + 'te_95', i, obj)
		obj = self.ti_95.putNonTimedElt(path, cpopath + 'ti_95', i, obj)
		obj = self.ne_95.putNonTimedElt(path, cpopath + 'ne_95', i, obj)
		obj = self.ni_95.putNonTimedElt(path, cpopath + 'ni_95', i, obj)
		obj = self.phi_95.putNonTimedElt(path, cpopath + 'phi_95', i, obj)
		obj = self.rho_95.putNonTimedElt(path, cpopath + 'rho_95', i, obj)
		obj = self.vtor_95.putNonTimedElt(path, cpopath + 'vtor_95', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ninety_fivestructurescenario_ninety_fiveObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.q_95.getNonTimedElt(path, cpopath + 'q_95', i, obj)
		self.elong_95.getNonTimedElt(path, cpopath + 'elong_95', i, obj)
		self.tria_95.getNonTimedElt(path, cpopath + 'tria_95', i, obj)
		self.tria_up_95.getNonTimedElt(path, cpopath + 'tria_up_95', i, obj)
		self.tria_lo_95.getNonTimedElt(path, cpopath + 'tria_lo_95', i, obj)
		self.te_95.getNonTimedElt(path, cpopath + 'te_95', i, obj)
		self.ti_95.getNonTimedElt(path, cpopath + 'ti_95', i, obj)
		self.ne_95.getNonTimedElt(path, cpopath + 'ne_95', i, obj)
		self.ni_95.getNonTimedElt(path, cpopath + 'ni_95', i, obj)
		self.phi_95.getNonTimedElt(path, cpopath + 'phi_95', i, obj)
		self.rho_95.getNonTimedElt(path, cpopath + 'rho_95', i, obj)
		self.vtor_95.getNonTimedElt(path, cpopath + 'vtor_95', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.q_95.deleteData(path, cpopath)
		self.elong_95.deleteData(path, cpopath)
		self.tria_95.deleteData(path, cpopath)
		self.tria_up_95.deleteData(path, cpopath)
		self.tria_lo_95.deleteData(path, cpopath)
		self.te_95.deleteData(path, cpopath)
		self.ti_95.deleteData(path, cpopath)
		self.ne_95.deleteData(path, cpopath)
		self.ni_95.deleteData(path, cpopath)
		self.phi_95.deleteData(path, cpopath)
		self.rho_95.deleteData(path, cpopath)
		self.vtor_95.deleteData(path, cpopath)


class q_95structurescenario_ref:
	'''
	class q_95structurescenario_ref
	safety factor value  @ 95 % of poloidal flux span []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class elong_95structurescenario_ref:
	'''
	class elong_95structurescenario_ref
	plasma elongation  @ 95 % of poloidal flux span []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='elong_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class elong_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type elong_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type elong_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type elong_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type elong_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type elong_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = elong_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type elong_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type elong_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type elong_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type elong_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tria_95structurescenario_ref:
	'''
	class tria_95structurescenario_ref
	averaged plasma triangularity  @ 95 % of poloidal flux span []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tria_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tria_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tria_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tria_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tria_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tria_up_95structurescenario_ref:
	'''
	class tria_up_95structurescenario_ref
	upper plasma triangularity  @ 95 % of poloidal flux span []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tria_up_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tria_up_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_up_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_up_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_up_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tria_up_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tria_up_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tria_up_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_up_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_up_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_up_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_up_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class tria_lo_95structurescenario_ref:
	'''
	class tria_lo_95structurescenario_ref
	lower plasma triangularity  @ 95 % of poloidal flux span []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='tria_lo_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class tria_lo_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_lo_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_lo_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type tria_lo_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type tria_lo_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type tria_lo_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = tria_lo_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_lo_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_lo_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_lo_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type tria_lo_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class te_95structurescenario_ref:
	'''
	class te_95structurescenario_ref
	electron temperature  @ 95 % of poloidal flux [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_95structurescenario_ref:
	'''
	class ti_95structurescenario_ref
	ion temperature  @ 95 % of poloidal flux [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_95structurescenario_ref:
	'''
	class ne_95structurescenario_ref
	electron density  @ 95 % of poloidal flux [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni_95structurescenario_ref:
	'''
	class ni_95structurescenario_ref
	ion density  @ 95 % of poloidal flux [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class phi_95structurescenario_ref:
	'''
	class phi_95structurescenario_ref
	toroidal flux  @ 95 % of poloidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='phi_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class phi_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type phi_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type phi_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = phi_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class rho_95structurescenario_ref:
	'''
	class rho_95structurescenario_ref
	 value of internal simulator coordinate  @ 95 % of poloidal flux [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='rho_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class rho_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type rho_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type rho_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = rho_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class vtor_95structurescenario_ref:
	'''
	class vtor_95structurescenario_ref
	rotation velocity of selected impurity   @ 95 % of poloidal flux [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='vtor_95'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class vtor_95structurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_95structurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_95structurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_95structurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_95structurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_95structurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = vtor_95structurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_95structurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_95structurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_95structurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_95structurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pedestalstructurescenario_pedestal:
	'''
	class pedestalstructurescenario_pedestal
	Values at the top of the H-mode pedestal

	Attributes:
	- te_ped : class te_pedstructurescenario_ref
	   pedestal electron temperature [eV]. Time-dependent.
	- ti_ped : class ti_pedstructurescenario_ref
	   pedestal ion temperature [eV]. Time-dependent.
	- ne_ped : class ne_pedstructurescenario_ref
	   pedestal electron density [m^-3]. Time-dependent.
	- ni_ped : class ni_pedstructurescenario_ref
	   pedestal ion density [m^-3]. Time-dependent.
	- psi_ped : class psi_pedstructurescenario_ref
	   pedestal poloidal flux [Wb]. Time-dependent.
	- phi_ped : class phi_pedstructurescenario_ref
	   pedestal toroidal flux [Wb]. Time-dependent.
	- rho_ped : class rho_pedstructurescenario_ref
	   top pedestal value of internal simulator coordinate [m]. Time-dependent.
	- q_ped : class q_pedstructurescenario_ref
	   top pedestal safety factor value []. Time-dependent.
	- pressure_ped : class pressure_pedstructurescenario_ref
	   top pedestal thermal pressure (n_e * T_e  + n_i * T_i) [Pa]. Time-dependent.
	- vtor_ped : class vtor_pedstructurescenario_ref
	   top pedestal value of rotation velocity of selected impurity [m/s]. Time-dependent.
	'''

	def __init__(self, base_path_in='pedestal'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.te_ped = te_pedstructurescenario_ref('te_ped')
		self.ti_ped = ti_pedstructurescenario_ref('ti_ped')
		self.ne_ped = ne_pedstructurescenario_ref('ne_ped')
		self.ni_ped = ni_pedstructurescenario_ref('ni_ped')
		self.psi_ped = psi_pedstructurescenario_ref('psi_ped')
		self.phi_ped = phi_pedstructurescenario_ref('phi_ped')
		self.rho_ped = rho_pedstructurescenario_ref('rho_ped')
		self.q_ped = q_pedstructurescenario_ref('q_ped')
		self.pressure_ped = pressure_pedstructurescenario_ref('pressure_ped')
		self.vtor_ped = vtor_pedstructurescenario_ref('vtor_ped')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pedestalstructurescenario_pedestal\n'
		ret = ret + space + 'Attribute te_ped\n ' + self.te_ped.__str__(depth+1)
		ret = ret + space + 'Attribute ti_ped\n ' + self.ti_ped.__str__(depth+1)
		ret = ret + space + 'Attribute ne_ped\n ' + self.ne_ped.__str__(depth+1)
		ret = ret + space + 'Attribute ni_ped\n ' + self.ni_ped.__str__(depth+1)
		ret = ret + space + 'Attribute psi_ped\n ' + self.psi_ped.__str__(depth+1)
		ret = ret + space + 'Attribute phi_ped\n ' + self.phi_ped.__str__(depth+1)
		ret = ret + space + 'Attribute rho_ped\n ' + self.rho_ped.__str__(depth+1)
		ret = ret + space + 'Attribute q_ped\n ' + self.q_ped.__str__(depth+1)
		ret = ret + space + 'Attribute pressure_ped\n ' + self.pressure_ped.__str__(depth+1)
		ret = ret + space + 'Attribute vtor_ped\n ' + self.vtor_ped.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.te_ped.setExpIdx(idx)
		self.ti_ped.setExpIdx(idx)
		self.ne_ped.setExpIdx(idx)
		self.ni_ped.setExpIdx(idx)
		self.psi_ped.setExpIdx(idx)
		self.phi_ped.setExpIdx(idx)
		self.rho_ped.setExpIdx(idx)
		self.q_ped.setExpIdx(idx)
		self.pressure_ped.setExpIdx(idx)
		self.vtor_ped.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pedestalstructurescenario_pedestal, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ped.cpoTime = self.cpoTime
		self.te_ped.putSlice(path, cpopath)
		self.ti_ped.cpoTime = self.cpoTime
		self.ti_ped.putSlice(path, cpopath)
		self.ne_ped.cpoTime = self.cpoTime
		self.ne_ped.putSlice(path, cpopath)
		self.ni_ped.cpoTime = self.cpoTime
		self.ni_ped.putSlice(path, cpopath)
		self.psi_ped.cpoTime = self.cpoTime
		self.psi_ped.putSlice(path, cpopath)
		self.phi_ped.cpoTime = self.cpoTime
		self.phi_ped.putSlice(path, cpopath)
		self.rho_ped.cpoTime = self.cpoTime
		self.rho_ped.putSlice(path, cpopath)
		self.q_ped.cpoTime = self.cpoTime
		self.q_ped.putSlice(path, cpopath)
		self.pressure_ped.cpoTime = self.cpoTime
		self.pressure_ped.putSlice(path, cpopath)
		self.vtor_ped.cpoTime = self.cpoTime
		self.vtor_ped.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pedestalstructurescenario_pedestal, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ped.replaceLastSlice(path, cpopath)
		self.ti_ped.replaceLastSlice(path, cpopath)
		self.ne_ped.replaceLastSlice(path, cpopath)
		self.ni_ped.replaceLastSlice(path, cpopath)
		self.psi_ped.replaceLastSlice(path, cpopath)
		self.phi_ped.replaceLastSlice(path, cpopath)
		self.rho_ped.replaceLastSlice(path, cpopath)
		self.q_ped.replaceLastSlice(path, cpopath)
		self.pressure_ped.replaceLastSlice(path, cpopath)
		self.vtor_ped.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pedestalstructurescenario_pedestal, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ped.putNonTimed(path, cpopath)
		self.ti_ped.putNonTimed(path, cpopath)
		self.ne_ped.putNonTimed(path, cpopath)
		self.ni_ped.putNonTimed(path, cpopath)
		self.psi_ped.putNonTimed(path, cpopath)
		self.phi_ped.putNonTimed(path, cpopath)
		self.rho_ped.putNonTimed(path, cpopath)
		self.q_ped.putNonTimed(path, cpopath)
		self.pressure_ped.putNonTimed(path, cpopath)
		self.vtor_ped.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pedestalstructurescenario_pedestal, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.ni_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.psi_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.phi_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.rho_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.q_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.pressure_ped.getSlice(path, cpopath, inTime, interpolMode)
		self.vtor_ped.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pedestalstructurescenario_pedestal, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			te_pedList = self.te_ped.build_non_resampled_data(path, cpopath, nbslice)
			ti_pedList = self.ti_ped.build_non_resampled_data(path, cpopath, nbslice)
			ne_pedList = self.ne_ped.build_non_resampled_data(path, cpopath, nbslice)
			ni_pedList = self.ni_ped.build_non_resampled_data(path, cpopath, nbslice)
			psi_pedList = self.psi_ped.build_non_resampled_data(path, cpopath, nbslice)
			phi_pedList = self.phi_ped.build_non_resampled_data(path, cpopath, nbslice)
			rho_pedList = self.rho_ped.build_non_resampled_data(path, cpopath, nbslice)
			q_pedList = self.q_ped.build_non_resampled_data(path, cpopath, nbslice)
			pressure_pedList = self.pressure_ped.build_non_resampled_data(path, cpopath, nbslice)
			vtor_pedList = self.vtor_ped.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = pedestalstructurescenario_pedestal(self.base_path)
				slice.setExpIdx(self.idx)
				slice.te_ped = te_pedList[i]
				slice.ti_ped = ti_pedList[i]
				slice.ne_ped = ne_pedList[i]
				slice.ni_ped = ni_pedList[i]
				slice.psi_ped = psi_pedList[i]
				slice.phi_ped = phi_pedList[i]
				slice.rho_ped = rho_pedList[i]
				slice.q_ped = q_pedList[i]
				slice.pressure_ped = pressure_pedList[i]
				slice.vtor_ped = vtor_pedList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pedestalstructurescenario_pedestalObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_ped.putTimedElt(path, cpopath + 'te_ped', i, obj)
		obj = self.ti_ped.putTimedElt(path, cpopath + 'ti_ped', i, obj)
		obj = self.ne_ped.putTimedElt(path, cpopath + 'ne_ped', i, obj)
		obj = self.ni_ped.putTimedElt(path, cpopath + 'ni_ped', i, obj)
		obj = self.psi_ped.putTimedElt(path, cpopath + 'psi_ped', i, obj)
		obj = self.phi_ped.putTimedElt(path, cpopath + 'phi_ped', i, obj)
		obj = self.rho_ped.putTimedElt(path, cpopath + 'rho_ped', i, obj)
		obj = self.q_ped.putTimedElt(path, cpopath + 'q_ped', i, obj)
		obj = self.pressure_ped.putTimedElt(path, cpopath + 'pressure_ped', i, obj)
		obj = self.vtor_ped.putTimedElt(path, cpopath + 'vtor_ped', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pedestalstructurescenario_pedestalObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.te_ped.getTimedElt(path, cpopath + 'te_ped', i, obj)
		self.ti_ped.getTimedElt(path, cpopath + 'ti_ped', i, obj)
		self.ne_ped.getTimedElt(path, cpopath + 'ne_ped', i, obj)
		self.ni_ped.getTimedElt(path, cpopath + 'ni_ped', i, obj)
		self.psi_ped.getTimedElt(path, cpopath + 'psi_ped', i, obj)
		self.phi_ped.getTimedElt(path, cpopath + 'phi_ped', i, obj)
		self.rho_ped.getTimedElt(path, cpopath + 'rho_ped', i, obj)
		self.q_ped.getTimedElt(path, cpopath + 'q_ped', i, obj)
		self.pressure_ped.getTimedElt(path, cpopath + 'pressure_ped', i, obj)
		self.vtor_ped.getTimedElt(path, cpopath + 'vtor_ped', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pedestalstructurescenario_pedestalObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_ped.putNonTimedElt(path, cpopath + 'te_ped', i, obj)
		obj = self.ti_ped.putNonTimedElt(path, cpopath + 'ti_ped', i, obj)
		obj = self.ne_ped.putNonTimedElt(path, cpopath + 'ne_ped', i, obj)
		obj = self.ni_ped.putNonTimedElt(path, cpopath + 'ni_ped', i, obj)
		obj = self.psi_ped.putNonTimedElt(path, cpopath + 'psi_ped', i, obj)
		obj = self.phi_ped.putNonTimedElt(path, cpopath + 'phi_ped', i, obj)
		obj = self.rho_ped.putNonTimedElt(path, cpopath + 'rho_ped', i, obj)
		obj = self.q_ped.putNonTimedElt(path, cpopath + 'q_ped', i, obj)
		obj = self.pressure_ped.putNonTimedElt(path, cpopath + 'pressure_ped', i, obj)
		obj = self.vtor_ped.putNonTimedElt(path, cpopath + 'vtor_ped', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pedestalstructurescenario_pedestalObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.te_ped.getNonTimedElt(path, cpopath + 'te_ped', i, obj)
		self.ti_ped.getNonTimedElt(path, cpopath + 'ti_ped', i, obj)
		self.ne_ped.getNonTimedElt(path, cpopath + 'ne_ped', i, obj)
		self.ni_ped.getNonTimedElt(path, cpopath + 'ni_ped', i, obj)
		self.psi_ped.getNonTimedElt(path, cpopath + 'psi_ped', i, obj)
		self.phi_ped.getNonTimedElt(path, cpopath + 'phi_ped', i, obj)
		self.rho_ped.getNonTimedElt(path, cpopath + 'rho_ped', i, obj)
		self.q_ped.getNonTimedElt(path, cpopath + 'q_ped', i, obj)
		self.pressure_ped.getNonTimedElt(path, cpopath + 'pressure_ped', i, obj)
		self.vtor_ped.getNonTimedElt(path, cpopath + 'vtor_ped', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ped.deleteData(path, cpopath)
		self.ti_ped.deleteData(path, cpopath)
		self.ne_ped.deleteData(path, cpopath)
		self.ni_ped.deleteData(path, cpopath)
		self.psi_ped.deleteData(path, cpopath)
		self.phi_ped.deleteData(path, cpopath)
		self.rho_ped.deleteData(path, cpopath)
		self.q_ped.deleteData(path, cpopath)
		self.pressure_ped.deleteData(path, cpopath)
		self.vtor_ped.deleteData(path, cpopath)


class te_pedstructurescenario_ref:
	'''
	class te_pedstructurescenario_ref
	pedestal electron temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_pedstructurescenario_ref:
	'''
	class ti_pedstructurescenario_ref
	pedestal ion temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_pedstructurescenario_ref:
	'''
	class ne_pedstructurescenario_ref
	pedestal electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni_pedstructurescenario_ref:
	'''
	class ni_pedstructurescenario_ref
	pedestal ion density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class psi_pedstructurescenario_ref:
	'''
	class psi_pedstructurescenario_ref
	pedestal poloidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='psi_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class psi_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type psi_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type psi_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type psi_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = psi_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type psi_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class phi_pedstructurescenario_ref:
	'''
	class phi_pedstructurescenario_ref
	pedestal toroidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='phi_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class phi_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type phi_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type phi_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type phi_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = phi_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type phi_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class rho_pedstructurescenario_ref:
	'''
	class rho_pedstructurescenario_ref
	top pedestal value of internal simulator coordinate [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='rho_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class rho_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type rho_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type rho_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type rho_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = rho_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type rho_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class q_pedstructurescenario_ref:
	'''
	class q_pedstructurescenario_ref
	top pedestal safety factor value []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='q_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class q_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type q_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type q_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type q_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = q_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type q_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pressure_pedstructurescenario_ref:
	'''
	class pressure_pedstructurescenario_ref
	top pedestal thermal pressure (n_e * T_e  + n_i * T_i) [Pa]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pressure_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pressure_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pressure_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pressure_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pressure_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pressure_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pressure_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pressure_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pressure_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pressure_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pressure_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pressure_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class vtor_pedstructurescenario_ref:
	'''
	class vtor_pedstructurescenario_ref
	top pedestal value of rotation velocity of selected impurity [m/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='vtor_ped'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class vtor_pedstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_pedstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_pedstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_pedstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_pedstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type vtor_pedstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = vtor_pedstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_pedstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_pedstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_pedstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vtor_pedstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class referencesstructurescenario_references:
	'''
	class referencesstructurescenario_references
	References

	Attributes:
	- plh : class plhstructurescenario_ref
	   Lower hybrid power [W]. Time-dependent.
	- picrh : class picrhstructurescenario_ref
	   Ion cyclotron resonnance heating power [W]. Time-dependent.
	- pecrh : class pecrhstructurescenario_ref
	   electron cyclotron resonnance heating power [W]. Time-dependent.
	- pnbi : class pnbistructurescenario_ref
	   neutral beam injection power [W]. Time-dependent.
	- ip : class ipstructurescenario_ref
	   Plasma current [A]. Time-dependent.
	- bvac_r : class bvac_rstructurescenario_ref
	   Vacuum field times radius in the toroidal field magnet [T.m]. Time-dependent.
	- zeffl : class zefflstructurescenario_ref
	   line averaged effective charge []. Time-dependent.
	- nbar : class nbarstructurescenario_ref
	   line averaged electron density [m^-3]. Time-dependent.
	- xecrh : class xecrhstructurescenario_ref
	   position of maximum  (normalized rho coordinate) of electron cyclotron resonnance heating power []. Time-dependent.
	- pol_flux : class pol_fluxstructurescenario_ref
	   separatrix poloidal flux [Wb]. Time-dependent.
	- enhancement : class enhancementstructurescenario_ref
	   energy enhancement factor []. Time-dependent.
	- isotopic : class isotopicstructurescenario_ref
	   ratio between tritium  and deuterium density (for burning plasma)  []. Time-dependent.
	- nbi_td_ratio : class nbi_td_ratiostructurescenario_ref
	   ratio between tritium  and deuterium power in neutral beam injection  []. Time-dependent.
	- gas_puff : class gas_puffstructurescenario_ref
	   gas puff flux reference, in equivalent [electrons.s^-1]. Time-dependent.
	'''

	def __init__(self, base_path_in='references'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.plh = plhstructurescenario_ref('plh')
		self.picrh = picrhstructurescenario_ref('picrh')
		self.pecrh = pecrhstructurescenario_ref('pecrh')
		self.pnbi = pnbistructurescenario_ref('pnbi')
		self.ip = ipstructurescenario_ref('ip')
		self.bvac_r = bvac_rstructurescenario_ref('bvac_r')
		self.zeffl = zefflstructurescenario_ref('zeffl')
		self.nbar = nbarstructurescenario_ref('nbar')
		self.xecrh = xecrhstructurescenario_ref('xecrh')
		self.pol_flux = pol_fluxstructurescenario_ref('pol_flux')
		self.enhancement = enhancementstructurescenario_ref('enhancement')
		self.isotopic = isotopicstructurescenario_ref('isotopic')
		self.nbi_td_ratio = nbi_td_ratiostructurescenario_ref('nbi_td_ratio')
		self.gas_puff = gas_puffstructurescenario_ref('gas_puff')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class referencesstructurescenario_references\n'
		ret = ret + space + 'Attribute plh\n ' + self.plh.__str__(depth+1)
		ret = ret + space + 'Attribute picrh\n ' + self.picrh.__str__(depth+1)
		ret = ret + space + 'Attribute pecrh\n ' + self.pecrh.__str__(depth+1)
		ret = ret + space + 'Attribute pnbi\n ' + self.pnbi.__str__(depth+1)
		ret = ret + space + 'Attribute ip\n ' + self.ip.__str__(depth+1)
		ret = ret + space + 'Attribute bvac_r\n ' + self.bvac_r.__str__(depth+1)
		ret = ret + space + 'Attribute zeffl\n ' + self.zeffl.__str__(depth+1)
		ret = ret + space + 'Attribute nbar\n ' + self.nbar.__str__(depth+1)
		ret = ret + space + 'Attribute xecrh\n ' + self.xecrh.__str__(depth+1)
		ret = ret + space + 'Attribute pol_flux\n ' + self.pol_flux.__str__(depth+1)
		ret = ret + space + 'Attribute enhancement\n ' + self.enhancement.__str__(depth+1)
		ret = ret + space + 'Attribute isotopic\n ' + self.isotopic.__str__(depth+1)
		ret = ret + space + 'Attribute nbi_td_ratio\n ' + self.nbi_td_ratio.__str__(depth+1)
		ret = ret + space + 'Attribute gas_puff\n ' + self.gas_puff.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.plh.setExpIdx(idx)
		self.picrh.setExpIdx(idx)
		self.pecrh.setExpIdx(idx)
		self.pnbi.setExpIdx(idx)
		self.ip.setExpIdx(idx)
		self.bvac_r.setExpIdx(idx)
		self.zeffl.setExpIdx(idx)
		self.nbar.setExpIdx(idx)
		self.xecrh.setExpIdx(idx)
		self.pol_flux.setExpIdx(idx)
		self.enhancement.setExpIdx(idx)
		self.isotopic.setExpIdx(idx)
		self.nbi_td_ratio.setExpIdx(idx)
		self.gas_puff.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type referencesstructurescenario_references, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.cpoTime = self.cpoTime
		self.plh.putSlice(path, cpopath)
		self.picrh.cpoTime = self.cpoTime
		self.picrh.putSlice(path, cpopath)
		self.pecrh.cpoTime = self.cpoTime
		self.pecrh.putSlice(path, cpopath)
		self.pnbi.cpoTime = self.cpoTime
		self.pnbi.putSlice(path, cpopath)
		self.ip.cpoTime = self.cpoTime
		self.ip.putSlice(path, cpopath)
		self.bvac_r.cpoTime = self.cpoTime
		self.bvac_r.putSlice(path, cpopath)
		self.zeffl.cpoTime = self.cpoTime
		self.zeffl.putSlice(path, cpopath)
		self.nbar.cpoTime = self.cpoTime
		self.nbar.putSlice(path, cpopath)
		self.xecrh.cpoTime = self.cpoTime
		self.xecrh.putSlice(path, cpopath)
		self.pol_flux.cpoTime = self.cpoTime
		self.pol_flux.putSlice(path, cpopath)
		self.enhancement.cpoTime = self.cpoTime
		self.enhancement.putSlice(path, cpopath)
		self.isotopic.cpoTime = self.cpoTime
		self.isotopic.putSlice(path, cpopath)
		self.nbi_td_ratio.cpoTime = self.cpoTime
		self.nbi_td_ratio.putSlice(path, cpopath)
		self.gas_puff.cpoTime = self.cpoTime
		self.gas_puff.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type referencesstructurescenario_references, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.replaceLastSlice(path, cpopath)
		self.picrh.replaceLastSlice(path, cpopath)
		self.pecrh.replaceLastSlice(path, cpopath)
		self.pnbi.replaceLastSlice(path, cpopath)
		self.ip.replaceLastSlice(path, cpopath)
		self.bvac_r.replaceLastSlice(path, cpopath)
		self.zeffl.replaceLastSlice(path, cpopath)
		self.nbar.replaceLastSlice(path, cpopath)
		self.xecrh.replaceLastSlice(path, cpopath)
		self.pol_flux.replaceLastSlice(path, cpopath)
		self.enhancement.replaceLastSlice(path, cpopath)
		self.isotopic.replaceLastSlice(path, cpopath)
		self.nbi_td_ratio.replaceLastSlice(path, cpopath)
		self.gas_puff.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type referencesstructurescenario_references, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.putNonTimed(path, cpopath)
		self.picrh.putNonTimed(path, cpopath)
		self.pecrh.putNonTimed(path, cpopath)
		self.pnbi.putNonTimed(path, cpopath)
		self.ip.putNonTimed(path, cpopath)
		self.bvac_r.putNonTimed(path, cpopath)
		self.zeffl.putNonTimed(path, cpopath)
		self.nbar.putNonTimed(path, cpopath)
		self.xecrh.putNonTimed(path, cpopath)
		self.pol_flux.putNonTimed(path, cpopath)
		self.enhancement.putNonTimed(path, cpopath)
		self.isotopic.putNonTimed(path, cpopath)
		self.nbi_td_ratio.putNonTimed(path, cpopath)
		self.gas_puff.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type referencesstructurescenario_references, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.getSlice(path, cpopath, inTime, interpolMode)
		self.picrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pecrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pnbi.getSlice(path, cpopath, inTime, interpolMode)
		self.ip.getSlice(path, cpopath, inTime, interpolMode)
		self.bvac_r.getSlice(path, cpopath, inTime, interpolMode)
		self.zeffl.getSlice(path, cpopath, inTime, interpolMode)
		self.nbar.getSlice(path, cpopath, inTime, interpolMode)
		self.xecrh.getSlice(path, cpopath, inTime, interpolMode)
		self.pol_flux.getSlice(path, cpopath, inTime, interpolMode)
		self.enhancement.getSlice(path, cpopath, inTime, interpolMode)
		self.isotopic.getSlice(path, cpopath, inTime, interpolMode)
		self.nbi_td_ratio.getSlice(path, cpopath, inTime, interpolMode)
		self.gas_puff.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type referencesstructurescenario_references, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			plhList = self.plh.build_non_resampled_data(path, cpopath, nbslice)
			picrhList = self.picrh.build_non_resampled_data(path, cpopath, nbslice)
			pecrhList = self.pecrh.build_non_resampled_data(path, cpopath, nbslice)
			pnbiList = self.pnbi.build_non_resampled_data(path, cpopath, nbslice)
			ipList = self.ip.build_non_resampled_data(path, cpopath, nbslice)
			bvac_rList = self.bvac_r.build_non_resampled_data(path, cpopath, nbslice)
			zefflList = self.zeffl.build_non_resampled_data(path, cpopath, nbslice)
			nbarList = self.nbar.build_non_resampled_data(path, cpopath, nbslice)
			xecrhList = self.xecrh.build_non_resampled_data(path, cpopath, nbslice)
			pol_fluxList = self.pol_flux.build_non_resampled_data(path, cpopath, nbslice)
			enhancementList = self.enhancement.build_non_resampled_data(path, cpopath, nbslice)
			isotopicList = self.isotopic.build_non_resampled_data(path, cpopath, nbslice)
			nbi_td_ratioList = self.nbi_td_ratio.build_non_resampled_data(path, cpopath, nbslice)
			gas_puffList = self.gas_puff.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = referencesstructurescenario_references(self.base_path)
				slice.setExpIdx(self.idx)
				slice.plh = plhList[i]
				slice.picrh = picrhList[i]
				slice.pecrh = pecrhList[i]
				slice.pnbi = pnbiList[i]
				slice.ip = ipList[i]
				slice.bvac_r = bvac_rList[i]
				slice.zeffl = zefflList[i]
				slice.nbar = nbarList[i]
				slice.xecrh = xecrhList[i]
				slice.pol_flux = pol_fluxList[i]
				slice.enhancement = enhancementList[i]
				slice.isotopic = isotopicList[i]
				slice.nbi_td_ratio = nbi_td_ratioList[i]
				slice.gas_puff = gas_puffList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type referencesstructurescenario_referencesObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.plh.putTimedElt(path, cpopath + 'plh', i, obj)
		obj = self.picrh.putTimedElt(path, cpopath + 'picrh', i, obj)
		obj = self.pecrh.putTimedElt(path, cpopath + 'pecrh', i, obj)
		obj = self.pnbi.putTimedElt(path, cpopath + 'pnbi', i, obj)
		obj = self.ip.putTimedElt(path, cpopath + 'ip', i, obj)
		obj = self.bvac_r.putTimedElt(path, cpopath + 'bvac_r', i, obj)
		obj = self.zeffl.putTimedElt(path, cpopath + 'zeffl', i, obj)
		obj = self.nbar.putTimedElt(path, cpopath + 'nbar', i, obj)
		obj = self.xecrh.putTimedElt(path, cpopath + 'xecrh', i, obj)
		obj = self.pol_flux.putTimedElt(path, cpopath + 'pol_flux', i, obj)
		obj = self.enhancement.putTimedElt(path, cpopath + 'enhancement', i, obj)
		obj = self.isotopic.putTimedElt(path, cpopath + 'isotopic', i, obj)
		obj = self.nbi_td_ratio.putTimedElt(path, cpopath + 'nbi_td_ratio', i, obj)
		obj = self.gas_puff.putTimedElt(path, cpopath + 'gas_puff', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type referencesstructurescenario_referencesObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.plh.getTimedElt(path, cpopath + 'plh', i, obj)
		self.picrh.getTimedElt(path, cpopath + 'picrh', i, obj)
		self.pecrh.getTimedElt(path, cpopath + 'pecrh', i, obj)
		self.pnbi.getTimedElt(path, cpopath + 'pnbi', i, obj)
		self.ip.getTimedElt(path, cpopath + 'ip', i, obj)
		self.bvac_r.getTimedElt(path, cpopath + 'bvac_r', i, obj)
		self.zeffl.getTimedElt(path, cpopath + 'zeffl', i, obj)
		self.nbar.getTimedElt(path, cpopath + 'nbar', i, obj)
		self.xecrh.getTimedElt(path, cpopath + 'xecrh', i, obj)
		self.pol_flux.getTimedElt(path, cpopath + 'pol_flux', i, obj)
		self.enhancement.getTimedElt(path, cpopath + 'enhancement', i, obj)
		self.isotopic.getTimedElt(path, cpopath + 'isotopic', i, obj)
		self.nbi_td_ratio.getTimedElt(path, cpopath + 'nbi_td_ratio', i, obj)
		self.gas_puff.getTimedElt(path, cpopath + 'gas_puff', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type referencesstructurescenario_referencesObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.plh.putNonTimedElt(path, cpopath + 'plh', i, obj)
		obj = self.picrh.putNonTimedElt(path, cpopath + 'picrh', i, obj)
		obj = self.pecrh.putNonTimedElt(path, cpopath + 'pecrh', i, obj)
		obj = self.pnbi.putNonTimedElt(path, cpopath + 'pnbi', i, obj)
		obj = self.ip.putNonTimedElt(path, cpopath + 'ip', i, obj)
		obj = self.bvac_r.putNonTimedElt(path, cpopath + 'bvac_r', i, obj)
		obj = self.zeffl.putNonTimedElt(path, cpopath + 'zeffl', i, obj)
		obj = self.nbar.putNonTimedElt(path, cpopath + 'nbar', i, obj)
		obj = self.xecrh.putNonTimedElt(path, cpopath + 'xecrh', i, obj)
		obj = self.pol_flux.putNonTimedElt(path, cpopath + 'pol_flux', i, obj)
		obj = self.enhancement.putNonTimedElt(path, cpopath + 'enhancement', i, obj)
		obj = self.isotopic.putNonTimedElt(path, cpopath + 'isotopic', i, obj)
		obj = self.nbi_td_ratio.putNonTimedElt(path, cpopath + 'nbi_td_ratio', i, obj)
		obj = self.gas_puff.putNonTimedElt(path, cpopath + 'gas_puff', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type referencesstructurescenario_referencesObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.plh.getNonTimedElt(path, cpopath + 'plh', i, obj)
		self.picrh.getNonTimedElt(path, cpopath + 'picrh', i, obj)
		self.pecrh.getNonTimedElt(path, cpopath + 'pecrh', i, obj)
		self.pnbi.getNonTimedElt(path, cpopath + 'pnbi', i, obj)
		self.ip.getNonTimedElt(path, cpopath + 'ip', i, obj)
		self.bvac_r.getNonTimedElt(path, cpopath + 'bvac_r', i, obj)
		self.zeffl.getNonTimedElt(path, cpopath + 'zeffl', i, obj)
		self.nbar.getNonTimedElt(path, cpopath + 'nbar', i, obj)
		self.xecrh.getNonTimedElt(path, cpopath + 'xecrh', i, obj)
		self.pol_flux.getNonTimedElt(path, cpopath + 'pol_flux', i, obj)
		self.enhancement.getNonTimedElt(path, cpopath + 'enhancement', i, obj)
		self.isotopic.getNonTimedElt(path, cpopath + 'isotopic', i, obj)
		self.nbi_td_ratio.getNonTimedElt(path, cpopath + 'nbi_td_ratio', i, obj)
		self.gas_puff.getNonTimedElt(path, cpopath + 'gas_puff', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.plh.deleteData(path, cpopath)
		self.picrh.deleteData(path, cpopath)
		self.pecrh.deleteData(path, cpopath)
		self.pnbi.deleteData(path, cpopath)
		self.ip.deleteData(path, cpopath)
		self.bvac_r.deleteData(path, cpopath)
		self.zeffl.deleteData(path, cpopath)
		self.nbar.deleteData(path, cpopath)
		self.xecrh.deleteData(path, cpopath)
		self.pol_flux.deleteData(path, cpopath)
		self.enhancement.deleteData(path, cpopath)
		self.isotopic.deleteData(path, cpopath)
		self.nbi_td_ratio.deleteData(path, cpopath)
		self.gas_puff.deleteData(path, cpopath)


class bvac_rstructurescenario_ref:
	'''
	class bvac_rstructurescenario_ref
	Vacuum field times radius in the toroidal field magnet [T.m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='bvac_r'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class bvac_rstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type bvac_rstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type bvac_rstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type bvac_rstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type bvac_rstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type bvac_rstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = bvac_rstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type bvac_rstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type bvac_rstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type bvac_rstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type bvac_rstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class zefflstructurescenario_ref:
	'''
	class zefflstructurescenario_ref
	line averaged effective charge []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='zeffl'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class zefflstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zefflstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zefflstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zefflstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type zefflstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type zefflstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = zefflstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zefflstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zefflstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zefflstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zefflstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class nbarstructurescenario_ref:
	'''
	class nbarstructurescenario_ref
	line averaged electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='nbar'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class nbarstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type nbarstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type nbarstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type nbarstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type nbarstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type nbarstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = nbarstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbarstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbarstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbarstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbarstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class xecrhstructurescenario_ref:
	'''
	class xecrhstructurescenario_ref
	position of maximum  (normalized rho coordinate) of electron cyclotron resonnance heating power []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='xecrh'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class xecrhstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type xecrhstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type xecrhstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type xecrhstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type xecrhstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type xecrhstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = xecrhstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xecrhstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xecrhstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xecrhstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type xecrhstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pol_fluxstructurescenario_ref:
	'''
	class pol_fluxstructurescenario_ref
	separatrix poloidal flux [Wb]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pol_flux'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pol_fluxstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pol_fluxstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pol_fluxstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pol_fluxstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pol_fluxstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pol_fluxstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pol_fluxstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pol_fluxstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pol_fluxstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pol_fluxstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pol_fluxstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class enhancementstructurescenario_ref:
	'''
	class enhancementstructurescenario_ref
	energy enhancement factor []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='enhancement'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class enhancementstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type enhancementstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type enhancementstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type enhancementstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type enhancementstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type enhancementstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = enhancementstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enhancementstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enhancementstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enhancementstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type enhancementstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class isotopicstructurescenario_ref:
	'''
	class isotopicstructurescenario_ref
	ratio between tritium  and deuterium density (for burning plasma)  []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='isotopic'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class isotopicstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type isotopicstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type isotopicstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type isotopicstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type isotopicstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type isotopicstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = isotopicstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type isotopicstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type isotopicstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type isotopicstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type isotopicstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class nbi_td_ratiostructurescenario_ref:
	'''
	class nbi_td_ratiostructurescenario_ref
	ratio between tritium  and deuterium power in neutral beam injection  []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='nbi_td_ratio'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class nbi_td_ratiostructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type nbi_td_ratiostructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type nbi_td_ratiostructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type nbi_td_ratiostructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type nbi_td_ratiostructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type nbi_td_ratiostructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = nbi_td_ratiostructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbi_td_ratiostructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbi_td_ratiostructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbi_td_ratiostructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type nbi_td_ratiostructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class reactorstructurescenario_reactor:
	'''
	class reactorstructurescenario_reactor
	reactor data (such as electricity cost ...)

	Attributes:
	- pnetwork : float
	   reactor electric power provide to the network [W].
	'''

	def __init__(self, base_path_in='reactor'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.pnetwork = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class reactorstructurescenario_reactor\n'
		ret = ret + space + 'Attribute pnetwork: ' + str(self.pnetwork) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type reactorstructurescenario_reactor, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type reactorstructurescenario_reactor, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type reactorstructurescenario_reactor, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDouble(self.idx, path, cpopath + 'pnetwork', self.pnetwork)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type reactorstructurescenario_reactor, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_pnetwork = ull.getDouble(self.idx, path, cpopath + 'pnetwork')
		check_status(status)
		if not status:
			self.pnetwork = ret_pnetwork

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type reactorstructurescenario_reactor, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, pnetworkVal = ull.getDouble(self.idx, path, cpopath + 'pnetwork')
			check_status(status)
			for i in range(nbslice):
				slice = reactorstructurescenario_reactor(self.base_path)
				slice.setExpIdx(self.idx)
				slice.pnetwork = pnetworkVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type reactorstructurescenario_reactorObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type reactorstructurescenario_reactorObj, run function getTimedElt') 
		cpopath = cpopath + '/' 

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type reactorstructurescenario_reactorObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'pnetwork') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'pnetwork', i, self.pnetwork)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type reactorstructurescenario_reactorObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'pnetwork') 
			print ('obj = ' + str(obj))
		status, ret_pnetwork = ull.getDoubleFromObject(self.idx, obj, cpopath + 'pnetwork', i)
		check_status(status)
		if not status:
			self.pnetwork = ret_pnetwork

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'pnetwork')


class solstructurescenario_sol:
	'''
	class solstructurescenario_sol
	SOL characteristic  (@ LCMS)

	Attributes:
	- l_te_sol : class l_te_solstructurescenario_ref
	   electron temperature radial decay length [m]. Time-dependent.
	- l_ti_sol : class l_ti_solstructurescenario_ref
	   ion temperature  radial decay length [m]. Time-dependent.
	- l_ne_sol : class l_ne_solstructurescenario_ref
	   electron density radial decay length [m]. Time-dependent.
	- l_ni_sol : class l_ni_solstructurescenario_ref
	   ion density  radial decay length [m]. Time-dependent.
	- l_qe_sol : class l_qe_solstructurescenario_ref
	   electron heat flux radial decay length [m]. Time-dependent.
	- l_qi_sol : class l_qi_solstructurescenario_ref
	   ion  heat flux radial decay length [m]. Time-dependent.
	- p_rad_sol : class p_rad_solstructurescenario_ref
	   radiative power of the SOL [W]. Time-dependent.
	- p_neut : float
	   Neutral pressure of the SOL [Pa]; Scalar
	- gas_puff : class gas_puffstructurescenario_ref
	   gas puff flux for each ion species [s^-1]. Time-dependent.
	- delta_r_in : float
	   Inner gap between the plasma and the first wall [m]; Scalar
	- delta_r_out : float
	   Outer gap between the plasma and the first wall [m]; Scalar
	- r_in : float
	   Inner radius of the first wall [m]; Scalar
	- r_out : float
	   Outer radius of the first wall [m]; Scalar
	- sol_width : float
	   Width of the SOL (the heat flux is assumed to fall off exponentially in the SOL according to the width parameter) [m]; Scalar
	'''

	def __init__(self, base_path_in='sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.l_te_sol = l_te_solstructurescenario_ref('l_te_sol')
		self.l_ti_sol = l_ti_solstructurescenario_ref('l_ti_sol')
		self.l_ne_sol = l_ne_solstructurescenario_ref('l_ne_sol')
		self.l_ni_sol = l_ni_solstructurescenario_ref('l_ni_sol')
		self.l_qe_sol = l_qe_solstructurescenario_ref('l_qe_sol')
		self.l_qi_sol = l_qi_solstructurescenario_ref('l_qi_sol')
		self.p_rad_sol = p_rad_solstructurescenario_ref('p_rad_sol')
		self.p_neut = EMPTY_DOUBLE
		self.gas_puff = gas_puffstructurescenario_ref('gas_puff')
		self.delta_r_in = EMPTY_DOUBLE
		self.delta_r_out = EMPTY_DOUBLE
		self.r_in = EMPTY_DOUBLE
		self.r_out = EMPTY_DOUBLE
		self.sol_width = EMPTY_DOUBLE

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class solstructurescenario_sol\n'
		ret = ret + space + 'Attribute l_te_sol\n ' + self.l_te_sol.__str__(depth+1)
		ret = ret + space + 'Attribute l_ti_sol\n ' + self.l_ti_sol.__str__(depth+1)
		ret = ret + space + 'Attribute l_ne_sol\n ' + self.l_ne_sol.__str__(depth+1)
		ret = ret + space + 'Attribute l_ni_sol\n ' + self.l_ni_sol.__str__(depth+1)
		ret = ret + space + 'Attribute l_qe_sol\n ' + self.l_qe_sol.__str__(depth+1)
		ret = ret + space + 'Attribute l_qi_sol\n ' + self.l_qi_sol.__str__(depth+1)
		ret = ret + space + 'Attribute p_rad_sol\n ' + self.p_rad_sol.__str__(depth+1)
		ret = ret + space + 'Attribute p_neut: ' + str(self.p_neut) + '\n'
		ret = ret + space + 'Attribute gas_puff\n ' + self.gas_puff.__str__(depth+1)
		ret = ret + space + 'Attribute delta_r_in: ' + str(self.delta_r_in) + '\n'
		ret = ret + space + 'Attribute delta_r_out: ' + str(self.delta_r_out) + '\n'
		ret = ret + space + 'Attribute r_in: ' + str(self.r_in) + '\n'
		ret = ret + space + 'Attribute r_out: ' + str(self.r_out) + '\n'
		ret = ret + space + 'Attribute sol_width: ' + str(self.sol_width) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.l_te_sol.setExpIdx(idx)
		self.l_ti_sol.setExpIdx(idx)
		self.l_ne_sol.setExpIdx(idx)
		self.l_ni_sol.setExpIdx(idx)
		self.l_qe_sol.setExpIdx(idx)
		self.l_qi_sol.setExpIdx(idx)
		self.p_rad_sol.setExpIdx(idx)
		self.gas_puff.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type solstructurescenario_sol, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.l_te_sol.cpoTime = self.cpoTime
		self.l_te_sol.putSlice(path, cpopath)
		self.l_ti_sol.cpoTime = self.cpoTime
		self.l_ti_sol.putSlice(path, cpopath)
		self.l_ne_sol.cpoTime = self.cpoTime
		self.l_ne_sol.putSlice(path, cpopath)
		self.l_ni_sol.cpoTime = self.cpoTime
		self.l_ni_sol.putSlice(path, cpopath)
		self.l_qe_sol.cpoTime = self.cpoTime
		self.l_qe_sol.putSlice(path, cpopath)
		self.l_qi_sol.cpoTime = self.cpoTime
		self.l_qi_sol.putSlice(path, cpopath)
		self.p_rad_sol.cpoTime = self.cpoTime
		self.p_rad_sol.putSlice(path, cpopath)
		self.gas_puff.cpoTime = self.cpoTime
		self.gas_puff.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type solstructurescenario_sol, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.l_te_sol.replaceLastSlice(path, cpopath)
		self.l_ti_sol.replaceLastSlice(path, cpopath)
		self.l_ne_sol.replaceLastSlice(path, cpopath)
		self.l_ni_sol.replaceLastSlice(path, cpopath)
		self.l_qe_sol.replaceLastSlice(path, cpopath)
		self.l_qi_sol.replaceLastSlice(path, cpopath)
		self.p_rad_sol.replaceLastSlice(path, cpopath)
		self.gas_puff.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type solstructurescenario_sol, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.l_te_sol.putNonTimed(path, cpopath)
		self.l_ti_sol.putNonTimed(path, cpopath)
		self.l_ne_sol.putNonTimed(path, cpopath)
		self.l_ni_sol.putNonTimed(path, cpopath)
		self.l_qe_sol.putNonTimed(path, cpopath)
		self.l_qi_sol.putNonTimed(path, cpopath)
		self.p_rad_sol.putNonTimed(path, cpopath)
		status = ull.putDouble(self.idx, path, cpopath + 'p_neut', self.p_neut)
		check_status(status)
		self.gas_puff.putNonTimed(path, cpopath)
		status = ull.putDouble(self.idx, path, cpopath + 'delta_r_in', self.delta_r_in)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'delta_r_out', self.delta_r_out)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'r_in', self.r_in)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'r_out', self.r_out)
		check_status(status)
		status = ull.putDouble(self.idx, path, cpopath + 'sol_width', self.sol_width)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type solstructurescenario_sol, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.l_te_sol.getSlice(path, cpopath, inTime, interpolMode)
		self.l_ti_sol.getSlice(path, cpopath, inTime, interpolMode)
		self.l_ne_sol.getSlice(path, cpopath, inTime, interpolMode)
		self.l_ni_sol.getSlice(path, cpopath, inTime, interpolMode)
		self.l_qe_sol.getSlice(path, cpopath, inTime, interpolMode)
		self.l_qi_sol.getSlice(path, cpopath, inTime, interpolMode)
		self.p_rad_sol.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_p_neut = ull.getDouble(self.idx, path, cpopath + 'p_neut')
		check_status(status)
		if not status:
			self.p_neut = ret_p_neut
		self.gas_puff.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_delta_r_in = ull.getDouble(self.idx, path, cpopath + 'delta_r_in')
		check_status(status)
		if not status:
			self.delta_r_in = ret_delta_r_in
		status, ret_delta_r_out = ull.getDouble(self.idx, path, cpopath + 'delta_r_out')
		check_status(status)
		if not status:
			self.delta_r_out = ret_delta_r_out
		status, ret_r_in = ull.getDouble(self.idx, path, cpopath + 'r_in')
		check_status(status)
		if not status:
			self.r_in = ret_r_in
		status, ret_r_out = ull.getDouble(self.idx, path, cpopath + 'r_out')
		check_status(status)
		if not status:
			self.r_out = ret_r_out
		status, ret_sol_width = ull.getDouble(self.idx, path, cpopath + 'sol_width')
		check_status(status)
		if not status:
			self.sol_width = ret_sol_width

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type solstructurescenario_sol, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			l_te_solList = self.l_te_sol.build_non_resampled_data(path, cpopath, nbslice)
			l_ti_solList = self.l_ti_sol.build_non_resampled_data(path, cpopath, nbslice)
			l_ne_solList = self.l_ne_sol.build_non_resampled_data(path, cpopath, nbslice)
			l_ni_solList = self.l_ni_sol.build_non_resampled_data(path, cpopath, nbslice)
			l_qe_solList = self.l_qe_sol.build_non_resampled_data(path, cpopath, nbslice)
			l_qi_solList = self.l_qi_sol.build_non_resampled_data(path, cpopath, nbslice)
			p_rad_solList = self.p_rad_sol.build_non_resampled_data(path, cpopath, nbslice)
			status, p_neutVal = ull.getDouble(self.idx, path, cpopath + 'p_neut')
			check_status(status)
			gas_puffList = self.gas_puff.build_non_resampled_data(path, cpopath, nbslice)
			status, delta_r_inVal = ull.getDouble(self.idx, path, cpopath + 'delta_r_in')
			check_status(status)
			status, delta_r_outVal = ull.getDouble(self.idx, path, cpopath + 'delta_r_out')
			check_status(status)
			status, r_inVal = ull.getDouble(self.idx, path, cpopath + 'r_in')
			check_status(status)
			status, r_outVal = ull.getDouble(self.idx, path, cpopath + 'r_out')
			check_status(status)
			status, sol_widthVal = ull.getDouble(self.idx, path, cpopath + 'sol_width')
			check_status(status)
			for i in range(nbslice):
				slice = solstructurescenario_sol(self.base_path)
				slice.setExpIdx(self.idx)
				slice.l_te_sol = l_te_solList[i]
				slice.l_ti_sol = l_ti_solList[i]
				slice.l_ne_sol = l_ne_solList[i]
				slice.l_ni_sol = l_ni_solList[i]
				slice.l_qe_sol = l_qe_solList[i]
				slice.l_qi_sol = l_qi_solList[i]
				slice.p_rad_sol = p_rad_solList[i]
				slice.p_neut = p_neutVal
				slice.gas_puff = gas_puffList[i]
				slice.delta_r_in = delta_r_inVal
				slice.delta_r_out = delta_r_outVal
				slice.r_in = r_inVal
				slice.r_out = r_outVal
				slice.sol_width = sol_widthVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type solstructurescenario_solObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.l_te_sol.putTimedElt(path, cpopath + 'l_te_sol', i, obj)
		obj = self.l_ti_sol.putTimedElt(path, cpopath + 'l_ti_sol', i, obj)
		obj = self.l_ne_sol.putTimedElt(path, cpopath + 'l_ne_sol', i, obj)
		obj = self.l_ni_sol.putTimedElt(path, cpopath + 'l_ni_sol', i, obj)
		obj = self.l_qe_sol.putTimedElt(path, cpopath + 'l_qe_sol', i, obj)
		obj = self.l_qi_sol.putTimedElt(path, cpopath + 'l_qi_sol', i, obj)
		obj = self.p_rad_sol.putTimedElt(path, cpopath + 'p_rad_sol', i, obj)
		obj = self.gas_puff.putTimedElt(path, cpopath + 'gas_puff', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type solstructurescenario_solObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.l_te_sol.getTimedElt(path, cpopath + 'l_te_sol', i, obj)
		self.l_ti_sol.getTimedElt(path, cpopath + 'l_ti_sol', i, obj)
		self.l_ne_sol.getTimedElt(path, cpopath + 'l_ne_sol', i, obj)
		self.l_ni_sol.getTimedElt(path, cpopath + 'l_ni_sol', i, obj)
		self.l_qe_sol.getTimedElt(path, cpopath + 'l_qe_sol', i, obj)
		self.l_qi_sol.getTimedElt(path, cpopath + 'l_qi_sol', i, obj)
		self.p_rad_sol.getTimedElt(path, cpopath + 'p_rad_sol', i, obj)
		self.gas_puff.getTimedElt(path, cpopath + 'gas_puff', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type solstructurescenario_solObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.l_te_sol.putNonTimedElt(path, cpopath + 'l_te_sol', i, obj)
		obj = self.l_ti_sol.putNonTimedElt(path, cpopath + 'l_ti_sol', i, obj)
		obj = self.l_ne_sol.putNonTimedElt(path, cpopath + 'l_ne_sol', i, obj)
		obj = self.l_ni_sol.putNonTimedElt(path, cpopath + 'l_ni_sol', i, obj)
		obj = self.l_qe_sol.putNonTimedElt(path, cpopath + 'l_qe_sol', i, obj)
		obj = self.l_qi_sol.putNonTimedElt(path, cpopath + 'l_qi_sol', i, obj)
		obj = self.p_rad_sol.putNonTimedElt(path, cpopath + 'p_rad_sol', i, obj)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'p_neut') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'p_neut', i, self.p_neut)
		obj = self.gas_puff.putNonTimedElt(path, cpopath + 'gas_puff', i, obj)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'delta_r_in') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'delta_r_in', i, self.delta_r_in)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'delta_r_out') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'delta_r_out', i, self.delta_r_out)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r_in') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r_in', i, self.r_in)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'r_out') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'r_out', i, self.r_out)
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'sol_width') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'sol_width', i, self.sol_width)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type solstructurescenario_solObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.l_te_sol.getNonTimedElt(path, cpopath + 'l_te_sol', i, obj)
		self.l_ti_sol.getNonTimedElt(path, cpopath + 'l_ti_sol', i, obj)
		self.l_ne_sol.getNonTimedElt(path, cpopath + 'l_ne_sol', i, obj)
		self.l_ni_sol.getNonTimedElt(path, cpopath + 'l_ni_sol', i, obj)
		self.l_qe_sol.getNonTimedElt(path, cpopath + 'l_qe_sol', i, obj)
		self.l_qi_sol.getNonTimedElt(path, cpopath + 'l_qi_sol', i, obj)
		self.p_rad_sol.getNonTimedElt(path, cpopath + 'p_rad_sol', i, obj)
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'p_neut') 
			print ('obj = ' + str(obj))
		status, ret_p_neut = ull.getDoubleFromObject(self.idx, obj, cpopath + 'p_neut', i)
		check_status(status)
		if not status:
			self.p_neut = ret_p_neut
		self.gas_puff.getNonTimedElt(path, cpopath + 'gas_puff', i, obj)
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'delta_r_in') 
			print ('obj = ' + str(obj))
		status, ret_delta_r_in = ull.getDoubleFromObject(self.idx, obj, cpopath + 'delta_r_in', i)
		check_status(status)
		if not status:
			self.delta_r_in = ret_delta_r_in
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'delta_r_out') 
			print ('obj = ' + str(obj))
		status, ret_delta_r_out = ull.getDoubleFromObject(self.idx, obj, cpopath + 'delta_r_out', i)
		check_status(status)
		if not status:
			self.delta_r_out = ret_delta_r_out
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r_in') 
			print ('obj = ' + str(obj))
		status, ret_r_in = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r_in', i)
		check_status(status)
		if not status:
			self.r_in = ret_r_in
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'r_out') 
			print ('obj = ' + str(obj))
		status, ret_r_out = ull.getDoubleFromObject(self.idx, obj, cpopath + 'r_out', i)
		check_status(status)
		if not status:
			self.r_out = ret_r_out
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'sol_width') 
			print ('obj = ' + str(obj))
		status, ret_sol_width = ull.getDoubleFromObject(self.idx, obj, cpopath + 'sol_width', i)
		check_status(status)
		if not status:
			self.sol_width = ret_sol_width

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.l_te_sol.deleteData(path, cpopath)
		self.l_ti_sol.deleteData(path, cpopath)
		self.l_ne_sol.deleteData(path, cpopath)
		self.l_ni_sol.deleteData(path, cpopath)
		self.l_qe_sol.deleteData(path, cpopath)
		self.l_qi_sol.deleteData(path, cpopath)
		self.p_rad_sol.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'p_neut')
		self.gas_puff.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'delta_r_in')
		ull.deleteData(self.idx, path, cpopath + 'delta_r_out')
		ull.deleteData(self.idx, path, cpopath + 'r_in')
		ull.deleteData(self.idx, path, cpopath + 'r_out')
		ull.deleteData(self.idx, path, cpopath + 'sol_width')


class l_te_solstructurescenario_ref:
	'''
	class l_te_solstructurescenario_ref
	electron temperature radial decay length [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='l_te_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class l_te_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_te_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_te_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_te_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type l_te_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type l_te_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = l_te_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_te_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_te_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_te_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_te_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class l_ti_solstructurescenario_ref:
	'''
	class l_ti_solstructurescenario_ref
	ion temperature  radial decay length [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='l_ti_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class l_ti_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ti_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ti_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ti_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type l_ti_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type l_ti_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = l_ti_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ti_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ti_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ti_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ti_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class l_ne_solstructurescenario_ref:
	'''
	class l_ne_solstructurescenario_ref
	electron density radial decay length [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='l_ne_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class l_ne_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ne_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ne_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ne_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type l_ne_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type l_ne_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = l_ne_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ne_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ne_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ne_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ne_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class l_ni_solstructurescenario_ref:
	'''
	class l_ni_solstructurescenario_ref
	ion density  radial decay length [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='l_ni_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class l_ni_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ni_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ni_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_ni_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type l_ni_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type l_ni_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = l_ni_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ni_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ni_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ni_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_ni_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class l_qe_solstructurescenario_ref:
	'''
	class l_qe_solstructurescenario_ref
	electron heat flux radial decay length [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='l_qe_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class l_qe_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_qe_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_qe_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_qe_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type l_qe_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type l_qe_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = l_qe_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qe_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qe_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qe_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qe_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class l_qi_solstructurescenario_ref:
	'''
	class l_qi_solstructurescenario_ref
	ion  heat flux radial decay length [m]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='l_qi_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class l_qi_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_qi_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_qi_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type l_qi_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type l_qi_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type l_qi_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = l_qi_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qi_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qi_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qi_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type l_qi_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class p_rad_solstructurescenario_ref:
	'''
	class p_rad_solstructurescenario_ref
	radiative power of the SOL [W]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='p_rad_sol'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class p_rad_solstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_solstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_solstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_solstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_solstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type p_rad_solstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = p_rad_solstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_solstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_solstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_solstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type p_rad_solstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class vol_avestructurescenario_vol_ave:
	'''
	class vol_avestructurescenario_vol_ave
	volume averaged value

	Attributes:
	- te_ave : class te_avestructurescenario_ref
	   volume averaged electron temperature [eV]. Time-dependent.
	- ti_ave : class ti_avestructurescenario_ref
	   volume averaged ion temperature [eV]. Time-dependent.
	- ne_ave : class ne_avestructurescenario_ref
	   volume averaged electron density [m^-3]. Time-dependent.
	- dne_ave_dt : class dne_ave_dtstructurescenario_ref
	   time derivative of volume averaged electron density [m^-3/s]. Time-dependent.
	- ni_ave : class ni_avestructurescenario_ref
	   volume averaged ion density (<sum(n_k)>, k in species) [m^-3]. Time-dependent.
	- zeff_ave : class zeff_avestructurescenario_ref
	   volume averaged effective charge. Time-dependent.
	- ti_o_te_ave : class ti_o_te_avestructurescenario_ref
	   volume averaged ion temperature over electron temperature  (<Ti/Te>) []. Time-dependent.
	- meff_ave : class meff_avestructurescenario_ref
	   volume averaged effectice mass  (<sum(n_k * m_k)  > /  < sum(n_k)> ) []. Time-dependent.
	- pellet_flux : class pellet_fluxstructurescenario_ref
	   number of electrons fuelling  the plasma every second coming from pellet injection [s^-1]. Time-dependent.
	- nions_ave : numpy.ndarray 1D with float
	   volume averaged ions densities (vector, one element per ion species) [m^-3]. Time-dependent.
	- omega_ave : class omega_avestructurescenario_ref
	   bulk volume average toroidal rotation velocity (whole plasma) [rad/s]. Time-dependent.
	'''

	def __init__(self, base_path_in='vol_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.te_ave = te_avestructurescenario_ref('te_ave')
		self.ti_ave = ti_avestructurescenario_ref('ti_ave')
		self.ne_ave = ne_avestructurescenario_ref('ne_ave')
		self.dne_ave_dt = dne_ave_dtstructurescenario_ref('dne_ave_dt')
		self.ni_ave = ni_avestructurescenario_ref('ni_ave')
		self.zeff_ave = zeff_avestructurescenario_ref('zeff_ave')
		self.ti_o_te_ave = ti_o_te_avestructurescenario_ref('ti_o_te_ave')
		self.meff_ave = meff_avestructurescenario_ref('meff_ave')
		self.pellet_flux = pellet_fluxstructurescenario_ref('pellet_flux')
		self.nions_ave = numpy.zeros(0, numpy.float64, order='C')
		self.omega_ave = omega_avestructurescenario_ref('omega_ave')

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class vol_avestructurescenario_vol_ave\n'
		ret = ret + space + 'Attribute te_ave\n ' + self.te_ave.__str__(depth+1)
		ret = ret + space + 'Attribute ti_ave\n ' + self.ti_ave.__str__(depth+1)
		ret = ret + space + 'Attribute ne_ave\n ' + self.ne_ave.__str__(depth+1)
		ret = ret + space + 'Attribute dne_ave_dt\n ' + self.dne_ave_dt.__str__(depth+1)
		ret = ret + space + 'Attribute ni_ave\n ' + self.ni_ave.__str__(depth+1)
		ret = ret + space + 'Attribute zeff_ave\n ' + self.zeff_ave.__str__(depth+1)
		ret = ret + space + 'Attribute ti_o_te_ave\n ' + self.ti_o_te_ave.__str__(depth+1)
		ret = ret + space + 'Attribute meff_ave\n ' + self.meff_ave.__str__(depth+1)
		ret = ret + space + 'Attribute pellet_flux\n ' + self.pellet_flux.__str__(depth+1)
		s = self.nions_ave.__str__()
		ret = ret + space + 'Attribute nions_ave\n' + space + s.replace('\n', '\n'+space) + '\n'
		ret = ret + space + 'Attribute omega_ave\n ' + self.omega_ave.__str__(depth+1)
		return ret

	def setExpIdx(self, idx):
		self.idx = idx
		self.te_ave.setExpIdx(idx)
		self.ti_ave.setExpIdx(idx)
		self.ne_ave.setExpIdx(idx)
		self.dne_ave_dt.setExpIdx(idx)
		self.ni_ave.setExpIdx(idx)
		self.zeff_ave.setExpIdx(idx)
		self.ti_o_te_ave.setExpIdx(idx)
		self.meff_ave.setExpIdx(idx)
		self.pellet_flux.setExpIdx(idx)
		self.omega_ave.setExpIdx(idx)

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vol_avestructurescenario_vol_ave, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ave.cpoTime = self.cpoTime
		self.te_ave.putSlice(path, cpopath)
		self.ti_ave.cpoTime = self.cpoTime
		self.ti_ave.putSlice(path, cpopath)
		self.ne_ave.cpoTime = self.cpoTime
		self.ne_ave.putSlice(path, cpopath)
		self.dne_ave_dt.cpoTime = self.cpoTime
		self.dne_ave_dt.putSlice(path, cpopath)
		self.ni_ave.cpoTime = self.cpoTime
		self.ni_ave.putSlice(path, cpopath)
		self.zeff_ave.cpoTime = self.cpoTime
		self.zeff_ave.putSlice(path, cpopath)
		self.ti_o_te_ave.cpoTime = self.cpoTime
		self.ti_o_te_ave.putSlice(path, cpopath)
		self.meff_ave.cpoTime = self.cpoTime
		self.meff_ave.putSlice(path, cpopath)
		self.pellet_flux.cpoTime = self.cpoTime
		self.pellet_flux.putSlice(path, cpopath)
		status = ull.putVect1DDoubleSlice(self.idx, path, cpopath + 'nions_ave', numpy.array(self.nions_ave).astype(numpy.float64), self.cpoTime)
		check_status(status)
		self.omega_ave.cpoTime = self.cpoTime
		self.omega_ave.putSlice(path, cpopath)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vol_avestructurescenario_vol_ave, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ave.replaceLastSlice(path, cpopath)
		self.ti_ave.replaceLastSlice(path, cpopath)
		self.ne_ave.replaceLastSlice(path, cpopath)
		self.dne_ave_dt.replaceLastSlice(path, cpopath)
		self.ni_ave.replaceLastSlice(path, cpopath)
		self.zeff_ave.replaceLastSlice(path, cpopath)
		self.ti_o_te_ave.replaceLastSlice(path, cpopath)
		self.meff_ave.replaceLastSlice(path, cpopath)
		self.pellet_flux.replaceLastSlice(path, cpopath)
		status = ull.replaceLastVect1DDoubleSlice(self.idx, path, cpopath + 'nions_ave', numpy.array(self.nions_ave).astype(numpy.float64))
		check_status(status)
		self.omega_ave.replaceLastSlice(path, cpopath)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type vol_avestructurescenario_vol_ave, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ave.putNonTimed(path, cpopath)
		self.ti_ave.putNonTimed(path, cpopath)
		self.ne_ave.putNonTimed(path, cpopath)
		self.dne_ave_dt.putNonTimed(path, cpopath)
		self.ni_ave.putNonTimed(path, cpopath)
		self.zeff_ave.putNonTimed(path, cpopath)
		self.ti_o_te_ave.putNonTimed(path, cpopath)
		self.meff_ave.putNonTimed(path, cpopath)
		self.pellet_flux.putNonTimed(path, cpopath)
		self.omega_ave.putNonTimed(path, cpopath)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type vol_avestructurescenario_vol_ave, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.ne_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.dne_ave_dt.getSlice(path, cpopath, inTime, interpolMode)
		self.ni_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.zeff_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.ti_o_te_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.meff_ave.getSlice(path, cpopath, inTime, interpolMode)
		self.pellet_flux.getSlice(path, cpopath, inTime, interpolMode)
		status, ret_nions_ave, retTime = ull.getVect1DDoubleSlice(self.idx, path, cpopath + 'nions_ave', inTime, interpolMode)
		check_status(status)
		if not status:
			self.nions_ave = ret_nions_ave
			self.cpoTime = retTime
		self.omega_ave.getSlice(path, cpopath, inTime, interpolMode)

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type vol_avestructurescenario_vol_ave, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			te_aveList = self.te_ave.build_non_resampled_data(path, cpopath, nbslice)
			ti_aveList = self.ti_ave.build_non_resampled_data(path, cpopath, nbslice)
			ne_aveList = self.ne_ave.build_non_resampled_data(path, cpopath, nbslice)
			dne_ave_dtList = self.dne_ave_dt.build_non_resampled_data(path, cpopath, nbslice)
			ni_aveList = self.ni_ave.build_non_resampled_data(path, cpopath, nbslice)
			zeff_aveList = self.zeff_ave.build_non_resampled_data(path, cpopath, nbslice)
			ti_o_te_aveList = self.ti_o_te_ave.build_non_resampled_data(path, cpopath, nbslice)
			meff_aveList = self.meff_ave.build_non_resampled_data(path, cpopath, nbslice)
			pellet_fluxList = self.pellet_flux.build_non_resampled_data(path, cpopath, nbslice)
			status, nions_aveList = ull.getVect2DDouble(self.idx, path, cpopath + 'nions_ave')
			if len(nions_aveList) == 0:
				nions_aveList = numpy.resize(nions_aveList, (0,nbslice))
			check_status(status)
			omega_aveList = self.omega_ave.build_non_resampled_data(path, cpopath, nbslice)
			for i in range(nbslice):
				slice = vol_avestructurescenario_vol_ave(self.base_path)
				slice.setExpIdx(self.idx)
				slice.te_ave = te_aveList[i]
				slice.ti_ave = ti_aveList[i]
				slice.ne_ave = ne_aveList[i]
				slice.dne_ave_dt = dne_ave_dtList[i]
				slice.ni_ave = ni_aveList[i]
				slice.zeff_ave = zeff_aveList[i]
				slice.ti_o_te_ave = ti_o_te_aveList[i]
				slice.meff_ave = meff_aveList[i]
				slice.pellet_flux = pellet_fluxList[i]
				slice.nions_ave = nions_aveList[:,i]
				slice.omega_ave = omega_aveList[i]
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vol_avestructurescenario_vol_aveObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_ave.putTimedElt(path, cpopath + 'te_ave', i, obj)
		obj = self.ti_ave.putTimedElt(path, cpopath + 'ti_ave', i, obj)
		obj = self.ne_ave.putTimedElt(path, cpopath + 'ne_ave', i, obj)
		obj = self.dne_ave_dt.putTimedElt(path, cpopath + 'dne_ave_dt', i, obj)
		obj = self.ni_ave.putTimedElt(path, cpopath + 'ni_ave', i, obj)
		obj = self.zeff_ave.putTimedElt(path, cpopath + 'zeff_ave', i, obj)
		obj = self.ti_o_te_ave.putTimedElt(path, cpopath + 'ti_o_te_ave', i, obj)
		obj = self.meff_ave.putTimedElt(path, cpopath + 'meff_ave', i, obj)
		obj = self.pellet_flux.putTimedElt(path, cpopath + 'pellet_flux', i, obj)
		if (dev()):
			print ('putVect1DDoubleInObject : ' + cpopath + 'nions_ave') 
			print ('obj = ' + str(obj))
		obj = ull.putVect1DDoubleInObject(self.idx, obj, cpopath + 'nions_ave', i, numpy.array(self.nions_ave).astype(numpy.float64))
		obj = self.omega_ave.putTimedElt(path, cpopath + 'omega_ave', i, obj)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vol_avestructurescenario_vol_aveObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		self.te_ave.getTimedElt(path, cpopath + 'te_ave', i, obj)
		self.ti_ave.getTimedElt(path, cpopath + 'ti_ave', i, obj)
		self.ne_ave.getTimedElt(path, cpopath + 'ne_ave', i, obj)
		self.dne_ave_dt.getTimedElt(path, cpopath + 'dne_ave_dt', i, obj)
		self.ni_ave.getTimedElt(path, cpopath + 'ni_ave', i, obj)
		self.zeff_ave.getTimedElt(path, cpopath + 'zeff_ave', i, obj)
		self.ti_o_te_ave.getTimedElt(path, cpopath + 'ti_o_te_ave', i, obj)
		self.meff_ave.getTimedElt(path, cpopath + 'meff_ave', i, obj)
		self.pellet_flux.getTimedElt(path, cpopath + 'pellet_flux', i, obj)
		if (dev()):
			print ('getVect1DDoubleInObject : ' + cpopath + 'nions_ave') 
			print ('obj = ' + str(obj))
		status, ret_nions_ave = ull.getVect1DDoubleFromObject(self.idx, obj, cpopath + 'nions_ave', i)
		check_status(status)
		if not status:
			self.nions_ave = ret_nions_ave
		self.omega_ave.getTimedElt(path, cpopath + 'omega_ave', i, obj)

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vol_avestructurescenario_vol_aveObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		obj = self.te_ave.putNonTimedElt(path, cpopath + 'te_ave', i, obj)
		obj = self.ti_ave.putNonTimedElt(path, cpopath + 'ti_ave', i, obj)
		obj = self.ne_ave.putNonTimedElt(path, cpopath + 'ne_ave', i, obj)
		obj = self.dne_ave_dt.putNonTimedElt(path, cpopath + 'dne_ave_dt', i, obj)
		obj = self.ni_ave.putNonTimedElt(path, cpopath + 'ni_ave', i, obj)
		obj = self.zeff_ave.putNonTimedElt(path, cpopath + 'zeff_ave', i, obj)
		obj = self.ti_o_te_ave.putNonTimedElt(path, cpopath + 'ti_o_te_ave', i, obj)
		obj = self.meff_ave.putNonTimedElt(path, cpopath + 'meff_ave', i, obj)
		obj = self.pellet_flux.putNonTimedElt(path, cpopath + 'pellet_flux', i, obj)
		obj = self.omega_ave.putNonTimedElt(path, cpopath + 'omega_ave', i, obj)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type vol_avestructurescenario_vol_aveObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		self.te_ave.getNonTimedElt(path, cpopath + 'te_ave', i, obj)
		self.ti_ave.getNonTimedElt(path, cpopath + 'ti_ave', i, obj)
		self.ne_ave.getNonTimedElt(path, cpopath + 'ne_ave', i, obj)
		self.dne_ave_dt.getNonTimedElt(path, cpopath + 'dne_ave_dt', i, obj)
		self.ni_ave.getNonTimedElt(path, cpopath + 'ni_ave', i, obj)
		self.zeff_ave.getNonTimedElt(path, cpopath + 'zeff_ave', i, obj)
		self.ti_o_te_ave.getNonTimedElt(path, cpopath + 'ti_o_te_ave', i, obj)
		self.meff_ave.getNonTimedElt(path, cpopath + 'meff_ave', i, obj)
		self.pellet_flux.getNonTimedElt(path, cpopath + 'pellet_flux', i, obj)
		self.omega_ave.getNonTimedElt(path, cpopath + 'omega_ave', i, obj)

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		self.te_ave.deleteData(path, cpopath)
		self.ti_ave.deleteData(path, cpopath)
		self.ne_ave.deleteData(path, cpopath)
		self.dne_ave_dt.deleteData(path, cpopath)
		self.ni_ave.deleteData(path, cpopath)
		self.zeff_ave.deleteData(path, cpopath)
		self.ti_o_te_ave.deleteData(path, cpopath)
		self.meff_ave.deleteData(path, cpopath)
		self.pellet_flux.deleteData(path, cpopath)
		ull.deleteData(self.idx, path, cpopath + 'nions_ave')
		self.omega_ave.deleteData(path, cpopath)


class te_avestructurescenario_ref:
	'''
	class te_avestructurescenario_ref
	volume averaged electron temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='te_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class te_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type te_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type te_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type te_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = te_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type te_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_avestructurescenario_ref:
	'''
	class ti_avestructurescenario_ref
	volume averaged ion temperature [eV]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ne_avestructurescenario_ref:
	'''
	class ne_avestructurescenario_ref
	volume averaged electron density [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ne_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ne_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ne_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ne_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ne_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ne_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ne_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class dne_ave_dtstructurescenario_ref:
	'''
	class dne_ave_dtstructurescenario_ref
	time derivative of volume averaged electron density [m^-3/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='dne_ave_dt'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class dne_ave_dtstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dne_ave_dtstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dne_ave_dtstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type dne_ave_dtstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type dne_ave_dtstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type dne_ave_dtstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = dne_ave_dtstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_ave_dtstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_ave_dtstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_ave_dtstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type dne_ave_dtstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ni_avestructurescenario_ref:
	'''
	class ni_avestructurescenario_ref
	volume averaged ion density (<sum(n_k)>, k in species) [m^-3]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ni_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ni_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ni_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ni_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ni_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ni_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ni_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class zeff_avestructurescenario_ref:
	'''
	class zeff_avestructurescenario_ref
	volume averaged effective charge. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='zeff_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class zeff_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type zeff_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = zeff_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type zeff_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class ti_o_te_avestructurescenario_ref:
	'''
	class ti_o_te_avestructurescenario_ref
	volume averaged ion temperature over electron temperature  (<Ti/Te>) []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='ti_o_te_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class ti_o_te_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_o_te_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_o_te_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type ti_o_te_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type ti_o_te_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type ti_o_te_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = ti_o_te_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_o_te_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_o_te_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_o_te_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type ti_o_te_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class meff_avestructurescenario_ref:
	'''
	class meff_avestructurescenario_ref
	volume averaged effectice mass  (<sum(n_k * m_k)  > /  < sum(n_k)> ) []. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='meff_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class meff_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type meff_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type meff_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type meff_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type meff_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type meff_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = meff_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type meff_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type meff_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type meff_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type meff_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class pellet_fluxstructurescenario_ref:
	'''
	class pellet_fluxstructurescenario_ref
	number of electrons fuelling  the plasma every second coming from pellet injection [s^-1]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='pellet_flux'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class pellet_fluxstructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_fluxstructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_fluxstructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_fluxstructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_fluxstructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type pellet_fluxstructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = pellet_fluxstructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_fluxstructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_fluxstructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_fluxstructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type pellet_fluxstructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class omega_avestructurescenario_ref:
	'''
	class omega_avestructurescenario_ref
	bulk volume average toroidal rotation velocity (whole plasma) [rad/s]. Time-dependent.

	Attributes:
	- value : float
	   Signal value; Time-dependent; Scalar
	- source : str
	   Source of the signal (any comment describing the origin of the signal : code, path to diagnostic signals, massaging, ...); String
	'''

	def __init__(self, base_path_in='omega_ave'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.value = EMPTY_DOUBLE
		self.source = ''

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class omega_avestructurescenario_ref\n'
		ret = ret + space + 'Attribute value: ' + str(self.value) + '\n'
		ret = ret + space + 'Attribute source: ' + str(self.source) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type omega_avestructurescenario_ref, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putDoubleSlice(self.idx, path, cpopath + 'value', self.value, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type omega_avestructurescenario_ref, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastDoubleSlice(self.idx, path, cpopath + 'value', self.value)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type omega_avestructurescenario_ref, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'source', self.source)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type omega_avestructurescenario_ref, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_value, retTime = ull.getDoubleSlice(self.idx, path, cpopath + 'value', inTime, interpolMode)
		check_status(status)
		if not status:
			self.value = ret_value
			self.cpoTime = retTime
		status, ret_source = ull.getString(self.idx, path, cpopath + 'source')
		check_status(status)
		if not status:
			self.source = ret_source

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type omega_avestructurescenario_ref, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, valueList = ull.getVect1DDouble(self.idx, path, cpopath + 'value')
			if len(valueList) == 0:
				valueList = numpy.resize(valueList, (nbslice))
			check_status(status)
			status, sourceVal = ull.getString(self.idx, path, cpopath + 'source')
			check_status(status)
			for i in range(nbslice):
				slice = omega_avestructurescenario_ref(self.base_path)
				slice.setExpIdx(self.idx)
				slice.value = valueList[i].copy().astype(float)
				slice.source = sourceVal
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type omega_avestructurescenario_refObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		obj = ull.putDoubleInObject(self.idx, obj, cpopath + 'value', i, self.value)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type omega_avestructurescenario_refObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getDoubleInObject : ' + cpopath + 'value') 
			print ('obj = ' + str(obj))
		status, ret_value = ull.getDoubleFromObject(self.idx, obj, cpopath + 'value', i)
		check_status(status)
		if not status:
			self.value = ret_value

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type omega_avestructurescenario_refObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'source', i, self.source)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type omega_avestructurescenario_refObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'source') 
			print ('obj = ' + str(obj))
		status, ret_source = ull.getStringFromObject(self.idx, obj, cpopath + 'source', i)
		check_status(status)
		if not status:
			self.source = ret_source

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'value')
		ull.deleteData(self.idx, path, cpopath + 'source')


class codeparamstructurecodeparam:
	'''
	class codeparamstructurecodeparam
	Code parameters

	Attributes:
	- codename : str
	   Name of the code
	- codeversion : str
	   Version of the code (as in the ITM repository)
	- parameters : str
	   List of the code specific parameters, string expected to be in XML format.
	- output_diag : str
	   List of the code specific diagnostic/output, string expected to be in XML format.
	- output_flag : int
	   Output flag : 0 means the run is successful, other values meaning some difficulty has been encountered, the exact meaning is then code specific. Negative values mean the result shall not be used. Exact rules could discussed and implemented in the module wrapper. Time-dependent.
	'''

	def __init__(self, base_path_in='codeparam'):
		self.base_path = base_path_in
		self.idx = EMPTY_INT
		self.cpoTime = EMPTY_DOUBLE
		self.codename = ''
		self.codeversion = ''
		self.parameters = ''
		self.output_diag = ''
		self.output_flag = EMPTY_INT

	def __str__(self, depth=0):
		space = depth*'\t'
		ret = space + 'class codeparamstructurecodeparam\n'
		ret = ret + space + 'Attribute codename: ' + str(self.codename) + '\n'
		ret = ret + space + 'Attribute codeversion: ' + str(self.codeversion) + '\n'
		ret = ret + space + 'Attribute parameters: ' + str(self.parameters) + '\n'
		ret = ret + space + 'Attribute output_diag: ' + str(self.output_diag) + '\n'
		ret = ret + space + 'Attribute output_flag: ' + str(self.output_flag) + '\n'
		return ret

	def setExpIdx(self, idx):
		self.idx = idx

	def putSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type codeparamstructurecodeparam, run function putSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putIntSlice(self.idx, path, cpopath + 'output_flag', self.output_flag, self.cpoTime)
		check_status(status)

	def replaceLastSlice(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type codeparamstructurecodeparam, run function replaceLastSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.replaceLastIntSlice(self.idx, path, cpopath + 'output_flag', self.output_flag)
		check_status(status)

	def putNonTimed(self, path, cpopath):
		if (verb()):
			print ('field '+self.base_path+' of type codeparamstructurecodeparam, run function putNonTimed') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status = ull.putString(self.idx, path, cpopath + 'codename', self.codename)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'codeversion', self.codeversion)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'parameters', self.parameters)
		check_status(status)
		status = ull.putString(self.idx, path, cpopath + 'output_diag', self.output_diag)
		check_status(status)

	def getSlice(self, path, cpopath, inTime, interpolMode):
		if (verb()):
			print ('field '+self.base_path+' of type codeparamstructurecodeparam, run function getSlice') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		status, ret_codename = ull.getString(self.idx, path, cpopath + 'codename')
		check_status(status)
		if not status:
			self.codename = ret_codename
		status, ret_codeversion = ull.getString(self.idx, path, cpopath + 'codeversion')
		check_status(status)
		if not status:
			self.codeversion = ret_codeversion
		status, ret_parameters = ull.getString(self.idx, path, cpopath + 'parameters')
		check_status(status)
		if not status:
			self.parameters = ret_parameters
		status, ret_output_diag = ull.getString(self.idx, path, cpopath + 'output_diag')
		check_status(status)
		if not status:
			self.output_diag = ret_output_diag
		status, ret_output_flag, retTime = ull.getIntSlice(self.idx, path, cpopath + 'output_flag', inTime, interpolMode)
		check_status(status)
		if not status:
			self.output_flag = ret_output_flag
			self.cpoTime = retTime

	def build_non_resampled_data(self, path, cpopath, nbslice):
		if (verb()):
			print ('field '+self.base_path+' of type codeparamstructurecodeparam, run function build_non_resampled_data') 
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		list=[]
		if nbslice > 0:
			status, codenameVal = ull.getString(self.idx, path, cpopath + 'codename')
			check_status(status)
			status, codeversionVal = ull.getString(self.idx, path, cpopath + 'codeversion')
			check_status(status)
			status, parametersVal = ull.getString(self.idx, path, cpopath + 'parameters')
			check_status(status)
			status, output_diagVal = ull.getString(self.idx, path, cpopath + 'output_diag')
			check_status(status)
			status, output_flagList = ull.getVect1DInt(self.idx, path, cpopath + 'output_flag')
			if len(output_flagList) == 0:
				output_flagList = numpy.resize(output_flagList, (nbslice))
			check_status(status)
			for i in range(nbslice):
				slice = codeparamstructurecodeparam(self.base_path)
				slice.setExpIdx(self.idx)
				slice.codename = codenameVal
				slice.codeversion = codeversionVal
				slice.parameters = parametersVal
				slice.output_diag = output_diagVal
				slice.output_flag = int(output_flagList[i].copy())
				list.append(slice)
		else:
			print ('error, nbslice must be > 0 and got:' + str(nbslice))
		return list

	def putTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type codeparamstructurecodeparamObj, run function putTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putIntInObject : ' + cpopath + 'output_flag') 
			print ('obj = ' + str(obj))
		obj = ull.putIntInObject(self.idx, obj, cpopath + 'output_flag', i, self.output_flag)
		return obj

	def getTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type codeparamstructurecodeparamObj, run function getTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getIntInObject : ' + cpopath + 'output_flag') 
			print ('obj = ' + str(obj))
		status, ret_output_flag = ull.getIntFromObject(self.idx, obj, cpopath + 'output_flag', i)
		check_status(status)
		if not status:
			self.output_flag = ret_output_flag

	def putNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type codeparamstructurecodeparamObj, run function putNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'codename') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'codename', i, self.codename)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'codeversion') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'codeversion', i, self.codeversion)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'parameters') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'parameters', i, self.parameters)
		if (dev()):
			print ('putStringInObject : ' + cpopath + 'output_diag') 
			print ('obj = ' + str(obj))
		obj = ull.putStringInObject(self.idx, obj, cpopath + 'output_diag', i, self.output_diag)
		return obj

	def getNonTimedElt(self, path, cpopath, i, obj):
		if (verb()):
			print ('object of type codeparamstructurecodeparamObj, run function getNonTimedElt') 
		cpopath = cpopath + '/' 
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'codename') 
			print ('obj = ' + str(obj))
		status, ret_codename = ull.getStringFromObject(self.idx, obj, cpopath + 'codename', i)
		check_status(status)
		if not status:
			self.codename = ret_codename
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'codeversion') 
			print ('obj = ' + str(obj))
		status, ret_codeversion = ull.getStringFromObject(self.idx, obj, cpopath + 'codeversion', i)
		check_status(status)
		if not status:
			self.codeversion = ret_codeversion
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'parameters') 
			print ('obj = ' + str(obj))
		status, ret_parameters = ull.getStringFromObject(self.idx, obj, cpopath + 'parameters', i)
		check_status(status)
		if not status:
			self.parameters = ret_parameters
		if (dev()):
			print ('getStringInObject : ' + cpopath + 'output_diag') 
			print ('obj = ' + str(obj))
		status, ret_output_diag = ull.getStringFromObject(self.idx, obj, cpopath + 'output_diag', i)
		check_status(status)
		if not status:
			self.output_diag = ret_output_diag

	def deleteData(self, path, cpopath):
		if cpopath=='':
			cpopath = self.base_path + '/'
		else:
			cpopath = cpopath + self.base_path + '/' 
		if (verb()):
			print ('path = ' + path + '  and cpopath = ' + cpopath) 
		ull.deleteData(self.idx, path, cpopath + 'codename')
		ull.deleteData(self.idx, path, cpopath + 'codeversion')
		ull.deleteData(self.idx, path, cpopath + 'parameters')
		ull.deleteData(self.idx, path, cpopath + 'output_diag')
		ull.deleteData(self.idx, path, cpopath + 'output_flag')
