 module diff_structures
 !------------------------------------------------------------------
 ! module for granular diffs of euitm structures
 !------------------------------------------------------------------

   use euitm_schemas

   interface diff_cpo
      module procedure diff_type_integer
      module procedure diff_type_float
      module procedure diff_type_array3dcplx_type
      module procedure diff_type_array3dflt_type
      module procedure diff_type_array3dint_type
      module procedure diff_type_array4dflt_type
      module procedure diff_type_array5dflt_type
      module procedure diff_type_array6dflt_type
      module procedure diff_type_array7dflt_type
      module procedure diff_type_matcplx_type
      module procedure diff_type_matflt_type
      module procedure diff_type_matint_type
      module procedure diff_type_veccplx_type
      module procedure diff_type_vecflt_type
      module procedure diff_type_vecint_type
      module procedure diff_type_vecstring_type
      module procedure diff_type_amns
      module procedure diff_arr_type_amns
      module procedure diff_type_antennas
      module procedure diff_arr_type_antennas
      module procedure diff_type_bb_shield
      module procedure diff_arr_type_bb_shield
      module procedure diff_type_compositionc
      module procedure diff_arr_type_compositionc
      module procedure diff_type_coredelta
      module procedure diff_arr_type_coredelta
      module procedure diff_type_corefast
      module procedure diff_arr_type_corefast
      module procedure diff_type_coreimpur
      module procedure diff_arr_type_coreimpur
      module procedure diff_type_coreneutrals
      module procedure diff_arr_type_coreneutrals
      module procedure diff_type_coreprof
      module procedure diff_arr_type_coreprof
      module procedure diff_type_coresource
      module procedure diff_arr_type_coresource
      module procedure diff_type_coretransp
      module procedure diff_arr_type_coretransp
      module procedure diff_type_cxdiag
      module procedure diff_arr_type_cxdiag
      module procedure diff_type_distribution
      module procedure diff_arr_type_distribution
      module procedure diff_type_distsource
      module procedure diff_arr_type_distsource
      module procedure diff_type_ecediag
      module procedure diff_arr_type_ecediag
      module procedure diff_type_edge
      module procedure diff_arr_type_edge
      module procedure diff_type_efcc
      module procedure diff_arr_type_efcc
      module procedure diff_type_equilibrium
      module procedure diff_arr_type_equilibrium
      module procedure diff_type_fusiondiag
      module procedure diff_arr_type_fusiondiag
      module procedure diff_type_halphadiag
      module procedure diff_arr_type_halphadiag
      module procedure diff_type_heat_sources
      module procedure diff_arr_type_heat_sources
      module procedure diff_type_interfdiag
      module procedure diff_arr_type_interfdiag
      module procedure diff_type_ironmodel
      module procedure diff_arr_type_ironmodel
      module procedure diff_type_langmuirdiag
      module procedure diff_arr_type_langmuirdiag
      module procedure diff_type_launchs
      module procedure diff_arr_type_launchs
      module procedure diff_type_lithiumdiag
      module procedure diff_arr_type_lithiumdiag
      module procedure diff_type_magdiag
      module procedure diff_arr_type_magdiag
      module procedure diff_type_mhd
      module procedure diff_arr_type_mhd
      module procedure diff_type_msediag
      module procedure diff_arr_type_msediag
      module procedure diff_type_nbi
      module procedure diff_arr_type_nbi
      module procedure diff_type_neoclassic
      module procedure diff_arr_type_neoclassic
      module procedure diff_type_ntm
      module procedure diff_arr_type_ntm
      module procedure diff_type_orbit
      module procedure diff_arr_type_orbit
      module procedure diff_type_pellets
      module procedure diff_arr_type_pellets
      module procedure diff_type_pfsystems
      module procedure diff_arr_type_pfsystems
      module procedure diff_type_polardiag
      module procedure diff_arr_type_polardiag
      module procedure diff_type_power_conv
      module procedure diff_arr_type_power_conv
      module procedure diff_type_reflectomet
      module procedure diff_arr_type_reflectomet
      module procedure diff_type_rfadiag
      module procedure diff_arr_type_rfadiag
      module procedure diff_type_sawteeth
      module procedure diff_arr_type_sawteeth
      module procedure diff_type_scenario
      module procedure diff_arr_type_scenario
      module procedure diff_type_solcurdiag
      module procedure diff_arr_type_solcurdiag
      module procedure diff_type_temporary
      module procedure diff_arr_type_temporary
      module procedure diff_type_topinfo
      module procedure diff_arr_type_topinfo
      module procedure diff_type_toroidfield
      module procedure diff_arr_type_toroidfield
      module procedure diff_type_tsdiag
      module procedure diff_arr_type_tsdiag
      module procedure diff_type_turbulence
      module procedure diff_arr_type_turbulence
      module procedure diff_type_wall
      module procedure diff_arr_type_wall
      module procedure diff_type_waves
      module procedure diff_arr_type_waves
      module procedure diff_type_amns_constituentType
      module procedure diff_arr_type_amns_constituentType
      module procedure diff_type_amns_processType
      module procedure diff_arr_type_amns_processType
      module procedure diff_type_antenna_ec
      module procedure diff_arr_type_antenna_ec
      module procedure diff_type_antenna_ic
      module procedure diff_arr_type_antenna_ic
      module procedure diff_type_antenna_lh
      module procedure diff_arr_type_antenna_lh
      module procedure diff_type_antennaic_setup
      module procedure diff_arr_type_antennaic_setup
      module procedure diff_type_antennalh_setup
      module procedure diff_arr_type_antennalh_setup
      module procedure diff_type_b0r0
      module procedure diff_arr_type_b0r0
      module procedure diff_type_bb
      module procedure diff_arr_type_bb
      module procedure diff_type_bb_dimension
      module procedure diff_arr_type_bb_dimension
      module procedure diff_type_bb_geometry
      module procedure diff_arr_type_bb_geometry
      module procedure diff_type_bb_specs
      module procedure diff_arr_type_bb_specs
      module procedure diff_type_beamletgroup
      module procedure diff_arr_type_beamletgroup
      module procedure diff_type_beamlets
      module procedure diff_arr_type_beamlets
      module procedure diff_type_beamtracing
      module procedure diff_arr_type_beamtracing
      module procedure diff_type_boundary
      module procedure diff_arr_type_boundary
      module procedure diff_type_boundary_neutrals
      module procedure diff_arr_type_boundary_neutrals
      module procedure diff_type_boundaryel
      module procedure diff_arr_type_boundaryel
      module procedure diff_type_boundaryimp
      module procedure diff_arr_type_boundaryimp
      module procedure diff_type_boundaryion
      module procedure diff_arr_type_boundaryion
      module procedure diff_type_bpol_probes
      module procedure diff_arr_type_bpol_probes
      module procedure diff_type_calorimetry_heat_source
      module procedure diff_arr_type_calorimetry_heat_source
      module procedure diff_type_circuits
      module procedure diff_arr_type_circuits
      module procedure diff_type_circularcoil
      module procedure diff_arr_type_circularcoil
      module procedure diff_type_clusters
      module procedure diff_arr_type_clusters
      module procedure diff_type_codeparam
      module procedure diff_arr_type_codeparam
      module procedure diff_type_coefficients_neutrals
      module procedure diff_arr_type_coefficients_neutrals
      module procedure diff_type_coherentwave
      module procedure diff_arr_type_coherentwave
      module procedure diff_type_coil
      module procedure diff_arr_type_coil
      module procedure diff_type_com
      module procedure diff_arr_type_com
      module procedure diff_type_complexgrid
      module procedure diff_arr_type_complexgrid
      module procedure diff_type_complexgrid_geo_global
      module procedure diff_arr_type_complexgrid_geo_global
      module procedure diff_type_complexgrid_indexlist
      module procedure diff_arr_type_complexgrid_indexlist
      module procedure diff_type_complexgrid_metric
      module procedure diff_arr_type_complexgrid_metric
      module procedure diff_type_complexgrid_objectlist
      module procedure diff_arr_type_complexgrid_objectlist
      module procedure diff_type_complexgrid_scalar
      module procedure diff_arr_type_complexgrid_scalar
      module procedure diff_type_complexgrid_scalar_cplx
      module procedure diff_arr_type_complexgrid_scalar_cplx
      module procedure diff_type_complexgrid_scalar_int
      module procedure diff_arr_type_complexgrid_scalar_int
      module procedure diff_type_complexgrid_scalar_simplestruct
      module procedure diff_arr_type_complexgrid_scalar_simplestruct
      module procedure diff_type_complexgrid_space
      module procedure diff_arr_type_complexgrid_space
      module procedure diff_type_complexgrid_subgrid
      module procedure diff_arr_type_complexgrid_subgrid
      module procedure diff_type_complexgrid_vector
      module procedure diff_arr_type_complexgrid_vector
      module procedure diff_type_complexgrid_vector_simplestruct
      module procedure diff_arr_type_complexgrid_vector_simplestruct
      module procedure diff_type_composition
      module procedure diff_arr_type_composition
      module procedure diff_type_composition_neutrals
      module procedure diff_arr_type_composition_neutrals
      module procedure diff_type_composition_neutrals_neutcomp
      module procedure diff_arr_type_composition_neutrals_neutcomp
      module procedure diff_type_composition_neutralscomp
      module procedure diff_arr_type_composition_neutralscomp
      module procedure diff_type_compositions_type
      module procedure diff_arr_type_compositions_type
      module procedure diff_type_compound_desc
      module procedure diff_arr_type_compound_desc
      module procedure diff_type_coord_sys
      module procedure diff_arr_type_coord_sys
      module procedure diff_type_coordinates
      module procedure diff_arr_type_coordinates
      module procedure diff_type_coords
      module procedure diff_arr_type_coords
      module procedure diff_type_coredelta_values
      module procedure diff_arr_type_coredelta_values
      module procedure diff_type_coredelta_values_impurity
      module procedure diff_arr_type_coredelta_values_impurity
      module procedure diff_type_corefast_values
      module procedure diff_arr_type_corefast_values
      module procedure diff_type_corefield
      module procedure diff_arr_type_corefield
      module procedure diff_type_corefieldion
      module procedure diff_arr_type_corefieldion
      module procedure diff_type_corefieldneutral
      module procedure diff_arr_type_corefieldneutral
      module procedure diff_type_corefieldneutrale
      module procedure diff_arr_type_corefieldneutrale
      module procedure diff_type_corefieldneutralv
      module procedure diff_arr_type_corefieldneutralv
      module procedure diff_type_corefieldneutralv0
      module procedure diff_arr_type_corefieldneutralv0
      module procedure diff_type_coreimpurdiag_sum_radiation
      module procedure diff_arr_type_coreimpurdiag_sum_radiation
      module procedure diff_type_coreimpurediag_energy
      module procedure diff_arr_type_coreimpurediag_energy
      module procedure diff_type_coreimpurediag_radiation
      module procedure diff_arr_type_coreimpurediag_radiation
      module procedure diff_type_coreimpurediag_sum
      module procedure diff_arr_type_coreimpurediag_sum
      module procedure diff_type_coreimpurediag_sum_energy
      module procedure diff_arr_type_coreimpurediag_sum_energy
      module procedure diff_type_coreimpurediag_type
      module procedure diff_arr_type_coreimpurediag_type
      module procedure diff_type_coreimpurediagprof_type
      module procedure diff_arr_type_coreimpurediagprof_type
      module procedure diff_type_coreimpurediagsum_type
      module procedure diff_arr_type_coreimpurediagsum_type
      module procedure diff_type_coreneutrals_atomlist
      module procedure diff_arr_type_coreneutrals_atomlist
      module procedure diff_type_coreneutrals_neutraltype
      module procedure diff_arr_type_coreneutrals_neutraltype
      module procedure diff_type_coreprofile
      module procedure diff_arr_type_coreprofile
      module procedure diff_type_coreprofion
      module procedure diff_arr_type_coreprofion
      module procedure diff_type_coresource_values
      module procedure diff_arr_type_coresource_values
      module procedure diff_type_coretransel
      module procedure diff_arr_type_coretransel
      module procedure diff_type_coretransimp
      module procedure diff_arr_type_coretransimp
      module procedure diff_type_coretransion
      module procedure diff_arr_type_coretransion
      module procedure diff_type_coretransp_values
      module procedure diff_arr_type_coretransp_values
      module procedure diff_type_current
      module procedure diff_arr_type_current
      module procedure diff_type_cxmeasure
      module procedure diff_arr_type_cxmeasure
      module procedure diff_type_cxsetup
      module procedure diff_arr_type_cxsetup
      module procedure diff_type_data_release
      module procedure diff_arr_type_data_release
      module procedure diff_type_datainfo
      module procedure diff_arr_type_datainfo
      module procedure diff_type_desc_coils
      module procedure diff_arr_type_desc_coils
      module procedure diff_type_desc_impur
      module procedure diff_arr_type_desc_impur
      module procedure diff_type_desc_iron
      module procedure diff_arr_type_desc_iron
      module procedure diff_type_desc_pfcoils
      module procedure diff_arr_type_desc_pfcoils
      module procedure diff_type_desc_supply
      module procedure diff_arr_type_desc_supply
      module procedure diff_type_diag_func
      module procedure diff_arr_type_diag_func
      module procedure diff_type_dist_collisional_transfer_0d
      module procedure diff_arr_type_dist_collisional_transfer_0d
      module procedure diff_type_dist_collisional_transfer_1d
      module procedure diff_arr_type_dist_collisional_transfer_1d
      module procedure diff_type_dist_collisional_transfer_2d
      module procedure diff_arr_type_dist_collisional_transfer_2d
      module procedure diff_type_dist_distrivec_distfunc_fexp_param
      module procedure diff_arr_type_dist_distrivec_distfunc_fexp_param
      module procedure diff_type_dist_ff
      module procedure diff_arr_type_dist_ff
      module procedure diff_type_dist_func
      module procedure diff_arr_type_dist_func
      module procedure diff_type_dist_geometry_0d
      module procedure diff_arr_type_dist_geometry_0d
      module procedure diff_type_dist_geometry_1d
      module procedure diff_arr_type_dist_geometry_1d
      module procedure diff_type_dist_geometry_2d
      module procedure diff_arr_type_dist_geometry_2d
      module procedure diff_type_dist_global_param
      module procedure diff_arr_type_dist_global_param
      module procedure diff_type_dist_global_param_collisions_z
      module procedure diff_arr_type_dist_global_param_collisions_z
      module procedure diff_type_dist_grid_info
      module procedure diff_arr_type_dist_grid_info
      module procedure diff_type_dist_profile_values_1d
      module procedure diff_arr_type_dist_profile_values_1d
      module procedure diff_type_dist_profile_values_2d
      module procedure diff_arr_type_dist_profile_values_2d
      module procedure diff_type_dist_profiles2d_collisions_z
      module procedure diff_arr_type_dist_profiles2d_collisions_z
      module procedure diff_type_dist_profiles_1d
      module procedure diff_arr_type_dist_profiles_1d
      module procedure diff_type_dist_profiles_1d_collisions_z
      module procedure diff_arr_type_dist_profiles_1d_collisions_z
      module procedure diff_type_dist_profiles_2d
      module procedure diff_arr_type_dist_profiles_2d
      module procedure diff_type_dist_sources_0d
      module procedure diff_arr_type_dist_sources_0d
      module procedure diff_type_dist_sources_1d
      module procedure diff_arr_type_dist_sources_1d
      module procedure diff_type_dist_sources_reference
      module procedure diff_arr_type_dist_sources_reference
      module procedure diff_type_dist_state_0d
      module procedure diff_arr_type_dist_state_0d
      module procedure diff_type_dist_state_1d
      module procedure diff_arr_type_dist_state_1d
      module procedure diff_type_dist_state_2d
      module procedure diff_arr_type_dist_state_2d
      module procedure diff_type_dist_thermalised_1d
      module procedure diff_arr_type_dist_thermalised_1d
      module procedure diff_type_distri_vec
      module procedure diff_arr_type_distri_vec
      module procedure diff_type_distsource_global_param
      module procedure diff_arr_type_distsource_global_param
      module procedure diff_type_distsource_line_src_prof
      module procedure diff_arr_type_distsource_line_src_prof
      module procedure diff_type_distsource_profiles_1d
      module procedure diff_arr_type_distsource_profiles_1d
      module procedure diff_type_distsource_profiles_2d
      module procedure diff_arr_type_distsource_profiles_2d
      module procedure diff_type_distsource_source
      module procedure diff_arr_type_distsource_source
      module procedure diff_type_divergence
      module procedure diff_arr_type_divergence
      module procedure diff_type_e_components
      module procedure diff_arr_type_e_components
      module procedure diff_type_ecemeasure
      module procedure diff_arr_type_ecemeasure
      module procedure diff_type_ecesetup
      module procedure diff_arr_type_ecesetup
      module procedure diff_type_edge_fluid
      module procedure diff_arr_type_edge_fluid
      module procedure diff_type_edge_fluid_scalar
      module procedure diff_arr_type_edge_fluid_scalar
      module procedure diff_type_edge_fluid_scalar_simplestruct
      module procedure diff_arr_type_edge_fluid_scalar_simplestruct
      module procedure diff_type_edge_fluid_scalar_transpcoeff
      module procedure diff_arr_type_edge_fluid_scalar_transpcoeff
      module procedure diff_type_edge_fluid_vector
      module procedure diff_arr_type_edge_fluid_vector
      module procedure diff_type_edge_fluid_vector_simplestruct
      module procedure diff_arr_type_edge_fluid_vector_simplestruct
      module procedure diff_type_edge_kinetic
      module procedure diff_arr_type_edge_kinetic
      module procedure diff_type_edge_kinetic_distribution
      module procedure diff_arr_type_edge_kinetic_distribution
      module procedure diff_type_edges
      module procedure diff_arr_type_edges
      module procedure diff_type_edgespecies
      module procedure diff_arr_type_edgespecies
      module procedure diff_type_element_desc
      module procedure diff_arr_type_element_desc
      module procedure diff_type_entry_def
      module procedure diff_arr_type_entry_def
      module procedure diff_type_enum_instance
      module procedure diff_arr_type_enum_instance
      module procedure diff_type_eqconstraint
      module procedure diff_arr_type_eqconstraint
      module procedure diff_type_eqgeometry
      module procedure diff_arr_type_eqgeometry
      module procedure diff_type_eqmes0D
      module procedure diff_arr_type_eqmes0D
      module procedure diff_type_eqmes1D
      module procedure diff_arr_type_eqmes1D
      module procedure diff_type_equatorial_plane
      module procedure diff_arr_type_equatorial_plane
      module procedure diff_type_equilibrium_profiles2d_grid
      module procedure diff_arr_type_equilibrium_profiles2d_grid
      module procedure diff_type_equilibrium_profiles_2d
      module procedure diff_arr_type_equilibrium_profiles_2d
      module procedure diff_type_exp0D
      module procedure diff_arr_type_exp0D
      module procedure diff_type_exp1D
      module procedure diff_arr_type_exp1D
      module procedure diff_type_exp2D
      module procedure diff_arr_type_exp2D
      module procedure diff_type_f_expansion
      module procedure diff_arr_type_f_expansion
      module procedure diff_type_fast_thermal_separation_filter
      module procedure diff_arr_type_fast_thermal_separation_filter
      module procedure diff_type_filter
      module procedure diff_arr_type_filter
      module procedure diff_type_flat_polygon
      module procedure diff_arr_type_flat_polygon
      module procedure diff_type_flush
      module procedure diff_arr_type_flush
      module procedure diff_type_flux_loops
      module procedure diff_arr_type_flux_loops
      module procedure diff_type_fluxel
      module procedure diff_arr_type_fluxel
      module procedure diff_type_fluximp
      module procedure diff_arr_type_fluximp
      module procedure diff_type_fluxion
      module procedure diff_arr_type_fluxion
      module procedure diff_type_focussing
      module procedure diff_arr_type_focussing
      module procedure diff_type_fullwave
      module procedure diff_arr_type_fullwave
      module procedure diff_type_fusiondiag_colli_3d
      module procedure diff_arr_type_fusiondiag_colli_3d
      module procedure diff_type_fusiondiag_colli_circ
      module procedure diff_arr_type_fusiondiag_colli_circ
      module procedure diff_type_fusiondiag_colli_poly
      module procedure diff_arr_type_fusiondiag_colli_poly
      module procedure diff_type_fusiondiag_collimator
      module procedure diff_arr_type_fusiondiag_collimator
      module procedure diff_type_fusiondiag_colliunit_circ
      module procedure diff_arr_type_fusiondiag_colliunit_circ
      module procedure diff_type_fusiondiag_colliunit_poly
      module procedure diff_arr_type_fusiondiag_colliunit_poly
      module procedure diff_type_fusiondiag_counts
      module procedure diff_arr_type_fusiondiag_counts
      module procedure diff_type_fusiondiag_ct_chords
      module procedure diff_arr_type_fusiondiag_ct_chords
      module procedure diff_type_fusiondiag_ct_energy
      module procedure diff_arr_type_fusiondiag_ct_energy
      module procedure diff_type_fusiondiag_detect_ct_energy
      module procedure diff_arr_type_fusiondiag_detect_ct_energy
      module procedure diff_type_fusiondiag_emissivity1d
      module procedure diff_arr_type_fusiondiag_emissivity1d
      module procedure diff_type_fusiondiag_emissivity2d
      module procedure diff_arr_type_fusiondiag_emissivity2d
      module procedure diff_type_fusiondiag_fus_product
      module procedure diff_arr_type_fusiondiag_fus_product
      module procedure diff_type_fusiondiag_spec1d
      module procedure diff_arr_type_fusiondiag_spec1d
      module procedure diff_type_fusiondiag_spec2d
      module procedure diff_arr_type_fusiondiag_spec2d
      module procedure diff_type_fusiondiag_voxels
      module procedure diff_arr_type_fusiondiag_voxels
      module procedure diff_type_geom
      module procedure diff_arr_type_geom
      module procedure diff_type_geom_iron
      module procedure diff_arr_type_geom_iron
      module procedure diff_type_global_param
      module procedure diff_arr_type_global_param
      module procedure diff_type_globalparam
      module procedure diff_arr_type_globalparam
      module procedure diff_type_halpha_setup
      module procedure diff_arr_type_halpha_setup
      module procedure diff_type_hcll
      module procedure diff_arr_type_hcll
      module procedure diff_type_hcll_bb
      module procedure diff_arr_type_hcll_bb
      module procedure diff_type_hcllbb_specs
      module procedure diff_arr_type_hcllbb_specs
      module procedure diff_type_holes
      module procedure diff_arr_type_holes
      module procedure diff_type_identifier
      module procedure diff_arr_type_identifier
      module procedure diff_type_impcoeff
      module procedure diff_arr_type_impcoeff
      module procedure diff_type_impurities
      module procedure diff_arr_type_impurities
      module procedure diff_type_impurity_type
      module procedure diff_arr_type_impurity_type
      module procedure diff_type_inj_spec
      module procedure diff_arr_type_inj_spec
      module procedure diff_type_ions
      module procedure diff_arr_type_ions
      module procedure diff_type_isoflux
      module procedure diff_arr_type_isoflux
      module procedure diff_type_jni
      module procedure diff_arr_type_jni
      module procedure diff_type_lang_derived
      module procedure diff_arr_type_lang_derived
      module procedure diff_type_lang_measure
      module procedure diff_arr_type_lang_measure
      module procedure diff_type_launchangles
      module procedure diff_arr_type_launchangles
      module procedure diff_type_launchs_parallel
      module procedure diff_arr_type_launchs_parallel
      module procedure diff_type_launchs_phi_theta
      module procedure diff_arr_type_launchs_phi_theta
      module procedure diff_type_launchs_rfbeam
      module procedure diff_arr_type_launchs_rfbeam
      module procedure diff_type_launchs_rfbeam_phaseellipse
      module procedure diff_arr_type_launchs_rfbeam_phaseellipse
      module procedure diff_type_launchs_rfbeam_spot
      module procedure diff_arr_type_launchs_rfbeam_spot
      module procedure diff_type_launchsignal
      module procedure diff_arr_type_launchsignal
      module procedure diff_type_limiter_unit
      module procedure diff_arr_type_limiter_unit
      module procedure diff_type_limits
      module procedure diff_arr_type_limits
      module procedure diff_type_lineintegraldiag
      module procedure diff_arr_type_lineintegraldiag
      module procedure diff_type_lithmeasure
      module procedure diff_arr_type_lithmeasure
      module procedure diff_type_lithsetup
      module procedure diff_arr_type_lithsetup
      module procedure diff_type_local
      module procedure diff_arr_type_local
      module procedure diff_type_mag_axis
      module procedure diff_arr_type_mag_axis
      module procedure diff_type_magnet_iron
      module procedure diff_arr_type_magnet_iron
      module procedure diff_type_magnetise
      module procedure diff_arr_type_magnetise
      module procedure diff_type_mat_lim
      module procedure diff_arr_type_mat_lim
      module procedure diff_type_mdinfo
      module procedure diff_arr_type_mdinfo
      module procedure diff_type_mhd_ideal_wall2d
      module procedure diff_arr_type_mhd_ideal_wall2d
      module procedure diff_type_mhd_mode
      module procedure diff_arr_type_mhd_mode
      module procedure diff_type_mhd_plasma
      module procedure diff_arr_type_mhd_plasma
      module procedure diff_type_mhd_res_wall2d
      module procedure diff_arr_type_mhd_res_wall2d
      module procedure diff_type_mhd_vacuum
      module procedure diff_arr_type_mhd_vacuum
      module procedure diff_type_mhd_vector
      module procedure diff_arr_type_mhd_vector
      module procedure diff_type_mode_lipb
      module procedure diff_arr_type_mode_lipb
      module procedure diff_type_mode_mech
      module procedure diff_arr_type_mode_mech
      module procedure diff_type_mode_neutr
      module procedure diff_arr_type_mode_neutr
      module procedure diff_type_mode_th_hyd
      module procedure diff_arr_type_mode_th_hyd
      module procedure diff_type_mode_therm
      module procedure diff_arr_type_mode_therm
      module procedure diff_type_mode_tritium
      module procedure diff_arr_type_mode_tritium
      module procedure diff_type_modules
      module procedure diff_arr_type_modules
      module procedure diff_type_msediag_emiss_chord
      module procedure diff_arr_type_msediag_emiss_chord
      module procedure diff_type_msediag_emissivity
      module procedure diff_arr_type_msediag_emissivity
      module procedure diff_type_msediag_polarization
      module procedure diff_arr_type_msediag_polarization
      module procedure diff_type_msediag_radia_chord
      module procedure diff_arr_type_msediag_radia_chord
      module procedure diff_type_msediag_radiance
      module procedure diff_arr_type_msediag_radiance
      module procedure diff_type_msediag_setup
      module procedure diff_arr_type_msediag_setup
      module procedure diff_type_msediag_setup_polarimetry
      module procedure diff_arr_type_msediag_setup_polarimetry
      module procedure diff_type_msediag_stokes
      module procedure diff_arr_type_msediag_stokes
      module procedure diff_type_nbi_nbi_unit_wall
      module procedure diff_arr_type_nbi_nbi_unit_wall
      module procedure diff_type_nbi_nbi_unit_wall_surface
      module procedure diff_arr_type_nbi_nbi_unit_wall_surface
      module procedure diff_type_nbi_unit
      module procedure diff_arr_type_nbi_unit
      module procedure diff_type_ne_transp
      module procedure diff_arr_type_ne_transp
      module procedure diff_type_neoclassic_impurity
      module procedure diff_arr_type_neoclassic_impurity
      module procedure diff_type_neut_results
      module procedure diff_arr_type_neut_results
      module procedure diff_type_neutral_complex_type
      module procedure diff_arr_type_neutral_complex_type
      module procedure diff_type_neutro_resul
      module procedure diff_arr_type_neutro_resul
      module procedure diff_type_ni_transp
      module procedure diff_arr_type_ni_transp
      module procedure diff_type_ntm_mode
      module procedure diff_arr_type_ntm_mode
      module procedure diff_type_ntm_mode_evolution
      module procedure diff_arr_type_ntm_mode_evolution
      module procedure diff_type_ntm_mode_evolution_island
      module procedure diff_arr_type_ntm_mode_evolution_island
      module procedure diff_type_ntm_mode_full_evol
      module procedure diff_arr_type_ntm_mode_full_evol
      module procedure diff_type_ntm_mode_full_evol_island
      module procedure diff_arr_type_ntm_mode_full_evol_island
      module procedure diff_type_ntm_mode_onset
      module procedure diff_arr_type_ntm_mode_onset
      module procedure diff_type_nuclei
      module procedure diff_arr_type_nuclei
      module procedure diff_type_objects
      module procedure diff_arr_type_objects
      module procedure diff_type_offdiagel
      module procedure diff_arr_type_offdiagel
      module procedure diff_type_offdiagion
      module procedure diff_arr_type_offdiagion
      module procedure diff_type_omnigen_surf
      module procedure diff_arr_type_omnigen_surf
      module procedure diff_type_orbit_global_param
      module procedure diff_arr_type_orbit_global_param
      module procedure diff_type_orbit_midplane
      module procedure diff_arr_type_orbit_midplane
      module procedure diff_type_orbit_pos
      module procedure diff_arr_type_orbit_pos
      module procedure diff_type_orbit_special_pos
      module procedure diff_arr_type_orbit_special_pos
      module procedure diff_type_orbit_turning_pts
      module procedure diff_arr_type_orbit_turning_pts
      module procedure diff_type_origin
      module procedure diff_arr_type_origin
      module procedure diff_type_param
      module procedure diff_arr_type_param
      module procedure diff_type_parameters
      module procedure diff_arr_type_parameters
      module procedure diff_type_pellet
      module procedure diff_arr_type_pellet
      module procedure diff_type_pellet_angles
      module procedure diff_arr_type_pellet_angles
      module procedure diff_type_pellet_deposition
      module procedure diff_arr_type_pellet_deposition
      module procedure diff_type_pellet_elements
      module procedure diff_arr_type_pellet_elements
      module procedure diff_type_pellet_geometry
      module procedure diff_arr_type_pellet_geometry
      module procedure diff_type_pellet_impurity
      module procedure diff_arr_type_pellet_impurity
      module procedure diff_type_pellet_pathprofiles
      module procedure diff_arr_type_pellet_pathprofiles
      module procedure diff_type_pellet_shape
      module procedure diff_arr_type_pellet_shape
      module procedure diff_type_permeability
      module procedure diff_arr_type_permeability
      module procedure diff_type_pfcircuits
      module procedure diff_arr_type_pfcircuits
      module procedure diff_type_pfcoils
      module procedure diff_arr_type_pfcoils
      module procedure diff_type_pfelement
      module procedure diff_arr_type_pfelement
      module procedure diff_type_pfgeometry
      module procedure diff_arr_type_pfgeometry
      module procedure diff_type_pfpageometry
      module procedure diff_arr_type_pfpageometry
      module procedure diff_type_pfpassive
      module procedure diff_arr_type_pfpassive
      module procedure diff_type_pfpassive_current
      module procedure diff_arr_type_pfpassive_current
      module procedure diff_type_pfsupplies
      module procedure diff_arr_type_pfsupplies
      module procedure diff_type_phaseellipse
      module procedure diff_arr_type_phaseellipse
      module procedure diff_type_planecoil
      module procedure diff_arr_type_planecoil
      module procedure diff_type_plasmaComplexType
      module procedure diff_arr_type_plasmaComplexType
      module procedure diff_type_plasmaedge
      module procedure diff_arr_type_plasmaedge
      module procedure diff_type_pol_decomp
      module procedure diff_arr_type_pol_decomp
      module procedure diff_type_polarimetry
      module procedure diff_arr_type_polarimetry
      module procedure diff_type_polarization
      module procedure diff_arr_type_polarization
      module procedure diff_type_power_conv_component
      module procedure diff_arr_type_power_conv_component
      module procedure diff_type_power_exchange
      module procedure diff_arr_type_power_exchange
      module procedure diff_type_powerflow
      module procedure diff_arr_type_powerflow
      module procedure diff_type_profiles1d
      module procedure diff_arr_type_profiles1d
      module procedure diff_type_profiles_1d
      module procedure diff_arr_type_profiles_1d
      module procedure diff_type_psi
      module procedure diff_arr_type_psi
      module procedure diff_type_putinfo
      module procedure diff_arr_type_putinfo
      module procedure diff_type_q
      module procedure diff_arr_type_q
      module procedure diff_type_reacprodType
      module procedure diff_arr_type_reacprodType
      module procedure diff_type_react
      module procedure diff_arr_type_react
      module procedure diff_type_rectanglexyz
      module procedure diff_arr_type_rectanglexyz
      module procedure diff_type_recycling_neutrals
      module procedure diff_arr_type_recycling_neutrals
      module procedure diff_type_reduced
      module procedure diff_arr_type_reduced
      module procedure diff_type_refl_receive
      module procedure diff_arr_type_refl_receive
      module procedure diff_type_reflectometry_antennas
      module procedure diff_arr_type_reflectometry_antennas
      module procedure diff_type_reflectometry_radfield
      module procedure diff_arr_type_reflectometry_radfield
      module procedure diff_type_reflectometry_radfield_gaussian
      module procedure diff_arr_type_reflectometry_radfield_gaussian
      module procedure diff_type_reflectometry_radifield_efield
      module procedure diff_arr_type_reflectometry_radifield_efield
      module procedure diff_type_reggrid
      module procedure diff_arr_type_reggrid
      module procedure diff_type_rfameasure
      module procedure diff_arr_type_rfameasure
      module procedure diff_type_rfasetup
      module procedure diff_arr_type_rfasetup
      module procedure diff_type_rfbeam
      module procedure diff_arr_type_rfbeam
      module procedure diff_type_rz0D
      module procedure diff_arr_type_rz0D
      module procedure diff_type_rz1D
      module procedure diff_arr_type_rz1D
      module procedure diff_type_rz1D_npoints
      module procedure diff_arr_type_rz1D_npoints
      module procedure diff_type_rz1Dexp
      module procedure diff_arr_type_rz1Dexp
      module procedure diff_type_rz2D
      module procedure diff_arr_type_rz2D
      module procedure diff_type_rz3D
      module procedure diff_arr_type_rz3D
      module procedure diff_type_rzphi0D
      module procedure diff_arr_type_rzphi0D
      module procedure diff_type_rzphi1D
      module procedure diff_arr_type_rzphi1D
      module procedure diff_type_rzphi1Dexp
      module procedure diff_arr_type_rzphi1Dexp
      module procedure diff_type_rzphi1Dexperimental
      module procedure diff_arr_type_rzphi1Dexperimental
      module procedure diff_type_rzphi2D
      module procedure diff_arr_type_rzphi2D
      module procedure diff_type_rzphi3D
      module procedure diff_arr_type_rzphi3D
      module procedure diff_type_rzphidrdzdphi1D
      module procedure diff_arr_type_rzphidrdzdphi1D
      module procedure diff_type_sawteeth_diags
      module procedure diff_arr_type_sawteeth_diags
      module procedure diff_type_sawteeth_profiles1d
      module procedure diff_arr_type_sawteeth_profiles1d
      module procedure diff_type_scenario_centre
      module procedure diff_arr_type_scenario_centre
      module procedure diff_type_scenario_composition
      module procedure diff_arr_type_scenario_composition
      module procedure diff_type_scenario_configuration
      module procedure diff_arr_type_scenario_configuration
      module procedure diff_type_scenario_confinement
      module procedure diff_arr_type_scenario_confinement
      module procedure diff_type_scenario_currents
      module procedure diff_arr_type_scenario_currents
      module procedure diff_type_scenario_edge
      module procedure diff_arr_type_scenario_edge
      module procedure diff_type_scenario_energy
      module procedure diff_arr_type_scenario_energy
      module procedure diff_type_scenario_global
      module procedure diff_arr_type_scenario_global
      module procedure diff_type_scenario_heat_power
      module procedure diff_arr_type_scenario_heat_power
      module procedure diff_type_scenario_int
      module procedure diff_arr_type_scenario_int
      module procedure diff_type_scenario_itb
      module procedure diff_arr_type_scenario_itb
      module procedure diff_type_scenario_lim_div_wall
      module procedure diff_arr_type_scenario_lim_div_wall
      module procedure diff_type_scenario_line_ave
      module procedure diff_arr_type_scenario_line_ave
      module procedure diff_type_scenario_neutron
      module procedure diff_arr_type_scenario_neutron
      module procedure diff_type_scenario_ninety_five
      module procedure diff_arr_type_scenario_ninety_five
      module procedure diff_type_scenario_pedestal
      module procedure diff_arr_type_scenario_pedestal
      module procedure diff_type_scenario_reactor
      module procedure diff_arr_type_scenario_reactor
      module procedure diff_type_scenario_ref
      module procedure diff_arr_type_scenario_ref
      module procedure diff_type_scenario_references
      module procedure diff_arr_type_scenario_references
      module procedure diff_type_scenario_sol
      module procedure diff_arr_type_scenario_sol
      module procedure diff_type_scenario_vol_ave
      module procedure diff_arr_type_scenario_vol_ave
      module procedure diff_type_setup_bprobe
      module procedure diff_arr_type_setup_bprobe
      module procedure diff_type_setup_floops
      module procedure diff_arr_type_setup_floops
      module procedure diff_type_setup_line
      module procedure diff_arr_type_setup_line
      module procedure diff_type_setup_line_exp
      module procedure diff_arr_type_setup_line_exp
      module procedure diff_type_shield
      module procedure diff_arr_type_shield
      module procedure diff_type_shield_specs
      module procedure diff_arr_type_shield_specs
      module procedure diff_type_simp_apert
      module procedure diff_arr_type_simp_apert
      module procedure diff_type_solcurdiag_sol_current
      module procedure diff_arr_type_solcurdiag_sol_current
      module procedure diff_type_solcurdiag_sol_current_setup
      module procedure diff_arr_type_solcurdiag_sol_current_setup
      module procedure diff_type_source_imp
      module procedure diff_arr_type_source_imp
      module procedure diff_type_source_ion
      module procedure diff_arr_type_source_ion
      module procedure diff_type_source_rate
      module procedure diff_arr_type_source_rate
      module procedure diff_type_source_vec
      module procedure diff_arr_type_source_vec
      module procedure diff_type_sourceel
      module procedure diff_arr_type_sourceel
      module procedure diff_type_sourceimp
      module procedure diff_arr_type_sourceimp
      module procedure diff_type_sourceion
      module procedure diff_arr_type_sourceion
      module procedure diff_type_species_desc
      module procedure diff_arr_type_species_desc
      module procedure diff_type_species_reference
      module procedure diff_arr_type_species_reference
      module procedure diff_type_spectral
      module procedure diff_arr_type_spectral
      module procedure diff_type_spectrum
      module procedure diff_arr_type_spectrum
      module procedure diff_type_spot
      module procedure diff_arr_type_spot
      module procedure diff_type_sputtering_neutrals
      module procedure diff_arr_type_sputtering_neutrals
      module procedure diff_type_straps
      module procedure diff_arr_type_straps
      module procedure diff_type_structure_cs
      module procedure diff_arr_type_structure_cs
      module procedure diff_type_t_series_cplx
      module procedure diff_arr_type_t_series_cplx
      module procedure diff_type_t_series_real
      module procedure diff_arr_type_t_series_real
      module procedure diff_type_table
      module procedure diff_arr_type_table
      module procedure diff_type_tables
      module procedure diff_arr_type_tables
      module procedure diff_type_tables_coord
      module procedure diff_arr_type_tables_coord
      module procedure diff_type_temporary_nt
      module procedure diff_arr_type_temporary_nt
      module procedure diff_type_temporary_nt_0dc
      module procedure diff_arr_type_temporary_nt_0dc
      module procedure diff_type_temporary_nt_0di
      module procedure diff_arr_type_temporary_nt_0di
      module procedure diff_type_temporary_nt_0dr
      module procedure diff_arr_type_temporary_nt_0dr
      module procedure diff_type_temporary_nt_0ds
      module procedure diff_arr_type_temporary_nt_0ds
      module procedure diff_type_temporary_nt_1dc
      module procedure diff_arr_type_temporary_nt_1dc
      module procedure diff_type_temporary_nt_1di
      module procedure diff_arr_type_temporary_nt_1di
      module procedure diff_type_temporary_nt_1dr
      module procedure diff_arr_type_temporary_nt_1dr
      module procedure diff_type_temporary_nt_1ds
      module procedure diff_arr_type_temporary_nt_1ds
      module procedure diff_type_temporary_nt_2dc
      module procedure diff_arr_type_temporary_nt_2dc
      module procedure diff_type_temporary_nt_2di
      module procedure diff_arr_type_temporary_nt_2di
      module procedure diff_type_temporary_nt_2dr
      module procedure diff_arr_type_temporary_nt_2dr
      module procedure diff_type_temporary_nt_3dc
      module procedure diff_arr_type_temporary_nt_3dc
      module procedure diff_type_temporary_nt_3di
      module procedure diff_arr_type_temporary_nt_3di
      module procedure diff_type_temporary_nt_3dr
      module procedure diff_arr_type_temporary_nt_3dr
      module procedure diff_type_temporary_nt_4dr
      module procedure diff_arr_type_temporary_nt_4dr
      module procedure diff_type_temporary_t
      module procedure diff_arr_type_temporary_t
      module procedure diff_type_temporary_t_0dc
      module procedure diff_arr_type_temporary_t_0dc
      module procedure diff_type_temporary_t_0di
      module procedure diff_arr_type_temporary_t_0di
      module procedure diff_type_temporary_t_0dr
      module procedure diff_arr_type_temporary_t_0dr
      module procedure diff_type_temporary_t_0ds
      module procedure diff_arr_type_temporary_t_0ds
      module procedure diff_type_temporary_t_1dc
      module procedure diff_arr_type_temporary_t_1dc
      module procedure diff_type_temporary_t_1di
      module procedure diff_arr_type_temporary_t_1di
      module procedure diff_type_temporary_t_1dr
      module procedure diff_arr_type_temporary_t_1dr
      module procedure diff_type_temporary_t_2dc
      module procedure diff_arr_type_temporary_t_2dc
      module procedure diff_type_temporary_t_2di
      module procedure diff_arr_type_temporary_t_2di
      module procedure diff_type_temporary_t_2dr
      module procedure diff_arr_type_temporary_t_2dr
      module procedure diff_type_temporary_t_3dc
      module procedure diff_arr_type_temporary_t_3dc
      module procedure diff_type_temporary_t_3di
      module procedure diff_arr_type_temporary_t_3di
      module procedure diff_type_temporary_t_3dr
      module procedure diff_arr_type_temporary_t_3dr
      module procedure diff_type_temporary_t_4dr
      module procedure diff_arr_type_temporary_t_4dr
      module procedure diff_type_tf_desc_tfcoils
      module procedure diff_arr_type_tf_desc_tfcoils
      module procedure diff_type_tf_desc_tfcoils_board
      module procedure diff_arr_type_tf_desc_tfcoils_board
      module procedure diff_type_tf_structure
      module procedure diff_arr_type_tf_structure
      module procedure diff_type_theta_info
      module procedure diff_arr_type_theta_info
      module procedure diff_type_topo_regions
      module procedure diff_arr_type_topo_regions
      module procedure diff_type_toroid_field
      module procedure diff_arr_type_toroid_field
      module procedure diff_type_trace
      module procedure diff_arr_type_trace
      module procedure diff_type_transcoefel
      module procedure diff_arr_type_transcoefel
      module procedure diff_type_transcoefimp
      module procedure diff_arr_type_transcoefimp
      module procedure diff_type_transcoefion
      module procedure diff_arr_type_transcoefion
      module procedure diff_type_transcoefvtor
      module procedure diff_arr_type_transcoefvtor
      module procedure diff_type_trap_type
      module procedure diff_arr_type_trap_type
      module procedure diff_type_trianglexyz
      module procedure diff_arr_type_trianglexyz
      module procedure diff_type_tsmeasure
      module procedure diff_arr_type_tsmeasure
      module procedure diff_type_tssetup
      module procedure diff_arr_type_tssetup
      module procedure diff_type_turbcomposition
      module procedure diff_arr_type_turbcomposition
      module procedure diff_type_turbcoordsys
      module procedure diff_arr_type_turbcoordsys
      module procedure diff_type_turbenv1d
      module procedure diff_arr_type_turbenv1d
      module procedure diff_type_turbgrid
      module procedure diff_arr_type_turbgrid
      module procedure diff_type_turbspec1d
      module procedure diff_arr_type_turbspec1d
      module procedure diff_type_turbvar0d
      module procedure diff_arr_type_turbvar0d
      module procedure diff_type_turbvar1d
      module procedure diff_arr_type_turbvar1d
      module procedure diff_type_turbvar2d
      module procedure diff_arr_type_turbvar2d
      module procedure diff_type_turbvar3d
      module procedure diff_arr_type_turbvar3d
      module procedure diff_type_turbvar4d
      module procedure diff_arr_type_turbvar4d
      module procedure diff_type_turbvar5d
      module procedure diff_arr_type_turbvar5d
      module procedure diff_type_version_ind
      module procedure diff_arr_type_version_ind
      module procedure diff_type_wall2d
      module procedure diff_arr_type_wall2d
      module procedure diff_type_wall2d_mhd
      module procedure diff_arr_type_wall2d_mhd
      module procedure diff_type_wall3d
      module procedure diff_arr_type_wall3d
      module procedure diff_type_wall_blocks
      module procedure diff_arr_type_wall_blocks
      module procedure diff_type_wall_blocks_unit
      module procedure diff_arr_type_wall_blocks_unit
      module procedure diff_type_wall_limiter
      module procedure diff_arr_type_wall_limiter
      module procedure diff_type_wall_types
      module procedure diff_arr_type_wall_types
      module procedure diff_type_wall_types_layers
      module procedure diff_arr_type_wall_types_layers
      module procedure diff_type_wall_unitsComplexType
      module procedure diff_arr_type_wall_unitsComplexType
      module procedure diff_type_wall_unitsComplexType_layers
      module procedure diff_arr_type_wall_unitsComplexType_layers
      module procedure diff_type_wall_vessel
      module procedure diff_arr_type_wall_vessel
      module procedure diff_type_wall_vessel_annular
      module procedure diff_arr_type_wall_vessel_annular
      module procedure diff_type_wall_vessel_unit
      module procedure diff_arr_type_wall_vessel_unit
      module procedure diff_type_wall_wall0d
      module procedure diff_arr_type_wall_wall0d
      module procedure diff_type_wall_wall0d_plasma
      module procedure diff_arr_type_wall_wall0d_plasma
      module procedure diff_type_wall_wall2d_vessel_radial_build
      module procedure diff_arr_type_wall_wall2d_vessel_radial_build
      module procedure diff_type_waveguides
      module procedure diff_arr_type_waveguides
      module procedure diff_type_waves_global_param
      module procedure diff_arr_type_waves_global_param
      module procedure diff_type_waves_grid_1d
      module procedure diff_arr_type_waves_grid_1d
      module procedure diff_type_waves_grid_2d
      module procedure diff_arr_type_waves_grid_2d
      module procedure diff_type_waves_profiles_1d
      module procedure diff_arr_type_waves_profiles_1d
      module procedure diff_type_waves_profiles_2d
      module procedure diff_arr_type_waves_profiles_2d
      module procedure diff_type_waves_rtposition
      module procedure diff_arr_type_waves_rtposition
      module procedure diff_type_waves_rtwavevector
      module procedure diff_arr_type_waves_rtwavevector
      module procedure diff_type_weighted_markers
      module procedure diff_arr_type_weighted_markers
      module procedure diff_type_whatref
      module procedure diff_arr_type_whatref
      module procedure diff_type_width
      module procedure diff_arr_type_width
      module procedure diff_type_xpts
      module procedure diff_arr_type_xpts
      module procedure diff_type_xyz0D
      module procedure diff_arr_type_xyz0D
   end interface
 
   integer, parameter, private :: iu6 = 6
   integer, private :: verbose = 0
   integer, private :: diff_counter
   real(euitm_r8), private :: error_level
 
 contains
 
 
   subroutine set_diff_verbosity(verbosity)
 
     use euitm_schemas
     implicit none
 
     integer, intent(in) :: verbosity
 
     if (verbosity < 0) then
       verbose = 0
     else
       verbose = verbosity
     end if
 
   end subroutine set_diff_verbosity
 
   subroutine reset_diff_counter
 
     use euitm_schemas
     implicit none
 
     diff_counter = 0
 
   end subroutine reset_diff_counter
 
   function get_diff_counter() result (f_counter)
 
     use euitm_schemas
     implicit none
 
     integer :: f_counter
 
     f_counter = diff_counter
 
   end function get_diff_counter
 
   subroutine set_error_level(err_level)
 
     use euitm_schemas
     implicit none
 
     real(euitm_r8) :: err_level
 
     error_level = err_level
 
   end subroutine set_error_level
 
   function get_error_level() result (f_error_level)
 
     use euitm_schemas
     implicit none
 
     real(euitm_r8) :: f_error_level
 
     f_error_level = error_level
 
   end function get_error_level
 
   subroutine diff_type_integer(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     integer, intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     if (structure_ref /= -999999999) then
       if (structure_new /= -999999999) then
         if (structure_ref /= structure_new) then
           diff_counter = diff_counter + 1
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'differs in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (structure_new /= -999999999) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_type_integer

   subroutine diff_type_float(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string

     if (structure_ref /= -9.0D40) then
       if (structure_new /= -9.0D40) then
         output_string = func(reference_field_float = structure_ref, &
          new_field_float = structure_new, diff_counter = diff_counter, error_level = error_level)
         if (verbose > 0) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) trim(adjustl(output_string))
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (structure_new /= -9.0D40) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_type_float

   subroutine diff_type_array3dcplx_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type:, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array3dcplx_type

   subroutine diff_type_array3dflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_array3dflt_type = structure_ref, & 
            new_field_array3dflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array3dflt_type

   subroutine diff_type_array3dint_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     integer, dimension(:, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           if (any(structure_ref /= structure_new)) then
             diff_counter = diff_counter + 1
             if (verbose > 0) then
               write(iu6, *) trim(adjustl(name))
               write(iu6, *) 'differs in reference and new CPO'
             end if
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array3dint_type

   subroutine diff_type_array4dflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_array4dflt_type = structure_ref, & 
            new_field_array4dflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array4dflt_type

   subroutine diff_type_array5dflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :, :, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_array5dflt_type = structure_ref, & 
            new_field_array5dflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array5dflt_type

   subroutine diff_type_array6dflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :, :, :, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_array6dflt_type = structure_ref, & 
            new_field_array6dflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array6dflt_type

   subroutine diff_type_array7dflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_array7dflt_type = structure_ref, & 
            new_field_array7dflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_array7dflt_type

   subroutine diff_type_matcplx_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer :: structure_ref, structure_new:, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_matcplx_type

   subroutine diff_type_matflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_matflt_type = structure_ref, & 
            new_field_matflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_matflt_type

   subroutine diff_type_matint_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     integer, dimension(:, :), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           if (any(structure_ref /= structure_new)) then
             diff_counter = diff_counter + 1
             if (verbose > 0) then
               write(iu6, *) trim(adjustl(name))
               write(iu6, *) 'differs in reference and new CPO'
             end if
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_matint_type

   subroutine diff_type_veccplx_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     integer, dimension(:, :), pointer :: structure_ref, structure_new:), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_veccplx_type

   subroutine diff_type_vecflt_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     real(euitm_r8), dimension(:), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           output_string = func(reference_field_vecflt_type = structure_ref, & 
            new_field_vecflt_type = structure_new, diff_counter = diff_counter, error_level = error_level)
           if (verbose > 0) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) trim(adjustl(output_string))
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_vecflt_type

   subroutine diff_type_vecint_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     integer, dimension(:), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           if (any(structure_ref /= structure_new)) then
             diff_counter = diff_counter + 1
             if (verbose > 0) then
               write(iu6, *) trim(adjustl(name))
               write(iu6, *) 'differs in reference and new CPO'
             end if
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_vecint_type

   subroutine diff_type_vecstring_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     character(len = 132), dimension(:), pointer :: structure_ref, structure_new
     character(len = *), intent(in) :: name
     character(len = 132) :: output_string
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           if (any(structure_ref /= structure_new)) then
             diff_counter = diff_counter + 1
             if (verbose > 0) then
               write(iu6, *) trim(adjustl(name))
               write(iu6, *) 'differs in reference and new CPO'
             end if
           end if
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if
 
   end subroutine diff_type_vecstring_type

   subroutine diff_type_amns(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_amns), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%version, structure_new%version, trim(name) // "%version", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_arr_type_amns_processType(structure_ref%process, structure_new%process, trim(name) // "%process", func)
     call diff_arr_type_tables(structure_ref%tables, structure_new%tables, trim(name) // "%tables", func)
     call diff_arr_type_tables_coord(structure_ref%tables_coord, structure_new%tables_coord, trim(name) // "%tables_coord", func)
     call diff_arr_type_version_ind(structure_ref%version_ind, structure_new%version_ind, trim(name) // "%version_ind", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_amns

   subroutine diff_arr_type_amns(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_amns), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_amns(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_amns

   subroutine diff_type_antennas(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antennas), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_antenna_ec(structure_ref%antenna_ec, structure_new%antenna_ec, trim(name) // "%antenna_ec", func)
     call diff_arr_type_antenna_ic(structure_ref%antenna_ic, structure_new%antenna_ic, trim(name) // "%antenna_ic", func)
     call diff_arr_type_antenna_lh(structure_ref%antenna_lh, structure_new%antenna_lh, trim(name) // "%antenna_lh", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_antennas

   subroutine diff_arr_type_antennas(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antennas), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_antennas(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_antennas

   subroutine diff_type_bb_shield(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_shield), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_limits(structure_ref%limits, structure_new%limits, trim(name) // "%limits", func)
     call diff_type_float(structure_ref%li6_enrich, structure_new%li6_enrich, trim(name) // "%li6_enrich", func)
     call diff_type_geom(structure_ref%geom, structure_new%geom, trim(name) // "%geom", func)
     call diff_type_neut_results(structure_ref%neut_results, structure_new%neut_results, trim(name) // "%neut_results", func)
     call diff_type_shield(structure_ref%shield, structure_new%shield, trim(name) // "%shield", func)
     call diff_type_bb(structure_ref%bb, structure_new%bb, trim(name) // "%bb", func)
     call diff_type_hcll(structure_ref%hcll, structure_new%hcll, trim(name) // "%hcll", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_bb_shield

   subroutine diff_arr_type_bb_shield(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_shield), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_bb_shield(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_bb_shield

   subroutine diff_type_compositionc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_compositionc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_compositionc

   subroutine diff_arr_type_compositionc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_compositionc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_compositionc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_compositionc

   subroutine diff_type_coredelta(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coredelta), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_arr_type_coredelta_values(structure_ref%values, structure_new%values, trim(name) // "%values", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_coredelta

   subroutine diff_arr_type_coredelta(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coredelta), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coredelta(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coredelta

   subroutine diff_type_corefast(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefast), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
     call diff_arr_type_corefast_values(structure_ref%values, structure_new%values, trim(name) // "%values", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_corefast

   subroutine diff_arr_type_corefast(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefast), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefast(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefast

   subroutine diff_type_coreimpur(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpur), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecint_type(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_vecstring_type(structure_ref%atomic_data, structure_new%atomic_data, trim(name) // "%atomic_data", func)
     call diff_arr_type_impurity_type(structure_ref%impurity, structure_new%impurity, trim(name) // "%impurity", func)
     call diff_type_coreimpurediag_type(structure_ref%diagnostic, structure_new%diagnostic, trim(name) // "%diagnostic", func)
     call diff_type_coreimpurediag_sum(structure_ref%diagnosticsum, structure_new%diagnosticsum, trim(name) // "%diagnosticsum", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_coreimpur

   subroutine diff_arr_type_coreimpur(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpur), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpur(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpur

   subroutine diff_type_coreneutrals(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreneutrals), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_composition_neutrals(structure_ref%neutcompo, structure_new%neutcompo, trim(name) // "%neutcompo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_arr_type_neutral_complex_type(structure_ref%profiles, structure_new%profiles, trim(name) // "%profiles", func)
     call diff_arr_type_coefficients_neutrals(structure_ref%ioncoeff, structure_new%ioncoeff, trim(name) // "%ioncoeff", func)
     call diff_arr_type_impcoeff(structure_ref%impcoeff, structure_new%impcoeff, trim(name) // "%impcoeff", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_coreneutrals

   subroutine diff_arr_type_coreneutrals(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreneutrals), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreneutrals(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreneutrals

   subroutine diff_type_coreprof(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreprof), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%drho_dt, structure_new%drho_dt, trim(name) // "%drho_dt", func)
     call diff_type_toroid_field(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_psi(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_corefield(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_corefieldion(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_corefield(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_corefieldion(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_corefieldion(structure_ref%vtor, structure_new%vtor, trim(name) // "%vtor", func)
     call diff_type_profiles1d(structure_ref%profiles1d, structure_new%profiles1d, trim(name) // "%profiles1d", func)
     call diff_type_globalparam(structure_ref%globalparam, structure_new%globalparam, trim(name) // "%globalparam", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_coreprof

   subroutine diff_arr_type_coreprof(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreprof), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreprof(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreprof

   subroutine diff_type_coresource(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coresource), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
     call diff_arr_type_coresource_values(structure_ref%values, structure_new%values, trim(name) // "%values", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_coresource

   subroutine diff_arr_type_coresource(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coresource), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coresource(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coresource

   subroutine diff_type_coretransp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_arr_type_coretransp_values(structure_ref%values, structure_new%values, trim(name) // "%values", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_coretransp

   subroutine diff_arr_type_coretransp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coretransp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coretransp

   subroutine diff_type_cxdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_cxdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_cxsetup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_cxmeasure(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_cxdiag

   subroutine diff_arr_type_cxdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_cxdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_cxdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_cxdiag

   subroutine diff_type_distribution(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distribution), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_arr_type_distri_vec(structure_ref%distri_vec, structure_new%distri_vec, trim(name) // "%distri_vec", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_distribution

   subroutine diff_arr_type_distribution(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distribution), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distribution(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distribution

   subroutine diff_type_distsource(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_arr_type_distsource_source(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_distsource

   subroutine diff_arr_type_distsource(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distsource(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distsource

   subroutine diff_type_ecediag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ecediag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_ecesetup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_ecemeasure(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_ecediag

   subroutine diff_arr_type_ecediag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ecediag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ecediag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ecediag

   subroutine diff_type_edge(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_complexgrid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_arr_type_species_desc(structure_ref%species, structure_new%species, trim(name) // "%species", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_edge_fluid(structure_ref%fluid, structure_new%fluid, trim(name) // "%fluid", func)
     call diff_type_edge_kinetic(structure_ref%kinetic, structure_new%kinetic, trim(name) // "%kinetic", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_edge

   subroutine diff_arr_type_edge(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge

   subroutine diff_type_efcc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_efcc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_coil(structure_ref%coil, structure_new%coil, trim(name) // "%coil", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)

   end subroutine diff_type_efcc

   subroutine diff_arr_type_efcc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_efcc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_efcc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_efcc

   subroutine diff_type_equilibrium(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equilibrium), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_eqconstraint(structure_ref%eqconstraint, structure_new%eqconstraint, trim(name) // "%eqconstraint", func)
     call diff_type_eqgeometry(structure_ref%eqgeometry, structure_new%eqgeometry, trim(name) // "%eqgeometry", func)
     call diff_type_flush(structure_ref%flush, structure_new%flush, trim(name) // "%flush", func)
     call diff_type_global_param(structure_ref%global_param, structure_new%global_param, trim(name) // "%global_param", func)
     call diff_type_profiles_1d(structure_ref%profiles_1d, structure_new%profiles_1d, trim(name) // "%profiles_1d", func)
     call diff_arr_type_equilibrium_profiles_2d(structure_ref%profiles_2d, structure_new%profiles_2d, trim(name) // "%profiles_2d", func)
     call diff_type_coord_sys(structure_ref%coord_sys, structure_new%coord_sys, trim(name) // "%coord_sys", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)

   end subroutine diff_type_equilibrium

   subroutine diff_arr_type_equilibrium(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equilibrium), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_equilibrium(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_equilibrium

   subroutine diff_type_fusiondiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_fusiondiag_fus_product(structure_ref%fus_product, structure_new%fus_product, trim(name) // "%fus_product", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_fusiondiag

   subroutine diff_arr_type_fusiondiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag

   subroutine diff_type_halphadiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_halphadiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_halpha_setup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_exp1D(structure_ref%intensity, structure_new%intensity, trim(name) // "%intensity", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_halphadiag

   subroutine diff_arr_type_halphadiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_halphadiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_halphadiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_halphadiag

   subroutine diff_type_heat_sources(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_heat_sources), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_calorimetry_heat_source(structure_ref%sources, structure_new%sources, trim(name) // "%sources", func)
     call diff_arr_type_calorimetry_heat_source(structure_ref%sinks, structure_new%sinks, trim(name) // "%sinks", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_heat_sources

   subroutine diff_arr_type_heat_sources(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_heat_sources), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_heat_sources(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_heat_sources

   subroutine diff_type_interfdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_interfdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%expression, structure_new%expression, trim(name) // "%expression", func)
     call diff_type_setup_line(structure_ref%setup_line, structure_new%setup_line, trim(name) // "%setup_line", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_interfdiag

   subroutine diff_arr_type_interfdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_interfdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_interfdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_interfdiag

   subroutine diff_type_ironmodel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ironmodel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_desc_iron(structure_ref%desc_iron, structure_new%desc_iron, trim(name) // "%desc_iron", func)
     call diff_type_magnetise(structure_ref%magnetise, structure_new%magnetise, trim(name) // "%magnetise", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_ironmodel

   subroutine diff_arr_type_ironmodel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ironmodel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ironmodel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ironmodel

   subroutine diff_type_langmuirdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_langmuirdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_lang_measure(structure_ref%potential, structure_new%potential, trim(name) // "%potential", func)
     call diff_type_lang_measure(structure_ref%bias, structure_new%bias, trim(name) // "%bias", func)
     call diff_type_lang_measure(structure_ref%jsat, structure_new%jsat, trim(name) // "%jsat", func)
     call diff_type_lang_derived(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_lang_derived(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_lang_derived(structure_ref%machpar, structure_new%machpar, trim(name) // "%machpar", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_langmuirdiag

   subroutine diff_arr_type_langmuirdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_langmuirdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_langmuirdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_langmuirdiag

   subroutine diff_type_launchs(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_vecint_type(structure_ref%mode, structure_new%mode, trim(name) // "%mode", func)
     call diff_type_rzphi1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_spectrum(structure_ref%spectrum, structure_new%spectrum, trim(name) // "%spectrum", func)
     call diff_type_launchs_rfbeam(structure_ref%beam, structure_new%beam, trim(name) // "%beam", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_launchs

   subroutine diff_arr_type_launchs(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchs(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchs

   subroutine diff_type_lithiumdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lithiumdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_lithsetup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_lithmeasure(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_lithiumdiag

   subroutine diff_arr_type_lithiumdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lithiumdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_lithiumdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_lithiumdiag

   subroutine diff_type_magdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_magdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_exp0D(structure_ref%ip, structure_new%ip, trim(name) // "%ip", func)
     call diff_type_exp0D(structure_ref%diamagflux, structure_new%diamagflux, trim(name) // "%diamagflux", func)
     call diff_type_exp0D(structure_ref%diamagener, structure_new%diamagener, trim(name) // "%diamagener", func)
     call diff_type_flux_loops(structure_ref%flux_loops, structure_new%flux_loops, trim(name) // "%flux_loops", func)
     call diff_type_bpol_probes(structure_ref%bpol_probes, structure_new%bpol_probes, trim(name) // "%bpol_probes", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_magdiag

   subroutine diff_arr_type_magdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_magdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_magdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_magdiag

   subroutine diff_type_mhd(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
     call diff_arr_type_mhd_mode(structure_ref%n, structure_new%n, trim(name) // "%n", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)

   end subroutine diff_type_mhd

   subroutine diff_arr_type_mhd(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd

   subroutine diff_type_msediag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_polarimetry(structure_ref%polarimetry, structure_new%polarimetry, trim(name) // "%polarimetry", func)
     call diff_type_spectral(structure_ref%spectral, structure_new%spectral, trim(name) // "%spectral", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_msediag

   subroutine diff_arr_type_msediag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag

   subroutine diff_type_nbi(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_nbi_unit(structure_ref%nbi_unit, structure_new%nbi_unit, trim(name) // "%nbi_unit", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_nbi

   subroutine diff_arr_type_nbi(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_nbi(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_nbi

   subroutine diff_type_neoclassic(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neoclassic), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_desc_impur(structure_ref%desc_impur, structure_new%desc_impur, trim(name) // "%desc_impur", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_transcoefion(structure_ref%ni_neo, structure_new%ni_neo, trim(name) // "%ni_neo", func)
     call diff_type_transcoefel(structure_ref%ne_neo, structure_new%ne_neo, trim(name) // "%ne_neo", func)
     call diff_arr_type_transcoefimp(structure_ref%nz_neo, structure_new%nz_neo, trim(name) // "%nz_neo", func)
     call diff_type_transcoefion(structure_ref%ti_neo, structure_new%ti_neo, trim(name) // "%ti_neo", func)
     call diff_type_transcoefel(structure_ref%te_neo, structure_new%te_neo, trim(name) // "%te_neo", func)
     call diff_arr_type_transcoefimp(structure_ref%tz_neo, structure_new%tz_neo, trim(name) // "%tz_neo", func)
     call diff_type_transcoefel(structure_ref%mtor_neo, structure_new%mtor_neo, trim(name) // "%mtor_neo", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_vecflt_type(structure_ref%jboot, structure_new%jboot, trim(name) // "%jboot", func)
     call diff_type_vecflt_type(structure_ref%er, structure_new%er, trim(name) // "%er", func)
     call diff_type_matflt_type(structure_ref%vpol, structure_new%vpol, trim(name) // "%vpol", func)
     call diff_type_matflt_type(structure_ref%vtor, structure_new%vtor, trim(name) // "%vtor", func)
     call diff_type_matflt_type(structure_ref%mach, structure_new%mach, trim(name) // "%mach", func)
     call diff_type_vecflt_type(structure_ref%utheta_e, structure_new%utheta_e, trim(name) // "%utheta_e", func)
     call diff_type_matflt_type(structure_ref%utheta_i, structure_new%utheta_i, trim(name) // "%utheta_i", func)
     call diff_type_matflt_type(structure_ref%viscosity_par, structure_new%viscosity_par, trim(name) // "%viscosity_par", func)
     call diff_arr_type_neoclassic_impurity(structure_ref%impurity, structure_new%impurity, trim(name) // "%impurity", func)
     call diff_type_array3dflt_type(structure_ref%fext, structure_new%fext, trim(name) // "%fext", func)
     call diff_type_vecflt_type(structure_ref%jext, structure_new%jext, trim(name) // "%jext", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)

   end subroutine diff_type_neoclassic

   subroutine diff_arr_type_neoclassic(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neoclassic), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_neoclassic(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_neoclassic

   subroutine diff_type_ntm(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_ntm_mode(structure_ref%mode, structure_new%mode, trim(name) // "%mode", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)

   end subroutine diff_type_ntm

   subroutine diff_arr_type_ntm(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm

   subroutine diff_type_orbit(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_com(structure_ref%com, structure_new%com, trim(name) // "%com", func)
     call diff_type_trace(structure_ref%trace, structure_new%trace, trim(name) // "%trace", func)
     call diff_type_orbit_global_param(structure_ref%global_param, structure_new%global_param, trim(name) // "%global_param", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_orbit

   subroutine diff_arr_type_orbit(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_orbit(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_orbit

   subroutine diff_type_pellets(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellets), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_arr_type_pellet(structure_ref%pellet, structure_new%pellet, trim(name) // "%pellet", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_pellets

   subroutine diff_arr_type_pellets(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellets), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellets(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellets

   subroutine diff_type_pfsystems(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfsystems), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_pfcoils(structure_ref%pfcoils, structure_new%pfcoils, trim(name) // "%pfcoils", func)
     call diff_type_pfpassive(structure_ref%pfpassive, structure_new%pfpassive, trim(name) // "%pfpassive", func)
     call diff_type_pfcircuits(structure_ref%pfcircuits, structure_new%pfcircuits, trim(name) // "%pfcircuits", func)
     call diff_type_pfsupplies(structure_ref%pfsupplies, structure_new%pfsupplies, trim(name) // "%pfsupplies", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_pfsystems

   subroutine diff_arr_type_pfsystems(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfsystems), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfsystems(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfsystems

   subroutine diff_type_polardiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_polardiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%expression, structure_new%expression, trim(name) // "%expression", func)
     call diff_type_setup_line(structure_ref%setup_line, structure_new%setup_line, trim(name) // "%setup_line", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_polardiag

   subroutine diff_arr_type_polardiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_polardiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_polardiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_polardiag

   subroutine diff_type_power_conv(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_power_conv), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%cycle_type, structure_new%cycle_type, trim(name) // "%cycle_type", func)
     call diff_arr_type_circuits(structure_ref%circuits, structure_new%circuits, trim(name) // "%circuits", func)
     call diff_type_float(structure_ref%power_recirc, structure_new%power_recirc, trim(name) // "%power_recirc", func)
     call diff_type_float(structure_ref%power_net, structure_new%power_net, trim(name) // "%power_net", func)
     call diff_type_float(structure_ref%power_int, structure_new%power_int, trim(name) // "%power_int", func)
     call diff_type_float(structure_ref%efficiency, structure_new%efficiency, trim(name) // "%efficiency", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_power_conv

   subroutine diff_arr_type_power_conv(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_power_conv), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_power_conv(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_power_conv

   subroutine diff_type_reflectomet(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectomet), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_refl_receive(structure_ref%refl_receive, structure_new%refl_receive, trim(name) // "%refl_receive", func)
     call diff_arr_type_reflectometry_antennas(structure_ref%antennas, structure_new%antennas, trim(name) // "%antennas", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_reflectomet

   subroutine diff_arr_type_reflectomet(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectomet), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reflectomet(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reflectomet

   subroutine diff_type_rfadiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfadiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_rfasetup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_rfameasure(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_rfadiag

   subroutine diff_arr_type_rfadiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfadiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rfadiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rfadiag

   subroutine diff_type_sawteeth(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sawteeth), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_integer(structure_ref%crash_trig, structure_new%crash_trig, trim(name) // "%crash_trig", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_sawteeth_profiles1d(structure_ref%profiles1d, structure_new%profiles1d, trim(name) // "%profiles1d", func)
     call diff_type_sawteeth_diags(structure_ref%diags, structure_new%diags, trim(name) // "%diags", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_sawteeth

   subroutine diff_arr_type_sawteeth(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sawteeth), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sawteeth(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sawteeth

   subroutine diff_type_scenario(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_scenario_centre(structure_ref%centre, structure_new%centre, trim(name) // "%centre", func)
     call diff_type_scenario_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_scenario_configuration(structure_ref%configs, structure_new%configs, trim(name) // "%configs", func)
     call diff_type_scenario_confinement(structure_ref%confinement, structure_new%confinement, trim(name) // "%confinement", func)
     call diff_type_scenario_currents(structure_ref%currents, structure_new%currents, trim(name) // "%currents", func)
     call diff_type_scenario_edge(structure_ref%edge, structure_new%edge, trim(name) // "%edge", func)
     call diff_type_scenario_energy(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_eqgeometry(structure_ref%eqgeometry, structure_new%eqgeometry, trim(name) // "%eqgeometry", func)
     call diff_type_scenario_global(structure_ref%global_param, structure_new%global_param, trim(name) // "%global_param", func)
     call diff_type_scenario_heat_power(structure_ref%heat_power, structure_new%heat_power, trim(name) // "%heat_power", func)
     call diff_type_scenario_itb(structure_ref%itb, structure_new%itb, trim(name) // "%itb", func)
     call diff_type_scenario_lim_div_wall(structure_ref%lim_div_wall, structure_new%lim_div_wall, trim(name) // "%lim_div_wall", func)
     call diff_type_scenario_line_ave(structure_ref%line_ave, structure_new%line_ave, trim(name) // "%line_ave", func)
     call diff_type_scenario_neutron(structure_ref%neutron, structure_new%neutron, trim(name) // "%neutron", func)
     call diff_type_scenario_ninety_five(structure_ref%ninety_five, structure_new%ninety_five, trim(name) // "%ninety_five", func)
     call diff_type_scenario_pedestal(structure_ref%pedestal, structure_new%pedestal, trim(name) // "%pedestal", func)
     call diff_type_scenario_references(structure_ref%references, structure_new%references, trim(name) // "%references", func)
     call diff_type_scenario_reactor(structure_ref%reactor, structure_new%reactor, trim(name) // "%reactor", func)
     call diff_type_scenario_sol(structure_ref%sol, structure_new%sol, trim(name) // "%sol", func)
     call diff_type_scenario_vol_ave(structure_ref%vol_ave, structure_new%vol_ave, trim(name) // "%vol_ave", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_scenario

   subroutine diff_arr_type_scenario(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario

   subroutine diff_type_solcurdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_solcurdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_solcurdiag_sol_current(structure_ref%sol_current, structure_new%sol_current, trim(name) // "%sol_current", func)
     call diff_arr_type_clusters(structure_ref%clusters, structure_new%clusters, trim(name) // "%clusters", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)

   end subroutine diff_type_solcurdiag

   subroutine diff_arr_type_solcurdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_solcurdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_solcurdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_solcurdiag

   subroutine diff_type_temporary(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_temporary_nt(structure_ref%non_timed, structure_new%non_timed, trim(name) // "%non_timed", func)
     call diff_type_temporary_t(structure_ref%timed, structure_new%timed, trim(name) // "%timed", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_temporary

   subroutine diff_arr_type_temporary(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary

   subroutine diff_type_topinfo(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_topinfo), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_vecstring_type(structure_ref%dataprovider, structure_new%dataprovider, trim(name) // "%dataprovider", func)
     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
     call diff_type_vecstring_type(structure_ref%firstputdate, structure_new%firstputdate, trim(name) // "%firstputdate", func)
     call diff_type_vecstring_type(structure_ref%lastupdate, structure_new%lastupdate, trim(name) // "%lastupdate", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecstring_type(structure_ref%comment, structure_new%comment, trim(name) // "%comment", func)
     call diff_type_vecstring_type(structure_ref%dataversion, structure_new%dataversion, trim(name) // "%dataversion", func)
     call diff_type_vecstring_type(structure_ref%workflow, structure_new%workflow, trim(name) // "%workflow", func)
     call diff_type_entry_def(structure_ref%entry, structure_new%entry, trim(name) // "%entry", func)
     call diff_type_entry_def(structure_ref%parent_entry, structure_new%parent_entry, trim(name) // "%parent_entry", func)
     call diff_type_mdinfo(structure_ref%mdinfo, structure_new%mdinfo, trim(name) // "%mdinfo", func)

   end subroutine diff_type_topinfo

   subroutine diff_arr_type_topinfo(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_topinfo), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_topinfo(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_topinfo

   subroutine diff_type_toroidfield(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_toroidfield), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_tf_desc_tfcoils(structure_ref%desc_tfcoils, structure_new%desc_tfcoils, trim(name) // "%desc_tfcoils", func)
     call diff_type_integer(structure_ref%nturns, structure_new%nturns, trim(name) // "%nturns", func)
     call diff_type_integer(structure_ref%ncoils, structure_new%ncoils, trim(name) // "%ncoils", func)
     call diff_type_exp0D(structure_ref%current, structure_new%current, trim(name) // "%current", func)
     call diff_type_exp0D(structure_ref%bvac_r, structure_new%bvac_r, trim(name) // "%bvac_r", func)
     call diff_type_float(structure_ref%r0, structure_new%r0, trim(name) // "%r0", func)
     call diff_type_float(structure_ref%p_cryo, structure_new%p_cryo, trim(name) // "%p_cryo", func)
     call diff_type_float(structure_ref%wp_nh_max, structure_new%wp_nh_max, trim(name) // "%wp_nh_max", func)
     call diff_type_float(structure_ref%tfc_nh, structure_new%tfc_nh, trim(name) // "%tfc_nh", func)
     call diff_type_float(structure_ref%neut_flux_inb, structure_new%neut_flux_inb, trim(name) // "%neut_flux_inb", func)
     call diff_type_float(structure_ref%neut_flux_outb, structure_new%neut_flux_outb, trim(name) // "%neut_flux_outb", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_toroidfield

   subroutine diff_arr_type_toroidfield(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_toroidfield), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_toroidfield(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_toroidfield

   subroutine diff_type_tsdiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tsdiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_tssetup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_tsmeasure(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_tsdiag

   subroutine diff_arr_type_tsdiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tsdiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tsdiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tsdiag

   subroutine diff_type_turbulence(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbulence), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_turbcomposition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_turbcoordsys(structure_ref%coordsys, structure_new%coordsys, trim(name) // "%coordsys", func)
     call diff_type_turbvar0d(structure_ref%var0d, structure_new%var0d, trim(name) // "%var0d", func)
     call diff_type_turbvar1d(structure_ref%var1d, structure_new%var1d, trim(name) // "%var1d", func)
     call diff_type_turbvar2d(structure_ref%var2d, structure_new%var2d, trim(name) // "%var2d", func)
     call diff_type_turbvar3d(structure_ref%var3d, structure_new%var3d, trim(name) // "%var3d", func)
     call diff_type_turbvar4d(structure_ref%var4d, structure_new%var4d, trim(name) // "%var4d", func)
     call diff_type_turbvar5d(structure_ref%var5d, structure_new%var5d, trim(name) // "%var5d", func)
     call diff_type_turbspec1d(structure_ref%spec1d, structure_new%spec1d, trim(name) // "%spec1d", func)
     call diff_type_turbenv1d(structure_ref%env1d, structure_new%env1d, trim(name) // "%env1d", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_turbulence

   subroutine diff_arr_type_turbulence(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbulence), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbulence(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbulence

   subroutine diff_type_wall(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_wall_wall0d(structure_ref%wall0d, structure_new%wall0d, trim(name) // "%wall0d", func)
     call diff_type_wall2d_mhd(structure_ref%wall2d_mhd, structure_new%wall2d_mhd, trim(name) // "%wall2d_mhd", func)
     call diff_arr_type_wall2d(structure_ref%wall2d, structure_new%wall2d, trim(name) // "%wall2d", func)
     call diff_arr_type_wall3d(structure_ref%wall3d, structure_new%wall3d, trim(name) // "%wall3d", func)
     call diff_arr_type_wall_types(structure_ref%wall_types, structure_new%wall_types, trim(name) // "%wall_types", func)
     call diff_arr_type_compound_desc(structure_ref%compounds, structure_new%compounds, trim(name) // "%compounds", func)
     call diff_arr_type_element_desc(structure_ref%elements, structure_new%elements, trim(name) // "%elements", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_wall

   subroutine diff_arr_type_wall(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall

   subroutine diff_type_waves(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name
 
     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_arr_type_coherentwave(structure_ref%coherentwave, structure_new%coherentwave, trim(name) // "%coherentwave", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)

   end subroutine diff_type_waves

   subroutine diff_arr_type_waves(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i

     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves

   subroutine diff_type_amns_constituentType(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_amns_constituentType), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_type_integer(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_integer(structure_ref%mn, structure_new%mn, trim(name) // "%mn", func)
     call diff_type_float(structure_ref%multiplicity, structure_new%multiplicity, trim(name) // "%multiplicity", func)
   end subroutine diff_type_amns_constituentType

   subroutine diff_arr_type_amns_constituentType(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_amns_constituentType), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_amns_constituentType(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_amns_constituentType

   subroutine diff_type_amns_processType(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_amns_processType), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%proc_label, structure_new%proc_label, trim(name) // "%proc_label", func)
     call diff_arr_type_reacprodType(structure_ref%reactant, structure_new%reactant, trim(name) // "%reactant", func)
     call diff_arr_type_reacprodType(structure_ref%product, structure_new%product, trim(name) // "%product", func)
     call diff_type_vecstring_type(structure_ref%sup_string, structure_new%sup_string, trim(name) // "%sup_string", func)
     call diff_type_vecflt_type(structure_ref%sup_real, structure_new%sup_real, trim(name) // "%sup_real", func)
     call diff_type_vecint_type(structure_ref%sup_int, structure_new%sup_int, trim(name) // "%sup_int", func)
     call diff_type_identifier(structure_ref%quality, structure_new%quality, trim(name) // "%quality", func)
     call diff_type_vecstring_type(structure_ref%err_proc_label, structure_new%err_proc_label, trim(name) // "%err_proc_label", func)
   end subroutine diff_type_amns_processType

   subroutine diff_arr_type_amns_processType(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_amns_processType), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_amns_processType(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_amns_processType

   subroutine diff_type_antenna_ec(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antenna_ec), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_exp0D(structure_ref%power, structure_new%power, trim(name) // "%power", func)
     call diff_type_integer(structure_ref%mode, structure_new%mode, trim(name) // "%mode", func)
     call diff_type_rzphi0D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_launchangles(structure_ref%launchangles, structure_new%launchangles, trim(name) // "%launchangles", func)
     call diff_type_rfbeam(structure_ref%beam, structure_new%beam, trim(name) // "%beam", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_antenna_ec

   subroutine diff_arr_type_antenna_ec(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antenna_ec), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_antenna_ec(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_antenna_ec

   subroutine diff_type_antenna_ic(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antenna_ic), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_exp0D(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_exp0D(structure_ref%power, structure_new%power, trim(name) // "%power", func)
     call diff_type_vecint_type(structure_ref%ntor, structure_new%ntor, trim(name) // "%ntor", func)
     call diff_type_vecflt_type(structure_ref%power_ntor, structure_new%power_ntor, trim(name) // "%power_ntor", func)
     call diff_type_antennaic_setup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_antenna_ic

   subroutine diff_arr_type_antenna_ic(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antenna_ic), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_antenna_ic(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_antenna_ic

   subroutine diff_type_antenna_lh(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antenna_lh), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_exp0D(structure_ref%power, structure_new%power, trim(name) // "%power", func)
     call diff_type_float(structure_ref%n_par, structure_new%n_par, trim(name) // "%n_par", func)
     call diff_type_rzphi0D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_antennalh_setup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_plasmaedge(structure_ref%plasmaedge, structure_new%plasmaedge, trim(name) // "%plasmaedge", func)
     call diff_type_rfbeam(structure_ref%beam, structure_new%beam, trim(name) // "%beam", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_antenna_lh

   subroutine diff_arr_type_antenna_lh(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antenna_lh), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_antenna_lh(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_antenna_lh

   subroutine diff_type_antennaic_setup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antennaic_setup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_straps(structure_ref%straps, structure_new%straps, trim(name) // "%straps", func)
     call diff_type_current(structure_ref%current, structure_new%current, trim(name) // "%current", func)
   end subroutine diff_type_antennaic_setup

   subroutine diff_arr_type_antennaic_setup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antennaic_setup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_antennaic_setup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_antennaic_setup

   subroutine diff_type_antennalh_setup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antennalh_setup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_modules(structure_ref%modules, structure_new%modules, trim(name) // "%modules", func)
   end subroutine diff_type_antennalh_setup

   subroutine diff_arr_type_antennalh_setup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_antennalh_setup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_antennalh_setup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_antennalh_setup

   subroutine diff_type_b0r0(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_b0r0), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%r0, structure_new%r0, trim(name) // "%r0", func)
     call diff_type_float(structure_ref%b0, structure_new%b0, trim(name) // "%b0", func)
   end subroutine diff_type_b0r0

   subroutine diff_arr_type_b0r0(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_b0r0), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_b0r0(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_b0r0

   subroutine diff_type_bb(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%nb_bb, structure_new%nb_bb, trim(name) // "%nb_bb", func)
     call diff_type_float(structure_ref%nb_bb_polcut, structure_new%nb_bb_polcut, trim(name) // "%nb_bb_polcut", func)
     call diff_type_float(structure_ref%teta_bb, structure_new%teta_bb, trim(name) // "%teta_bb", func)
     call diff_type_float(structure_ref%tbr, structure_new%tbr, trim(name) // "%tbr", func)
     call diff_type_neutro_resul(structure_ref%neutro_resul, structure_new%neutro_resul, trim(name) // "%neutro_resul", func)
     call diff_type_bb_specs(structure_ref%inboard, structure_new%inboard, trim(name) // "%inboard", func)
     call diff_type_bb_specs(structure_ref%outboard, structure_new%outboard, trim(name) // "%outboard", func)
   end subroutine diff_type_bb

   subroutine diff_arr_type_bb(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_bb(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_bb

   subroutine diff_type_bb_dimension(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_dimension), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%radial, structure_new%radial, trim(name) // "%radial", func)
     call diff_type_vecflt_type(structure_ref%toroidal, structure_new%toroidal, trim(name) // "%toroidal", func)
     call diff_type_vecflt_type(structure_ref%poloidal, structure_new%poloidal, trim(name) // "%poloidal", func)
   end subroutine diff_type_bb_dimension

   subroutine diff_arr_type_bb_dimension(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_dimension), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_bb_dimension(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_bb_dimension

   subroutine diff_type_bb_geometry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_geometry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%dr_fw, structure_new%dr_fw, trim(name) // "%dr_fw", func)
     call diff_type_float(structure_ref%dr_bz, structure_new%dr_bz, trim(name) // "%dr_bz", func)
     call diff_type_float(structure_ref%dr_bp, structure_new%dr_bp, trim(name) // "%dr_bp", func)
     call diff_type_vecflt_type(structure_ref%dr_bp_plates, structure_new%dr_bp_plates, trim(name) // "%dr_bp_plates", func)
     call diff_type_vecflt_type(structure_ref%dr_bp_he, structure_new%dr_bp_he, trim(name) // "%dr_bp_he", func)
     call diff_type_float(structure_ref%dr_man, structure_new%dr_man, trim(name) // "%dr_man", func)
     call diff_type_float(structure_ref%dt_sw, structure_new%dt_sw, trim(name) // "%dt_sw", func)
     call diff_type_float(structure_ref%dt_bz, structure_new%dt_bz, trim(name) // "%dt_bz", func)
     call diff_type_float(structure_ref%dp_bz, structure_new%dp_bz, trim(name) // "%dp_bz", func)
     call diff_type_bb_dimension(structure_ref%top_cap_dim, structure_new%top_cap_dim, trim(name) // "%top_cap_dim", func)
     call diff_type_bb_dimension(structure_ref%bot_cap_dim, structure_new%bot_cap_dim, trim(name) // "%bot_cap_dim", func)
     call diff_type_float(structure_ref%a_fw_ch, structure_new%a_fw_ch, trim(name) // "%a_fw_ch", func)
     call diff_type_float(structure_ref%b_fw_ch, structure_new%b_fw_ch, trim(name) // "%b_fw_ch", func)
     call diff_type_float(structure_ref%td_tc_ch, structure_new%td_tc_ch, trim(name) // "%td_tc_ch", func)
     call diff_type_float(structure_ref%rd_tc_ch, structure_new%rd_tc_ch, trim(name) // "%rd_tc_ch", func)
     call diff_type_float(structure_ref%td_bc_ch, structure_new%td_bc_ch, trim(name) // "%td_bc_ch", func)
     call diff_type_float(structure_ref%rd_bc_ch, structure_new%rd_bc_ch, trim(name) // "%rd_bc_ch", func)
     call diff_type_float(structure_ref%n_fw_ch, structure_new%n_fw_ch, trim(name) // "%n_fw_ch", func)
     call diff_type_float(structure_ref%n_fw_circ, structure_new%n_fw_circ, trim(name) // "%n_fw_circ", func)
     call diff_type_float(structure_ref%a_sg_ch, structure_new%a_sg_ch, trim(name) // "%a_sg_ch", func)
     call diff_type_float(structure_ref%b_sg_ch, structure_new%b_sg_ch, trim(name) // "%b_sg_ch", func)
     call diff_type_float(structure_ref%n_sg_ch, structure_new%n_sg_ch, trim(name) // "%n_sg_ch", func)
     call diff_type_float(structure_ref%sg_thick, structure_new%sg_thick, trim(name) // "%sg_thick", func)
     call diff_type_float(structure_ref%sg_weld, structure_new%sg_weld, trim(name) // "%sg_weld", func)
     call diff_type_float(structure_ref%sg_in_out, structure_new%sg_in_out, trim(name) // "%sg_in_out", func)
     call diff_type_float(structure_ref%r_sg_cp, structure_new%r_sg_cp, trim(name) // "%r_sg_cp", func)
     call diff_type_float(structure_ref%cp_tor_gap, structure_new%cp_tor_gap, trim(name) // "%cp_tor_gap", func)
     call diff_type_float(structure_ref%a_cp_ch, structure_new%a_cp_ch, trim(name) // "%a_cp_ch", func)
     call diff_type_float(structure_ref%b_cp_ch, structure_new%b_cp_ch, trim(name) // "%b_cp_ch", func)
     call diff_type_float(structure_ref%n_cp_ch, structure_new%n_cp_ch, trim(name) // "%n_cp_ch", func)
     call diff_type_float(structure_ref%cp_thick, structure_new%cp_thick, trim(name) // "%cp_thick", func)
     call diff_type_float(structure_ref%n_pol_bu, structure_new%n_pol_bu, trim(name) // "%n_pol_bu", func)
     call diff_type_float(structure_ref%n_tor_bu, structure_new%n_tor_bu, trim(name) // "%n_tor_bu", func)
     call diff_type_float(structure_ref%n_cp_bu, structure_new%n_cp_bu, trim(name) // "%n_cp_bu", func)
     call diff_type_float(structure_ref%cp_in_out, structure_new%cp_in_out, trim(name) // "%cp_in_out", func)
     call diff_type_float(structure_ref%he_man_tck, structure_new%he_man_tck, trim(name) // "%he_man_tck", func)
     call diff_type_float(structure_ref%man_tck, structure_new%man_tck, trim(name) // "%man_tck", func)
     call diff_type_float(structure_ref%pbli_bptb_od, structure_new%pbli_bptb_od, trim(name) // "%pbli_bptb_od", func)
     call diff_type_float(structure_ref%pbli_bptb_id, structure_new%pbli_bptb_id, trim(name) // "%pbli_bptb_id", func)
     call diff_type_float(structure_ref%he_bptb_od, structure_new%he_bptb_od, trim(name) // "%he_bptb_od", func)
     call diff_type_float(structure_ref%he_bptb_id, structure_new%he_bptb_id, trim(name) // "%he_bptb_id", func)
     call diff_type_float(structure_ref%dr_max_fw, structure_new%dr_max_fw, trim(name) // "%dr_max_fw", func)
     call diff_type_float(structure_ref%dr_fwpl, structure_new%dr_fwpl, trim(name) // "%dr_fwpl", func)
   end subroutine diff_type_bb_geometry

   subroutine diff_arr_type_bb_geometry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_geometry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_bb_geometry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_bb_geometry

   subroutine diff_type_bb_specs(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_specs), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%nbb, structure_new%nbb, trim(name) // "%nbb", func)
     call diff_type_float(structure_ref%r1, structure_new%r1, trim(name) // "%r1", func)
     call diff_type_float(structure_ref%r2, structure_new%r2, trim(name) // "%r2", func)
     call diff_type_bb_dimension(structure_ref%dimension, structure_new%dimension, trim(name) // "%dimension", func)
   end subroutine diff_type_bb_specs

   subroutine diff_arr_type_bb_specs(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bb_specs), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_bb_specs(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_bb_specs

   subroutine diff_type_beamletgroup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_beamletgroup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi0D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_float(structure_ref%tang_rad, structure_new%tang_rad, trim(name) // "%tang_rad", func)
     call diff_type_float(structure_ref%angle, structure_new%angle, trim(name) // "%angle", func)
     call diff_type_integer(structure_ref%direction, structure_new%direction, trim(name) // "%direction", func)
     call diff_type_float(structure_ref%width_horiz, structure_new%width_horiz, trim(name) // "%width_horiz", func)
     call diff_type_float(structure_ref%width_vert, structure_new%width_vert, trim(name) // "%width_vert", func)
     call diff_type_focussing(structure_ref%focussing, structure_new%focussing, trim(name) // "%focussing", func)
     call diff_type_divergence(structure_ref%divergence, structure_new%divergence, trim(name) // "%divergence", func)
     call diff_type_beamlets(structure_ref%beamlets, structure_new%beamlets, trim(name) // "%beamlets", func)
   end subroutine diff_type_beamletgroup

   subroutine diff_arr_type_beamletgroup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_beamletgroup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_beamletgroup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_beamletgroup

   subroutine diff_type_beamlets(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_beamlets), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_vecflt_type(structure_ref%tang_rad_blt, structure_new%tang_rad_blt, trim(name) // "%tang_rad_blt", func)
     call diff_type_vecflt_type(structure_ref%angle_blt, structure_new%angle_blt, trim(name) // "%angle_blt", func)
     call diff_type_vecflt_type(structure_ref%pow_frc_blt, structure_new%pow_frc_blt, trim(name) // "%pow_frc_blt", func)
   end subroutine diff_type_beamlets

   subroutine diff_arr_type_beamlets(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_beamlets), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_beamlets(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_beamlets

   subroutine diff_type_beamtracing(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_beamtracing), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
     call diff_type_float(structure_ref%power, structure_new%power, trim(name) // "%power", func)
     call diff_type_vecflt_type(structure_ref%dnpar, structure_new%dnpar, trim(name) // "%dnpar", func)
     call diff_type_vecflt_type(structure_ref%length, structure_new%length, trim(name) // "%length", func)
     call diff_type_waves_rtposition(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_waves_rtwavevector(structure_ref%wavevector, structure_new%wavevector, trim(name) // "%wavevector", func)
     call diff_type_polarization(structure_ref%polarization, structure_new%polarization, trim(name) // "%polarization", func)
     call diff_type_powerflow(structure_ref%powerflow, structure_new%powerflow, trim(name) // "%powerflow", func)
   end subroutine diff_type_beamtracing

   subroutine diff_arr_type_beamtracing(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_beamtracing), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_beamtracing(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_beamtracing

   subroutine diff_type_boundary(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundary), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_float(structure_ref%rho, structure_new%rho, trim(name) // "%rho", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_boundary

   subroutine diff_arr_type_boundary(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundary), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_boundary(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_boundary

   subroutine diff_type_boundary_neutrals(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundary_neutrals), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_integer(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_float(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
   end subroutine diff_type_boundary_neutrals

   subroutine diff_arr_type_boundary_neutrals(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundary_neutrals), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_boundary_neutrals(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_boundary_neutrals

   subroutine diff_type_boundaryel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundaryel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_float(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
   end subroutine diff_type_boundaryel

   subroutine diff_arr_type_boundaryel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundaryel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_boundaryel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_boundaryel

   subroutine diff_type_boundaryimp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundaryimp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecint_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%rho, structure_new%rho, trim(name) // "%rho", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_boundaryimp

   subroutine diff_arr_type_boundaryimp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundaryimp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_boundaryimp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_boundaryimp

   subroutine diff_type_boundaryion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundaryion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecint_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
   end subroutine diff_type_boundaryion

   subroutine diff_arr_type_boundaryion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_boundaryion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_boundaryion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_boundaryion

   subroutine diff_type_bpol_probes(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bpol_probes), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_setup_bprobe(structure_ref%setup_bprobe, structure_new%setup_bprobe, trim(name) // "%setup_bprobe", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_bpol_probes

   subroutine diff_arr_type_bpol_probes(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_bpol_probes), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_bpol_probes(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_bpol_probes

   subroutine diff_type_calorimetry_heat_source(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_calorimetry_heat_source), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_float(structure_ref%temp_in, structure_new%temp_in, trim(name) // "%temp_in", func)
     call diff_type_float(structure_ref%temp_out, structure_new%temp_out, trim(name) // "%temp_out", func)
     call diff_type_float(structure_ref%press_in, structure_new%press_in, trim(name) // "%press_in", func)
     call diff_type_float(structure_ref%press_out, structure_new%press_out, trim(name) // "%press_out", func)
     call diff_type_float(structure_ref%flow, structure_new%flow, trim(name) // "%flow", func)
     call diff_type_float(structure_ref%power, structure_new%power, trim(name) // "%power", func)
   end subroutine diff_type_calorimetry_heat_source

   subroutine diff_arr_type_calorimetry_heat_source(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_calorimetry_heat_source), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_calorimetry_heat_source(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_calorimetry_heat_source

   subroutine diff_type_circuits(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_circuits), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_power_conv_component(structure_ref%component, structure_new%component, trim(name) // "%component", func)
     call diff_type_float(structure_ref%power_net, structure_new%power_net, trim(name) // "%power_net", func)
     call diff_type_float(structure_ref%power_int, structure_new%power_int, trim(name) // "%power_int", func)
     call diff_type_float(structure_ref%efficiency, structure_new%efficiency, trim(name) // "%efficiency", func)
   end subroutine diff_type_circuits

   subroutine diff_arr_type_circuits(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_circuits), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_circuits(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_circuits

   subroutine diff_type_circularcoil(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_circularcoil), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz0D(structure_ref%centre, structure_new%centre, trim(name) // "%centre", func)
     call diff_type_float(structure_ref%hlength, structure_new%hlength, trim(name) // "%hlength", func)
     call diff_type_float(structure_ref%radialhwidth, structure_new%radialhwidth, trim(name) // "%radialhwidth", func)
   end subroutine diff_type_circularcoil

   subroutine diff_arr_type_circularcoil(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_circularcoil), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_circularcoil(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_circularcoil

   subroutine diff_type_clusters(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_clusters), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_integer(structure_ref%start, structure_new%start, trim(name) // "%start", func)
     call diff_type_integer(structure_ref%finish, structure_new%finish, trim(name) // "%finish", func)
   end subroutine diff_type_clusters

   subroutine diff_arr_type_clusters(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_clusters), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_clusters(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_clusters

   subroutine diff_type_codeparam(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_codeparam), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%codename, structure_new%codename, trim(name) // "%codename", func)
     call diff_type_vecstring_type(structure_ref%codeversion, structure_new%codeversion, trim(name) // "%codeversion", func)
     call diff_type_vecstring_type(structure_ref%parameters, structure_new%parameters, trim(name) // "%parameters", func)
     call diff_type_vecstring_type(structure_ref%output_diag, structure_new%output_diag, trim(name) // "%output_diag", func)
     call diff_type_integer(structure_ref%output_flag, structure_new%output_flag, trim(name) // "%output_flag", func)
   end subroutine diff_type_codeparam

   subroutine diff_arr_type_codeparam(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_codeparam), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_codeparam(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_codeparam

   subroutine diff_type_coefficients_neutrals(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coefficients_neutrals), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_recycling_neutrals(structure_ref%recycling, structure_new%recycling, trim(name) // "%recycling", func)
     call diff_type_sputtering_neutrals(structure_ref%sputtering, structure_new%sputtering, trim(name) // "%sputtering", func)
   end subroutine diff_type_coefficients_neutrals

   subroutine diff_arr_type_coefficients_neutrals(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coefficients_neutrals), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coefficients_neutrals(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coefficients_neutrals

   subroutine diff_type_coherentwave(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coherentwave), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_enum_instance(structure_ref%wave_id, structure_new%wave_id, trim(name) // "%wave_id", func)
     call diff_type_composition(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_compositions_type(structure_ref%compositions, structure_new%compositions, trim(name) // "%compositions", func)
     call diff_type_waves_global_param(structure_ref%global_param, structure_new%global_param, trim(name) // "%global_param", func)
     call diff_type_waves_grid_1d(structure_ref%grid_1d, structure_new%grid_1d, trim(name) // "%grid_1d", func)
     call diff_type_waves_grid_2d(structure_ref%grid_2d, structure_new%grid_2d, trim(name) // "%grid_2d", func)
     call diff_type_waves_profiles_1d(structure_ref%profiles_1d, structure_new%profiles_1d, trim(name) // "%profiles_1d", func)
     call diff_type_waves_profiles_2d(structure_ref%profiles_2d, structure_new%profiles_2d, trim(name) // "%profiles_2d", func)
     call diff_arr_type_beamtracing(structure_ref%beamtracing, structure_new%beamtracing, trim(name) // "%beamtracing", func)
     call diff_type_fullwave(structure_ref%fullwave, structure_new%fullwave, trim(name) // "%fullwave", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_coherentwave

   subroutine diff_arr_type_coherentwave(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coherentwave), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coherentwave(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coherentwave

   subroutine diff_type_coil(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coil), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_desc_coils(structure_ref%desc_coils, structure_new%desc_coils, trim(name) // "%desc_coils", func)
     call diff_type_exp1D(structure_ref%coilcurrent, structure_new%coilcurrent, trim(name) // "%coilcurrent", func)
     call diff_type_exp1D(structure_ref%coilvoltage, structure_new%coilvoltage, trim(name) // "%coilvoltage", func)
   end subroutine diff_type_coil

   subroutine diff_arr_type_coil(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coil), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coil(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coil

   subroutine diff_type_com(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_com), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_float(structure_ref%zion, structure_new%zion, trim(name) // "%zion", func)
     call diff_type_vecflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_vecflt_type(structure_ref%magn_mom, structure_new%magn_mom, trim(name) // "%magn_mom", func)
     call diff_type_vecflt_type(structure_ref%p_phi, structure_new%p_phi, trim(name) // "%p_phi", func)
     call diff_type_vecint_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
   end subroutine diff_type_com

   subroutine diff_arr_type_com(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_com), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_com(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_com

   subroutine diff_type_complexgrid(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%uid, structure_new%uid, trim(name) // "%uid", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_arr_type_complexgrid_space(structure_ref%spaces, structure_new%spaces, trim(name) // "%spaces", func)
     call diff_arr_type_complexgrid_subgrid(structure_ref%subgrids, structure_new%subgrids, trim(name) // "%subgrids", func)
     call diff_type_complexgrid_metric(structure_ref%metric, structure_new%metric, trim(name) // "%metric", func)
     call diff_arr_type_complexgrid_geo_global(structure_ref%geo, structure_new%geo, trim(name) // "%geo", func)
     call diff_arr_type_complexgrid_vector(structure_ref%bases, structure_new%bases, trim(name) // "%bases", func)
   end subroutine diff_type_complexgrid

   subroutine diff_arr_type_complexgrid(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid

   subroutine diff_type_complexgrid_geo_global(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_geo_global), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%geotype, structure_new%geotype, trim(name) // "%geotype", func)
     call diff_type_vecstring_type(structure_ref%geotypeid, structure_new%geotypeid, trim(name) // "%geotypeid", func)
     call diff_type_vecint_type(structure_ref%coordtype, structure_new%coordtype, trim(name) // "%coordtype", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%geo_matrix, structure_new%geo_matrix, trim(name) // "%geo_matrix", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_complexgrid_geo_global

   subroutine diff_arr_type_complexgrid_geo_global(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_geo_global), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_geo_global(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_geo_global

   subroutine diff_type_complexgrid_indexlist(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_indexlist), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%range, structure_new%range, trim(name) // "%range", func)
     call diff_type_vecint_type(structure_ref%ind, structure_new%ind, trim(name) // "%ind", func)
   end subroutine diff_type_complexgrid_indexlist

   subroutine diff_arr_type_complexgrid_indexlist(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_indexlist), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_indexlist(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_indexlist

   subroutine diff_type_complexgrid_metric(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_metric), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_complexgrid_scalar(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%g11, structure_new%g11, trim(name) // "%g11", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%g12, structure_new%g12, trim(name) // "%g12", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%g13, structure_new%g13, trim(name) // "%g13", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%g22, structure_new%g22, trim(name) // "%g22", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%g23, structure_new%g23, trim(name) // "%g23", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%g33, structure_new%g33, trim(name) // "%g33", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%jacobian, structure_new%jacobian, trim(name) // "%jacobian", func)
   end subroutine diff_type_complexgrid_metric

   subroutine diff_arr_type_complexgrid_metric(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_metric), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_metric(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_metric

   subroutine diff_type_complexgrid_objectlist(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_objectlist), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%cls, structure_new%cls, trim(name) // "%cls", func)
     call diff_arr_type_complexgrid_indexlist(structure_ref%indset, structure_new%indset, trim(name) // "%indset", func)
     call diff_type_matint_type(structure_ref%ind, structure_new%ind, trim(name) // "%ind", func)
   end subroutine diff_type_complexgrid_objectlist

   subroutine diff_arr_type_complexgrid_objectlist(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_objectlist), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_objectlist(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_objectlist

   subroutine diff_type_complexgrid_scalar(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%griduid, structure_new%griduid, trim(name) // "%griduid", func)
     call diff_type_integer(structure_ref%subgrid, structure_new%subgrid, trim(name) // "%subgrid", func)
     call diff_type_vecflt_type(structure_ref%scalar, structure_new%scalar, trim(name) // "%scalar", func)
     call diff_type_matflt_type(structure_ref%vector, structure_new%vector, trim(name) // "%vector", func)
     call diff_type_array3dflt_type(structure_ref%matrix, structure_new%matrix, trim(name) // "%matrix", func)
   end subroutine diff_type_complexgrid_scalar

   subroutine diff_arr_type_complexgrid_scalar(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_scalar(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_scalar

   subroutine diff_type_complexgrid_scalar_cplx(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar_cplx), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%griduid, structure_new%griduid, trim(name) // "%griduid", func)
     call diff_type_integer(structure_ref%subgrid, structure_new%subgrid, trim(name) // "%subgrid", func)
     call diff_type_veccplx_type(structure_ref%scalar, structure_new%scalar, trim(name) // "%scalar", func)
     call diff_type_matcplx_type(structure_ref%vector, structure_new%vector, trim(name) // "%vector", func)
     call diff_type_array3dcplx_type(structure_ref%matrix, structure_new%matrix, trim(name) // "%matrix", func)
   end subroutine diff_type_complexgrid_scalar_cplx

   subroutine diff_arr_type_complexgrid_scalar_cplx(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar_cplx), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_scalar_cplx(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_scalar_cplx

   subroutine diff_type_complexgrid_scalar_int(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar_int), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%griduid, structure_new%griduid, trim(name) // "%griduid", func)
     call diff_type_integer(structure_ref%subgrid, structure_new%subgrid, trim(name) // "%subgrid", func)
     call diff_type_vecint_type(structure_ref%scalar, structure_new%scalar, trim(name) // "%scalar", func)
     call diff_type_matint_type(structure_ref%vector, structure_new%vector, trim(name) // "%vector", func)
     call diff_type_array3dint_type(structure_ref%matrix, structure_new%matrix, trim(name) // "%matrix", func)
   end subroutine diff_type_complexgrid_scalar_int

   subroutine diff_arr_type_complexgrid_scalar_int(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar_int), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_scalar_int(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_scalar_int

   subroutine diff_type_complexgrid_scalar_simplestruct(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar_simplestruct), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%subgrid, structure_new%subgrid, trim(name) // "%subgrid", func)
     call diff_type_vecflt_type(structure_ref%scalar, structure_new%scalar, trim(name) // "%scalar", func)
     call diff_type_matflt_type(structure_ref%vector, structure_new%vector, trim(name) // "%vector", func)
     call diff_type_array3dflt_type(structure_ref%matrix, structure_new%matrix, trim(name) // "%matrix", func)
   end subroutine diff_type_complexgrid_scalar_simplestruct

   subroutine diff_arr_type_complexgrid_scalar_simplestruct(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_scalar_simplestruct), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_scalar_simplestruct(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_scalar_simplestruct

   subroutine diff_type_complexgrid_space(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_space), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%geotype, structure_new%geotype, trim(name) // "%geotype", func)
     call diff_type_vecstring_type(structure_ref%geotypeid, structure_new%geotypeid, trim(name) // "%geotypeid", func)
     call diff_type_matint_type(structure_ref%coordtype, structure_new%coordtype, trim(name) // "%coordtype", func)
     call diff_arr_type_objects(structure_ref%objects, structure_new%objects, trim(name) // "%objects", func)
     call diff_type_vecint_type(structure_ref%xpoints, structure_new%xpoints, trim(name) // "%xpoints", func)
   end subroutine diff_type_complexgrid_space

   subroutine diff_arr_type_complexgrid_space(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_space), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_space(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_space

   subroutine diff_type_complexgrid_subgrid(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_subgrid), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_arr_type_complexgrid_objectlist(structure_ref%list, structure_new%list, trim(name) // "%list", func)
   end subroutine diff_type_complexgrid_subgrid

   subroutine diff_arr_type_complexgrid_subgrid(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_subgrid), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_subgrid(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_subgrid

   subroutine diff_type_complexgrid_vector(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_vector), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%griduid, structure_new%griduid, trim(name) // "%griduid", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%comp, structure_new%comp, trim(name) // "%comp", func)
     call diff_type_vecint_type(structure_ref%align, structure_new%align, trim(name) // "%align", func)
     call diff_type_vecstring_type(structure_ref%alignid, structure_new%alignid, trim(name) // "%alignid", func)
     call diff_type_integer(structure_ref%basis, structure_new%basis, trim(name) // "%basis", func)
   end subroutine diff_type_complexgrid_vector

   subroutine diff_arr_type_complexgrid_vector(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_vector), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_vector(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_vector

   subroutine diff_type_complexgrid_vector_simplestruct(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_vector_simplestruct), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%comp, structure_new%comp, trim(name) // "%comp", func)
     call diff_type_vecint_type(structure_ref%align, structure_new%align, trim(name) // "%align", func)
     call diff_type_vecstring_type(structure_ref%alignid, structure_new%alignid, trim(name) // "%alignid", func)
   end subroutine diff_type_complexgrid_vector_simplestruct

   subroutine diff_arr_type_complexgrid_vector_simplestruct(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_complexgrid_vector_simplestruct), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_complexgrid_vector_simplestruct(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_complexgrid_vector_simplestruct

   subroutine diff_type_composition(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_vecflt_type(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_vecflt_type(structure_ref%zion, structure_new%zion, trim(name) // "%zion", func)
     call diff_type_vecint_type(structure_ref%imp_flag, structure_new%imp_flag, trim(name) // "%imp_flag", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_composition

   subroutine diff_arr_type_composition(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_composition(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_composition

   subroutine diff_type_composition_neutrals(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition_neutrals), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_coreneutrals_atomlist(structure_ref%atomlist, structure_new%atomlist, trim(name) // "%atomlist", func)
     call diff_arr_type_composition_neutralscomp(structure_ref%neutral, structure_new%neutral, trim(name) // "%neutral", func)
   end subroutine diff_type_composition_neutrals

   subroutine diff_arr_type_composition_neutrals(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition_neutrals), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_composition_neutrals(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_composition_neutrals

   subroutine diff_type_composition_neutrals_neutcomp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition_neutrals_neutcomp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nucindex, structure_new%nucindex, trim(name) // "%nucindex", func)
     call diff_type_integer(structure_ref%multiplicity, structure_new%multiplicity, trim(name) // "%multiplicity", func)
   end subroutine diff_type_composition_neutrals_neutcomp

   subroutine diff_arr_type_composition_neutrals_neutcomp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition_neutrals_neutcomp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_composition_neutrals_neutcomp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_composition_neutrals_neutcomp

   subroutine diff_type_composition_neutralscomp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition_neutralscomp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_composition_neutrals_neutcomp(structure_ref%neutcomp, structure_new%neutcomp, trim(name) // "%neutcomp", func)
     call diff_arr_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_composition_neutralscomp

   subroutine diff_arr_type_composition_neutralscomp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_composition_neutralscomp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_composition_neutralscomp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_composition_neutralscomp

   subroutine diff_type_compositions_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_compositions_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_nuclei(structure_ref%nuclei, structure_new%nuclei, trim(name) // "%nuclei", func)
     call diff_arr_type_ions(structure_ref%ions, structure_new%ions, trim(name) // "%ions", func)
     call diff_arr_type_impurities(structure_ref%impurities, structure_new%impurities, trim(name) // "%impurities", func)
     call diff_arr_type_composition_neutralscomp(structure_ref%neutralscomp, structure_new%neutralscomp, trim(name) // "%neutralscomp", func)
     call diff_arr_type_edgespecies(structure_ref%edgespecies, structure_new%edgespecies, trim(name) // "%edgespecies", func)
     call diff_type_identifier(structure_ref%signature, structure_new%signature, trim(name) // "%signature", func)
   end subroutine diff_type_compositions_type

   subroutine diff_arr_type_compositions_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_compositions_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_compositions_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_compositions_type

   subroutine diff_type_compound_desc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_compound_desc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_type_vecflt_type(structure_ref%stochiometry, structure_new%stochiometry, trim(name) // "%stochiometry", func)
     call diff_type_float(structure_ref%density, structure_new%density, trim(name) // "%density", func)
     call diff_type_float(structure_ref%heat_cap, structure_new%heat_cap, trim(name) // "%heat_cap", func)
     call diff_type_vecflt_type(structure_ref%heat_cond, structure_new%heat_cond, trim(name) // "%heat_cond", func)
     call diff_type_matflt_type(structure_ref%surf_recrate, structure_new%surf_recrate, trim(name) // "%surf_recrate", func)
   end subroutine diff_type_compound_desc

   subroutine diff_arr_type_compound_desc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_compound_desc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_compound_desc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_compound_desc

   subroutine diff_type_coord_sys(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coord_sys), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%grid_type, structure_new%grid_type, trim(name) // "%grid_type", func)
     call diff_type_reggrid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_type_matflt_type(structure_ref%jacobian, structure_new%jacobian, trim(name) // "%jacobian", func)
     call diff_type_matflt_type(structure_ref%g_11, structure_new%g_11, trim(name) // "%g_11", func)
     call diff_type_matflt_type(structure_ref%g_12, structure_new%g_12, trim(name) // "%g_12", func)
     call diff_type_matflt_type(structure_ref%g_13, structure_new%g_13, trim(name) // "%g_13", func)
     call diff_type_matflt_type(structure_ref%g_22, structure_new%g_22, trim(name) // "%g_22", func)
     call diff_type_matflt_type(structure_ref%g_23, structure_new%g_23, trim(name) // "%g_23", func)
     call diff_type_matflt_type(structure_ref%g_33, structure_new%g_33, trim(name) // "%g_33", func)
     call diff_type_rz2D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_coord_sys

   subroutine diff_arr_type_coord_sys(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coord_sys), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coord_sys(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coord_sys

   subroutine diff_type_coordinates(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coordinates), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_coordinates

   subroutine diff_arr_type_coordinates(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coordinates), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coordinates(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coordinates

   subroutine diff_type_coords(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coords), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%coord, structure_new%coord, trim(name) // "%coord", func)
     call diff_type_vecstring_type(structure_ref%coord_label, structure_new%coord_label, trim(name) // "%coord_label", func)
     call diff_type_vecint_type(structure_ref%extrap_type, structure_new%extrap_type, trim(name) // "%extrap_type", func)
     call diff_type_integer(structure_ref%interp_type, structure_new%interp_type, trim(name) // "%interp_type", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_type_vecstring_type(structure_ref%unit, structure_new%unit, trim(name) // "%unit", func)
     call diff_type_integer(structure_ref%transform, structure_new%transform, trim(name) // "%transform", func)
     call diff_type_integer(structure_ref%spacing, structure_new%spacing, trim(name) // "%spacing", func)
   end subroutine diff_type_coords

   subroutine diff_arr_type_coords(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coords), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coords(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coords

   subroutine diff_type_coredelta_values(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coredelta_values), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%deltaid, structure_new%deltaid, trim(name) // "%deltaid", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%delta_psi, structure_new%delta_psi, trim(name) // "%delta_psi", func)
     call diff_type_vecflt_type(structure_ref%delta_te, structure_new%delta_te, trim(name) // "%delta_te", func)
     call diff_type_matflt_type(structure_ref%delta_ti, structure_new%delta_ti, trim(name) // "%delta_ti", func)
     call diff_type_vecflt_type(structure_ref%delta_ne, structure_new%delta_ne, trim(name) // "%delta_ne", func)
     call diff_type_matflt_type(structure_ref%delta_ni, structure_new%delta_ni, trim(name) // "%delta_ni", func)
     call diff_arr_type_coredelta_values_impurity(structure_ref%impurity, structure_new%impurity, trim(name) // "%impurity", func)
     call diff_type_matflt_type(structure_ref%delta_vtor, structure_new%delta_vtor, trim(name) // "%delta_vtor", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_coredelta_values

   subroutine diff_arr_type_coredelta_values(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coredelta_values), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coredelta_values(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coredelta_values

   subroutine diff_type_coredelta_values_impurity(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coredelta_values_impurity), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%delta_tz, structure_new%delta_tz, trim(name) // "%delta_tz", func)
     call diff_type_matflt_type(structure_ref%delta_nz, structure_new%delta_nz, trim(name) // "%delta_nz", func)
   end subroutine diff_type_coredelta_values_impurity

   subroutine diff_arr_type_coredelta_values_impurity(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coredelta_values_impurity), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coredelta_values_impurity(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coredelta_values_impurity

   subroutine diff_type_corefast_values(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefast_values), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%fastid, structure_new%fastid, trim(name) // "%fastid", func)
     call diff_type_fast_thermal_separation_filter(structure_ref%filter, structure_new%filter, trim(name) // "%filter", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%j, structure_new%j, trim(name) // "%j", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_matflt_type(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_vecflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_matflt_type(structure_ref%nz, structure_new%nz, trim(name) // "%nz", func)
     call diff_type_matflt_type(structure_ref%pi, structure_new%pi, trim(name) // "%pi", func)
     call diff_type_vecflt_type(structure_ref%pe, structure_new%pe, trim(name) // "%pe", func)
     call diff_type_matflt_type(structure_ref%pz, structure_new%pz, trim(name) // "%pz", func)
     call diff_type_matflt_type(structure_ref%pi_para, structure_new%pi_para, trim(name) // "%pi_para", func)
     call diff_type_vecflt_type(structure_ref%pe_para, structure_new%pe_para, trim(name) // "%pe_para", func)
     call diff_type_matflt_type(structure_ref%pz_para, structure_new%pz_para, trim(name) // "%pz_para", func)
     call diff_type_matflt_type(structure_ref%ui, structure_new%ui, trim(name) // "%ui", func)
     call diff_type_matflt_type(structure_ref%uz, structure_new%uz, trim(name) // "%uz", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_corefast_values

   subroutine diff_arr_type_corefast_values(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefast_values), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefast_values(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefast_values

   subroutine diff_type_corefield(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefield), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%ddrho, structure_new%ddrho, trim(name) // "%ddrho", func)
     call diff_type_vecflt_type(structure_ref%d2drho2, structure_new%d2drho2, trim(name) // "%d2drho2", func)
     call diff_type_vecflt_type(structure_ref%ddt, structure_new%ddt, trim(name) // "%ddt", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
     call diff_type_boundaryel(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
     call diff_type_sourceel(structure_ref%source_term, structure_new%source_term, trim(name) // "%source_term", func)
     call diff_type_coretransel(structure_ref%transp_coef, structure_new%transp_coef, trim(name) // "%transp_coef", func)
     call diff_type_fluxel(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_vecflt_type(structure_ref%flux_dv_surf, structure_new%flux_dv_surf, trim(name) // "%flux_dv_surf", func)
     call diff_type_vecflt_type(structure_ref%time_deriv, structure_new%time_deriv, trim(name) // "%time_deriv", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_corefield

   subroutine diff_arr_type_corefield(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefield), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefield(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefield

   subroutine diff_type_corefieldion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_matflt_type(structure_ref%ddrho, structure_new%ddrho, trim(name) // "%ddrho", func)
     call diff_type_matflt_type(structure_ref%d2drho2, structure_new%d2drho2, trim(name) // "%d2drho2", func)
     call diff_type_matflt_type(structure_ref%ddt, structure_new%ddt, trim(name) // "%ddt", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecint_type(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
     call diff_type_boundaryion(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
     call diff_type_sourceion(structure_ref%source_term, structure_new%source_term, trim(name) // "%source_term", func)
     call diff_type_coretransion(structure_ref%transp_coef, structure_new%transp_coef, trim(name) // "%transp_coef", func)
     call diff_type_fluxion(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_matflt_type(structure_ref%flux_dv_surf, structure_new%flux_dv_surf, trim(name) // "%flux_dv_surf", func)
     call diff_type_matflt_type(structure_ref%time_deriv, structure_new%time_deriv, trim(name) // "%time_deriv", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_corefieldion

   subroutine diff_arr_type_corefieldion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefieldion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefieldion

   subroutine diff_type_corefieldneutral(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutral), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_boundary_neutrals(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
   end subroutine diff_type_corefieldneutral

   subroutine diff_arr_type_corefieldneutral(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutral), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefieldneutral(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefieldneutral

   subroutine diff_type_corefieldneutrale(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutrale), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_boundary_neutrals(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
   end subroutine diff_type_corefieldneutrale

   subroutine diff_arr_type_corefieldneutrale(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutrale), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefieldneutrale(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefieldneutrale

   subroutine diff_type_corefieldneutralv(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutralv), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_boundary_neutrals(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
   end subroutine diff_type_corefieldneutralv

   subroutine diff_arr_type_corefieldneutralv(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutralv), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefieldneutralv(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefieldneutralv

   subroutine diff_type_corefieldneutralv0(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutralv0), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_corefieldneutralv(structure_ref%toroidal, structure_new%toroidal, trim(name) // "%toroidal", func)
     call diff_type_corefieldneutralv(structure_ref%poloidal, structure_new%poloidal, trim(name) // "%poloidal", func)
     call diff_type_corefieldneutralv(structure_ref%radial, structure_new%radial, trim(name) // "%radial", func)
   end subroutine diff_type_corefieldneutralv0

   subroutine diff_arr_type_corefieldneutralv0(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_corefieldneutralv0), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_corefieldneutralv0(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_corefieldneutralv0

   subroutine diff_type_coreimpurdiag_sum_radiation(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurdiag_sum_radiation), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreimpurediagsum_type(structure_ref%line_rad, structure_new%line_rad, trim(name) // "%line_rad", func)
     call diff_type_coreimpurediagsum_type(structure_ref%brem_radrec, structure_new%brem_radrec, trim(name) // "%brem_radrec", func)
     call diff_type_coreimpurediagsum_type(structure_ref%sum, structure_new%sum, trim(name) // "%sum", func)
   end subroutine diff_type_coreimpurdiag_sum_radiation

   subroutine diff_arr_type_coreimpurdiag_sum_radiation(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurdiag_sum_radiation), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurdiag_sum_radiation(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurdiag_sum_radiation

   subroutine diff_type_coreimpurediag_energy(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_energy), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreimpurediagprof_type(structure_ref%ionization, structure_new%ionization, trim(name) // "%ionization", func)
     call diff_type_coreimpurediagprof_type(structure_ref%recombin, structure_new%recombin, trim(name) // "%recombin", func)
     call diff_type_coreimpurediagprof_type(structure_ref%sum, structure_new%sum, trim(name) // "%sum", func)
   end subroutine diff_type_coreimpurediag_energy

   subroutine diff_arr_type_coreimpurediag_energy(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_energy), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediag_energy(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediag_energy

   subroutine diff_type_coreimpurediag_radiation(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_radiation), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreimpurediagprof_type(structure_ref%line_rad, structure_new%line_rad, trim(name) // "%line_rad", func)
     call diff_type_coreimpurediagprof_type(structure_ref%brem_radrec, structure_new%brem_radrec, trim(name) // "%brem_radrec", func)
     call diff_type_coreimpurediagprof_type(structure_ref%sum, structure_new%sum, trim(name) // "%sum", func)
   end subroutine diff_type_coreimpurediag_radiation

   subroutine diff_arr_type_coreimpurediag_radiation(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_radiation), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediag_radiation(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediag_radiation

   subroutine diff_type_coreimpurediag_sum(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_sum), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreimpurdiag_sum_radiation(structure_ref%radiation, structure_new%radiation, trim(name) // "%radiation", func)
     call diff_type_coreimpurediag_sum_energy(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_coreimpurediag_sum

   subroutine diff_arr_type_coreimpurediag_sum(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_sum), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediag_sum(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediag_sum

   subroutine diff_type_coreimpurediag_sum_energy(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_sum_energy), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreimpurediagsum_type(structure_ref%ionization, structure_new%ionization, trim(name) // "%ionization", func)
     call diff_type_coreimpurediagsum_type(structure_ref%recombin, structure_new%recombin, trim(name) // "%recombin", func)
     call diff_type_coreimpurediagsum_type(structure_ref%sum, structure_new%sum, trim(name) // "%sum", func)
   end subroutine diff_type_coreimpurediag_sum_energy

   subroutine diff_arr_type_coreimpurediag_sum_energy(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_sum_energy), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediag_sum_energy(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediag_sum_energy

   subroutine diff_type_coreimpurediag_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreimpurediag_radiation(structure_ref%radiation, structure_new%radiation, trim(name) // "%radiation", func)
     call diff_type_coreimpurediag_energy(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_coreimpurediag_type

   subroutine diff_arr_type_coreimpurediag_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediag_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediag_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediag_type

   subroutine diff_type_coreimpurediagprof_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediagprof_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%profile, structure_new%profile, trim(name) // "%profile", func)
     call diff_type_matflt_type(structure_ref%integral, structure_new%integral, trim(name) // "%integral", func)
   end subroutine diff_type_coreimpurediagprof_type

   subroutine diff_arr_type_coreimpurediagprof_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediagprof_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediagprof_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediagprof_type

   subroutine diff_type_coreimpurediagsum_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediagsum_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%profile, structure_new%profile, trim(name) // "%profile", func)
     call diff_type_vecflt_type(structure_ref%integral, structure_new%integral, trim(name) // "%integral", func)
   end subroutine diff_type_coreimpurediagsum_type

   subroutine diff_arr_type_coreimpurediagsum_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreimpurediagsum_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreimpurediagsum_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreimpurediagsum_type

   subroutine diff_type_coreneutrals_atomlist(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreneutrals_atomlist), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_float(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_identifier(structure_ref%ionimptype, structure_new%ionimptype, trim(name) // "%ionimptype", func)
     call diff_type_integer(structure_ref%ionimpindex, structure_new%ionimpindex, trim(name) // "%ionimpindex", func)
   end subroutine diff_type_coreneutrals_atomlist

   subroutine diff_arr_type_coreneutrals_atomlist(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreneutrals_atomlist), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreneutrals_atomlist(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreneutrals_atomlist

   subroutine diff_type_coreneutrals_neutraltype(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreneutrals_neutraltype), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_corefieldneutral(structure_ref%n0, structure_new%n0, trim(name) // "%n0", func)
     call diff_type_corefieldneutrale(structure_ref%t0, structure_new%t0, trim(name) // "%t0", func)
     call diff_type_corefieldneutralv0(structure_ref%v0, structure_new%v0, trim(name) // "%v0", func)
   end subroutine diff_type_coreneutrals_neutraltype

   subroutine diff_arr_type_coreneutrals_neutraltype(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreneutrals_neutraltype), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreneutrals_neutraltype(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreneutrals_neutraltype

   subroutine diff_type_coreprofile(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreprofile), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_coreprofile

   subroutine diff_arr_type_coreprofile(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreprofile), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreprofile(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreprofile

   subroutine diff_type_coreprofion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreprofion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_coreprofion

   subroutine diff_arr_type_coreprofion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coreprofion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coreprofion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coreprofion

   subroutine diff_type_coresource_values(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coresource_values), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%sourceid, structure_new%sourceid, trim(name) // "%sourceid", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%j, structure_new%j, trim(name) // "%j", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_source_ion(structure_ref%si, structure_new%si, trim(name) // "%si", func)
     call diff_type_source_vec(structure_ref%se, structure_new%se, trim(name) // "%se", func)
     call diff_arr_type_source_imp(structure_ref%sz, structure_new%sz, trim(name) // "%sz", func)
     call diff_type_source_ion(structure_ref%qi, structure_new%qi, trim(name) // "%qi", func)
     call diff_type_source_vec(structure_ref%qe, structure_new%qe, trim(name) // "%qe", func)
     call diff_arr_type_source_imp(structure_ref%qz, structure_new%qz, trim(name) // "%qz", func)
     call diff_type_source_ion(structure_ref%ui, structure_new%ui, trim(name) // "%ui", func)
     call diff_type_source_vec(structure_ref%ujxb, structure_new%ujxb, trim(name) // "%ujxb", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_coresource_values

   subroutine diff_arr_type_coresource_values(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coresource_values), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coresource_values(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coresource_values

   subroutine diff_type_coretransel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%diff, structure_new%diff, trim(name) // "%diff", func)
     call diff_type_vecflt_type(structure_ref%vconv, structure_new%vconv, trim(name) // "%vconv", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_coretransel

   subroutine diff_arr_type_coretransel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coretransel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coretransel

   subroutine diff_type_coretransimp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransimp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%diff, structure_new%diff, trim(name) // "%diff", func)
     call diff_type_matflt_type(structure_ref%vconv, structure_new%vconv, trim(name) // "%vconv", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_coretransimp

   subroutine diff_arr_type_coretransimp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransimp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coretransimp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coretransimp

   subroutine diff_type_coretransion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%diff, structure_new%diff, trim(name) // "%diff", func)
     call diff_type_matflt_type(structure_ref%vconv, structure_new%vconv, trim(name) // "%vconv", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_coretransion

   subroutine diff_arr_type_coretransion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coretransion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coretransion

   subroutine diff_type_coretransp_values(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransp_values), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%transportid, structure_new%transportid, trim(name) // "%transportid", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_ni_transp(structure_ref%ni_transp, structure_new%ni_transp, trim(name) // "%ni_transp", func)
     call diff_type_ne_transp(structure_ref%ne_transp, structure_new%ne_transp, trim(name) // "%ne_transp", func)
     call diff_arr_type_transcoefimp(structure_ref%nz_transp, structure_new%nz_transp, trim(name) // "%nz_transp", func)
     call diff_type_transcoefion(structure_ref%ti_transp, structure_new%ti_transp, trim(name) // "%ti_transp", func)
     call diff_type_transcoefel(structure_ref%te_transp, structure_new%te_transp, trim(name) // "%te_transp", func)
     call diff_arr_type_transcoefimp(structure_ref%tz_transp, structure_new%tz_transp, trim(name) // "%tz_transp", func)
     call diff_type_transcoefvtor(structure_ref%vtor_transp, structure_new%vtor_transp, trim(name) // "%vtor_transp", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_coretransp_values

   subroutine diff_arr_type_coretransp_values(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_coretransp_values), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_coretransp_values(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_coretransp_values

   subroutine diff_type_current(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_current), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%mpol, structure_new%mpol, trim(name) // "%mpol", func)
     call diff_type_vecint_type(structure_ref%ntor, structure_new%ntor, trim(name) // "%ntor", func)
     call diff_type_exp1D(structure_ref%spectrum, structure_new%spectrum, trim(name) // "%spectrum", func)
     call diff_type_rz0D(structure_ref%rz_reference, structure_new%rz_reference, trim(name) // "%rz_reference", func)
   end subroutine diff_type_current

   subroutine diff_arr_type_current(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_current), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_current(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_current

   subroutine diff_type_cxmeasure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_cxmeasure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_exp1D(structure_ref%vtor, structure_new%vtor, trim(name) // "%vtor", func)
     call diff_type_exp1D(structure_ref%vpol, structure_new%vpol, trim(name) // "%vpol", func)
   end subroutine diff_type_cxmeasure

   subroutine diff_arr_type_cxmeasure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_cxmeasure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_cxmeasure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_cxmeasure

   subroutine diff_type_cxsetup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_cxsetup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_vecflt_type(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_rzphi1Dexp(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_cxsetup

   subroutine diff_arr_type_cxsetup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_cxsetup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_cxsetup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_cxsetup

   subroutine diff_type_data_release(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_data_release), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%shot, structure_new%shot, trim(name) // "%shot", func)
     call diff_type_integer(structure_ref%run, structure_new%run, trim(name) // "%run", func)
     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
   end subroutine diff_type_data_release

   subroutine diff_arr_type_data_release(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_data_release), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_data_release(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_data_release

   subroutine diff_type_datainfo(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_datainfo), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%dataprovider, structure_new%dataprovider, trim(name) // "%dataprovider", func)
     call diff_type_vecstring_type(structure_ref%putdate, structure_new%putdate, trim(name) // "%putdate", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecstring_type(structure_ref%comment, structure_new%comment, trim(name) // "%comment", func)
     call diff_type_integer(structure_ref%cocos, structure_new%cocos, trim(name) // "%cocos", func)
     call diff_type_integer(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_integer(structure_ref%isref, structure_new%isref, trim(name) // "%isref", func)
     call diff_type_whatref(structure_ref%whatref, structure_new%whatref, trim(name) // "%whatref", func)
     call diff_type_putinfo(structure_ref%putinfo, structure_new%putinfo, trim(name) // "%putinfo", func)
   end subroutine diff_type_datainfo

   subroutine diff_arr_type_datainfo(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_datainfo), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_datainfo(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_datainfo

   subroutine diff_type_desc_coils(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_coils), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_float(structure_ref%res, structure_new%res, trim(name) // "%res", func)
     call diff_type_integer(structure_ref%nturns, structure_new%nturns, trim(name) // "%nturns", func)
     call diff_type_vecstring_type(structure_ref%closed, structure_new%closed, trim(name) // "%closed", func)
     call diff_arr_type_edges(structure_ref%edges, structure_new%edges, trim(name) // "%edges", func)
   end subroutine diff_type_desc_coils

   subroutine diff_arr_type_desc_coils(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_coils), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_desc_coils(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_desc_coils

   subroutine diff_type_desc_impur(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_impur), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_vecint_type(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_vecint_type(structure_ref%i_ion, structure_new%i_ion, trim(name) // "%i_ion", func)
     call diff_type_vecint_type(structure_ref%nzimp, structure_new%nzimp, trim(name) // "%nzimp", func)
     call diff_type_matint_type(structure_ref%zmin, structure_new%zmin, trim(name) // "%zmin", func)
     call diff_type_matint_type(structure_ref%zmax, structure_new%zmax, trim(name) // "%zmax", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_desc_impur

   subroutine diff_arr_type_desc_impur(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_impur), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_desc_impur(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_desc_impur

   subroutine diff_type_desc_iron(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_iron), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_permeability(structure_ref%permeability, structure_new%permeability, trim(name) // "%permeability", func)
     call diff_type_geom_iron(structure_ref%geom_iron, structure_new%geom_iron, trim(name) // "%geom_iron", func)
   end subroutine diff_type_desc_iron

   subroutine diff_arr_type_desc_iron(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_iron), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_desc_iron(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_desc_iron

   subroutine diff_type_desc_pfcoils(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_pfcoils), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_vecflt_type(structure_ref%res, structure_new%res, trim(name) // "%res", func)
     call diff_type_vecflt_type(structure_ref%emax, structure_new%emax, trim(name) // "%emax", func)
     call diff_type_structure_cs(structure_ref%structure_cs, structure_new%structure_cs, trim(name) // "%structure_cs", func)
     call diff_type_float(structure_ref%pol_flux_cs, structure_new%pol_flux_cs, trim(name) // "%pol_flux_cs", func)
     call diff_type_vecint_type(structure_ref%nelement, structure_new%nelement, trim(name) // "%nelement", func)
     call diff_type_pfelement(structure_ref%pfelement, structure_new%pfelement, trim(name) // "%pfelement", func)
   end subroutine diff_type_desc_pfcoils

   subroutine diff_arr_type_desc_pfcoils(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_pfcoils), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_desc_pfcoils(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_desc_pfcoils

   subroutine diff_type_desc_supply(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_supply), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_vecstring_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%delay, structure_new%delay, trim(name) // "%delay", func)
     call diff_type_filter(structure_ref%filter, structure_new%filter, trim(name) // "%filter", func)
     call diff_type_vecflt_type(structure_ref%imin, structure_new%imin, trim(name) // "%imin", func)
     call diff_type_vecflt_type(structure_ref%imax, structure_new%imax, trim(name) // "%imax", func)
     call diff_type_vecflt_type(structure_ref%res, structure_new%res, trim(name) // "%res", func)
     call diff_type_vecflt_type(structure_ref%umin, structure_new%umin, trim(name) // "%umin", func)
     call diff_type_vecflt_type(structure_ref%umax, structure_new%umax, trim(name) // "%umax", func)
     call diff_type_vecflt_type(structure_ref%emax, structure_new%emax, trim(name) // "%emax", func)
   end subroutine diff_type_desc_supply

   subroutine diff_arr_type_desc_supply(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_desc_supply), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_desc_supply(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_desc_supply

   subroutine diff_type_diag_func(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_diag_func), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
     call diff_type_matflt_type(structure_ref%transf_mat, structure_new%transf_mat, trim(name) // "%transf_mat", func)
   end subroutine diff_type_diag_func

   subroutine diff_arr_type_diag_func(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_diag_func), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_diag_func(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_diag_func

   subroutine diff_type_dist_collisional_transfer_0d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_collisional_transfer_0d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%power_th, structure_new%power_th, trim(name) // "%power_th", func)
     call diff_type_float(structure_ref%power_fast, structure_new%power_fast, trim(name) // "%power_fast", func)
     call diff_type_float(structure_ref%torque_th, structure_new%torque_th, trim(name) // "%torque_th", func)
     call diff_type_float(structure_ref%torque_fast, structure_new%torque_fast, trim(name) // "%torque_fast", func)
   end subroutine diff_type_dist_collisional_transfer_0d

   subroutine diff_arr_type_dist_collisional_transfer_0d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_collisional_transfer_0d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_collisional_transfer_0d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_collisional_transfer_0d

   subroutine diff_type_dist_collisional_transfer_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_collisional_transfer_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%power_th, structure_new%power_th, trim(name) // "%power_th", func)
     call diff_type_vecflt_type(structure_ref%power_fast, structure_new%power_fast, trim(name) // "%power_fast", func)
     call diff_type_vecflt_type(structure_ref%torque_th, structure_new%torque_th, trim(name) // "%torque_th", func)
     call diff_type_vecflt_type(structure_ref%torque_fast, structure_new%torque_fast, trim(name) // "%torque_fast", func)
   end subroutine diff_type_dist_collisional_transfer_1d

   subroutine diff_arr_type_dist_collisional_transfer_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_collisional_transfer_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_collisional_transfer_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_collisional_transfer_1d

   subroutine diff_type_dist_collisional_transfer_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_collisional_transfer_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%power_th, structure_new%power_th, trim(name) // "%power_th", func)
     call diff_type_matflt_type(structure_ref%power_fast, structure_new%power_fast, trim(name) // "%power_fast", func)
     call diff_type_matflt_type(structure_ref%torque_th, structure_new%torque_th, trim(name) // "%torque_th", func)
     call diff_type_matflt_type(structure_ref%torque_fast, structure_new%torque_fast, trim(name) // "%torque_fast", func)
   end subroutine diff_type_dist_collisional_transfer_2d

   subroutine diff_arr_type_dist_collisional_transfer_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_collisional_transfer_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_collisional_transfer_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_collisional_transfer_2d

   subroutine diff_type_dist_distrivec_distfunc_fexp_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_distrivec_distfunc_fexp_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_equatorial_plane(structure_ref%equatorial, structure_new%equatorial, trim(name) // "%equatorial", func)
     call diff_type_vecflt_type(structure_ref%temperature, structure_new%temperature, trim(name) // "%temperature", func)
   end subroutine diff_type_dist_distrivec_distfunc_fexp_param

   subroutine diff_arr_type_dist_distrivec_distfunc_fexp_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_distrivec_distfunc_fexp_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_distrivec_distfunc_fexp_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_distrivec_distfunc_fexp_param

   subroutine diff_type_dist_ff(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_ff), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_grid_info(structure_ref%grid_info, structure_new%grid_info, trim(name) // "%grid_info", func)
     call diff_arr_type_topo_regions(structure_ref%topo_regions, structure_new%topo_regions, trim(name) // "%topo_regions", func)
   end subroutine diff_type_dist_ff

   subroutine diff_arr_type_dist_ff(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_ff), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_ff(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_ff

   subroutine diff_type_dist_func(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_func), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%is_delta_f, structure_new%is_delta_f, trim(name) // "%is_delta_f", func)
     call diff_type_weighted_markers(structure_ref%markers, structure_new%markers, trim(name) // "%markers", func)
     call diff_arr_type_dist_ff(structure_ref%f_expan_topo, structure_new%f_expan_topo, trim(name) // "%f_expan_topo", func)
     call diff_arr_type_f_expansion(structure_ref%f_expansion, structure_new%f_expansion, trim(name) // "%f_expansion", func)
   end subroutine diff_type_dist_func

   subroutine diff_arr_type_dist_func(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_func), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_func(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_func

   subroutine diff_type_dist_geometry_0d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_geometry_0d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz0D(structure_ref%mag_axis, structure_new%mag_axis, trim(name) // "%mag_axis", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
   end subroutine diff_type_dist_geometry_0d

   subroutine diff_arr_type_dist_geometry_0d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_geometry_0d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_geometry_0d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_geometry_0d

   subroutine diff_type_dist_geometry_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_geometry_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
   end subroutine diff_type_dist_geometry_1d

   subroutine diff_arr_type_dist_geometry_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_geometry_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_geometry_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_geometry_1d

   subroutine diff_type_dist_geometry_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_geometry_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%coord_type, structure_new%coord_type, trim(name) // "%coord_type", func)
     call diff_type_matflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_matflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_matflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_matflt_type(structure_ref%theta_geom, structure_new%theta_geom, trim(name) // "%theta_geom", func)
     call diff_type_matflt_type(structure_ref%theta_strt, structure_new%theta_strt, trim(name) // "%theta_strt", func)
   end subroutine diff_type_dist_geometry_2d

   subroutine diff_arr_type_dist_geometry_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_geometry_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_geometry_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_geometry_2d

   subroutine diff_type_dist_global_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_global_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_geometry_0d(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_dist_state_0d(structure_ref%state, structure_new%state, trim(name) // "%state", func)
     call diff_type_dist_collisional_transfer_0d(structure_ref%collisions_e, structure_new%collisions_e, trim(name) // "%collisions_e", func)
     call diff_arr_type_dist_collisional_transfer_0d(structure_ref%collisions_i, structure_new%collisions_i, trim(name) // "%collisions_i", func)
     call diff_arr_type_dist_global_param_collisions_z(structure_ref%collisions_z, structure_new%collisions_z, trim(name) // "%collisions_z", func)
     call diff_arr_type_dist_sources_0d(structure_ref%sources, structure_new%sources, trim(name) // "%sources", func)
   end subroutine diff_type_dist_global_param

   subroutine diff_arr_type_dist_global_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_global_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_global_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_global_param

   subroutine diff_type_dist_global_param_collisions_z(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_global_param_collisions_z), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_dist_collisional_transfer_0d(structure_ref%charge_state, structure_new%charge_state, trim(name) // "%charge_state", func)
   end subroutine diff_type_dist_global_param_collisions_z

   subroutine diff_arr_type_dist_global_param_collisions_z(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_global_param_collisions_z), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_global_param_collisions_z(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_global_param_collisions_z

   subroutine diff_type_dist_grid_info(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_grid_info), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%grid_type, structure_new%grid_type, trim(name) // "%grid_type", func)
     call diff_type_integer(structure_ref%ngriddim, structure_new%ngriddim, trim(name) // "%ngriddim", func)
     call diff_type_vecint_type(structure_ref%grid_coord, structure_new%grid_coord, trim(name) // "%grid_coord", func)
     call diff_type_integer(structure_ref%thin_orbits, structure_new%thin_orbits, trim(name) // "%thin_orbits", func)
     call diff_type_vecstring_type(structure_ref%topology, structure_new%topology, trim(name) // "%topology", func)
     call diff_arr_type_omnigen_surf(structure_ref%omnigen_surf, structure_new%omnigen_surf, trim(name) // "%omnigen_surf", func)
   end subroutine diff_type_dist_grid_info

   subroutine diff_arr_type_dist_grid_info(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_grid_info), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_grid_info(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_grid_info

   subroutine diff_type_dist_profile_values_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profile_values_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_state_1d(structure_ref%state, structure_new%state, trim(name) // "%state", func)
     call diff_type_dist_collisional_transfer_1d(structure_ref%collisions_e, structure_new%collisions_e, trim(name) // "%collisions_e", func)
     call diff_arr_type_dist_collisional_transfer_1d(structure_ref%collisions_i, structure_new%collisions_i, trim(name) // "%collisions_i", func)
     call diff_arr_type_dist_profiles_1d_collisions_z(structure_ref%collisions_z, structure_new%collisions_z, trim(name) // "%collisions_z", func)
     call diff_arr_type_dist_sources_1d(structure_ref%sources, structure_new%sources, trim(name) // "%sources", func)
   end subroutine diff_type_dist_profile_values_1d

   subroutine diff_arr_type_dist_profile_values_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profile_values_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_profile_values_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_profile_values_1d

   subroutine diff_type_dist_profile_values_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profile_values_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_state_2d(structure_ref%state, structure_new%state, trim(name) // "%state", func)
     call diff_type_dist_collisional_transfer_2d(structure_ref%collisions_e, structure_new%collisions_e, trim(name) // "%collisions_e", func)
     call diff_arr_type_dist_collisional_transfer_2d(structure_ref%collisions_i, structure_new%collisions_i, trim(name) // "%collisions_i", func)
     call diff_arr_type_dist_profiles2d_collisions_z(structure_ref%collisions_z, structure_new%collisions_z, trim(name) // "%collisions_z", func)
   end subroutine diff_type_dist_profile_values_2d

   subroutine diff_arr_type_dist_profile_values_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profile_values_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_profile_values_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_profile_values_2d

   subroutine diff_type_dist_profiles2d_collisions_z(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles2d_collisions_z), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_dist_collisional_transfer_2d(structure_ref%charge_state, structure_new%charge_state, trim(name) // "%charge_state", func)
   end subroutine diff_type_dist_profiles2d_collisions_z

   subroutine diff_arr_type_dist_profiles2d_collisions_z(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles2d_collisions_z), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_profiles2d_collisions_z(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_profiles2d_collisions_z

   subroutine diff_type_dist_profiles_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_geometry_1d(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_dist_state_1d(structure_ref%state, structure_new%state, trim(name) // "%state", func)
     call diff_type_dist_collisional_transfer_1d(structure_ref%collisions_e, structure_new%collisions_e, trim(name) // "%collisions_e", func)
     call diff_arr_type_dist_collisional_transfer_1d(structure_ref%collisions_i, structure_new%collisions_i, trim(name) // "%collisions_i", func)
     call diff_arr_type_dist_profiles_1d_collisions_z(structure_ref%collisions_z, structure_new%collisions_z, trim(name) // "%collisions_z", func)
     call diff_type_dist_thermalised_1d(structure_ref%thermalised, structure_new%thermalised, trim(name) // "%thermalised", func)
     call diff_arr_type_dist_sources_1d(structure_ref%sources, structure_new%sources, trim(name) // "%sources", func)
     call diff_type_dist_profile_values_1d(structure_ref%trapped, structure_new%trapped, trim(name) // "%trapped", func)
     call diff_type_dist_profile_values_1d(structure_ref%co_passing, structure_new%co_passing, trim(name) // "%co_passing", func)
     call diff_type_dist_profile_values_1d(structure_ref%cntr_passing, structure_new%cntr_passing, trim(name) // "%cntr_passing", func)
   end subroutine diff_type_dist_profiles_1d

   subroutine diff_arr_type_dist_profiles_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_profiles_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_profiles_1d

   subroutine diff_type_dist_profiles_1d_collisions_z(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles_1d_collisions_z), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_dist_collisional_transfer_1d(structure_ref%charge_state, structure_new%charge_state, trim(name) // "%charge_state", func)
   end subroutine diff_type_dist_profiles_1d_collisions_z

   subroutine diff_arr_type_dist_profiles_1d_collisions_z(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles_1d_collisions_z), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_profiles_1d_collisions_z(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_profiles_1d_collisions_z

   subroutine diff_type_dist_profiles_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_geometry_2d(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_dist_state_2d(structure_ref%state, structure_new%state, trim(name) // "%state", func)
     call diff_type_dist_collisional_transfer_2d(structure_ref%collisions_e, structure_new%collisions_e, trim(name) // "%collisions_e", func)
     call diff_arr_type_dist_collisional_transfer_2d(structure_ref%collisions_i, structure_new%collisions_i, trim(name) // "%collisions_i", func)
     call diff_arr_type_dist_profiles2d_collisions_z(structure_ref%collisions_z, structure_new%collisions_z, trim(name) // "%collisions_z", func)
     call diff_type_dist_profile_values_2d(structure_ref%trapped, structure_new%trapped, trim(name) // "%trapped", func)
     call diff_type_dist_profile_values_2d(structure_ref%co_passing, structure_new%co_passing, trim(name) // "%co_passing", func)
     call diff_type_dist_profile_values_2d(structure_ref%cntr_passing, structure_new%cntr_passing, trim(name) // "%cntr_passing", func)
   end subroutine diff_type_dist_profiles_2d

   subroutine diff_arr_type_dist_profiles_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_profiles_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_profiles_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_profiles_2d

   subroutine diff_type_dist_sources_0d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_sources_0d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_sources_reference(structure_ref%source_ref, structure_new%source_ref, trim(name) // "%source_ref", func)
     call diff_type_float(structure_ref%particle, structure_new%particle, trim(name) // "%particle", func)
     call diff_type_float(structure_ref%momentum, structure_new%momentum, trim(name) // "%momentum", func)
     call diff_type_float(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_dist_sources_0d

   subroutine diff_arr_type_dist_sources_0d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_sources_0d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_sources_0d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_sources_0d

   subroutine diff_type_dist_sources_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_sources_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_dist_sources_reference(structure_ref%source_ref, structure_new%source_ref, trim(name) // "%source_ref", func)
     call diff_type_vecflt_type(structure_ref%particle, structure_new%particle, trim(name) // "%particle", func)
     call diff_type_vecflt_type(structure_ref%momentum, structure_new%momentum, trim(name) // "%momentum", func)
     call diff_type_vecflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_dist_sources_1d

   subroutine diff_arr_type_dist_sources_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_sources_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_sources_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_sources_1d

   subroutine diff_type_dist_sources_reference(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_sources_reference), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecint_type(structure_ref%index_waveid, structure_new%index_waveid, trim(name) // "%index_waveid", func)
     call diff_type_vecint_type(structure_ref%index_srcid, structure_new%index_srcid, trim(name) // "%index_srcid", func)
   end subroutine diff_type_dist_sources_reference

   subroutine diff_arr_type_dist_sources_reference(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_sources_reference), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_sources_reference(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_sources_reference

   subroutine diff_type_dist_state_0d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_state_0d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%n_particles, structure_new%n_particles, trim(name) // "%n_particles", func)
     call diff_type_float(structure_ref%n_part_fast, structure_new%n_part_fast, trim(name) // "%n_part_fast", func)
     call diff_type_float(structure_ref%enrg, structure_new%enrg, trim(name) // "%enrg", func)
     call diff_type_float(structure_ref%enrg_fast, structure_new%enrg_fast, trim(name) // "%enrg_fast", func)
     call diff_type_float(structure_ref%enrg_fast_pa, structure_new%enrg_fast_pa, trim(name) // "%enrg_fast_pa", func)
     call diff_type_float(structure_ref%momentm_fast, structure_new%momentm_fast, trim(name) // "%momentm_fast", func)
     call diff_type_float(structure_ref%current_dr, structure_new%current_dr, trim(name) // "%current_dr", func)
     call diff_type_float(structure_ref%torque_jrxb, structure_new%torque_jrxb, trim(name) // "%torque_jrxb", func)
   end subroutine diff_type_dist_state_0d

   subroutine diff_arr_type_dist_state_0d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_state_0d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_state_0d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_state_0d

   subroutine diff_type_dist_state_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_state_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%dens, structure_new%dens, trim(name) // "%dens", func)
     call diff_type_vecflt_type(structure_ref%dens_fast, structure_new%dens_fast, trim(name) // "%dens_fast", func)
     call diff_type_vecflt_type(structure_ref%pres, structure_new%pres, trim(name) // "%pres", func)
     call diff_type_vecflt_type(structure_ref%pres_fast, structure_new%pres_fast, trim(name) // "%pres_fast", func)
     call diff_type_vecflt_type(structure_ref%pres_fast_pa, structure_new%pres_fast_pa, trim(name) // "%pres_fast_pa", func)
     call diff_type_vecflt_type(structure_ref%momentm_fast, structure_new%momentm_fast, trim(name) // "%momentm_fast", func)
     call diff_type_vecflt_type(structure_ref%current, structure_new%current, trim(name) // "%current", func)
     call diff_type_vecflt_type(structure_ref%current_fast, structure_new%current_fast, trim(name) // "%current_fast", func)
     call diff_type_vecflt_type(structure_ref%torque_jrxb, structure_new%torque_jrxb, trim(name) // "%torque_jrxb", func)
   end subroutine diff_type_dist_state_1d

   subroutine diff_arr_type_dist_state_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_state_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_state_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_state_1d

   subroutine diff_type_dist_state_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_state_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%dens, structure_new%dens, trim(name) // "%dens", func)
     call diff_type_matflt_type(structure_ref%dens_fast, structure_new%dens_fast, trim(name) // "%dens_fast", func)
     call diff_type_matflt_type(structure_ref%pres, structure_new%pres, trim(name) // "%pres", func)
     call diff_type_matflt_type(structure_ref%pres_fast, structure_new%pres_fast, trim(name) // "%pres_fast", func)
     call diff_type_matflt_type(structure_ref%pres_fast_pa, structure_new%pres_fast_pa, trim(name) // "%pres_fast_pa", func)
     call diff_type_matflt_type(structure_ref%momentm_fast, structure_new%momentm_fast, trim(name) // "%momentm_fast", func)
     call diff_type_matflt_type(structure_ref%current, structure_new%current, trim(name) // "%current", func)
     call diff_type_matflt_type(structure_ref%current_fast, structure_new%current_fast, trim(name) // "%current_fast", func)
     call diff_type_matflt_type(structure_ref%torque_jrxb, structure_new%torque_jrxb, trim(name) // "%torque_jrxb", func)
   end subroutine diff_type_dist_state_2d

   subroutine diff_arr_type_dist_state_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_state_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_state_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_state_2d

   subroutine diff_type_dist_thermalised_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_thermalised_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%particle, structure_new%particle, trim(name) // "%particle", func)
     call diff_type_vecflt_type(structure_ref%momentum, structure_new%momentum, trim(name) // "%momentum", func)
     call diff_type_vecflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_dist_thermalised_1d

   subroutine diff_arr_type_dist_thermalised_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_dist_thermalised_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_dist_thermalised_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_dist_thermalised_1d

   subroutine diff_type_distri_vec(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distri_vec), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_enum_instance(structure_ref%wave_id, structure_new%wave_id, trim(name) // "%wave_id", func)
     call diff_arr_type_enum_instance(structure_ref%source_id, structure_new%source_id, trim(name) // "%source_id", func)
     call diff_type_species_reference(structure_ref%species, structure_new%species, trim(name) // "%species", func)
     call diff_type_integer(structure_ref%gyro_type, structure_new%gyro_type, trim(name) // "%gyro_type", func)
     call diff_type_fast_thermal_separation_filter(structure_ref%fast_filter, structure_new%fast_filter, trim(name) // "%fast_filter", func)
     call diff_type_dist_global_param(structure_ref%global_param, structure_new%global_param, trim(name) // "%global_param", func)
     call diff_type_dist_profiles_1d(structure_ref%profiles_1d, structure_new%profiles_1d, trim(name) // "%profiles_1d", func)
     call diff_type_dist_profiles_2d(structure_ref%profiles_2d, structure_new%profiles_2d, trim(name) // "%profiles_2d", func)
     call diff_type_dist_func(structure_ref%dist_func, structure_new%dist_func, trim(name) // "%dist_func", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_distri_vec

   subroutine diff_arr_type_distri_vec(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distri_vec), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distri_vec(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distri_vec

   subroutine diff_type_distsource_global_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_global_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp0D(structure_ref%src_pow, structure_new%src_pow, trim(name) // "%src_pow", func)
     call diff_type_exp0D(structure_ref%src_rate, structure_new%src_rate, trim(name) // "%src_rate", func)
     call diff_type_rz0D(structure_ref%mag_axis, structure_new%mag_axis, trim(name) // "%mag_axis", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
   end subroutine diff_type_distsource_global_param

   subroutine diff_arr_type_distsource_global_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_global_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distsource_global_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distsource_global_param

   subroutine diff_type_distsource_line_src_prof(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_line_src_prof), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%R, structure_new%R, trim(name) // "%R", func)
     call diff_type_vecflt_type(structure_ref%Z, structure_new%Z, trim(name) // "%Z", func)
     call diff_type_vecflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
     call diff_type_vecflt_type(structure_ref%theta_id, structure_new%theta_id, trim(name) // "%theta_id", func)
     call diff_type_matflt_type(structure_ref%th2th_pol, structure_new%th2th_pol, trim(name) // "%th2th_pol", func)
     call diff_type_vecflt_type(structure_ref%pitch, structure_new%pitch, trim(name) // "%pitch", func)
     call diff_type_vecflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_vecflt_type(structure_ref%ang_momentum, structure_new%ang_momentum, trim(name) // "%ang_momentum", func)
     call diff_type_vecflt_type(structure_ref%src_rate, structure_new%src_rate, trim(name) // "%src_rate", func)
   end subroutine diff_type_distsource_line_src_prof

   subroutine diff_arr_type_distsource_line_src_prof(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_line_src_prof), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distsource_line_src_prof(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distsource_line_src_prof

   subroutine diff_type_distsource_profiles_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_profiles_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_exp1D(structure_ref%pow_den, structure_new%pow_den, trim(name) // "%pow_den", func)
     call diff_type_exp1D(structure_ref%trq_den, structure_new%trq_den, trim(name) // "%trq_den", func)
     call diff_type_exp1D(structure_ref%src_rate, structure_new%src_rate, trim(name) // "%src_rate", func)
   end subroutine diff_type_distsource_profiles_1d

   subroutine diff_arr_type_distsource_profiles_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_profiles_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distsource_profiles_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distsource_profiles_1d

   subroutine diff_type_distsource_profiles_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_profiles_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%grid_coord, structure_new%grid_coord, trim(name) // "%grid_coord", func)
     call diff_type_matflt_type(structure_ref%dim1, structure_new%dim1, trim(name) // "%dim1", func)
     call diff_type_matflt_type(structure_ref%dim2, structure_new%dim2, trim(name) // "%dim2", func)
     call diff_type_matflt_type(structure_ref%g11, structure_new%g11, trim(name) // "%g11", func)
     call diff_type_matflt_type(structure_ref%g12, structure_new%g12, trim(name) // "%g12", func)
     call diff_type_matflt_type(structure_ref%g21, structure_new%g21, trim(name) // "%g21", func)
     call diff_type_matflt_type(structure_ref%g22, structure_new%g22, trim(name) // "%g22", func)
     call diff_type_exp2D(structure_ref%pow_den, structure_new%pow_den, trim(name) // "%pow_den", func)
     call diff_type_exp2D(structure_ref%src_rate, structure_new%src_rate, trim(name) // "%src_rate", func)
   end subroutine diff_type_distsource_profiles_2d

   subroutine diff_arr_type_distsource_profiles_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_profiles_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distsource_profiles_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distsource_profiles_2d

   subroutine diff_type_distsource_source(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_source), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_enum_instance(structure_ref%source_id, structure_new%source_id, trim(name) // "%source_id", func)
     call diff_type_species_reference(structure_ref%species, structure_new%species, trim(name) // "%species", func)
     call diff_type_integer(structure_ref%gyro_type, structure_new%gyro_type, trim(name) // "%gyro_type", func)
     call diff_type_distsource_global_param(structure_ref%global_param, structure_new%global_param, trim(name) // "%global_param", func)
     call diff_type_distsource_profiles_1d(structure_ref%profiles_1d, structure_new%profiles_1d, trim(name) // "%profiles_1d", func)
     call diff_type_distsource_profiles_2d(structure_ref%profiles_2d, structure_new%profiles_2d, trim(name) // "%profiles_2d", func)
     call diff_arr_type_distsource_line_src_prof(structure_ref%line_srcprof, structure_new%line_srcprof, trim(name) // "%line_srcprof", func)
     call diff_type_source_rate(structure_ref%source_rate, structure_new%source_rate, trim(name) // "%source_rate", func)
     call diff_type_weighted_markers(structure_ref%markers, structure_new%markers, trim(name) // "%markers", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_distsource_source

   subroutine diff_arr_type_distsource_source(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_distsource_source), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_distsource_source(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_distsource_source

   subroutine diff_type_divergence(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_divergence), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%frac_divcomp, structure_new%frac_divcomp, trim(name) // "%frac_divcomp", func)
     call diff_type_vecflt_type(structure_ref%div_vert, structure_new%div_vert, trim(name) // "%div_vert", func)
     call diff_type_vecflt_type(structure_ref%div_horiz, structure_new%div_horiz, trim(name) // "%div_horiz", func)
   end subroutine diff_type_divergence

   subroutine diff_arr_type_divergence(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_divergence), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_divergence(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_divergence

   subroutine diff_type_e_components(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_e_components), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_complexgrid_scalar_cplx(structure_ref%e_plus, structure_new%e_plus, trim(name) // "%e_plus", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%e_minus, structure_new%e_minus, trim(name) // "%e_minus", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%e_para, structure_new%e_para, trim(name) // "%e_para", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%e_norm, structure_new%e_norm, trim(name) // "%e_norm", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%e_binorm, structure_new%e_binorm, trim(name) // "%e_binorm", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%b_norm, structure_new%b_norm, trim(name) // "%b_norm", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%b_binorm, structure_new%b_binorm, trim(name) // "%b_binorm", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%b_para, structure_new%b_para, trim(name) // "%b_para", func)
     call diff_type_complexgrid_scalar_cplx(structure_ref%k_perp, structure_new%k_perp, trim(name) // "%k_perp", func)
   end subroutine diff_type_e_components

   subroutine diff_arr_type_e_components(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_e_components), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_e_components(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_e_components

   subroutine diff_type_ecemeasure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ecemeasure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%harmonic, structure_new%harmonic, trim(name) // "%harmonic", func)
     call diff_type_rzphi1Dexp(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_exp1D(structure_ref%te, structure_new%te, trim(name) // "%te", func)
   end subroutine diff_type_ecemeasure

   subroutine diff_arr_type_ecemeasure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ecemeasure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ecemeasure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ecemeasure

   subroutine diff_type_ecesetup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ecesetup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_setup_line_exp(structure_ref%los, structure_new%los, trim(name) // "%los", func)
   end subroutine diff_type_ecesetup

   subroutine diff_arr_type_ecesetup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ecesetup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ecesetup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ecesetup

   subroutine diff_type_edge_fluid(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_edge_fluid_scalar_simplestruct(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_arr_type_edge_fluid_scalar(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_edge_fluid_vector_simplestruct(structure_ref%ve, structure_new%ve, trim(name) // "%ve", func)
     call diff_arr_type_edge_fluid_vector(structure_ref%vi, structure_new%vi, trim(name) // "%vi", func)
     call diff_type_edge_fluid_scalar_simplestruct(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_arr_type_edge_fluid_scalar(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_edge_fluid_vector_simplestruct(structure_ref%te_aniso, structure_new%te_aniso, trim(name) // "%te_aniso", func)
     call diff_arr_type_edge_fluid_vector(structure_ref%ti_aniso, structure_new%ti_aniso, trim(name) // "%ti_aniso", func)
     call diff_type_edge_fluid_scalar_simplestruct(structure_ref%po, structure_new%po, trim(name) // "%po", func)
     call diff_type_edge_fluid_vector_simplestruct(structure_ref%j, structure_new%j, trim(name) // "%j", func)
     call diff_arr_type_complexgrid_vector(structure_ref%b, structure_new%b, trim(name) // "%b", func)
   end subroutine diff_type_edge_fluid

   subroutine diff_arr_type_edge_fluid(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_fluid(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_fluid

   subroutine diff_type_edge_fluid_scalar(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_scalar), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_complexgrid_scalar(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%bndvalue, structure_new%bndvalue, trim(name) // "%bndvalue", func)
     call diff_arr_type_complexgrid_vector(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_arr_type_complexgrid_vector(structure_ref%bndflux, structure_new%bndflux, trim(name) // "%bndflux", func)
     call diff_arr_type_edge_fluid_scalar_transpcoeff(structure_ref%transpcoeff, structure_new%transpcoeff, trim(name) // "%transpcoeff", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_edge_fluid_scalar

   subroutine diff_arr_type_edge_fluid_scalar(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_scalar), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_fluid_scalar(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_fluid_scalar

   subroutine diff_type_edge_fluid_scalar_simplestruct(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_scalar_simplestruct), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_complexgrid_scalar(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%bndvalue, structure_new%bndvalue, trim(name) // "%bndvalue", func)
     call diff_arr_type_complexgrid_vector(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_arr_type_complexgrid_vector(structure_ref%bndflux, structure_new%bndflux, trim(name) // "%bndflux", func)
     call diff_arr_type_edge_fluid_scalar_transpcoeff(structure_ref%transpcoeff, structure_new%transpcoeff, trim(name) // "%transpcoeff", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_edge_fluid_scalar_simplestruct

   subroutine diff_arr_type_edge_fluid_scalar_simplestruct(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_scalar_simplestruct), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_fluid_scalar_simplestruct(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_fluid_scalar_simplestruct

   subroutine diff_type_edge_fluid_scalar_transpcoeff(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_scalar_transpcoeff), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_complexgrid_vector_simplestruct(structure_ref%d, structure_new%d, trim(name) // "%d", func)
     call diff_type_complexgrid_vector_simplestruct(structure_ref%v, structure_new%v, trim(name) // "%v", func)
   end subroutine diff_type_edge_fluid_scalar_transpcoeff

   subroutine diff_arr_type_edge_fluid_scalar_transpcoeff(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_scalar_transpcoeff), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_fluid_scalar_transpcoeff(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_fluid_scalar_transpcoeff

   subroutine diff_type_edge_fluid_vector(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_vector), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%griduid, structure_new%griduid, trim(name) // "%griduid", func)
     call diff_type_integer(structure_ref%basis, structure_new%basis, trim(name) // "%basis", func)
     call diff_type_vecint_type(structure_ref%align, structure_new%align, trim(name) // "%align", func)
     call diff_type_vecstring_type(structure_ref%alignid, structure_new%alignid, trim(name) // "%alignid", func)
     call diff_arr_type_edge_fluid_scalar(structure_ref%comps, structure_new%comps, trim(name) // "%comps", func)
   end subroutine diff_type_edge_fluid_vector

   subroutine diff_arr_type_edge_fluid_vector(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_vector), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_fluid_vector(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_fluid_vector

   subroutine diff_type_edge_fluid_vector_simplestruct(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_vector_simplestruct), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%griduid, structure_new%griduid, trim(name) // "%griduid", func)
     call diff_type_integer(structure_ref%basis, structure_new%basis, trim(name) // "%basis", func)
     call diff_arr_type_edge_fluid_scalar(structure_ref%comps, structure_new%comps, trim(name) // "%comps", func)
     call diff_type_vecint_type(structure_ref%align, structure_new%align, trim(name) // "%align", func)
     call diff_type_vecstring_type(structure_ref%alignid, structure_new%alignid, trim(name) // "%alignid", func)
   end subroutine diff_type_edge_fluid_vector_simplestruct

   subroutine diff_arr_type_edge_fluid_vector_simplestruct(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_fluid_vector_simplestruct), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_fluid_vector_simplestruct(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_fluid_vector_simplestruct

   subroutine diff_type_edge_kinetic(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_kinetic), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_edge_kinetic_distribution(structure_ref%f, structure_new%f, trim(name) // "%f", func)
   end subroutine diff_type_edge_kinetic

   subroutine diff_arr_type_edge_kinetic(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_kinetic), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_kinetic(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_kinetic

   subroutine diff_type_edge_kinetic_distribution(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_kinetic_distribution), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_complexgrid_scalar(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%bndvalue, structure_new%bndvalue, trim(name) // "%bndvalue", func)
     call diff_arr_type_complexgrid_vector(structure_ref%fluxes, structure_new%fluxes, trim(name) // "%fluxes", func)
     call diff_arr_type_complexgrid_scalar(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_edge_kinetic_distribution

   subroutine diff_arr_type_edge_kinetic_distribution(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edge_kinetic_distribution), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edge_kinetic_distribution(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edge_kinetic_distribution

   subroutine diff_type_edges(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edges), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1D(structure_ref%edge_rzphi, structure_new%edge_rzphi, trim(name) // "%edge_rzphi", func)
   end subroutine diff_type_edges

   subroutine diff_arr_type_edges(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edges), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edges(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edges

   subroutine diff_type_edgespecies(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edgespecies), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nucindex, structure_new%nucindex, trim(name) // "%nucindex", func)
     call diff_type_float(structure_ref%zmin, structure_new%zmin, trim(name) // "%zmin", func)
     call diff_type_float(structure_ref%zmax, structure_new%zmax, trim(name) // "%zmax", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_edgespecies

   subroutine diff_arr_type_edgespecies(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_edgespecies), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_edgespecies(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_edgespecies

   subroutine diff_type_element_desc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_element_desc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nucindex, structure_new%nucindex, trim(name) // "%nucindex", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_type_float(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
   end subroutine diff_type_element_desc

   subroutine diff_arr_type_element_desc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_element_desc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_element_desc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_element_desc

   subroutine diff_type_entry_def(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_entry_def), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%user, structure_new%user, trim(name) // "%user", func)
     call diff_type_vecstring_type(structure_ref%machine, structure_new%machine, trim(name) // "%machine", func)
     call diff_type_integer(structure_ref%shot, structure_new%shot, trim(name) // "%shot", func)
     call diff_type_integer(structure_ref%run, structure_new%run, trim(name) // "%run", func)
   end subroutine diff_type_entry_def

   subroutine diff_arr_type_entry_def(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_entry_def), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_entry_def(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_entry_def

   subroutine diff_type_enum_instance(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_enum_instance), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_integer(structure_ref%index, structure_new%index, trim(name) // "%index", func)
   end subroutine diff_type_enum_instance

   subroutine diff_arr_type_enum_instance(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_enum_instance), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_enum_instance(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_enum_instance

   subroutine diff_type_eqconstraint(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqconstraint), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_eqmes1D(structure_ref%bpol, structure_new%bpol, trim(name) // "%bpol", func)
     call diff_type_eqmes0D(structure_ref%bvac_r, structure_new%bvac_r, trim(name) // "%bvac_r", func)
     call diff_type_eqmes0D(structure_ref%diamagflux, structure_new%diamagflux, trim(name) // "%diamagflux", func)
     call diff_type_eqmes1D(structure_ref%faraday, structure_new%faraday, trim(name) // "%faraday", func)
     call diff_type_eqmes1D(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_eqmes0D(structure_ref%i_plasma, structure_new%i_plasma, trim(name) // "%i_plasma", func)
     call diff_type_isoflux(structure_ref%isoflux, structure_new%isoflux, trim(name) // "%isoflux", func)
     call diff_type_eqmes1D(structure_ref%jsurf, structure_new%jsurf, trim(name) // "%jsurf", func)
     call diff_type_magnet_iron(structure_ref%magnet_iron, structure_new%magnet_iron, trim(name) // "%magnet_iron", func)
     call diff_type_eqmes1D(structure_ref%mse, structure_new%mse, trim(name) // "%mse", func)
     call diff_type_eqmes1D(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_eqmes1D(structure_ref%pfcurrent, structure_new%pfcurrent, trim(name) // "%pfcurrent", func)
     call diff_type_eqmes1D(structure_ref%pressure, structure_new%pressure, trim(name) // "%pressure", func)
     call diff_type_q(structure_ref%q, structure_new%q, trim(name) // "%q", func)
     call diff_type_xpts(structure_ref%xpts, structure_new%xpts, trim(name) // "%xpts", func)
   end subroutine diff_type_eqconstraint

   subroutine diff_arr_type_eqconstraint(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqconstraint), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_eqconstraint(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_eqconstraint

   subroutine diff_type_eqgeometry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqgeometry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%boundarytype, structure_new%boundarytype, trim(name) // "%boundarytype", func)
     call diff_arr_type_rz1Dexp(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
     call diff_type_rz0D(structure_ref%geom_axis, structure_new%geom_axis, trim(name) // "%geom_axis", func)
     call diff_type_float(structure_ref%a_minor, structure_new%a_minor, trim(name) // "%a_minor", func)
     call diff_type_float(structure_ref%elongation, structure_new%elongation, trim(name) // "%elongation", func)
     call diff_type_float(structure_ref%elong_upper, structure_new%elong_upper, trim(name) // "%elong_upper", func)
     call diff_type_float(structure_ref%elong_lower, structure_new%elong_lower, trim(name) // "%elong_lower", func)
     call diff_type_float(structure_ref%tria_upper, structure_new%tria_upper, trim(name) // "%tria_upper", func)
     call diff_type_float(structure_ref%tria_lower, structure_new%tria_lower, trim(name) // "%tria_lower", func)
     call diff_arr_type_rz1Dexp(structure_ref%xpts, structure_new%xpts, trim(name) // "%xpts", func)
     call diff_type_rz0D(structure_ref%left_low_st, structure_new%left_low_st, trim(name) // "%left_low_st", func)
     call diff_type_rz0D(structure_ref%right_low_st, structure_new%right_low_st, trim(name) // "%right_low_st", func)
     call diff_type_rz0D(structure_ref%left_up_st, structure_new%left_up_st, trim(name) // "%left_up_st", func)
     call diff_type_rz0D(structure_ref%right_up_st, structure_new%right_up_st, trim(name) // "%right_up_st", func)
     call diff_type_rz0D(structure_ref%active_limit, structure_new%active_limit, trim(name) // "%active_limit", func)
     call diff_type_float(structure_ref%ang_lcms_upo, structure_new%ang_lcms_upo, trim(name) // "%ang_lcms_upo", func)
     call diff_type_float(structure_ref%ang_lcms_upi, structure_new%ang_lcms_upi, trim(name) // "%ang_lcms_upi", func)
     call diff_type_float(structure_ref%ang_lcms_lwo, structure_new%ang_lcms_lwo, trim(name) // "%ang_lcms_lwo", func)
     call diff_type_float(structure_ref%ang_lcms_lwi, structure_new%ang_lcms_lwi, trim(name) // "%ang_lcms_lwi", func)
   end subroutine diff_type_eqgeometry

   subroutine diff_arr_type_eqgeometry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqgeometry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_eqgeometry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_eqgeometry

   subroutine diff_type_eqmes0D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqmes0D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%measured, structure_new%measured, trim(name) // "%measured", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_integer(structure_ref%exact, structure_new%exact, trim(name) // "%exact", func)
     call diff_type_float(structure_ref%weight, structure_new%weight, trim(name) // "%weight", func)
     call diff_type_float(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_float(structure_ref%calculated, structure_new%calculated, trim(name) // "%calculated", func)
     call diff_type_float(structure_ref%chi2, structure_new%chi2, trim(name) // "%chi2", func)
   end subroutine diff_type_eqmes0D

   subroutine diff_arr_type_eqmes0D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqmes0D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_eqmes0D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_eqmes0D

   subroutine diff_type_eqmes1D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqmes1D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%measured, structure_new%measured, trim(name) // "%measured", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
     call diff_type_vecint_type(structure_ref%exact, structure_new%exact, trim(name) // "%exact", func)
     call diff_type_vecflt_type(structure_ref%weight, structure_new%weight, trim(name) // "%weight", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_vecflt_type(structure_ref%calculated, structure_new%calculated, trim(name) // "%calculated", func)
     call diff_type_vecflt_type(structure_ref%chi2, structure_new%chi2, trim(name) // "%chi2", func)
   end subroutine diff_type_eqmes1D

   subroutine diff_arr_type_eqmes1D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_eqmes1D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_eqmes1D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_eqmes1D

   subroutine diff_type_equatorial_plane(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equatorial_plane), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_vecflt_type(structure_ref%s, structure_new%s, trim(name) // "%s", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%b_mod, structure_new%b_mod, trim(name) // "%b_mod", func)
   end subroutine diff_type_equatorial_plane

   subroutine diff_arr_type_equatorial_plane(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equatorial_plane), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_equatorial_plane(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_equatorial_plane

   subroutine diff_type_equilibrium_profiles2d_grid(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equilibrium_profiles2d_grid), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%dim1, structure_new%dim1, trim(name) // "%dim1", func)
     call diff_type_vecflt_type(structure_ref%dim2, structure_new%dim2, trim(name) // "%dim2", func)
     call diff_type_matint_type(structure_ref%connect, structure_new%connect, trim(name) // "%connect", func)
   end subroutine diff_type_equilibrium_profiles2d_grid

   subroutine diff_arr_type_equilibrium_profiles2d_grid(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equilibrium_profiles2d_grid), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_equilibrium_profiles2d_grid(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_equilibrium_profiles2d_grid

   subroutine diff_type_equilibrium_profiles_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equilibrium_profiles_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%grid_type, structure_new%grid_type, trim(name) // "%grid_type", func)
     call diff_type_equilibrium_profiles2d_grid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_type_matflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_matflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_matflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
     call diff_type_matflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_matflt_type(structure_ref%jphi, structure_new%jphi, trim(name) // "%jphi", func)
     call diff_type_matflt_type(structure_ref%jpar, structure_new%jpar, trim(name) // "%jpar", func)
     call diff_type_matflt_type(structure_ref%br, structure_new%br, trim(name) // "%br", func)
     call diff_type_matflt_type(structure_ref%bz, structure_new%bz, trim(name) // "%bz", func)
     call diff_type_matflt_type(structure_ref%bphi, structure_new%bphi, trim(name) // "%bphi", func)
     call diff_type_matflt_type(structure_ref%vphi, structure_new%vphi, trim(name) // "%vphi", func)
     call diff_type_matflt_type(structure_ref%vtheta, structure_new%vtheta, trim(name) // "%vtheta", func)
     call diff_type_matflt_type(structure_ref%rho_mass, structure_new%rho_mass, trim(name) // "%rho_mass", func)
     call diff_type_matflt_type(structure_ref%pressure, structure_new%pressure, trim(name) // "%pressure", func)
     call diff_type_matflt_type(structure_ref%temperature, structure_new%temperature, trim(name) // "%temperature", func)
   end subroutine diff_type_equilibrium_profiles_2d

   subroutine diff_arr_type_equilibrium_profiles_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_equilibrium_profiles_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_equilibrium_profiles_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_equilibrium_profiles_2d

   subroutine diff_type_exp0D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_exp0D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_float(structure_ref%abserror, structure_new%abserror, trim(name) // "%abserror", func)
     call diff_type_float(structure_ref%relerror, structure_new%relerror, trim(name) // "%relerror", func)
   end subroutine diff_type_exp0D

   subroutine diff_arr_type_exp0D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_exp0D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_exp0D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_exp0D

   subroutine diff_type_exp1D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_exp1D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%abserror, structure_new%abserror, trim(name) // "%abserror", func)
     call diff_type_vecflt_type(structure_ref%relerror, structure_new%relerror, trim(name) // "%relerror", func)
   end subroutine diff_type_exp1D

   subroutine diff_arr_type_exp1D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_exp1D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_exp1D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_exp1D

   subroutine diff_type_exp2D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_exp2D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_matflt_type(structure_ref%abserror, structure_new%abserror, trim(name) // "%abserror", func)
     call diff_type_matflt_type(structure_ref%relerror, structure_new%relerror, trim(name) // "%relerror", func)
   end subroutine diff_type_exp2D

   subroutine diff_arr_type_exp2D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_exp2D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_exp2D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_exp2D

   subroutine diff_type_f_expansion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_f_expansion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_complexgrid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_type_complexgrid_scalar(structure_ref%values, structure_new%values, trim(name) // "%values", func)
     call diff_type_dist_distrivec_distfunc_fexp_param(structure_ref%parameters, structure_new%parameters, trim(name) // "%parameters", func)
   end subroutine diff_type_f_expansion

   subroutine diff_arr_type_f_expansion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_f_expansion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_f_expansion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_f_expansion

   subroutine diff_type_fast_thermal_separation_filter(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fast_thermal_separation_filter), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%method, structure_new%method, trim(name) // "%method", func)
     call diff_type_vecflt_type(structure_ref%energy_sep, structure_new%energy_sep, trim(name) // "%energy_sep", func)
   end subroutine diff_type_fast_thermal_separation_filter

   subroutine diff_arr_type_fast_thermal_separation_filter(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fast_thermal_separation_filter), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fast_thermal_separation_filter(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fast_thermal_separation_filter

   subroutine diff_type_filter(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_filter), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%num, structure_new%num, trim(name) // "%num", func)
     call diff_type_matflt_type(structure_ref%den, structure_new%den, trim(name) // "%den", func)
   end subroutine diff_type_filter

   subroutine diff_arr_type_filter(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_filter), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_filter(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_filter

   subroutine diff_type_flat_polygon(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_flat_polygon), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_xyz0D(structure_ref%origin, structure_new%origin, trim(name) // "%origin", func)
     call diff_type_xyz0D(structure_ref%basis1, structure_new%basis1, trim(name) // "%basis1", func)
     call diff_type_xyz0D(structure_ref%basis2, structure_new%basis2, trim(name) // "%basis2", func)
     call diff_type_vecflt_type(structure_ref%coord1, structure_new%coord1, trim(name) // "%coord1", func)
     call diff_type_vecflt_type(structure_ref%coord2, structure_new%coord2, trim(name) // "%coord2", func)
   end subroutine diff_type_flat_polygon

   subroutine diff_arr_type_flat_polygon(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_flat_polygon), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_flat_polygon(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_flat_polygon

   subroutine diff_type_flush(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_flush), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_matflt_type(structure_ref%coef, structure_new%coef, trim(name) // "%coef", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_flush

   subroutine diff_arr_type_flush(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_flush), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_flush(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_flush

   subroutine diff_type_flux_loops(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_flux_loops), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_setup_floops(structure_ref%setup_floops, structure_new%setup_floops, trim(name) // "%setup_floops", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_flux_loops

   subroutine diff_arr_type_flux_loops(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_flux_loops), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_flux_loops(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_flux_loops

   subroutine diff_type_fluxel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fluxel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%flux_dv, structure_new%flux_dv, trim(name) // "%flux_dv", func)
     call diff_type_vecflt_type(structure_ref%flux_interp, structure_new%flux_interp, trim(name) // "%flux_interp", func)
   end subroutine diff_type_fluxel

   subroutine diff_arr_type_fluxel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fluxel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fluxel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fluxel

   subroutine diff_type_fluximp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fluximp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%flux_dv, structure_new%flux_dv, trim(name) // "%flux_dv", func)
     call diff_type_matflt_type(structure_ref%flux_interp, structure_new%flux_interp, trim(name) // "%flux_interp", func)
   end subroutine diff_type_fluximp

   subroutine diff_arr_type_fluximp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fluximp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fluximp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fluximp

   subroutine diff_type_fluxion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fluxion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%flux_dv, structure_new%flux_dv, trim(name) // "%flux_dv", func)
     call diff_type_matflt_type(structure_ref%flux_interp, structure_new%flux_interp, trim(name) // "%flux_interp", func)
   end subroutine diff_type_fluxion

   subroutine diff_arr_type_fluxion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fluxion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fluxion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fluxion

   subroutine diff_type_focussing(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_focussing), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%focal_len_hz, structure_new%focal_len_hz, trim(name) // "%focal_len_hz", func)
     call diff_type_float(structure_ref%focal_len_vc, structure_new%focal_len_vc, trim(name) // "%focal_len_vc", func)
     call diff_type_float(structure_ref%width_min_hz, structure_new%width_min_hz, trim(name) // "%width_min_hz", func)
     call diff_type_float(structure_ref%width_min_vc, structure_new%width_min_vc, trim(name) // "%width_min_vc", func)
   end subroutine diff_type_focussing

   subroutine diff_arr_type_focussing(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_focussing), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_focussing(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_focussing

   subroutine diff_type_fullwave(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fullwave), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_complexgrid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_type_e_components(structure_ref%e_components, structure_new%e_components, trim(name) // "%e_components", func)
     call diff_type_pol_decomp(structure_ref%pol_decomp, structure_new%pol_decomp, trim(name) // "%pol_decomp", func)
     call diff_type_local(structure_ref%local, structure_new%local, trim(name) // "%local", func)
   end subroutine diff_type_fullwave

   subroutine diff_arr_type_fullwave(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fullwave), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fullwave(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fullwave

   subroutine diff_type_fusiondiag_colli_3d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colli_3d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_arr_type_fusiondiag_voxels(structure_ref%voxels, structure_new%voxels, trim(name) // "%voxels", func)
   end subroutine diff_type_fusiondiag_colli_3d

   subroutine diff_arr_type_fusiondiag_colli_3d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colli_3d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_colli_3d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_colli_3d

   subroutine diff_type_fusiondiag_colli_circ(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colli_circ), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_setup_line(structure_ref%setup_line, structure_new%setup_line, trim(name) // "%setup_line", func)
     call diff_arr_type_fusiondiag_colliunit_circ(structure_ref%colliunit, structure_new%colliunit, trim(name) // "%colliunit", func)
   end subroutine diff_type_fusiondiag_colli_circ

   subroutine diff_arr_type_fusiondiag_colli_circ(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colli_circ), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_colli_circ(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_colli_circ

   subroutine diff_type_fusiondiag_colli_poly(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colli_poly), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_setup_line(structure_ref%setup_line, structure_new%setup_line, trim(name) // "%setup_line", func)
     call diff_arr_type_fusiondiag_colliunit_poly(structure_ref%colliunit, structure_new%colliunit, trim(name) // "%colliunit", func)
   end subroutine diff_type_fusiondiag_colli_poly

   subroutine diff_arr_type_fusiondiag_colli_poly(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colli_poly), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_colli_poly(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_colli_poly

   subroutine diff_type_fusiondiag_collimator(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_collimator), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_fusiondiag_colli_circ(structure_ref%colli_circ, structure_new%colli_circ, trim(name) // "%colli_circ", func)
     call diff_arr_type_fusiondiag_colli_poly(structure_ref%colli_poly, structure_new%colli_poly, trim(name) // "%colli_poly", func)
     call diff_arr_type_fusiondiag_colli_3d(structure_ref%colli_3d, structure_new%colli_3d, trim(name) // "%colli_3d", func)
   end subroutine diff_type_fusiondiag_collimator

   subroutine diff_arr_type_fusiondiag_collimator(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_collimator), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_collimator(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_collimator

   subroutine diff_type_fusiondiag_colliunit_circ(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colliunit_circ), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%radius, structure_new%radius, trim(name) // "%radius", func)
     call diff_type_rzphi1D(structure_ref%centre, structure_new%centre, trim(name) // "%centre", func)
   end subroutine diff_type_fusiondiag_colliunit_circ

   subroutine diff_arr_type_fusiondiag_colliunit_circ(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colliunit_circ), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_colliunit_circ(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_colliunit_circ

   subroutine diff_type_fusiondiag_colliunit_poly(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colliunit_poly), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%dimension, structure_new%dimension, trim(name) // "%dimension", func)
     call diff_type_rzphi2D(structure_ref%nodes, structure_new%nodes, trim(name) // "%nodes", func)
   end subroutine diff_type_fusiondiag_colliunit_poly

   subroutine diff_arr_type_fusiondiag_colliunit_poly(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_colliunit_poly), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_colliunit_poly(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_colliunit_poly

   subroutine diff_type_fusiondiag_counts(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_counts), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%units, structure_new%units, trim(name) // "%units", func)
     call diff_arr_type_fusiondiag_ct_chords(structure_ref%ct_chords, structure_new%ct_chords, trim(name) // "%ct_chords", func)
     call diff_arr_type_fusiondiag_ct_energy(structure_ref%ct_energy, structure_new%ct_energy, trim(name) // "%ct_energy", func)
     call diff_arr_type_fusiondiag_detect_ct_energy(structure_ref%detect_ct, structure_new%detect_ct, trim(name) // "%detect_ct", func)
   end subroutine diff_type_fusiondiag_counts

   subroutine diff_arr_type_fusiondiag_counts(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_counts), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_counts(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_counts

   subroutine diff_type_fusiondiag_ct_chords(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_ct_chords), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_exp0D(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_fusiondiag_ct_chords

   subroutine diff_arr_type_fusiondiag_ct_chords(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_ct_chords), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_ct_chords(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_ct_chords

   subroutine diff_type_fusiondiag_ct_energy(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_ct_energy), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_fusiondiag_ct_energy

   subroutine diff_arr_type_fusiondiag_ct_energy(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_ct_energy), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_ct_energy(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_ct_energy

   subroutine diff_type_fusiondiag_detect_ct_energy(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_detect_ct_energy), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_diag_func(structure_ref%diag_func, structure_new%diag_func, trim(name) // "%diag_func", func)
   end subroutine diff_type_fusiondiag_detect_ct_energy

   subroutine diff_arr_type_fusiondiag_detect_ct_energy(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_detect_ct_energy), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_detect_ct_energy(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_detect_ct_energy

   subroutine diff_type_fusiondiag_emissivity1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_emissivity1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%units, structure_new%units, trim(name) // "%units", func)
     call diff_type_exp1D(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_exp1D(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_arr_type_fusiondiag_spec1d(structure_ref%spec1d, structure_new%spec1d, trim(name) // "%spec1d", func)
   end subroutine diff_type_fusiondiag_emissivity1d

   subroutine diff_arr_type_fusiondiag_emissivity1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_emissivity1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_emissivity1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_emissivity1d

   subroutine diff_type_fusiondiag_emissivity2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_emissivity2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%units, structure_new%units, trim(name) // "%units", func)
     call diff_type_exp2D(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_exp2D(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_arr_type_fusiondiag_spec2d(structure_ref%spec2d, structure_new%spec2d, trim(name) // "%spec2d", func)
   end subroutine diff_type_fusiondiag_emissivity2d

   subroutine diff_arr_type_fusiondiag_emissivity2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_emissivity2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_emissivity2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_emissivity2d

   subroutine diff_type_fusiondiag_fus_product(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_fus_product), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%product, structure_new%product, trim(name) // "%product", func)
     call diff_type_vecstring_type(structure_ref%reaction, structure_new%reaction, trim(name) // "%reaction", func)
     call diff_type_fusiondiag_collimator(structure_ref%collimator, structure_new%collimator, trim(name) // "%collimator", func)
     call diff_type_fusiondiag_counts(structure_ref%counts, structure_new%counts, trim(name) // "%counts", func)
     call diff_type_fusiondiag_emissivity1d(structure_ref%emissivity1d, structure_new%emissivity1d, trim(name) // "%emissivity1d", func)
     call diff_type_fusiondiag_emissivity2d(structure_ref%emissivity2d, structure_new%emissivity2d, trim(name) // "%emissivity2d", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_fusiondiag_fus_product

   subroutine diff_arr_type_fusiondiag_fus_product(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_fus_product), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_fus_product(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_fus_product

   subroutine diff_type_fusiondiag_spec1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_spec1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp0D(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_fusiondiag_spec1d

   subroutine diff_arr_type_fusiondiag_spec1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_spec1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_spec1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_spec1d

   subroutine diff_type_fusiondiag_spec2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_spec2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp0D(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_exp2D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_fusiondiag_spec2d

   subroutine diff_arr_type_fusiondiag_spec2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_spec2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_spec2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_spec2d

   subroutine diff_type_fusiondiag_voxels(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_voxels), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi0D(structure_ref%centre, structure_new%centre, trim(name) // "%centre", func)
     call diff_type_rzphi0D(structure_ref%direction, structure_new%direction, trim(name) // "%direction", func)
     call diff_type_float(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_float(structure_ref%solid_angle, structure_new%solid_angle, trim(name) // "%solid_angle", func)
   end subroutine diff_type_fusiondiag_voxels

   subroutine diff_arr_type_fusiondiag_voxels(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_fusiondiag_voxels), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_fusiondiag_voxels(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_fusiondiag_voxels

   subroutine diff_type_geom(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_geom), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%dr_bb_sh_ib, structure_new%dr_bb_sh_ib, trim(name) // "%dr_bb_sh_ib", func)
     call diff_type_float(structure_ref%dr_sh_vv_ib, structure_new%dr_sh_vv_ib, trim(name) // "%dr_sh_vv_ib", func)
     call diff_type_float(structure_ref%dr_bb_sh_ob, structure_new%dr_bb_sh_ob, trim(name) // "%dr_bb_sh_ob", func)
     call diff_type_float(structure_ref%dr_sh_vv_ob, structure_new%dr_sh_vv_ob, trim(name) // "%dr_sh_vv_ob", func)
     call diff_type_float(structure_ref%dr_bb__sh_ib, structure_new%dr_bb__sh_ib, trim(name) // "%dr_bb__sh_ib", func)
     call diff_type_float(structure_ref%dr_bb__sh_ob, structure_new%dr_bb__sh_ob, trim(name) // "%dr_bb__sh_ob", func)
     call diff_type_float(structure_ref%delta_int, structure_new%delta_int, trim(name) // "%delta_int", func)
   end subroutine diff_type_geom

   subroutine diff_arr_type_geom(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_geom), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_geom(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_geom

   subroutine diff_type_geom_iron(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_geom_iron), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
     call diff_type_rz2D(structure_ref%rzcoordinate, structure_new%rzcoordinate, trim(name) // "%rzcoordinate", func)
   end subroutine diff_type_geom_iron

   subroutine diff_arr_type_geom_iron(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_geom_iron), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_geom_iron(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_geom_iron

   subroutine diff_type_global_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_global_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%beta_pol, structure_new%beta_pol, trim(name) // "%beta_pol", func)
     call diff_type_float(structure_ref%beta_tor, structure_new%beta_tor, trim(name) // "%beta_tor", func)
     call diff_type_float(structure_ref%beta_normal, structure_new%beta_normal, trim(name) // "%beta_normal", func)
     call diff_type_float(structure_ref%i_plasma, structure_new%i_plasma, trim(name) // "%i_plasma", func)
     call diff_type_float(structure_ref%li, structure_new%li, trim(name) // "%li", func)
     call diff_type_float(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_float(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_float(structure_ref%psi_ax, structure_new%psi_ax, trim(name) // "%psi_ax", func)
     call diff_type_float(structure_ref%psi_bound, structure_new%psi_bound, trim(name) // "%psi_bound", func)
     call diff_type_mag_axis(structure_ref%mag_axis, structure_new%mag_axis, trim(name) // "%mag_axis", func)
     call diff_type_float(structure_ref%q_95, structure_new%q_95, trim(name) // "%q_95", func)
     call diff_type_float(structure_ref%q_min, structure_new%q_min, trim(name) // "%q_min", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
     call diff_type_float(structure_ref%w_mhd, structure_new%w_mhd, trim(name) // "%w_mhd", func)
     call diff_type_float(structure_ref%gamma, structure_new%gamma, trim(name) // "%gamma", func)
   end subroutine diff_type_global_param

   subroutine diff_arr_type_global_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_global_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_global_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_global_param

   subroutine diff_type_globalparam(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_globalparam), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%current_tot, structure_new%current_tot, trim(name) // "%current_tot", func)
     call diff_type_float(structure_ref%current_bnd, structure_new%current_bnd, trim(name) // "%current_bnd", func)
     call diff_type_float(structure_ref%current_ni, structure_new%current_ni, trim(name) // "%current_ni", func)
     call diff_type_float(structure_ref%vloop, structure_new%vloop, trim(name) // "%vloop", func)
     call diff_type_float(structure_ref%li, structure_new%li, trim(name) // "%li", func)
     call diff_type_float(structure_ref%beta_tor, structure_new%beta_tor, trim(name) // "%beta_tor", func)
     call diff_type_float(structure_ref%beta_normal, structure_new%beta_normal, trim(name) // "%beta_normal", func)
     call diff_type_float(structure_ref%beta_pol, structure_new%beta_pol, trim(name) // "%beta_pol", func)
     call diff_type_float(structure_ref%w_dia, structure_new%w_dia, trim(name) // "%w_dia", func)
     call diff_type_rz0D(structure_ref%geom_axis, structure_new%geom_axis, trim(name) // "%geom_axis", func)
   end subroutine diff_type_globalparam

   subroutine diff_arr_type_globalparam(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_globalparam), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_globalparam(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_globalparam

   subroutine diff_type_halpha_setup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_halpha_setup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_rzphi1D(structure_ref%pivot_point, structure_new%pivot_point, trim(name) // "%pivot_point", func)
     call diff_type_vecflt_type(structure_ref%horchordang, structure_new%horchordang, trim(name) // "%horchordang", func)
     call diff_type_vecflt_type(structure_ref%verchordang, structure_new%verchordang, trim(name) // "%verchordang", func)
     call diff_type_rzphi1D(structure_ref%second_point, structure_new%second_point, trim(name) // "%second_point", func)
     call diff_type_exp1D(structure_ref%solidangle, structure_new%solidangle, trim(name) // "%solidangle", func)
   end subroutine diff_type_halpha_setup

   subroutine diff_arr_type_halpha_setup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_halpha_setup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_halpha_setup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_halpha_setup

   subroutine diff_type_hcll(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_hcll), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_mat_lim(structure_ref%mat_lim, structure_new%mat_lim, trim(name) // "%mat_lim", func)
     call diff_type_hcll_bb(structure_ref%hcll_bb, structure_new%hcll_bb, trim(name) // "%hcll_bb", func)
   end subroutine diff_type_hcll

   subroutine diff_arr_type_hcll(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_hcll), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_hcll(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_hcll

   subroutine diff_type_hcll_bb(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_hcll_bb), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%bb_lifetime, structure_new%bb_lifetime, trim(name) // "%bb_lifetime", func)
     call diff_type_float(structure_ref%he_inl_t, structure_new%he_inl_t, trim(name) // "%he_inl_t", func)
     call diff_type_float(structure_ref%he_fr, structure_new%he_fr, trim(name) // "%he_fr", func)
     call diff_type_float(structure_ref%he_inl_p, structure_new%he_inl_p, trim(name) // "%he_inl_p", func)
     call diff_type_float(structure_ref%loca_des_p, structure_new%loca_des_p, trim(name) // "%loca_des_p", func)
     call diff_type_float(structure_ref%he_dp, structure_new%he_dp, trim(name) // "%he_dp", func)
     call diff_type_float(structure_ref%lipb_dp, structure_new%lipb_dp, trim(name) // "%lipb_dp", func)
     call diff_type_react(structure_ref%react, structure_new%react, trim(name) // "%react", func)
     call diff_type_hcllbb_specs(structure_ref%inboard, structure_new%inboard, trim(name) // "%inboard", func)
     call diff_type_hcllbb_specs(structure_ref%outboard, structure_new%outboard, trim(name) // "%outboard", func)
   end subroutine diff_type_hcll_bb

   subroutine diff_arr_type_hcll_bb(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_hcll_bb), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_hcll_bb(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_hcll_bb

   subroutine diff_type_hcllbb_specs(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_hcllbb_specs), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%mass, structure_new%mass, trim(name) // "%mass", func)
     call diff_type_vecflt_type(structure_ref%dr, structure_new%dr, trim(name) // "%dr", func)
     call diff_type_vecflt_type(structure_ref%mat, structure_new%mat, trim(name) // "%mat", func)
     call diff_type_matflt_type(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_bb_geometry(structure_ref%mod_geom, structure_new%mod_geom, trim(name) // "%mod_geom", func)
     call diff_type_mode_neutr(structure_ref%mod_neutr, structure_new%mod_neutr, trim(name) // "%mod_neutr", func)
     call diff_type_mode_therm(structure_ref%mod_therm, structure_new%mod_therm, trim(name) // "%mod_therm", func)
     call diff_type_mode_th_hyd(structure_ref%mod_th_hyd, structure_new%mod_th_hyd, trim(name) // "%mod_th_hyd", func)
     call diff_type_mode_mech(structure_ref%mod_mech, structure_new%mod_mech, trim(name) // "%mod_mech", func)
     call diff_type_mode_lipb(structure_ref%mod_lipb, structure_new%mod_lipb, trim(name) // "%mod_lipb", func)
     call diff_type_mode_tritium(structure_ref%mod_tritium, structure_new%mod_tritium, trim(name) // "%mod_tritium", func)
   end subroutine diff_type_hcllbb_specs

   subroutine diff_arr_type_hcllbb_specs(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_hcllbb_specs), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_hcllbb_specs(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_hcllbb_specs

   subroutine diff_type_holes(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_holes), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%n_holes, structure_new%n_holes, trim(name) // "%n_holes", func)
     call diff_type_coordinates(structure_ref%coordinates, structure_new%coordinates, trim(name) // "%coordinates", func)
     call diff_type_width(structure_ref%width, structure_new%width, trim(name) // "%width", func)
     call diff_type_vecflt_type(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
   end subroutine diff_type_holes

   subroutine diff_arr_type_holes(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_holes), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_holes(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_holes

   subroutine diff_type_identifier(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_identifier), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
   end subroutine diff_type_identifier

   subroutine diff_arr_type_identifier(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_identifier), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_identifier(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_identifier

   subroutine diff_type_impcoeff(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_impcoeff), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_coefficients_neutrals(structure_ref%chargestate, structure_new%chargestate, trim(name) // "%chargestate", func)
   end subroutine diff_type_impcoeff

   subroutine diff_arr_type_impcoeff(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_impcoeff), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_impcoeff(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_impcoeff

   subroutine diff_type_impurities(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_impurities), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nucindex, structure_new%nucindex, trim(name) // "%nucindex", func)
     call diff_type_integer(structure_ref%i_ion, structure_new%i_ion, trim(name) // "%i_ion", func)
     call diff_type_integer(structure_ref%nzimp, structure_new%nzimp, trim(name) // "%nzimp", func)
     call diff_type_vecflt_type(structure_ref%zmin, structure_new%zmin, trim(name) // "%zmin", func)
     call diff_type_vecflt_type(structure_ref%zmax, structure_new%zmax, trim(name) // "%zmax", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_impurities

   subroutine diff_arr_type_impurities(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_impurities), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_impurities(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_impurities

   subroutine diff_type_impurity_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_impurity_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_matflt_type(structure_ref%zsq, structure_new%zsq, trim(name) // "%zsq", func)
     call diff_type_matflt_type(structure_ref%nz, structure_new%nz, trim(name) // "%nz", func)
     call diff_type_matflt_type(structure_ref%tz, structure_new%tz, trim(name) // "%tz", func)
     call diff_type_sourceimp(structure_ref%source_term, structure_new%source_term, trim(name) // "%source_term", func)
     call diff_type_boundaryimp(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
     call diff_type_coretransimp(structure_ref%transp_coef, structure_new%transp_coef, trim(name) // "%transp_coef", func)
     call diff_type_fluximp(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_matflt_type(structure_ref%time_deriv, structure_new%time_deriv, trim(name) // "%time_deriv", func)
     call diff_type_coreimpurediag_type(structure_ref%diagnostic, structure_new%diagnostic, trim(name) // "%diagnostic", func)
   end subroutine diff_type_impurity_type

   subroutine diff_arr_type_impurity_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_impurity_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_impurity_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_impurity_type

   subroutine diff_type_inj_spec(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_inj_spec), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_float(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
   end subroutine diff_type_inj_spec

   subroutine diff_arr_type_inj_spec(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_inj_spec), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_inj_spec(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_inj_spec

   subroutine diff_type_ions(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ions), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nucindex, structure_new%nucindex, trim(name) // "%nucindex", func)
     call diff_type_float(structure_ref%zion, structure_new%zion, trim(name) // "%zion", func)
     call diff_type_integer(structure_ref%imp_flag, structure_new%imp_flag, trim(name) // "%imp_flag", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_ions

   subroutine diff_arr_type_ions(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ions), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ions(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ions

   subroutine diff_type_isoflux(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_isoflux), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecflt_type(structure_ref%weight, structure_new%weight, trim(name) // "%weight", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_vecflt_type(structure_ref%calculated, structure_new%calculated, trim(name) // "%calculated", func)
     call diff_type_vecflt_type(structure_ref%chi2, structure_new%chi2, trim(name) // "%chi2", func)
   end subroutine diff_type_isoflux

   subroutine diff_arr_type_isoflux(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_isoflux), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_isoflux(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_isoflux

   subroutine diff_type_jni(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_jni), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%integral, structure_new%integral, trim(name) // "%integral", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_jni

   subroutine diff_arr_type_jni(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_jni), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_jni(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_jni

   subroutine diff_type_lang_derived(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lang_derived), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_rzphi1Dexp(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_lang_derived

   subroutine diff_arr_type_lang_derived(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lang_derived), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_lang_derived(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_lang_derived

   subroutine diff_type_lang_measure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lang_measure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%direction, structure_new%direction, trim(name) // "%direction", func)
     call diff_type_exp1D(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_rzphi1Dexp(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_lang_measure

   subroutine diff_arr_type_lang_measure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lang_measure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_lang_measure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_lang_measure

   subroutine diff_type_launchangles(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchangles), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%alpha, structure_new%alpha, trim(name) // "%alpha", func)
     call diff_type_float(structure_ref%beta, structure_new%beta, trim(name) // "%beta", func)
   end subroutine diff_type_launchangles

   subroutine diff_arr_type_launchangles(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchangles), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchangles(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchangles

   subroutine diff_type_launchs_parallel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_parallel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%nn_par, structure_new%nn_par, trim(name) // "%nn_par", func)
     call diff_type_matflt_type(structure_ref%n_par, structure_new%n_par, trim(name) // "%n_par", func)
     call diff_type_vecflt_type(structure_ref%power, structure_new%power, trim(name) // "%power", func)
   end subroutine diff_type_launchs_parallel

   subroutine diff_arr_type_launchs_parallel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_parallel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchs_parallel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchs_parallel

   subroutine diff_type_launchs_phi_theta(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_phi_theta), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%nn_phi, structure_new%nn_phi, trim(name) // "%nn_phi", func)
     call diff_type_vecint_type(structure_ref%nn_theta, structure_new%nn_theta, trim(name) // "%nn_theta", func)
     call diff_type_matflt_type(structure_ref%n_phi, structure_new%n_phi, trim(name) // "%n_phi", func)
     call diff_type_matflt_type(structure_ref%n_theta, structure_new%n_theta, trim(name) // "%n_theta", func)
     call diff_type_array3dflt_type(structure_ref%power, structure_new%power, trim(name) // "%power", func)
   end subroutine diff_type_launchs_phi_theta

   subroutine diff_arr_type_launchs_phi_theta(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_phi_theta), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchs_phi_theta(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchs_phi_theta

   subroutine diff_type_launchs_rfbeam(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_rfbeam), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_launchs_rfbeam_spot(structure_ref%spot, structure_new%spot, trim(name) // "%spot", func)
     call diff_type_launchs_rfbeam_phaseellipse(structure_ref%phaseellipse, structure_new%phaseellipse, trim(name) // "%phaseellipse", func)
   end subroutine diff_type_launchs_rfbeam

   subroutine diff_arr_type_launchs_rfbeam(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_rfbeam), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchs_rfbeam(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchs_rfbeam

   subroutine diff_type_launchs_rfbeam_phaseellipse(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_rfbeam_phaseellipse), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%invcurvrad, structure_new%invcurvrad, trim(name) // "%invcurvrad", func)
     call diff_type_vecflt_type(structure_ref%angle, structure_new%angle, trim(name) // "%angle", func)
   end subroutine diff_type_launchs_rfbeam_phaseellipse

   subroutine diff_arr_type_launchs_rfbeam_phaseellipse(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_rfbeam_phaseellipse), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchs_rfbeam_phaseellipse(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchs_rfbeam_phaseellipse

   subroutine diff_type_launchs_rfbeam_spot(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_rfbeam_spot), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%waist, structure_new%waist, trim(name) // "%waist", func)
     call diff_type_vecflt_type(structure_ref%angle, structure_new%angle, trim(name) // "%angle", func)
   end subroutine diff_type_launchs_rfbeam_spot

   subroutine diff_arr_type_launchs_rfbeam_spot(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchs_rfbeam_spot), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchs_rfbeam_spot(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchs_rfbeam_spot

   subroutine diff_type_launchsignal(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchsignal), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%time_launch, structure_new%time_launch, trim(name) // "%time_launch", func)
     call diff_type_vecflt_type(structure_ref%freq, structure_new%freq, trim(name) // "%freq", func)
     call diff_type_vecflt_type(structure_ref%amplitude, structure_new%amplitude, trim(name) // "%amplitude", func)
     call diff_type_vecflt_type(structure_ref%phase, structure_new%phase, trim(name) // "%phase", func)
   end subroutine diff_type_launchsignal

   subroutine diff_arr_type_launchsignal(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_launchsignal), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_launchsignal(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_launchsignal

   subroutine diff_type_limiter_unit(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_limiter_unit), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%closed, structure_new%closed, trim(name) // "%closed", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_float(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
     call diff_type_float(structure_ref%delta, structure_new%delta, trim(name) // "%delta", func)
     call diff_type_float(structure_ref%permeability, structure_new%permeability, trim(name) // "%permeability", func)
   end subroutine diff_type_limiter_unit

   subroutine diff_arr_type_limiter_unit(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_limiter_unit), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_limiter_unit(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_limiter_unit

   subroutine diff_type_limits(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_limits), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%fw_dpa, structure_new%fw_dpa, trim(name) // "%fw_dpa", func)
     call diff_type_float(structure_ref%he_appm, structure_new%he_appm, trim(name) // "%he_appm", func)
     call diff_type_float(structure_ref%ins_dose, structure_new%ins_dose, trim(name) // "%ins_dose", func)
     call diff_type_float(structure_ref%fn_flu, structure_new%fn_flu, trim(name) // "%fn_flu", func)
     call diff_type_float(structure_ref%dpa_cu, structure_new%dpa_cu, trim(name) // "%dpa_cu", func)
     call diff_type_float(structure_ref%wp_nh, structure_new%wp_nh, trim(name) // "%wp_nh", func)
   end subroutine diff_type_limits

   subroutine diff_arr_type_limits(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_limits), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_limits(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_limits

   subroutine diff_type_lineintegraldiag(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lineintegraldiag), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_datainfo(structure_ref%datainfo, structure_new%datainfo, trim(name) // "%datainfo", func)
     call diff_type_vecstring_type(structure_ref%expression, structure_new%expression, trim(name) // "%expression", func)
     call diff_type_setup_line(structure_ref%setup_line, structure_new%setup_line, trim(name) // "%setup_line", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
   end subroutine diff_type_lineintegraldiag

   subroutine diff_arr_type_lineintegraldiag(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lineintegraldiag), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_lineintegraldiag(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_lineintegraldiag

   subroutine diff_type_lithmeasure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lithmeasure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
   end subroutine diff_type_lithmeasure

   subroutine diff_arr_type_lithmeasure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lithmeasure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_lithmeasure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_lithmeasure

   subroutine diff_type_lithsetup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lithsetup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_lithsetup

   subroutine diff_arr_type_lithsetup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_lithsetup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_lithsetup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_lithsetup

   subroutine diff_type_local(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_local), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%e_plus, structure_new%e_plus, trim(name) // "%e_plus", func)
     call diff_type_array3dflt_type(structure_ref%e_plus_ph, structure_new%e_plus_ph, trim(name) // "%e_plus_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_minus, structure_new%e_minus, trim(name) // "%e_minus", func)
     call diff_type_array3dflt_type(structure_ref%e_minus_ph, structure_new%e_minus_ph, trim(name) // "%e_minus_ph", func)
     call diff_type_array3dint_type(structure_ref%e_norm, structure_new%e_norm, trim(name) // "%e_norm", func)
     call diff_type_array3dflt_type(structure_ref%enorm_ph, structure_new%enorm_ph, trim(name) // "%enorm_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_binorm, structure_new%e_binorm, trim(name) // "%e_binorm", func)
     call diff_type_array3dflt_type(structure_ref%e_binorm_ph, structure_new%e_binorm_ph, trim(name) // "%e_binorm_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_para, structure_new%e_para, trim(name) // "%e_para", func)
     call diff_type_array3dflt_type(structure_ref%e_para_ph, structure_new%e_para_ph, trim(name) // "%e_para_ph", func)
     call diff_type_array3dflt_type(structure_ref%b_norm, structure_new%b_norm, trim(name) // "%b_norm", func)
     call diff_type_array3dflt_type(structure_ref%b_norm_ph, structure_new%b_norm_ph, trim(name) // "%b_norm_ph", func)
     call diff_type_array3dflt_type(structure_ref%b_binorm, structure_new%b_binorm, trim(name) // "%b_binorm", func)
     call diff_type_array3dflt_type(structure_ref%b_binorm_ph, structure_new%b_binorm_ph, trim(name) // "%b_binorm_ph", func)
     call diff_type_array3dflt_type(structure_ref%b_para, structure_new%b_para, trim(name) // "%b_para", func)
     call diff_type_array3dflt_type(structure_ref%b_para_ph, structure_new%b_para_ph, trim(name) // "%b_para_ph", func)
     call diff_type_array3dflt_type(structure_ref%k_perp, structure_new%k_perp, trim(name) // "%k_perp", func)
   end subroutine diff_type_local

   subroutine diff_arr_type_local(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_local), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_local(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_local

   subroutine diff_type_mag_axis(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mag_axis), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz0D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_float(structure_ref%bphi, structure_new%bphi, trim(name) // "%bphi", func)
     call diff_type_float(structure_ref%q, structure_new%q, trim(name) // "%q", func)
   end subroutine diff_type_mag_axis

   subroutine diff_arr_type_mag_axis(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mag_axis), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mag_axis(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mag_axis

   subroutine diff_type_magnet_iron(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_magnet_iron), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_eqmes1D(structure_ref%mr, structure_new%mr, trim(name) // "%mr", func)
     call diff_type_eqmes1D(structure_ref%mz, structure_new%mz, trim(name) // "%mz", func)
   end subroutine diff_type_magnet_iron

   subroutine diff_arr_type_magnet_iron(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_magnet_iron), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_magnet_iron(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_magnet_iron

   subroutine diff_type_magnetise(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_magnetise), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%mr, structure_new%mr, trim(name) // "%mr", func)
     call diff_type_exp1D(structure_ref%mz, structure_new%mz, trim(name) // "%mz", func)
   end subroutine diff_type_magnetise

   subroutine diff_arr_type_magnetise(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_magnetise), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_magnetise(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_magnetise

   subroutine diff_type_mat_lim(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mat_lim), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%cool_t_lim, structure_new%cool_t_lim, trim(name) // "%cool_t_lim", func)
     call diff_type_float(structure_ref%steel_t_lim, structure_new%steel_t_lim, trim(name) // "%steel_t_lim", func)
     call diff_type_float(structure_ref%lipb_t_lim, structure_new%lipb_t_lim, trim(name) // "%lipb_t_lim", func)
   end subroutine diff_type_mat_lim

   subroutine diff_arr_type_mat_lim(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mat_lim), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mat_lim(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mat_lim

   subroutine diff_type_mdinfo(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mdinfo), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%shot_min, structure_new%shot_min, trim(name) // "%shot_min", func)
     call diff_type_integer(structure_ref%shot_max, structure_new%shot_max, trim(name) // "%shot_max", func)
     call diff_type_entry_def(structure_ref%md_entry, structure_new%md_entry, trim(name) // "%md_entry", func)
   end subroutine diff_type_mdinfo

   subroutine diff_arr_type_mdinfo(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mdinfo), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mdinfo(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mdinfo

   subroutine diff_type_mhd_ideal_wall2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_ideal_wall2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%walltype, structure_new%walltype, trim(name) // "%walltype", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_mhd_ideal_wall2d

   subroutine diff_arr_type_mhd_ideal_wall2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_ideal_wall2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd_ideal_wall2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd_ideal_wall2d

   subroutine diff_type_mhd_mode(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_mode), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%modenum, structure_new%modenum, trim(name) // "%modenum", func)
     call diff_type_float(structure_ref%growthrate, structure_new%growthrate, trim(name) // "%growthrate", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_mhd_plasma(structure_ref%plasma, structure_new%plasma, trim(name) // "%plasma", func)
     call diff_type_mhd_vacuum(structure_ref%vacuum, structure_new%vacuum, trim(name) // "%vacuum", func)
   end subroutine diff_type_mhd_mode

   subroutine diff_arr_type_mhd_mode(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_mode), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd_mode(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd_mode

   subroutine diff_type_mhd_plasma(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_plasma), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_matflt_type(structure_ref%m, structure_new%m, trim(name) // "%m", func)
     call diff_type_matcplx_type(structure_ref%disp_perp, structure_new%disp_perp, trim(name) // "%disp_perp", func)
     call diff_type_matcplx_type(structure_ref%disp_par, structure_new%disp_par, trim(name) // "%disp_par", func)
     call diff_type_vecflt_type(structure_ref%tau_alfven, structure_new%tau_alfven, trim(name) // "%tau_alfven", func)
     call diff_type_vecflt_type(structure_ref%tau_res, structure_new%tau_res, trim(name) // "%tau_res", func)
     call diff_type_coord_sys(structure_ref%coord_sys, structure_new%coord_sys, trim(name) // "%coord_sys", func)
     call diff_type_mhd_vector(structure_ref%a_pert, structure_new%a_pert, trim(name) // "%a_pert", func)
     call diff_type_mhd_vector(structure_ref%b_pert, structure_new%b_pert, trim(name) // "%b_pert", func)
     call diff_type_mhd_vector(structure_ref%v_pert, structure_new%v_pert, trim(name) // "%v_pert", func)
     call diff_type_matcplx_type(structure_ref%p_pert, structure_new%p_pert, trim(name) // "%p_pert", func)
     call diff_type_matcplx_type(structure_ref%rho_mass_per, structure_new%rho_mass_per, trim(name) // "%rho_mass_per", func)
     call diff_type_matcplx_type(structure_ref%temp_per, structure_new%temp_per, trim(name) // "%temp_per", func)
   end subroutine diff_type_mhd_plasma

   subroutine diff_arr_type_mhd_plasma(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_plasma), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd_plasma(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd_plasma

   subroutine diff_type_mhd_res_wall2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_res_wall2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%walltype, structure_new%walltype, trim(name) // "%walltype", func)
     call diff_type_float(structure_ref%delta, structure_new%delta, trim(name) // "%delta", func)
     call diff_type_float(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
     call diff_type_integer(structure_ref%npoloidal, structure_new%npoloidal, trim(name) // "%npoloidal", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_holes(structure_ref%holes, structure_new%holes, trim(name) // "%holes", func)
   end subroutine diff_type_mhd_res_wall2d

   subroutine diff_arr_type_mhd_res_wall2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_res_wall2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd_res_wall2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd_res_wall2d

   subroutine diff_type_mhd_vacuum(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_vacuum), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%m, structure_new%m, trim(name) // "%m", func)
     call diff_type_coord_sys(structure_ref%coord_sys, structure_new%coord_sys, trim(name) // "%coord_sys", func)
     call diff_type_mhd_vector(structure_ref%a_pert, structure_new%a_pert, trim(name) // "%a_pert", func)
     call diff_type_mhd_vector(structure_ref%b_pert, structure_new%b_pert, trim(name) // "%b_pert", func)
   end subroutine diff_type_mhd_vacuum

   subroutine diff_arr_type_mhd_vacuum(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_vacuum), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd_vacuum(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd_vacuum

   subroutine diff_type_mhd_vector(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_vector), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matcplx_type(structure_ref%coord1, structure_new%coord1, trim(name) // "%coord1", func)
     call diff_type_matcplx_type(structure_ref%coord2, structure_new%coord2, trim(name) // "%coord2", func)
     call diff_type_matcplx_type(structure_ref%coord3, structure_new%coord3, trim(name) // "%coord3", func)
   end subroutine diff_type_mhd_vector

   subroutine diff_arr_type_mhd_vector(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mhd_vector), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mhd_vector(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mhd_vector

   subroutine diff_type_mode_lipb(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_lipb), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%lp_rec_day, structure_new%lp_rec_day, trim(name) // "%lp_rec_day", func)
     call diff_type_vecflt_type(structure_ref%bb_lp_fr, structure_new%bb_lp_fr, trim(name) // "%bb_lp_fr", func)
     call diff_type_float(structure_ref%lp_inl_p, structure_new%lp_inl_p, trim(name) // "%lp_inl_p", func)
     call diff_type_float(structure_ref%bu_dp_lp, structure_new%bu_dp_lp, trim(name) // "%bu_dp_lp", func)
     call diff_type_float(structure_ref%man_dp_lp, structure_new%man_dp_lp, trim(name) // "%man_dp_lp", func)
     call diff_type_float(structure_ref%tot_dp_lp, structure_new%tot_dp_lp, trim(name) // "%tot_dp_lp", func)
     call diff_type_float(structure_ref%bu_lp_ave_t, structure_new%bu_lp_ave_t, trim(name) // "%bu_lp_ave_t", func)
     call diff_type_float(structure_ref%bu_lp_max_t, structure_new%bu_lp_max_t, trim(name) // "%bu_lp_max_t", func)
   end subroutine diff_type_mode_lipb

   subroutine diff_arr_type_mode_lipb(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_lipb), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mode_lipb(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mode_lipb

   subroutine diff_type_mode_mech(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_mech), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%fw_min_ts_mg, structure_new%fw_min_ts_mg, trim(name) // "%fw_min_ts_mg", func)
     call diff_type_float(structure_ref%fw_min_bd_mg, structure_new%fw_min_bd_mg, trim(name) // "%fw_min_bd_mg", func)
     call diff_type_float(structure_ref%sg_min_ts_mg, structure_new%sg_min_ts_mg, trim(name) // "%sg_min_ts_mg", func)
     call diff_type_float(structure_ref%sg_min_bd_mg, structure_new%sg_min_bd_mg, trim(name) // "%sg_min_bd_mg", func)
     call diff_type_float(structure_ref%cp_min_ts_mg, structure_new%cp_min_ts_mg, trim(name) // "%cp_min_ts_mg", func)
     call diff_type_float(structure_ref%cp_min_bd_mg, structure_new%cp_min_bd_mg, trim(name) // "%cp_min_bd_mg", func)
     call diff_type_float(structure_ref%min_ts_mg_ac, structure_new%min_ts_mg_ac, trim(name) // "%min_ts_mg_ac", func)
     call diff_type_float(structure_ref%min_bd_mg_ac, structure_new%min_bd_mg_ac, trim(name) // "%min_bd_mg_ac", func)
   end subroutine diff_type_mode_mech

   subroutine diff_arr_type_mode_mech(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_mech), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mode_mech(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mode_mech

   subroutine diff_type_mode_neutr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_neutr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%pd_rad, structure_new%pd_rad, trim(name) // "%pd_rad", func)
     call diff_type_vecflt_type(structure_ref%lipb_coef_pd, structure_new%lipb_coef_pd, trim(name) // "%lipb_coef_pd", func)
     call diff_type_vecflt_type(structure_ref%steel_coef_pd, structure_new%steel_coef_pd, trim(name) // "%steel_coef_pd", func)
     call diff_type_power_exchange(structure_ref%pow_exchange, structure_new%pow_exchange, trim(name) // "%pow_exchange", func)
   end subroutine diff_type_mode_neutr

   subroutine diff_arr_type_mode_neutr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_neutr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mode_neutr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mode_neutr

   subroutine diff_type_mode_th_hyd(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_th_hyd), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%fw_dp_he, structure_new%fw_dp_he, trim(name) // "%fw_dp_he", func)
     call diff_type_float(structure_ref%sg_dp_he, structure_new%sg_dp_he, trim(name) // "%sg_dp_he", func)
     call diff_type_float(structure_ref%cp_dp_he, structure_new%cp_dp_he, trim(name) // "%cp_dp_he", func)
     call diff_type_float(structure_ref%man_dp_he, structure_new%man_dp_he, trim(name) // "%man_dp_he", func)
     call diff_type_float(structure_ref%tot_dp_he, structure_new%tot_dp_he, trim(name) // "%tot_dp_he", func)
     call diff_type_float(structure_ref%bp_dp_he, structure_new%bp_dp_he, trim(name) // "%bp_dp_he", func)
     call diff_type_float(structure_ref%circ_dp_he, structure_new%circ_dp_he, trim(name) // "%circ_dp_he", func)
   end subroutine diff_type_mode_th_hyd

   subroutine diff_arr_type_mode_th_hyd(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_th_hyd), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mode_th_hyd(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mode_th_hyd

   subroutine diff_type_mode_therm(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_therm), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%he_fr, structure_new%he_fr, trim(name) // "%he_fr", func)
     call diff_type_float(structure_ref%perc_bp_he, structure_new%perc_bp_he, trim(name) // "%perc_bp_he", func)
     call diff_type_float(structure_ref%he_out_t, structure_new%he_out_t, trim(name) // "%he_out_t", func)
     call diff_type_float(structure_ref%fw_he_out_t, structure_new%fw_he_out_t, trim(name) // "%fw_he_out_t", func)
     call diff_type_float(structure_ref%sg_he_out_t, structure_new%sg_he_out_t, trim(name) // "%sg_he_out_t", func)
     call diff_type_float(structure_ref%cp_he_out_t, structure_new%cp_he_out_t, trim(name) // "%cp_he_out_t", func)
     call diff_type_float(structure_ref%fw_st_max_t, structure_new%fw_st_max_t, trim(name) // "%fw_st_max_t", func)
     call diff_type_float(structure_ref%sg_st_max_t, structure_new%sg_st_max_t, trim(name) // "%sg_st_max_t", func)
     call diff_type_float(structure_ref%cp_st_max_t, structure_new%cp_st_max_t, trim(name) // "%cp_st_max_t", func)
   end subroutine diff_type_mode_therm

   subroutine diff_arr_type_mode_therm(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_therm), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mode_therm(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mode_therm

   subroutine diff_type_mode_tritium(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_tritium), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%t_conc_lipb, structure_new%t_conc_lipb, trim(name) // "%t_conc_lipb", func)
     call diff_type_float(structure_ref%t_conc_he, structure_new%t_conc_he, trim(name) // "%t_conc_he", func)
   end subroutine diff_type_mode_tritium

   subroutine diff_arr_type_mode_tritium(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_mode_tritium), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_mode_tritium(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_mode_tritium

   subroutine diff_type_modules(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_modules), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nma_theta, structure_new%nma_theta, trim(name) // "%nma_theta", func)
     call diff_type_integer(structure_ref%nma_phi, structure_new%nma_phi, trim(name) // "%nma_phi", func)
     call diff_type_vecint_type(structure_ref%ima_theta, structure_new%ima_theta, trim(name) // "%ima_theta", func)
     call diff_type_vecint_type(structure_ref%ima_phi, structure_new%ima_phi, trim(name) // "%ima_phi", func)
     call diff_type_float(structure_ref%sm_theta, structure_new%sm_theta, trim(name) // "%sm_theta", func)
     call diff_type_exp1D(structure_ref%amplitude, structure_new%amplitude, trim(name) // "%amplitude", func)
     call diff_type_exp1D(structure_ref%phase, structure_new%phase, trim(name) // "%phase", func)
     call diff_type_waveguides(structure_ref%waveguides, structure_new%waveguides, trim(name) // "%waveguides", func)
   end subroutine diff_type_modules

   subroutine diff_arr_type_modules(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_modules), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_modules(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_modules

   subroutine diff_type_msediag_emiss_chord(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_emiss_chord), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_rzphi1D(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_arr_type_msediag_polarization(structure_ref%polarization, structure_new%polarization, trim(name) // "%polarization", func)
     call diff_type_vecflt_type(structure_ref%quantiaxis, structure_new%quantiaxis, trim(name) // "%quantiaxis", func)
   end subroutine diff_type_msediag_emiss_chord

   subroutine diff_arr_type_msediag_emiss_chord(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_emiss_chord), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_emiss_chord(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_emiss_chord

   subroutine diff_type_msediag_emissivity(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_emissivity), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%wavelength, structure_new%wavelength, trim(name) // "%wavelength", func)
     call diff_arr_type_msediag_emiss_chord(structure_ref%emiss_chord, structure_new%emiss_chord, trim(name) // "%emiss_chord", func)
   end subroutine diff_type_msediag_emissivity

   subroutine diff_arr_type_msediag_emissivity(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_emissivity), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_emissivity(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_emissivity

   subroutine diff_type_msediag_polarization(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_polarization), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_matflt_type(structure_ref%spec_emiss, structure_new%spec_emiss, trim(name) // "%spec_emiss", func)
   end subroutine diff_type_msediag_polarization

   subroutine diff_arr_type_msediag_polarization(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_polarization), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_polarization(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_polarization

   subroutine diff_type_msediag_radia_chord(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_radia_chord), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_msediag_setup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_arr_type_msediag_stokes(structure_ref%stokes, structure_new%stokes, trim(name) // "%stokes", func)
     call diff_type_exp1D(structure_ref%totradiance, structure_new%totradiance, trim(name) // "%totradiance", func)
   end subroutine diff_type_msediag_radia_chord

   subroutine diff_arr_type_msediag_radia_chord(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_radia_chord), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_radia_chord(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_radia_chord

   subroutine diff_type_msediag_radiance(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_radiance), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%wavelength, structure_new%wavelength, trim(name) // "%wavelength", func)
     call diff_arr_type_msediag_radia_chord(structure_ref%radia_chord, structure_new%radia_chord, trim(name) // "%radia_chord", func)
   end subroutine diff_type_msediag_radiance

   subroutine diff_arr_type_msediag_radiance(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_radiance), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_radiance(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_radiance

   subroutine diff_type_msediag_setup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_setup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi0D(structure_ref%pivot_point, structure_new%pivot_point, trim(name) // "%pivot_point", func)
     call diff_type_float(structure_ref%horchordang, structure_new%horchordang, trim(name) // "%horchordang", func)
     call diff_type_float(structure_ref%verchordang, structure_new%verchordang, trim(name) // "%verchordang", func)
     call diff_type_rzphi0D(structure_ref%second_point, structure_new%second_point, trim(name) // "%second_point", func)
   end subroutine diff_type_msediag_setup

   subroutine diff_arr_type_msediag_setup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_setup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_setup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_setup

   subroutine diff_type_msediag_setup_polarimetry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_setup_polarimetry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphidrdzdphi1D(structure_ref%rzgamma, structure_new%rzgamma, trim(name) // "%rzgamma", func)
     call diff_type_matflt_type(structure_ref%geom_coef, structure_new%geom_coef, trim(name) // "%geom_coef", func)
   end subroutine diff_type_msediag_setup_polarimetry

   subroutine diff_arr_type_msediag_setup_polarimetry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_setup_polarimetry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_setup_polarimetry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_setup_polarimetry

   subroutine diff_type_msediag_stokes(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_stokes), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_matflt_type(structure_ref%vector, structure_new%vector, trim(name) // "%vector", func)
   end subroutine diff_type_msediag_stokes

   subroutine diff_arr_type_msediag_stokes(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_msediag_stokes), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_msediag_stokes(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_msediag_stokes

   subroutine diff_type_nbi_nbi_unit_wall(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi_nbi_unit_wall), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_nbi_nbi_unit_wall_surface(structure_ref%surface, structure_new%surface, trim(name) // "%surface", func)
     call diff_arr_type_flat_polygon(structure_ref%collimator, structure_new%collimator, trim(name) // "%collimator", func)
   end subroutine diff_type_nbi_nbi_unit_wall

   subroutine diff_arr_type_nbi_nbi_unit_wall(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi_nbi_unit_wall), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_nbi_nbi_unit_wall(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_nbi_nbi_unit_wall

   subroutine diff_type_nbi_nbi_unit_wall_surface(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi_nbi_unit_wall_surface), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_trianglexyz(structure_ref%triangle, structure_new%triangle, trim(name) // "%triangle", func)
     call diff_arr_type_rectanglexyz(structure_ref%rectangle, structure_new%rectangle, trim(name) // "%rectangle", func)
   end subroutine diff_type_nbi_nbi_unit_wall_surface

   subroutine diff_arr_type_nbi_nbi_unit_wall_surface(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi_nbi_unit_wall_surface), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_nbi_nbi_unit_wall_surface(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_nbi_nbi_unit_wall_surface

   subroutine diff_type_nbi_unit(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi_unit), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_inj_spec(structure_ref%inj_spec, structure_new%inj_spec, trim(name) // "%inj_spec", func)
     call diff_type_exp0D(structure_ref%pow_unit, structure_new%pow_unit, trim(name) // "%pow_unit", func)
     call diff_type_exp0D(structure_ref%inj_eng_unit, structure_new%inj_eng_unit, trim(name) // "%inj_eng_unit", func)
     call diff_type_exp1D(structure_ref%beamcurrfrac, structure_new%beamcurrfrac, trim(name) // "%beamcurrfrac", func)
     call diff_type_exp1D(structure_ref%beampowrfrac, structure_new%beampowrfrac, trim(name) // "%beampowrfrac", func)
     call diff_arr_type_beamletgroup(structure_ref%beamletgroup, structure_new%beamletgroup, trim(name) // "%beamletgroup", func)
     call diff_type_nbi_nbi_unit_wall(structure_ref%wall, structure_new%wall, trim(name) // "%wall", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_nbi_unit

   subroutine diff_arr_type_nbi_unit(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nbi_unit), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_nbi_unit(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_nbi_unit

   subroutine diff_type_ne_transp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ne_transp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%diff_eff, structure_new%diff_eff, trim(name) // "%diff_eff", func)
     call diff_type_matflt_type(structure_ref%vconv_eff, structure_new%vconv_eff, trim(name) // "%vconv_eff", func)
     call diff_type_vecflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_offdiagel(structure_ref%off_diagonal, structure_new%off_diagonal, trim(name) // "%off_diagonal", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
   end subroutine diff_type_ne_transp

   subroutine diff_arr_type_ne_transp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ne_transp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ne_transp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ne_transp

   subroutine diff_type_neoclassic_impurity(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neoclassic_impurity), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%utheta_z, structure_new%utheta_z, trim(name) // "%utheta_z", func)
   end subroutine diff_type_neoclassic_impurity

   subroutine diff_arr_type_neoclassic_impurity(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neoclassic_impurity), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_neoclassic_impurity(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_neoclassic_impurity

   subroutine diff_type_neut_results(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neut_results), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%tbr_bk, structure_new%tbr_bk, trim(name) // "%tbr_bk", func)
     call diff_type_float(structure_ref%tbr_bk_inb, structure_new%tbr_bk_inb, trim(name) // "%tbr_bk_inb", func)
     call diff_type_float(structure_ref%tbr_bk_outb, structure_new%tbr_bk_outb, trim(name) // "%tbr_bk_outb", func)
     call diff_type_float(structure_ref%me_bk, structure_new%me_bk, trim(name) // "%me_bk", func)
     call diff_type_float(structure_ref%me_shield, structure_new%me_shield, trim(name) // "%me_shield", func)
     call diff_type_float(structure_ref%he_appm_res, structure_new%he_appm_res, trim(name) // "%he_appm_res", func)
     call diff_type_float(structure_ref%ins_dose_max, structure_new%ins_dose_max, trim(name) // "%ins_dose_max", func)
     call diff_type_float(structure_ref%fn_flu_max, structure_new%fn_flu_max, trim(name) // "%fn_flu_max", func)
     call diff_type_float(structure_ref%dpa_cu_max, structure_new%dpa_cu_max, trim(name) // "%dpa_cu_max", func)
     call diff_type_float(structure_ref%fn_flux_bz, structure_new%fn_flux_bz, trim(name) // "%fn_flux_bz", func)
     call diff_type_float(structure_ref%fn_flux_bp, structure_new%fn_flux_bp, trim(name) // "%fn_flux_bp", func)
     call diff_type_float(structure_ref%fn_flux_man, structure_new%fn_flux_man, trim(name) // "%fn_flux_man", func)
     call diff_type_float(structure_ref%fn_flux_sh, structure_new%fn_flux_sh, trim(name) // "%fn_flux_sh", func)
     call diff_type_float(structure_ref%p_nh_bk, structure_new%p_nh_bk, trim(name) // "%p_nh_bk", func)
     call diff_type_float(structure_ref%p_nh_sh, structure_new%p_nh_sh, trim(name) // "%p_nh_sh", func)
   end subroutine diff_type_neut_results

   subroutine diff_arr_type_neut_results(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neut_results), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_neut_results(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_neut_results

   subroutine diff_type_neutral_complex_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neutral_complex_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_coreneutrals_neutraltype(structure_ref%neutraltype, structure_new%neutraltype, trim(name) // "%neutraltype", func)
     call diff_type_vecflt_type(structure_ref%prad0, structure_new%prad0, trim(name) // "%prad0", func)
   end subroutine diff_type_neutral_complex_type

   subroutine diff_arr_type_neutral_complex_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neutral_complex_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_neutral_complex_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_neutral_complex_type

   subroutine diff_type_neutro_resul(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neutro_resul), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%nwl_max, structure_new%nwl_max, trim(name) // "%nwl_max", func)
     call diff_type_vecflt_type(structure_ref%nwl_pol_prof, structure_new%nwl_pol_prof, trim(name) // "%nwl_pol_prof", func)
   end subroutine diff_type_neutro_resul

   subroutine diff_arr_type_neutro_resul(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_neutro_resul), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_neutro_resul(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_neutro_resul

   subroutine diff_type_ni_transp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ni_transp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%diff_eff, structure_new%diff_eff, trim(name) // "%diff_eff", func)
     call diff_type_array3dflt_type(structure_ref%vconv_eff, structure_new%vconv_eff, trim(name) // "%vconv_eff", func)
     call diff_type_matflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_offdiagion(structure_ref%off_diagonal, structure_new%off_diagonal, trim(name) // "%off_diagonal", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
   end subroutine diff_type_ni_transp

   subroutine diff_arr_type_ni_transp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ni_transp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ni_transp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ni_transp

   subroutine diff_type_ntm_mode(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_ntm_mode_onset(structure_ref%onset, structure_new%onset, trim(name) // "%onset", func)
     call diff_type_ntm_mode_full_evol(structure_ref%full_evol, structure_new%full_evol, trim(name) // "%full_evol", func)
     call diff_type_ntm_mode_evolution(structure_ref%evolution, structure_new%evolution, trim(name) // "%evolution", func)
   end subroutine diff_type_ntm_mode

   subroutine diff_arr_type_ntm_mode(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm_mode(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm_mode

   subroutine diff_type_ntm_mode_evolution(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_evolution), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%w, structure_new%w, trim(name) // "%w", func)
     call diff_type_float(structure_ref%dwdt, structure_new%dwdt, trim(name) // "%dwdt", func)
     call diff_type_float(structure_ref%phase, structure_new%phase, trim(name) // "%phase", func)
     call diff_type_float(structure_ref%dphasedt, structure_new%dphasedt, trim(name) // "%dphasedt", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_float(structure_ref%dfrequencydt, structure_new%dfrequencydt, trim(name) // "%dfrequencydt", func)
     call diff_type_ntm_mode_evolution_island(structure_ref%island, structure_new%island, trim(name) // "%island", func)
     call diff_type_integer(structure_ref%n, structure_new%n, trim(name) // "%n", func)
     call diff_type_integer(structure_ref%m, structure_new%m, trim(name) // "%m", func)
     call diff_type_vecflt_type(structure_ref%deltaw_value, structure_new%deltaw_value, trim(name) // "%deltaw_value", func)
     call diff_type_vecstring_type(structure_ref%deltaw_name, structure_new%deltaw_name, trim(name) // "%deltaw_name", func)
     call diff_type_vecflt_type(structure_ref%torque_value, structure_new%torque_value, trim(name) // "%torque_value", func)
     call diff_type_vecstring_type(structure_ref%torque_name, structure_new%torque_name, trim(name) // "%torque_name", func)
     call diff_type_vecflt_type(structure_ref%delta_diff, structure_new%delta_diff, trim(name) // "%delta_diff", func)
     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
     call diff_type_float(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
   end subroutine diff_type_ntm_mode_evolution

   subroutine diff_arr_type_ntm_mode_evolution(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_evolution), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm_mode_evolution(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm_mode_evolution

   subroutine diff_type_ntm_mode_evolution_island(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_evolution_island), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_vecflt_type(structure_ref%coord_values, structure_new%coord_values, trim(name) // "%coord_values", func)
     call diff_type_vecstring_type(structure_ref%coord_desc, structure_new%coord_desc, trim(name) // "%coord_desc", func)
   end subroutine diff_type_ntm_mode_evolution_island

   subroutine diff_arr_type_ntm_mode_evolution_island(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_evolution_island), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm_mode_evolution_island(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm_mode_evolution_island

   subroutine diff_type_ntm_mode_full_evol(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_full_evol), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%time_evol, structure_new%time_evol, trim(name) // "%time_evol", func)
     call diff_type_vecflt_type(structure_ref%w, structure_new%w, trim(name) // "%w", func)
     call diff_type_vecflt_type(structure_ref%dwdt, structure_new%dwdt, trim(name) // "%dwdt", func)
     call diff_type_vecflt_type(structure_ref%phase, structure_new%phase, trim(name) // "%phase", func)
     call diff_type_vecflt_type(structure_ref%dphasedt, structure_new%dphasedt, trim(name) // "%dphasedt", func)
     call diff_type_vecflt_type(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_vecflt_type(structure_ref%dfrequencydt, structure_new%dfrequencydt, trim(name) // "%dfrequencydt", func)
     call diff_type_ntm_mode_full_evol_island(structure_ref%island, structure_new%island, trim(name) // "%island", func)
     call diff_type_integer(structure_ref%n, structure_new%n, trim(name) // "%n", func)
     call diff_type_integer(structure_ref%m, structure_new%m, trim(name) // "%m", func)
     call diff_type_matflt_type(structure_ref%deltaw_value, structure_new%deltaw_value, trim(name) // "%deltaw_value", func)
     call diff_type_vecstring_type(structure_ref%deltaw_name, structure_new%deltaw_name, trim(name) // "%deltaw_name", func)
     call diff_type_matflt_type(structure_ref%torque_value, structure_new%torque_value, trim(name) // "%torque_value", func)
     call diff_type_vecstring_type(structure_ref%torque_name, structure_new%torque_name, trim(name) // "%torque_name", func)
     call diff_type_matflt_type(structure_ref%delta_diff, structure_new%delta_diff, trim(name) // "%delta_diff", func)
     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
   end subroutine diff_type_ntm_mode_full_evol

   subroutine diff_arr_type_ntm_mode_full_evol(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_full_evol), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm_mode_full_evol(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm_mode_full_evol

   subroutine diff_type_ntm_mode_full_evol_island(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_full_evol_island), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_matflt_type(structure_ref%coord_values, structure_new%coord_values, trim(name) // "%coord_values", func)
     call diff_type_vecstring_type(structure_ref%coord_desc, structure_new%coord_desc, trim(name) // "%coord_desc", func)
   end subroutine diff_type_ntm_mode_full_evol_island

   subroutine diff_arr_type_ntm_mode_full_evol_island(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_full_evol_island), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm_mode_full_evol_island(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm_mode_full_evol_island

   subroutine diff_type_ntm_mode_onset(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_onset), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%w, structure_new%w, trim(name) // "%w", func)
     call diff_type_float(structure_ref%time_onset, structure_new%time_onset, trim(name) // "%time_onset", func)
     call diff_type_float(structure_ref%time_offset, structure_new%time_offset, trim(name) // "%time_offset", func)
     call diff_type_float(structure_ref%phase, structure_new%phase, trim(name) // "%phase", func)
     call diff_type_integer(structure_ref%n, structure_new%n, trim(name) // "%n", func)
     call diff_type_integer(structure_ref%m, structure_new%m, trim(name) // "%m", func)
     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
   end subroutine diff_type_ntm_mode_onset

   subroutine diff_arr_type_ntm_mode_onset(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_ntm_mode_onset), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_ntm_mode_onset(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_ntm_mode_onset

   subroutine diff_type_nuclei(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nuclei), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
   end subroutine diff_type_nuclei

   subroutine diff_arr_type_nuclei(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_nuclei), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_nuclei(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_nuclei

   subroutine diff_type_objects(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_objects), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matint_type(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
     call diff_type_array3dint_type(structure_ref%neighbour, structure_new%neighbour, trim(name) // "%neighbour", func)
     call diff_type_array4dflt_type(structure_ref%geo, structure_new%geo, trim(name) // "%geo", func)
     call diff_type_matflt_type(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_objects

   subroutine diff_arr_type_objects(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_objects), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_objects(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_objects

   subroutine diff_type_offdiagel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_offdiagel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%d_ni, structure_new%d_ni, trim(name) // "%d_ni", func)
     call diff_type_matflt_type(structure_ref%d_ti, structure_new%d_ti, trim(name) // "%d_ti", func)
     call diff_type_vecflt_type(structure_ref%d_ne, structure_new%d_ne, trim(name) // "%d_ne", func)
     call diff_type_vecflt_type(structure_ref%d_te, structure_new%d_te, trim(name) // "%d_te", func)
     call diff_type_vecflt_type(structure_ref%d_epar, structure_new%d_epar, trim(name) // "%d_epar", func)
     call diff_type_vecflt_type(structure_ref%d_mtor, structure_new%d_mtor, trim(name) // "%d_mtor", func)
   end subroutine diff_type_offdiagel

   subroutine diff_arr_type_offdiagel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_offdiagel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_offdiagel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_offdiagel

   subroutine diff_type_offdiagion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_offdiagion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%d_ni, structure_new%d_ni, trim(name) // "%d_ni", func)
     call diff_type_array3dflt_type(structure_ref%d_ti, structure_new%d_ti, trim(name) // "%d_ti", func)
     call diff_type_matflt_type(structure_ref%d_ne, structure_new%d_ne, trim(name) // "%d_ne", func)
     call diff_type_matflt_type(structure_ref%d_te, structure_new%d_te, trim(name) // "%d_te", func)
     call diff_type_matflt_type(structure_ref%d_epar, structure_new%d_epar, trim(name) // "%d_epar", func)
     call diff_type_matflt_type(structure_ref%d_mtor, structure_new%d_mtor, trim(name) // "%d_mtor", func)
   end subroutine diff_type_offdiagion

   subroutine diff_arr_type_offdiagion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_offdiagion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_offdiagion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_offdiagion

   subroutine diff_type_omnigen_surf(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_omnigen_surf), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz1D(structure_ref%rz, structure_new%rz, trim(name) // "%rz", func)
     call diff_type_vecflt_type(structure_ref%s, structure_new%s, trim(name) // "%s", func)
   end subroutine diff_type_omnigen_surf

   subroutine diff_arr_type_omnigen_surf(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_omnigen_surf), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_omnigen_surf(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_omnigen_surf

   subroutine diff_type_orbit_global_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_global_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%orbit_type, structure_new%orbit_type, trim(name) // "%orbit_type", func)
     call diff_type_vecflt_type(structure_ref%omega_b, structure_new%omega_b, trim(name) // "%omega_b", func)
     call diff_type_vecflt_type(structure_ref%omega_phi, structure_new%omega_phi, trim(name) // "%omega_phi", func)
     call diff_type_vecflt_type(structure_ref%omega_c_av, structure_new%omega_c_av, trim(name) // "%omega_c_av", func)
     call diff_type_orbit_special_pos(structure_ref%special_pos, structure_new%special_pos, trim(name) // "%special_pos", func)
   end subroutine diff_type_orbit_global_param

   subroutine diff_arr_type_orbit_global_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_global_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_orbit_global_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_orbit_global_param

   subroutine diff_type_orbit_midplane(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_midplane), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_orbit_pos(structure_ref%outer, structure_new%outer, trim(name) // "%outer", func)
     call diff_type_orbit_pos(structure_ref%inner, structure_new%inner, trim(name) // "%inner", func)
   end subroutine diff_type_orbit_midplane

   subroutine diff_arr_type_orbit_midplane(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_midplane), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_orbit_midplane(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_orbit_midplane

   subroutine diff_type_orbit_pos(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_pos), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%theta_b, structure_new%theta_b, trim(name) // "%theta_b", func)
   end subroutine diff_type_orbit_pos

   subroutine diff_arr_type_orbit_pos(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_pos), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_orbit_pos(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_orbit_pos

   subroutine diff_type_orbit_special_pos(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_special_pos), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_orbit_midplane(structure_ref%midplane, structure_new%midplane, trim(name) // "%midplane", func)
     call diff_type_orbit_turning_pts(structure_ref%turning_pts, structure_new%turning_pts, trim(name) // "%turning_pts", func)
   end subroutine diff_type_orbit_special_pos

   subroutine diff_arr_type_orbit_special_pos(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_special_pos), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_orbit_special_pos(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_orbit_special_pos

   subroutine diff_type_orbit_turning_pts(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_turning_pts), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_orbit_pos(structure_ref%upper, structure_new%upper, trim(name) // "%upper", func)
     call diff_type_orbit_pos(structure_ref%lower, structure_new%lower, trim(name) // "%lower", func)
   end subroutine diff_type_orbit_turning_pts

   subroutine diff_arr_type_orbit_turning_pts(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_orbit_turning_pts), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_orbit_turning_pts(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_orbit_turning_pts

   subroutine diff_type_origin(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_origin), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi0D(structure_ref%refpos, structure_new%refpos, trim(name) // "%refpos", func)
     call diff_type_float(structure_ref%alpha, structure_new%alpha, trim(name) // "%alpha", func)
     call diff_type_float(structure_ref%beta, structure_new%beta, trim(name) // "%beta", func)
     call diff_type_float(structure_ref%gamma, structure_new%gamma, trim(name) // "%gamma", func)
   end subroutine diff_type_origin

   subroutine diff_arr_type_origin(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_origin), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_origin(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_origin

   subroutine diff_type_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%parameters, structure_new%parameters, trim(name) // "%parameters", func)
     call diff_type_vecstring_type(structure_ref%default_param, structure_new%default_param, trim(name) // "%default_param", func)
     call diff_type_vecstring_type(structure_ref%schema, structure_new%schema, trim(name) // "%schema", func)
   end subroutine diff_type_param

   subroutine diff_arr_type_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_param

   subroutine diff_type_parameters(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_parameters), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_equatorial_plane(structure_ref%equatorial, structure_new%equatorial, trim(name) // "%equatorial", func)
   end subroutine diff_type_parameters

   subroutine diff_arr_type_parameters(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_parameters), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_parameters(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_parameters

   subroutine diff_type_pellet(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_pellet_shape(structure_ref%shape, structure_new%shape, trim(name) // "%shape", func)
     call diff_type_pellet_elements(structure_ref%elements, structure_new%elements, trim(name) // "%elements", func)
     call diff_type_pellet_geometry(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_pellet_pathprofiles(structure_ref%pathprofiles, structure_new%pathprofiles, trim(name) // "%pathprofiles", func)
     call diff_type_pellet_deposition(structure_ref%deposition, structure_new%deposition, trim(name) // "%deposition", func)
   end subroutine diff_type_pellet

   subroutine diff_arr_type_pellet(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet

   subroutine diff_type_pellet_angles(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_angles), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%horizontal, structure_new%horizontal, trim(name) // "%horizontal", func)
     call diff_type_float(structure_ref%vertical, structure_new%vertical, trim(name) // "%vertical", func)
   end subroutine diff_type_pellet_angles

   subroutine diff_arr_type_pellet_angles(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_angles), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_angles(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_angles

   subroutine diff_type_pellet_deposition(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_deposition), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_pol, structure_new%rho_pol, trim(name) // "%rho_pol", func)
     call diff_type_vecflt_type(structure_ref%delta_ne, structure_new%delta_ne, trim(name) // "%delta_ne", func)
     call diff_type_vecflt_type(structure_ref%delta_te, structure_new%delta_te, trim(name) // "%delta_te", func)
     call diff_type_matflt_type(structure_ref%delta_ni, structure_new%delta_ni, trim(name) // "%delta_ni", func)
     call diff_type_matflt_type(structure_ref%delta_ti, structure_new%delta_ti, trim(name) // "%delta_ti", func)
     call diff_type_matflt_type(structure_ref%delta_vtor, structure_new%delta_vtor, trim(name) // "%delta_vtor", func)
     call diff_arr_type_pellet_impurity(structure_ref%impurity, structure_new%impurity, trim(name) // "%impurity", func)
   end subroutine diff_type_pellet_deposition

   subroutine diff_arr_type_pellet_deposition(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_deposition), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_deposition(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_deposition

   subroutine diff_type_pellet_elements(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_elements), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%nucindex, structure_new%nucindex, trim(name) // "%nucindex", func)
     call diff_type_vecflt_type(structure_ref%density, structure_new%density, trim(name) // "%density", func)
     call diff_type_vecflt_type(structure_ref%fraction, structure_new%fraction, trim(name) // "%fraction", func)
     call diff_type_vecflt_type(structure_ref%subl_energy, structure_new%subl_energy, trim(name) // "%subl_energy", func)
   end subroutine diff_type_pellet_elements

   subroutine diff_arr_type_pellet_elements(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_elements), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_elements(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_elements

   subroutine diff_type_pellet_geometry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_geometry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi0D(structure_ref%pivot_point, structure_new%pivot_point, trim(name) // "%pivot_point", func)
     call diff_type_rzphi0D(structure_ref%second_point, structure_new%second_point, trim(name) // "%second_point", func)
     call diff_type_float(structure_ref%velocity, structure_new%velocity, trim(name) // "%velocity", func)
     call diff_type_pellet_angles(structure_ref%angles, structure_new%angles, trim(name) // "%angles", func)
   end subroutine diff_type_pellet_geometry

   subroutine diff_arr_type_pellet_geometry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_geometry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_geometry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_geometry

   subroutine diff_type_pellet_impurity(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_impurity), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%delta_nz, structure_new%delta_nz, trim(name) // "%delta_nz", func)
   end subroutine diff_type_pellet_impurity

   subroutine diff_arr_type_pellet_impurity(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_impurity), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_impurity(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_impurity

   subroutine diff_type_pellet_pathprofiles(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_pathprofiles), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%distance, structure_new%distance, trim(name) // "%distance", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_pol, structure_new%rho_pol, trim(name) // "%rho_pol", func)
     call diff_type_vecflt_type(structure_ref%velocity, structure_new%velocity, trim(name) // "%velocity", func)
     call diff_type_vecflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_vecflt_type(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_vecflt_type(structure_ref%abl_rate, structure_new%abl_rate, trim(name) // "%abl_rate", func)
     call diff_type_vecflt_type(structure_ref%abl_particles, structure_new%abl_particles, trim(name) // "%abl_particles", func)
     call diff_type_vecflt_type(structure_ref%delta_drift, structure_new%delta_drift, trim(name) // "%delta_drift", func)
     call diff_type_rzphi1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_pellet_pathprofiles

   subroutine diff_arr_type_pellet_pathprofiles(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_pathprofiles), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_pathprofiles(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_pathprofiles

   subroutine diff_type_pellet_shape(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_shape), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%dimensions, structure_new%dimensions, trim(name) // "%dimensions", func)
   end subroutine diff_type_pellet_shape

   subroutine diff_arr_type_pellet_shape(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pellet_shape), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pellet_shape(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pellet_shape

   subroutine diff_type_permeability(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_permeability), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%b, structure_new%b, trim(name) // "%b", func)
     call diff_type_matflt_type(structure_ref%mur, structure_new%mur, trim(name) // "%mur", func)
   end subroutine diff_type_permeability

   subroutine diff_arr_type_permeability(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_permeability), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_permeability(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_permeability

   subroutine diff_type_pfcircuits(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfcircuits), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_vecstring_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecint_type(structure_ref%nnodes, structure_new%nnodes, trim(name) // "%nnodes", func)
     call diff_type_array3dint_type(structure_ref%connections, structure_new%connections, trim(name) // "%connections", func)
   end subroutine diff_type_pfcircuits

   subroutine diff_arr_type_pfcircuits(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfcircuits), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfcircuits(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfcircuits

   subroutine diff_type_pfcoils(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfcoils), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_desc_pfcoils(structure_ref%desc_pfcoils, structure_new%desc_pfcoils, trim(name) // "%desc_pfcoils", func)
     call diff_type_exp1D(structure_ref%coilcurrent, structure_new%coilcurrent, trim(name) // "%coilcurrent", func)
     call diff_type_exp1D(structure_ref%coilvoltage, structure_new%coilvoltage, trim(name) // "%coilvoltage", func)
     call diff_type_float(structure_ref%p_cryo, structure_new%p_cryo, trim(name) // "%p_cryo", func)
     call diff_type_vecflt_type(structure_ref%p_nh, structure_new%p_nh, trim(name) // "%p_nh", func)
   end subroutine diff_type_pfcoils

   subroutine diff_arr_type_pfcoils(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfcoils), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfcoils(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfcoils

   subroutine diff_type_pfelement(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfelement), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_matflt_type(structure_ref%turnsign, structure_new%turnsign, trim(name) // "%turnsign", func)
     call diff_type_matflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_pfgeometry(structure_ref%pfgeometry, structure_new%pfgeometry, trim(name) // "%pfgeometry", func)
   end subroutine diff_type_pfelement

   subroutine diff_arr_type_pfelement(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfelement), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfelement(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfelement

   subroutine diff_type_pfgeometry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfgeometry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matint_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_matint_type(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
     call diff_type_rz3D(structure_ref%rzcoordinate, structure_new%rzcoordinate, trim(name) // "%rzcoordinate", func)
     call diff_type_array3dflt_type(structure_ref%rzdrdz, structure_new%rzdrdz, trim(name) // "%rzdrdz", func)
   end subroutine diff_type_pfgeometry

   subroutine diff_arr_type_pfgeometry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfgeometry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfgeometry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfgeometry

   subroutine diff_type_pfpageometry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfpageometry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecint_type(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
     call diff_type_rz2D(structure_ref%rzcoordinate, structure_new%rzcoordinate, trim(name) // "%rzcoordinate", func)
     call diff_type_matflt_type(structure_ref%rzdrdz, structure_new%rzdrdz, trim(name) // "%rzdrdz", func)
   end subroutine diff_type_pfpageometry

   subroutine diff_arr_type_pfpageometry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfpageometry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfpageometry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfpageometry

   subroutine diff_type_pfpassive(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfpassive), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%res, structure_new%res, trim(name) // "%res", func)
     call diff_type_vecflt_type(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
     call diff_type_pfpassive_current(structure_ref%current, structure_new%current, trim(name) // "%current", func)
     call diff_type_pfpageometry(structure_ref%pfpageometry, structure_new%pfpageometry, trim(name) // "%pfpageometry", func)
   end subroutine diff_type_pfpassive

   subroutine diff_arr_type_pfpassive(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfpassive), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfpassive(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfpassive

   subroutine diff_type_pfpassive_current(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfpassive_current), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%toroidal, structure_new%toroidal, trim(name) // "%toroidal", func)
     call diff_type_exp1D(structure_ref%poloidal, structure_new%poloidal, trim(name) // "%poloidal", func)
   end subroutine diff_type_pfpassive_current

   subroutine diff_arr_type_pfpassive_current(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfpassive_current), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfpassive_current(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfpassive_current

   subroutine diff_type_pfsupplies(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfsupplies), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_desc_supply(structure_ref%desc_supply, structure_new%desc_supply, trim(name) // "%desc_supply", func)
     call diff_type_exp1D(structure_ref%voltage, structure_new%voltage, trim(name) // "%voltage", func)
     call diff_type_exp1D(structure_ref%current, structure_new%current, trim(name) // "%current", func)
   end subroutine diff_type_pfsupplies

   subroutine diff_arr_type_pfsupplies(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pfsupplies), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pfsupplies(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pfsupplies

   subroutine diff_type_phaseellipse(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_phaseellipse), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%invcurvrad, structure_new%invcurvrad, trim(name) // "%invcurvrad", func)
     call diff_type_float(structure_ref%angle, structure_new%angle, trim(name) // "%angle", func)
   end subroutine diff_type_phaseellipse

   subroutine diff_arr_type_phaseellipse(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_phaseellipse), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_phaseellipse(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_phaseellipse

   subroutine diff_type_planecoil(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_planecoil), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz1D(structure_ref%coordinates, structure_new%coordinates, trim(name) // "%coordinates", func)
     call diff_type_vecflt_type(structure_ref%hlength, structure_new%hlength, trim(name) // "%hlength", func)
     call diff_type_vecflt_type(structure_ref%radialhwidth, structure_new%radialhwidth, trim(name) // "%radialhwidth", func)
   end subroutine diff_type_planecoil

   subroutine diff_arr_type_planecoil(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_planecoil), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_planecoil(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_planecoil

   subroutine diff_type_plasmaComplexType(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_plasmaComplexType), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%species, structure_new%species, trim(name) // "%species", func)
     call diff_type_matflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_matflt_type(structure_ref%b, structure_new%b, trim(name) // "%b", func)
     call diff_type_matflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_plasmaComplexType

   subroutine diff_arr_type_plasmaComplexType(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_plasmaComplexType), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_plasmaComplexType(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_plasmaComplexType

   subroutine diff_type_plasmaedge(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_plasmaedge), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
     call diff_type_vecflt_type(structure_ref%distance, structure_new%distance, trim(name) // "%distance", func)
     call diff_type_vecflt_type(structure_ref%density, structure_new%density, trim(name) // "%density", func)
   end subroutine diff_type_plasmaedge

   subroutine diff_arr_type_plasmaedge(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_plasmaedge), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_plasmaedge(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_plasmaedge

   subroutine diff_type_pol_decomp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pol_decomp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%mpol, structure_new%mpol, trim(name) // "%mpol", func)
     call diff_type_array3dflt_type(structure_ref%e_plus, structure_new%e_plus, trim(name) // "%e_plus", func)
     call diff_type_array3dflt_type(structure_ref%e_plus_ph, structure_new%e_plus_ph, trim(name) // "%e_plus_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_minus, structure_new%e_minus, trim(name) // "%e_minus", func)
     call diff_type_array3dflt_type(structure_ref%e_minus_ph, structure_new%e_minus_ph, trim(name) // "%e_minus_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_norm, structure_new%e_norm, trim(name) // "%e_norm", func)
     call diff_type_array3dflt_type(structure_ref%e_norm_ph, structure_new%e_norm_ph, trim(name) // "%e_norm_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_binorm, structure_new%e_binorm, trim(name) // "%e_binorm", func)
     call diff_type_array3dflt_type(structure_ref%e_binorm_ph, structure_new%e_binorm_ph, trim(name) // "%e_binorm_ph", func)
     call diff_type_array3dflt_type(structure_ref%e_para, structure_new%e_para, trim(name) // "%e_para", func)
     call diff_type_array3dflt_type(structure_ref%e_para_ph, structure_new%e_para_ph, trim(name) // "%e_para_ph", func)
     call diff_type_array3dflt_type(structure_ref%b_norm, structure_new%b_norm, trim(name) // "%b_norm", func)
     call diff_type_array3dflt_type(structure_ref%b_norm_ph, structure_new%b_norm_ph, trim(name) // "%b_norm_ph", func)
     call diff_type_array3dflt_type(structure_ref%b_binorm, structure_new%b_binorm, trim(name) // "%b_binorm", func)
     call diff_type_array3dflt_type(structure_ref%b_binorm_ph, structure_new%b_binorm_ph, trim(name) // "%b_binorm_ph", func)
     call diff_type_array3dflt_type(structure_ref%b_para, structure_new%b_para, trim(name) // "%b_para", func)
     call diff_type_array3dflt_type(structure_ref%b_para_ph, structure_new%b_para_ph, trim(name) // "%b_para_ph", func)
     call diff_type_array3dflt_type(structure_ref%k_perp, structure_new%k_perp, trim(name) // "%k_perp", func)
   end subroutine diff_type_pol_decomp

   subroutine diff_arr_type_pol_decomp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_pol_decomp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_pol_decomp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_pol_decomp

   subroutine diff_type_polarimetry(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_polarimetry), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_msediag_setup_polarimetry(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_exp1D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_polarimetry

   subroutine diff_arr_type_polarimetry(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_polarimetry), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_polarimetry(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_polarimetry

   subroutine diff_type_polarization(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_polarization), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%epol_p_re, structure_new%epol_p_re, trim(name) // "%epol_p_re", func)
     call diff_type_vecflt_type(structure_ref%epol_p_im, structure_new%epol_p_im, trim(name) // "%epol_p_im", func)
     call diff_type_vecflt_type(structure_ref%epol_m_re, structure_new%epol_m_re, trim(name) // "%epol_m_re", func)
     call diff_type_vecflt_type(structure_ref%epol_m_im, structure_new%epol_m_im, trim(name) // "%epol_m_im", func)
     call diff_type_vecflt_type(structure_ref%epol_par_re, structure_new%epol_par_re, trim(name) // "%epol_par_re", func)
     call diff_type_vecflt_type(structure_ref%epol_par_im, structure_new%epol_par_im, trim(name) // "%epol_par_im", func)
   end subroutine diff_type_polarization

   subroutine diff_arr_type_polarization(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_polarization), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_polarization(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_polarization

   subroutine diff_type_power_conv_component(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_power_conv_component), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_float(structure_ref%temp_in, structure_new%temp_in, trim(name) // "%temp_in", func)
     call diff_type_float(structure_ref%temp_out, structure_new%temp_out, trim(name) // "%temp_out", func)
     call diff_type_float(structure_ref%press_in, structure_new%press_in, trim(name) // "%press_in", func)
     call diff_type_float(structure_ref%press_out, structure_new%press_out, trim(name) // "%press_out", func)
     call diff_type_float(structure_ref%power, structure_new%power, trim(name) // "%power", func)
     call diff_type_float(structure_ref%flow, structure_new%flow, trim(name) // "%flow", func)
   end subroutine diff_type_power_conv_component

   subroutine diff_arr_type_power_conv_component(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_power_conv_component), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_power_conv_component(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_power_conv_component

   subroutine diff_type_power_exchange(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_power_exchange), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%dep_pow, structure_new%dep_pow, trim(name) // "%dep_pow", func)
     call diff_type_float(structure_ref%dep_fw, structure_new%dep_fw, trim(name) // "%dep_fw", func)
     call diff_type_float(structure_ref%dep_sg, structure_new%dep_sg, trim(name) // "%dep_sg", func)
     call diff_type_float(structure_ref%dep_cp, structure_new%dep_cp, trim(name) // "%dep_cp", func)
     call diff_type_float(structure_ref%dep_lp, structure_new%dep_lp, trim(name) // "%dep_lp", func)
     call diff_type_float(structure_ref%dep_man, structure_new%dep_man, trim(name) // "%dep_man", func)
     call diff_type_float(structure_ref%dep_pl, structure_new%dep_pl, trim(name) // "%dep_pl", func)
     call diff_type_float(structure_ref%rec_fw, structure_new%rec_fw, trim(name) // "%rec_fw", func)
     call diff_type_float(structure_ref%rec_sg, structure_new%rec_sg, trim(name) // "%rec_sg", func)
     call diff_type_float(structure_ref%rec_cp, structure_new%rec_cp, trim(name) // "%rec_cp", func)
     call diff_type_float(structure_ref%pow_dens_fw, structure_new%pow_dens_fw, trim(name) // "%pow_dens_fw", func)
     call diff_type_float(structure_ref%pow_dens_bz, structure_new%pow_dens_bz, trim(name) // "%pow_dens_bz", func)
     call diff_type_float(structure_ref%pow_dens_bz10, structure_new%pow_dens_bz10, trim(name) // "%pow_dens_bz10", func)
     call diff_type_float(structure_ref%pow_dens_bp, structure_new%pow_dens_bp, trim(name) // "%pow_dens_bp", func)
     call diff_type_float(structure_ref%pow_dens_man, structure_new%pow_dens_man, trim(name) // "%pow_dens_man", func)
     call diff_type_float(structure_ref%pow_dens_sh, structure_new%pow_dens_sh, trim(name) // "%pow_dens_sh", func)
   end subroutine diff_type_power_exchange

   subroutine diff_arr_type_power_exchange(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_power_exchange), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_power_exchange(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_power_exchange

   subroutine diff_type_powerflow(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_powerflow), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%phi_perp, structure_new%phi_perp, trim(name) // "%phi_perp", func)
     call diff_type_vecflt_type(structure_ref%phi_par, structure_new%phi_par, trim(name) // "%phi_par", func)
     call diff_type_vecflt_type(structure_ref%power_e, structure_new%power_e, trim(name) // "%power_e", func)
     call diff_type_matflt_type(structure_ref%power_i, structure_new%power_i, trim(name) // "%power_i", func)
   end subroutine diff_type_powerflow

   subroutine diff_arr_type_powerflow(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_powerflow), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_powerflow(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_powerflow

   subroutine diff_type_profiles1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_profiles1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_coreprofile(structure_ref%pe, structure_new%pe, trim(name) // "%pe", func)
     call diff_type_coreprofile(structure_ref%dpedt, structure_new%dpedt, trim(name) // "%dpedt", func)
     call diff_type_coreprofion(structure_ref%pi, structure_new%pi, trim(name) // "%pi", func)
     call diff_type_coreprofile(structure_ref%pi_tot, structure_new%pi_tot, trim(name) // "%pi_tot", func)
     call diff_type_coreprofile(structure_ref%dpi_totdt, structure_new%dpi_totdt, trim(name) // "%dpi_totdt", func)
     call diff_type_coreprofile(structure_ref%pr_th, structure_new%pr_th, trim(name) // "%pr_th", func)
     call diff_type_coreprofile(structure_ref%pr_perp, structure_new%pr_perp, trim(name) // "%pr_perp", func)
     call diff_type_coreprofile(structure_ref%pr_parallel, structure_new%pr_parallel, trim(name) // "%pr_parallel", func)
     call diff_type_coreprofile(structure_ref%jtot, structure_new%jtot, trim(name) // "%jtot", func)
     call diff_type_coreprofile(structure_ref%jni, structure_new%jni, trim(name) // "%jni", func)
     call diff_type_coreprofile(structure_ref%jphi, structure_new%jphi, trim(name) // "%jphi", func)
     call diff_type_coreprofile(structure_ref%joh, structure_new%joh, trim(name) // "%joh", func)
     call diff_type_coreprofile(structure_ref%vloop, structure_new%vloop, trim(name) // "%vloop", func)
     call diff_type_coreprofile(structure_ref%sigmapar, structure_new%sigmapar, trim(name) // "%sigmapar", func)
     call diff_type_sourceel(structure_ref%qoh, structure_new%qoh, trim(name) // "%qoh", func)
     call diff_type_coreprofile(structure_ref%qei, structure_new%qei, trim(name) // "%qei", func)
     call diff_type_coreprofile(structure_ref%eparallel, structure_new%eparallel, trim(name) // "%eparallel", func)
     call diff_type_coreprofile(structure_ref%e_b, structure_new%e_b, trim(name) // "%e_b", func)
     call diff_type_coreprofile(structure_ref%q, structure_new%q, trim(name) // "%q", func)
     call diff_type_coreprofile(structure_ref%shear, structure_new%shear, trim(name) // "%shear", func)
     call diff_type_coreprofion(structure_ref%ns, structure_new%ns, trim(name) // "%ns", func)
     call diff_type_coreprofion(structure_ref%mtor, structure_new%mtor, trim(name) // "%mtor", func)
     call diff_type_coreprofion(structure_ref%wtor, structure_new%wtor, trim(name) // "%wtor", func)
     call diff_type_coreprofion(structure_ref%vpol, structure_new%vpol, trim(name) // "%vpol", func)
     call diff_type_coreprofile(structure_ref%zeff, structure_new%zeff, trim(name) // "%zeff", func)
     call diff_type_coreprofile(structure_ref%bpol, structure_new%bpol, trim(name) // "%bpol", func)
     call diff_type_coreprofile(structure_ref%dvprimedt, structure_new%dvprimedt, trim(name) // "%dvprimedt", func)
   end subroutine diff_type_profiles1d

   subroutine diff_arr_type_profiles1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_profiles1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_profiles1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_profiles1d

   subroutine diff_type_profiles_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_profiles_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%pressure, structure_new%pressure, trim(name) // "%pressure", func)
     call diff_type_vecflt_type(structure_ref%F_dia, structure_new%F_dia, trim(name) // "%F_dia", func)
     call diff_type_vecflt_type(structure_ref%pprime, structure_new%pprime, trim(name) // "%pprime", func)
     call diff_type_vecflt_type(structure_ref%ffprime, structure_new%ffprime, trim(name) // "%ffprime", func)
     call diff_type_vecflt_type(structure_ref%jphi, structure_new%jphi, trim(name) // "%jphi", func)
     call diff_type_vecflt_type(structure_ref%jparallel, structure_new%jparallel, trim(name) // "%jparallel", func)
     call diff_type_vecflt_type(structure_ref%q, structure_new%q, trim(name) // "%q", func)
     call diff_type_vecflt_type(structure_ref%shear, structure_new%shear, trim(name) // "%shear", func)
     call diff_type_vecflt_type(structure_ref%r_inboard, structure_new%r_inboard, trim(name) // "%r_inboard", func)
     call diff_type_vecflt_type(structure_ref%r_outboard, structure_new%r_outboard, trim(name) // "%r_outboard", func)
     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%dpsidrho_tor, structure_new%dpsidrho_tor, trim(name) // "%dpsidrho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_vol, structure_new%rho_vol, trim(name) // "%rho_vol", func)
     call diff_type_vecflt_type(structure_ref%beta_pol, structure_new%beta_pol, trim(name) // "%beta_pol", func)
     call diff_type_vecflt_type(structure_ref%li, structure_new%li, trim(name) // "%li", func)
     call diff_type_vecflt_type(structure_ref%elongation, structure_new%elongation, trim(name) // "%elongation", func)
     call diff_type_vecflt_type(structure_ref%tria_upper, structure_new%tria_upper, trim(name) // "%tria_upper", func)
     call diff_type_vecflt_type(structure_ref%tria_lower, structure_new%tria_lower, trim(name) // "%tria_lower", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%vprime, structure_new%vprime, trim(name) // "%vprime", func)
     call diff_type_vecflt_type(structure_ref%dvdrho, structure_new%dvdrho, trim(name) // "%dvdrho", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%aprime, structure_new%aprime, trim(name) // "%aprime", func)
     call diff_type_vecflt_type(structure_ref%surface, structure_new%surface, trim(name) // "%surface", func)
     call diff_type_vecflt_type(structure_ref%ftrap, structure_new%ftrap, trim(name) // "%ftrap", func)
     call diff_type_vecflt_type(structure_ref%gm1, structure_new%gm1, trim(name) // "%gm1", func)
     call diff_type_vecflt_type(structure_ref%gm2, structure_new%gm2, trim(name) // "%gm2", func)
     call diff_type_vecflt_type(structure_ref%gm3, structure_new%gm3, trim(name) // "%gm3", func)
     call diff_type_vecflt_type(structure_ref%gm4, structure_new%gm4, trim(name) // "%gm4", func)
     call diff_type_vecflt_type(structure_ref%gm5, structure_new%gm5, trim(name) // "%gm5", func)
     call diff_type_vecflt_type(structure_ref%gm6, structure_new%gm6, trim(name) // "%gm6", func)
     call diff_type_vecflt_type(structure_ref%gm7, structure_new%gm7, trim(name) // "%gm7", func)
     call diff_type_vecflt_type(structure_ref%gm8, structure_new%gm8, trim(name) // "%gm8", func)
     call diff_type_vecflt_type(structure_ref%gm9, structure_new%gm9, trim(name) // "%gm9", func)
     call diff_type_vecflt_type(structure_ref%b_av, structure_new%b_av, trim(name) // "%b_av", func)
     call diff_type_vecflt_type(structure_ref%b_min, structure_new%b_min, trim(name) // "%b_min", func)
     call diff_type_vecflt_type(structure_ref%b_max, structure_new%b_max, trim(name) // "%b_max", func)
     call diff_type_vecflt_type(structure_ref%omega, structure_new%omega, trim(name) // "%omega", func)
     call diff_type_vecflt_type(structure_ref%omegaprime, structure_new%omegaprime, trim(name) // "%omegaprime", func)
     call diff_type_vecflt_type(structure_ref%mach_a, structure_new%mach_a, trim(name) // "%mach_a", func)
     call diff_type_vecflt_type(structure_ref%phi_flow, structure_new%phi_flow, trim(name) // "%phi_flow", func)
     call diff_type_vecflt_type(structure_ref%s_flow, structure_new%s_flow, trim(name) // "%s_flow", func)
     call diff_type_vecflt_type(structure_ref%h_flow, structure_new%h_flow, trim(name) // "%h_flow", func)
     call diff_type_vecflt_type(structure_ref%rho_mass, structure_new%rho_mass, trim(name) // "%rho_mass", func)
   end subroutine diff_type_profiles_1d

   subroutine diff_arr_type_profiles_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_profiles_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_profiles_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_profiles_1d

   subroutine diff_type_psi(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_psi), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%ddrho, structure_new%ddrho, trim(name) // "%ddrho", func)
     call diff_type_vecflt_type(structure_ref%d2drho2, structure_new%d2drho2, trim(name) // "%d2drho2", func)
     call diff_type_vecflt_type(structure_ref%ddt_rhotorn, structure_new%ddt_rhotorn, trim(name) // "%ddt_rhotorn", func)
     call diff_type_vecflt_type(structure_ref%ddt_phi, structure_new%ddt_phi, trim(name) // "%ddt_phi", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
     call diff_type_boundary(structure_ref%boundary, structure_new%boundary, trim(name) // "%boundary", func)
     call diff_type_jni(structure_ref%jni, structure_new%jni, trim(name) // "%jni", func)
     call diff_type_coreprofile(structure_ref%sigma_par, structure_new%sigma_par, trim(name) // "%sigma_par", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_psi

   subroutine diff_arr_type_psi(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_psi), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_psi(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_psi

   subroutine diff_type_putinfo(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_putinfo), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%putmethod, structure_new%putmethod, trim(name) // "%putmethod", func)
     call diff_type_vecstring_type(structure_ref%putaccess, structure_new%putaccess, trim(name) // "%putaccess", func)
     call diff_type_vecstring_type(structure_ref%putlocation, structure_new%putlocation, trim(name) // "%putlocation", func)
     call diff_type_vecstring_type(structure_ref%rights, structure_new%rights, trim(name) // "%rights", func)
   end subroutine diff_type_putinfo

   subroutine diff_arr_type_putinfo(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_putinfo), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_putinfo(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_putinfo

   subroutine diff_type_q(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_q), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%qvalue, structure_new%qvalue, trim(name) // "%qvalue", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_integer(structure_ref%exact, structure_new%exact, trim(name) // "%exact", func)
     call diff_type_vecflt_type(structure_ref%weight, structure_new%weight, trim(name) // "%weight", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_vecflt_type(structure_ref%calculated, structure_new%calculated, trim(name) // "%calculated", func)
     call diff_type_vecflt_type(structure_ref%chi2, structure_new%chi2, trim(name) // "%chi2", func)
   end subroutine diff_type_q

   subroutine diff_arr_type_q(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_q), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_q(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_q

   subroutine diff_type_reacprodType(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reacprodType), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_arr_type_amns_constituentType(structure_ref%constituents, structure_new%constituents, trim(name) // "%constituents", func)
     call diff_type_identifier(structure_ref%role, structure_new%role, trim(name) // "%role", func)
     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_integer(structure_ref%relative, structure_new%relative, trim(name) // "%relative", func)
     call diff_type_float(structure_ref%za, structure_new%za, trim(name) // "%za", func)
     call diff_type_float(structure_ref%multiplicity, structure_new%multiplicity, trim(name) // "%multiplicity", func)
     call diff_type_vecint_type(structure_ref%metastable, structure_new%metastable, trim(name) // "%metastable", func)
     call diff_type_vecstring_type(structure_ref%metastable_label, structure_new%metastable_label, trim(name) // "%metastable_label", func)
   end subroutine diff_type_reacprodType

   subroutine diff_arr_type_reacprodType(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reacprodType), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reacprodType(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reacprodType

   subroutine diff_type_react(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_react), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%he_fr, structure_new%he_fr, trim(name) // "%he_fr", func)
     call diff_type_float(structure_ref%lp_fr, structure_new%lp_fr, trim(name) // "%lp_fr", func)
     call diff_type_float(structure_ref%he_dp, structure_new%he_dp, trim(name) // "%he_dp", func)
     call diff_type_float(structure_ref%lipb_dp, structure_new%lipb_dp, trim(name) // "%lipb_dp", func)
   end subroutine diff_type_react

   subroutine diff_arr_type_react(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_react), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_react(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_react

   subroutine diff_type_rectanglexyz(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rectanglexyz), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_xyz0D(structure_ref%point01, structure_new%point01, trim(name) // "%point01", func)
     call diff_type_xyz0D(structure_ref%point11, structure_new%point11, trim(name) // "%point11", func)
     call diff_type_xyz0D(structure_ref%point10, structure_new%point10, trim(name) // "%point10", func)
   end subroutine diff_type_rectanglexyz

   subroutine diff_arr_type_rectanglexyz(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rectanglexyz), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rectanglexyz(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rectanglexyz

   subroutine diff_type_recycling_neutrals(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_recycling_neutrals), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%particles, structure_new%particles, trim(name) // "%particles", func)
     call diff_type_vecflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_recycling_neutrals

   subroutine diff_arr_type_recycling_neutrals(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_recycling_neutrals), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_recycling_neutrals(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_recycling_neutrals

   subroutine diff_type_reduced(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reduced), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
   end subroutine diff_type_reduced

   subroutine diff_arr_type_reduced(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reduced), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reduced(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reduced

   subroutine diff_type_refl_receive(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_refl_receive), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_t_series_real(structure_ref%raw_signal, structure_new%raw_signal, trim(name) // "%raw_signal", func)
     call diff_type_t_series_real(structure_ref%io_signal, structure_new%io_signal, trim(name) // "%io_signal", func)
     call diff_type_t_series_cplx(structure_ref%iq_receiver, structure_new%iq_receiver, trim(name) // "%iq_receiver", func)
     call diff_type_integer(structure_ref%antenna_ind, structure_new%antenna_ind, trim(name) // "%antenna_ind", func)
   end subroutine diff_type_refl_receive

   subroutine diff_arr_type_refl_receive(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_refl_receive), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_refl_receive(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_refl_receive

   subroutine diff_type_reflectometry_antennas(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_antennas), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_origin(structure_ref%origin, structure_new%origin, trim(name) // "%origin", func)
     call diff_type_reflectometry_radfield(structure_ref%radfield, structure_new%radfield, trim(name) // "%radfield", func)
     call diff_type_float(structure_ref%geometry, structure_new%geometry, trim(name) // "%geometry", func)
     call diff_type_launchsignal(structure_ref%launchsignal, structure_new%launchsignal, trim(name) // "%launchsignal", func)
   end subroutine diff_type_reflectometry_antennas

   subroutine diff_arr_type_reflectometry_antennas(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_antennas), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reflectometry_antennas(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reflectometry_antennas

   subroutine diff_type_reflectometry_radfield(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_radfield), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_arr_type_reflectometry_radfield_gaussian(structure_ref%gaussian, structure_new%gaussian, trim(name) // "%gaussian", func)
     call diff_arr_type_reflectometry_radifield_efield(structure_ref%efield, structure_new%efield, trim(name) // "%efield", func)
   end subroutine diff_type_reflectometry_radfield

   subroutine diff_arr_type_reflectometry_radfield(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_radfield), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reflectometry_radfield(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reflectometry_radfield

   subroutine diff_type_reflectometry_radfield_gaussian(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_radfield_gaussian), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_simp_apert(structure_ref%aperture, structure_new%aperture, trim(name) // "%aperture", func)
     call diff_type_vecflt_type(structure_ref%waistsize, structure_new%waistsize, trim(name) // "%waistsize", func)
     call diff_type_vecflt_type(structure_ref%waistzpos, structure_new%waistzpos, trim(name) // "%waistzpos", func)
     call diff_type_vecflt_type(structure_ref%tiltangle, structure_new%tiltangle, trim(name) // "%tiltangle", func)
     call diff_type_vecflt_type(structure_ref%polar_angle, structure_new%polar_angle, trim(name) // "%polar_angle", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
   end subroutine diff_type_reflectometry_radfield_gaussian

   subroutine diff_arr_type_reflectometry_radfield_gaussian(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_radfield_gaussian), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reflectometry_radfield_gaussian(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reflectometry_radfield_gaussian

   subroutine diff_type_reflectometry_radifield_efield(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_radifield_efield), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_reggrid(structure_ref%grid2d, structure_new%grid2d, trim(name) // "%grid2d", func)
     call diff_type_matcplx_type(structure_ref%e1, structure_new%e1, trim(name) // "%e1", func)
     call diff_type_matcplx_type(structure_ref%e2, structure_new%e2, trim(name) // "%e2", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
   end subroutine diff_type_reflectometry_radifield_efield

   subroutine diff_arr_type_reflectometry_radifield_efield(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reflectometry_radifield_efield), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reflectometry_radifield_efield(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reflectometry_radifield_efield

   subroutine diff_type_reggrid(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reggrid), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%dim1, structure_new%dim1, trim(name) // "%dim1", func)
     call diff_type_vecflt_type(structure_ref%dim2, structure_new%dim2, trim(name) // "%dim2", func)
   end subroutine diff_type_reggrid

   subroutine diff_arr_type_reggrid(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_reggrid), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_reggrid(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_reggrid

   subroutine diff_type_rfameasure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfameasure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
   end subroutine diff_type_rfameasure

   subroutine diff_arr_type_rfameasure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfameasure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rfameasure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rfameasure

   subroutine diff_type_rfasetup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfasetup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1Dexp(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_rfasetup

   subroutine diff_arr_type_rfasetup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfasetup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rfasetup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rfasetup

   subroutine diff_type_rfbeam(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfbeam), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_spot(structure_ref%spot, structure_new%spot, trim(name) // "%spot", func)
     call diff_type_phaseellipse(structure_ref%phaseellipse, structure_new%phaseellipse, trim(name) // "%phaseellipse", func)
   end subroutine diff_type_rfbeam

   subroutine diff_arr_type_rfbeam(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rfbeam), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rfbeam(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rfbeam

   subroutine diff_type_rz0D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz0D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_float(structure_ref%z, structure_new%z, trim(name) // "%z", func)
   end subroutine diff_type_rz0D

   subroutine diff_arr_type_rz0D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz0D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rz0D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rz0D

   subroutine diff_type_rz1D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz1D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
   end subroutine diff_type_rz1D

   subroutine diff_arr_type_rz1D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz1D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rz1D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rz1D

   subroutine diff_type_rz1D_npoints(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz1D_npoints), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_integer(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
   end subroutine diff_type_rz1D_npoints

   subroutine diff_arr_type_rz1D_npoints(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz1D_npoints), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rz1D_npoints(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rz1D_npoints

   subroutine diff_type_rz1Dexp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz1Dexp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
   end subroutine diff_type_rz1Dexp

   subroutine diff_arr_type_rz1Dexp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz1Dexp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rz1Dexp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rz1Dexp

   subroutine diff_type_rz2D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz2D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
   end subroutine diff_type_rz2D

   subroutine diff_arr_type_rz2D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz2D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rz2D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rz2D

   subroutine diff_type_rz3D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz3D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_array3dflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
   end subroutine diff_type_rz3D

   subroutine diff_arr_type_rz3D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rz3D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rz3D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rz3D

   subroutine diff_type_rzphi0D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi0D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_float(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_float(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_rzphi0D

   subroutine diff_arr_type_rzphi0D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi0D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphi0D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphi0D

   subroutine diff_type_rzphi1D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi1D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_rzphi1D

   subroutine diff_arr_type_rzphi1D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi1D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphi1D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphi1D

   subroutine diff_type_rzphi1Dexp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi1Dexp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_exp1D(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_exp1D(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_rzphi1Dexp

   subroutine diff_arr_type_rzphi1Dexp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi1Dexp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphi1Dexp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphi1Dexp

   subroutine diff_type_rzphi1Dexperimental(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi1Dexperimental), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_rzphi1Dexperimental

   subroutine diff_arr_type_rzphi1Dexperimental(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi1Dexperimental), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphi1Dexperimental(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphi1Dexperimental

   subroutine diff_type_rzphi2D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi2D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_matflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_rzphi2D

   subroutine diff_arr_type_rzphi2D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi2D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphi2D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphi2D

   subroutine diff_type_rzphi3D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi3D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_array3dflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_array3dflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_rzphi3D

   subroutine diff_arr_type_rzphi3D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphi3D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphi3D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphi3D

   subroutine diff_type_rzphidrdzdphi1D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphidrdzdphi1D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%dr, structure_new%dr, trim(name) // "%dr", func)
     call diff_type_vecflt_type(structure_ref%dz, structure_new%dz, trim(name) // "%dz", func)
     call diff_type_vecflt_type(structure_ref%dphi, structure_new%dphi, trim(name) // "%dphi", func)
   end subroutine diff_type_rzphidrdzdphi1D

   subroutine diff_arr_type_rzphidrdzdphi1D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_rzphidrdzdphi1D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_rzphidrdzdphi1D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_rzphidrdzdphi1D

   subroutine diff_type_sawteeth_diags(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sawteeth_diags), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%shear1, structure_new%shear1, trim(name) // "%shear1", func)
     call diff_type_float(structure_ref%rhotorn_q1, structure_new%rhotorn_q1, trim(name) // "%rhotorn_q1", func)
     call diff_type_float(structure_ref%rhotorn_inv, structure_new%rhotorn_inv, trim(name) // "%rhotorn_inv", func)
     call diff_type_float(structure_ref%rhotorn_mix, structure_new%rhotorn_mix, trim(name) // "%rhotorn_mix", func)
   end subroutine diff_type_sawteeth_diags

   subroutine diff_arr_type_sawteeth_diags(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sawteeth_diags), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sawteeth_diags(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sawteeth_diags

   subroutine diff_type_sawteeth_profiles1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sawteeth_profiles1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_matflt_type(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_vecflt_type(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_matflt_type(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%psistar, structure_new%psistar, trim(name) // "%psistar", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%q, structure_new%q, trim(name) // "%q", func)
   end subroutine diff_type_sawteeth_profiles1d

   subroutine diff_arr_type_sawteeth_profiles1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sawteeth_profiles1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sawteeth_profiles1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sawteeth_profiles1d

   subroutine diff_type_scenario_centre(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_centre), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%te0, structure_new%te0, trim(name) // "%te0", func)
     call diff_type_scenario_ref(structure_ref%ti0, structure_new%ti0, trim(name) // "%ti0", func)
     call diff_type_scenario_ref(structure_ref%ne0, structure_new%ne0, trim(name) // "%ne0", func)
     call diff_type_scenario_ref(structure_ref%ni0, structure_new%ni0, trim(name) // "%ni0", func)
     call diff_type_scenario_ref(structure_ref%shift0, structure_new%shift0, trim(name) // "%shift0", func)
     call diff_type_scenario_ref(structure_ref%psi0, structure_new%psi0, trim(name) // "%psi0", func)
     call diff_type_scenario_ref(structure_ref%phi0, structure_new%phi0, trim(name) // "%phi0", func)
     call diff_type_scenario_ref(structure_ref%q0, structure_new%q0, trim(name) // "%q0", func)
     call diff_type_scenario_ref(structure_ref%Rmag, structure_new%Rmag, trim(name) // "%Rmag", func)
     call diff_type_scenario_ref(structure_ref%Zmag, structure_new%Zmag, trim(name) // "%Zmag", func)
     call diff_type_scenario_ref(structure_ref%vtor_0, structure_new%vtor_0, trim(name) // "%vtor_0", func)
   end subroutine diff_type_scenario_centre

   subroutine diff_arr_type_scenario_centre(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_centre), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_centre(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_centre

   subroutine diff_type_scenario_composition(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_composition), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_vecflt_type(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_vecflt_type(structure_ref%zion, structure_new%zion, trim(name) // "%zion", func)
     call diff_type_vecint_type(structure_ref%imp_flag, structure_new%imp_flag, trim(name) // "%imp_flag", func)
     call diff_type_vecint_type(structure_ref%rot_imp_flag, structure_new%rot_imp_flag, trim(name) // "%rot_imp_flag", func)
     call diff_type_vecflt_type(structure_ref%pellet_amn, structure_new%pellet_amn, trim(name) // "%pellet_amn", func)
     call diff_type_vecflt_type(structure_ref%pellet_zn, structure_new%pellet_zn, trim(name) // "%pellet_zn", func)
     call diff_type_vecflt_type(structure_ref%nbi_amn, structure_new%nbi_amn, trim(name) // "%nbi_amn", func)
     call diff_type_vecflt_type(structure_ref%nbi_zn, structure_new%nbi_zn, trim(name) // "%nbi_zn", func)
   end subroutine diff_type_scenario_composition

   subroutine diff_arr_type_scenario_composition(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_composition), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_composition(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_composition

   subroutine diff_type_scenario_configuration(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_configuration), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_int(structure_ref%config, structure_new%config, trim(name) // "%config", func)
     call diff_type_vecstring_type(structure_ref%lmode_sc, structure_new%lmode_sc, trim(name) // "%lmode_sc", func)
     call diff_type_vecstring_type(structure_ref%hmode_sc, structure_new%hmode_sc, trim(name) // "%hmode_sc", func)
     call diff_type_vecstring_type(structure_ref%core_sc, structure_new%core_sc, trim(name) // "%core_sc", func)
     call diff_type_vecstring_type(structure_ref%pedestal_sc, structure_new%pedestal_sc, trim(name) // "%pedestal_sc", func)
     call diff_type_vecstring_type(structure_ref%helium_sc, structure_new%helium_sc, trim(name) // "%helium_sc", func)
     call diff_type_vecstring_type(structure_ref%impurity_sc, structure_new%impurity_sc, trim(name) // "%impurity_sc", func)
     call diff_type_vecstring_type(structure_ref%l2h_sc, structure_new%l2h_sc, trim(name) // "%l2h_sc", func)
     call diff_type_vecstring_type(structure_ref%tor_rot_sc, structure_new%tor_rot_sc, trim(name) // "%tor_rot_sc", func)
     call diff_type_vecstring_type(structure_ref%wall_mat, structure_new%wall_mat, trim(name) // "%wall_mat", func)
     call diff_type_vecstring_type(structure_ref%evap_mat, structure_new%evap_mat, trim(name) // "%evap_mat", func)
     call diff_type_vecstring_type(structure_ref%lim_mat, structure_new%lim_mat, trim(name) // "%lim_mat", func)
     call diff_type_vecstring_type(structure_ref%div_mat, structure_new%div_mat, trim(name) // "%div_mat", func)
     call diff_type_vecstring_type(structure_ref%coordinate, structure_new%coordinate, trim(name) // "%coordinate", func)
     call diff_type_scenario_ref(structure_ref%ecrh_freq, structure_new%ecrh_freq, trim(name) // "%ecrh_freq", func)
     call diff_type_scenario_ref(structure_ref%ecrh_loc, structure_new%ecrh_loc, trim(name) // "%ecrh_loc", func)
     call diff_type_scenario_int(structure_ref%ecrh_mode, structure_new%ecrh_mode, trim(name) // "%ecrh_mode", func)
     call diff_type_scenario_ref(structure_ref%ecrh_tor_ang, structure_new%ecrh_tor_ang, trim(name) // "%ecrh_tor_ang", func)
     call diff_type_scenario_ref(structure_ref%ecrh_pol_ang, structure_new%ecrh_pol_ang, trim(name) // "%ecrh_pol_ang", func)
     call diff_type_scenario_int(structure_ref%ecrh_harm, structure_new%ecrh_harm, trim(name) // "%ecrh_harm", func)
     call diff_type_scenario_ref(structure_ref%enbi, structure_new%enbi, trim(name) // "%enbi", func)
     call diff_type_scenario_ref(structure_ref%r_nbi, structure_new%r_nbi, trim(name) // "%r_nbi", func)
     call diff_type_scenario_int(structure_ref%grad_b_drift, structure_new%grad_b_drift, trim(name) // "%grad_b_drift", func)
     call diff_type_scenario_ref(structure_ref%icrh_freq, structure_new%icrh_freq, trim(name) // "%icrh_freq", func)
     call diff_type_vecstring_type(structure_ref%icrh_scheme, structure_new%icrh_scheme, trim(name) // "%icrh_scheme", func)
     call diff_type_scenario_ref(structure_ref%icrh_phase, structure_new%icrh_phase, trim(name) // "%icrh_phase", func)
     call diff_type_scenario_ref(structure_ref%LH_freq, structure_new%LH_freq, trim(name) // "%LH_freq", func)
     call diff_type_scenario_ref(structure_ref%LH_npar, structure_new%LH_npar, trim(name) // "%LH_npar", func)
     call diff_type_scenario_ref(structure_ref%pellet_ang, structure_new%pellet_ang, trim(name) // "%pellet_ang", func)
     call diff_type_scenario_ref(structure_ref%pellet_v, structure_new%pellet_v, trim(name) // "%pellet_v", func)
     call diff_type_scenario_ref(structure_ref%pellet_nba, structure_new%pellet_nba, trim(name) // "%pellet_nba", func)
   end subroutine diff_type_scenario_configuration

   subroutine diff_arr_type_scenario_configuration(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_configuration), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_configuration(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_configuration

   subroutine diff_type_scenario_confinement(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_confinement), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%tau_e, structure_new%tau_e, trim(name) // "%tau_e", func)
     call diff_type_scenario_ref(structure_ref%tau_l_sc, structure_new%tau_l_sc, trim(name) // "%tau_l_sc", func)
     call diff_type_scenario_ref(structure_ref%tau_h_sc, structure_new%tau_h_sc, trim(name) // "%tau_h_sc", func)
     call diff_type_scenario_ref(structure_ref%tau_he, structure_new%tau_he, trim(name) // "%tau_he", func)
     call diff_type_scenario_ref(structure_ref%tau_e_ee, structure_new%tau_e_ee, trim(name) // "%tau_e_ee", func)
     call diff_type_scenario_ref(structure_ref%tau_e_ii, structure_new%tau_e_ii, trim(name) // "%tau_e_ii", func)
     call diff_type_scenario_ref(structure_ref%tau_e_ei, structure_new%tau_e_ei, trim(name) // "%tau_e_ei", func)
     call diff_type_scenario_ref(structure_ref%tau_cur_diff, structure_new%tau_cur_diff, trim(name) // "%tau_cur_diff", func)
     call diff_type_scenario_ref(structure_ref%tau_i_rol, structure_new%tau_i_rol, trim(name) // "%tau_i_rol", func)
   end subroutine diff_type_scenario_confinement

   subroutine diff_arr_type_scenario_confinement(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_confinement), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_confinement(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_confinement

   subroutine diff_type_scenario_currents(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_currents), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%RR, structure_new%RR, trim(name) // "%RR", func)
     call diff_type_scenario_ref(structure_ref%i_align, structure_new%i_align, trim(name) // "%i_align", func)
     call diff_type_scenario_ref(structure_ref%i_boot, structure_new%i_boot, trim(name) // "%i_boot", func)
     call diff_type_scenario_ref(structure_ref%i_cd_tot, structure_new%i_cd_tot, trim(name) // "%i_cd_tot", func)
     call diff_type_scenario_ref(structure_ref%i_eccd, structure_new%i_eccd, trim(name) // "%i_eccd", func)
     call diff_type_scenario_ref(structure_ref%i_fast_ion, structure_new%i_fast_ion, trim(name) // "%i_fast_ion", func)
     call diff_type_scenario_ref(structure_ref%i_fwcd, structure_new%i_fwcd, trim(name) // "%i_fwcd", func)
     call diff_type_scenario_ref(structure_ref%i_lhcd, structure_new%i_lhcd, trim(name) // "%i_lhcd", func)
     call diff_type_scenario_ref(structure_ref%i_nbicd, structure_new%i_nbicd, trim(name) // "%i_nbicd", func)
     call diff_type_scenario_ref(structure_ref%i_ni_tot, structure_new%i_ni_tot, trim(name) // "%i_ni_tot", func)
     call diff_type_scenario_ref(structure_ref%i_ohm, structure_new%i_ohm, trim(name) // "%i_ohm", func)
     call diff_type_scenario_ref(structure_ref%i_par, structure_new%i_par, trim(name) // "%i_par", func)
     call diff_type_scenario_ref(structure_ref%i_runaway, structure_new%i_runaway, trim(name) // "%i_runaway", func)
     call diff_type_scenario_ref(structure_ref%v_loop, structure_new%v_loop, trim(name) // "%v_loop", func)
     call diff_type_scenario_ref(structure_ref%v_meas, structure_new%v_meas, trim(name) // "%v_meas", func)
   end subroutine diff_type_scenario_currents

   subroutine diff_arr_type_scenario_currents(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_currents), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_currents(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_currents

   subroutine diff_type_scenario_edge(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_edge), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%te_edge, structure_new%te_edge, trim(name) // "%te_edge", func)
     call diff_type_scenario_ref(structure_ref%ti_edge, structure_new%ti_edge, trim(name) // "%ti_edge", func)
     call diff_type_scenario_ref(structure_ref%ne_edge, structure_new%ne_edge, trim(name) // "%ne_edge", func)
     call diff_type_scenario_ref(structure_ref%ni_edge, structure_new%ni_edge, trim(name) // "%ni_edge", func)
     call diff_type_scenario_ref(structure_ref%psi_edge, structure_new%psi_edge, trim(name) // "%psi_edge", func)
     call diff_type_scenario_ref(structure_ref%phi_edge, structure_new%phi_edge, trim(name) // "%phi_edge", func)
     call diff_type_scenario_ref(structure_ref%rho_edge, structure_new%rho_edge, trim(name) // "%rho_edge", func)
     call diff_type_scenario_ref(structure_ref%drho_edge_dt, structure_new%drho_edge_dt, trim(name) // "%drho_edge_dt", func)
     call diff_type_scenario_ref(structure_ref%q_edge, structure_new%q_edge, trim(name) // "%q_edge", func)
     call diff_type_scenario_ref(structure_ref%neutral_flux, structure_new%neutral_flux, trim(name) // "%neutral_flux", func)
     call diff_type_scenario_ref(structure_ref%phi_plasma, structure_new%phi_plasma, trim(name) // "%phi_plasma", func)
     call diff_type_scenario_ref(structure_ref%vtor_edge, structure_new%vtor_edge, trim(name) // "%vtor_edge", func)
   end subroutine diff_type_scenario_edge

   subroutine diff_arr_type_scenario_edge(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_edge), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_edge(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_edge

   subroutine diff_type_scenario_energy(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_energy), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%w_tot, structure_new%w_tot, trim(name) // "%w_tot", func)
     call diff_type_scenario_ref(structure_ref%w_b_pol, structure_new%w_b_pol, trim(name) // "%w_b_pol", func)
     call diff_type_scenario_ref(structure_ref%w_dia, structure_new%w_dia, trim(name) // "%w_dia", func)
     call diff_type_scenario_ref(structure_ref%dwdia_dt, structure_new%dwdia_dt, trim(name) // "%dwdia_dt", func)
     call diff_type_scenario_ref(structure_ref%w_b_tor_pla, structure_new%w_b_tor_pla, trim(name) // "%w_b_tor_pla", func)
     call diff_type_scenario_ref(structure_ref%w_th, structure_new%w_th, trim(name) // "%w_th", func)
     call diff_type_scenario_ref(structure_ref%dwtot_dt, structure_new%dwtot_dt, trim(name) // "%dwtot_dt", func)
     call diff_type_scenario_ref(structure_ref%dwbpol_dt, structure_new%dwbpol_dt, trim(name) // "%dwbpol_dt", func)
     call diff_type_scenario_ref(structure_ref%dwbtorpla_dt, structure_new%dwbtorpla_dt, trim(name) // "%dwbtorpla_dt", func)
     call diff_type_scenario_ref(structure_ref%dwth_dt, structure_new%dwth_dt, trim(name) // "%dwth_dt", func)
     call diff_type_scenario_ref(structure_ref%esup_icrhtot, structure_new%esup_icrhtot, trim(name) // "%esup_icrhtot", func)
     call diff_type_scenario_ref(structure_ref%esup_icrhper, structure_new%esup_icrhper, trim(name) // "%esup_icrhper", func)
     call diff_type_scenario_ref(structure_ref%esup_nbitot, structure_new%esup_nbitot, trim(name) // "%esup_nbitot", func)
     call diff_type_scenario_ref(structure_ref%esup_nbiperp, structure_new%esup_nbiperp, trim(name) // "%esup_nbiperp", func)
     call diff_type_scenario_ref(structure_ref%esup_lhcd, structure_new%esup_lhcd, trim(name) // "%esup_lhcd", func)
     call diff_type_scenario_ref(structure_ref%esup_alpha, structure_new%esup_alpha, trim(name) // "%esup_alpha", func)
   end subroutine diff_type_scenario_energy

   subroutine diff_arr_type_scenario_energy(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_energy), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_energy(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_energy

   subroutine diff_type_scenario_global(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_global), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%ip, structure_new%ip, trim(name) // "%ip", func)
     call diff_type_scenario_ref(structure_ref%dip_dt, structure_new%dip_dt, trim(name) // "%dip_dt", func)
     call diff_type_scenario_ref(structure_ref%beta_pol, structure_new%beta_pol, trim(name) // "%beta_pol", func)
     call diff_type_scenario_ref(structure_ref%beta_tor, structure_new%beta_tor, trim(name) // "%beta_tor", func)
     call diff_type_scenario_ref(structure_ref%beta_normal, structure_new%beta_normal, trim(name) // "%beta_normal", func)
     call diff_type_scenario_ref(structure_ref%li, structure_new%li, trim(name) // "%li", func)
     call diff_type_scenario_ref(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_scenario_ref(structure_ref%area_pol, structure_new%area_pol, trim(name) // "%area_pol", func)
     call diff_type_scenario_ref(structure_ref%area_ext, structure_new%area_ext, trim(name) // "%area_ext", func)
     call diff_type_scenario_ref(structure_ref%len_sepa, structure_new%len_sepa, trim(name) // "%len_sepa", func)
     call diff_type_scenario_ref(structure_ref%beta_pol_th, structure_new%beta_pol_th, trim(name) // "%beta_pol_th", func)
     call diff_type_scenario_ref(structure_ref%beta_tor_th, structure_new%beta_tor_th, trim(name) // "%beta_tor_th", func)
     call diff_type_scenario_ref(structure_ref%beta_n_th, structure_new%beta_n_th, trim(name) // "%beta_n_th", func)
     call diff_type_scenario_ref(structure_ref%disruption, structure_new%disruption, trim(name) // "%disruption", func)
     call diff_type_scenario_ref(structure_ref%mode_h, structure_new%mode_h, trim(name) // "%mode_h", func)
     call diff_type_scenario_ref(structure_ref%s_alpha, structure_new%s_alpha, trim(name) // "%s_alpha", func)
   end subroutine diff_type_scenario_global

   subroutine diff_arr_type_scenario_global(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_global), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_global(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_global

   subroutine diff_type_scenario_heat_power(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_heat_power), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%plh, structure_new%plh, trim(name) // "%plh", func)
     call diff_type_scenario_ref(structure_ref%pohmic, structure_new%pohmic, trim(name) // "%pohmic", func)
     call diff_type_scenario_ref(structure_ref%picrh, structure_new%picrh, trim(name) // "%picrh", func)
     call diff_type_scenario_ref(structure_ref%pecrh, structure_new%pecrh, trim(name) // "%pecrh", func)
     call diff_type_scenario_ref(structure_ref%pnbi, structure_new%pnbi, trim(name) // "%pnbi", func)
     call diff_type_scenario_ref(structure_ref%pnbi_co_cur, structure_new%pnbi_co_cur, trim(name) // "%pnbi_co_cur", func)
     call diff_type_scenario_ref(structure_ref%pnbi_counter, structure_new%pnbi_counter, trim(name) // "%pnbi_counter", func)
     call diff_type_scenario_ref(structure_ref%plh_th, structure_new%plh_th, trim(name) // "%plh_th", func)
     call diff_type_scenario_ref(structure_ref%picrh_th, structure_new%picrh_th, trim(name) // "%picrh_th", func)
     call diff_type_scenario_ref(structure_ref%pecrh_th, structure_new%pecrh_th, trim(name) // "%pecrh_th", func)
     call diff_type_scenario_ref(structure_ref%pnbi_th, structure_new%pnbi_th, trim(name) // "%pnbi_th", func)
     call diff_type_scenario_ref(structure_ref%ploss_icrh, structure_new%ploss_icrh, trim(name) // "%ploss_icrh", func)
     call diff_type_scenario_ref(structure_ref%ploss_nbi, structure_new%ploss_nbi, trim(name) // "%ploss_nbi", func)
     call diff_type_scenario_ref(structure_ref%pbrem, structure_new%pbrem, trim(name) // "%pbrem", func)
     call diff_type_scenario_ref(structure_ref%pcyclo, structure_new%pcyclo, trim(name) // "%pcyclo", func)
     call diff_type_scenario_ref(structure_ref%prad, structure_new%prad, trim(name) // "%prad", func)
     call diff_type_scenario_ref(structure_ref%pdd_fus, structure_new%pdd_fus, trim(name) // "%pdd_fus", func)
     call diff_type_scenario_ref(structure_ref%pei, structure_new%pei, trim(name) // "%pei", func)
     call diff_type_scenario_ref(structure_ref%pel_tot, structure_new%pel_tot, trim(name) // "%pel_tot", func)
     call diff_type_scenario_ref(structure_ref%pel_fus, structure_new%pel_fus, trim(name) // "%pel_fus", func)
     call diff_type_scenario_ref(structure_ref%pel_icrh, structure_new%pel_icrh, trim(name) // "%pel_icrh", func)
     call diff_type_scenario_ref(structure_ref%pel_nbi, structure_new%pel_nbi, trim(name) // "%pel_nbi", func)
     call diff_type_scenario_ref(structure_ref%pfus_dt, structure_new%pfus_dt, trim(name) // "%pfus_dt", func)
     call diff_type_scenario_ref(structure_ref%ploss_fus, structure_new%ploss_fus, trim(name) // "%ploss_fus", func)
     call diff_type_scenario_ref(structure_ref%pfus_nbi, structure_new%pfus_nbi, trim(name) // "%pfus_nbi", func)
     call diff_type_scenario_ref(structure_ref%pfus_th, structure_new%pfus_th, trim(name) // "%pfus_th", func)
     call diff_type_scenario_ref(structure_ref%padd_tot, structure_new%padd_tot, trim(name) // "%padd_tot", func)
     call diff_type_scenario_ref(structure_ref%pion_tot, structure_new%pion_tot, trim(name) // "%pion_tot", func)
     call diff_type_scenario_ref(structure_ref%pion_fus, structure_new%pion_fus, trim(name) // "%pion_fus", func)
     call diff_type_scenario_ref(structure_ref%pion_icrh, structure_new%pion_icrh, trim(name) // "%pion_icrh", func)
     call diff_type_scenario_ref(structure_ref%pion_nbi, structure_new%pion_nbi, trim(name) // "%pion_nbi", func)
     call diff_type_scenario_ref(structure_ref%pioniz, structure_new%pioniz, trim(name) // "%pioniz", func)
     call diff_type_scenario_ref(structure_ref%ploss, structure_new%ploss, trim(name) // "%ploss", func)
     call diff_type_scenario_ref(structure_ref%p_wth, structure_new%p_wth, trim(name) // "%p_wth", func)
     call diff_type_scenario_ref(structure_ref%p_w, structure_new%p_w, trim(name) // "%p_w", func)
     call diff_type_scenario_ref(structure_ref%p_l2h_thr, structure_new%p_l2h_thr, trim(name) // "%p_l2h_thr", func)
     call diff_type_scenario_ref(structure_ref%p_l2h_sc, structure_new%p_l2h_sc, trim(name) // "%p_l2h_sc", func)
     call diff_type_scenario_ref(structure_ref%p_nbi_icrh, structure_new%p_nbi_icrh, trim(name) // "%p_nbi_icrh", func)
   end subroutine diff_type_scenario_heat_power

   subroutine diff_arr_type_scenario_heat_power(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_heat_power), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_heat_power(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_heat_power

   subroutine diff_type_scenario_int(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_int), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_scenario_int

   subroutine diff_arr_type_scenario_int(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_int), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_int(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_int

   subroutine diff_type_scenario_itb(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_itb), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%q_min, structure_new%q_min, trim(name) // "%q_min", func)
     call diff_type_scenario_ref(structure_ref%te_itb, structure_new%te_itb, trim(name) // "%te_itb", func)
     call diff_type_scenario_ref(structure_ref%ti_itb, structure_new%ti_itb, trim(name) // "%ti_itb", func)
     call diff_type_scenario_ref(structure_ref%ne_itb, structure_new%ne_itb, trim(name) // "%ne_itb", func)
     call diff_type_scenario_ref(structure_ref%ni_itb, structure_new%ni_itb, trim(name) // "%ni_itb", func)
     call diff_type_scenario_ref(structure_ref%psi_itb, structure_new%psi_itb, trim(name) // "%psi_itb", func)
     call diff_type_scenario_ref(structure_ref%phi_itb, structure_new%phi_itb, trim(name) // "%phi_itb", func)
     call diff_type_scenario_ref(structure_ref%rho_itb, structure_new%rho_itb, trim(name) // "%rho_itb", func)
     call diff_type_scenario_ref(structure_ref%h_itb, structure_new%h_itb, trim(name) // "%h_itb", func)
     call diff_type_scenario_ref(structure_ref%width_itb, structure_new%width_itb, trim(name) // "%width_itb", func)
     call diff_type_scenario_ref(structure_ref%vtor_itb, structure_new%vtor_itb, trim(name) // "%vtor_itb", func)
     call diff_type_scenario_int(structure_ref%itb_type, structure_new%itb_type, trim(name) // "%itb_type", func)
   end subroutine diff_type_scenario_itb

   subroutine diff_arr_type_scenario_itb(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_itb), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_itb(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_itb

   subroutine diff_type_scenario_lim_div_wall(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_lim_div_wall), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%te_lim_div, structure_new%te_lim_div, trim(name) // "%te_lim_div", func)
     call diff_type_scenario_ref(structure_ref%ti_lim_div, structure_new%ti_lim_div, trim(name) // "%ti_lim_div", func)
     call diff_type_scenario_ref(structure_ref%ne_lim_div, structure_new%ne_lim_div, trim(name) // "%ne_lim_div", func)
     call diff_type_scenario_ref(structure_ref%ni_lim_div, structure_new%ni_lim_div, trim(name) // "%ni_lim_div", func)
     call diff_type_scenario_ref(structure_ref%q_peak_div, structure_new%q_peak_div, trim(name) // "%q_peak_div", func)
     call diff_type_scenario_ref(structure_ref%q_peak_wall, structure_new%q_peak_wall, trim(name) // "%q_peak_wall", func)
     call diff_type_scenario_ref(structure_ref%surf_temp, structure_new%surf_temp, trim(name) // "%surf_temp", func)
     call diff_type_scenario_ref(structure_ref%p_lim_div, structure_new%p_lim_div, trim(name) // "%p_lim_div", func)
     call diff_type_scenario_ref(structure_ref%p_rad_div, structure_new%p_rad_div, trim(name) // "%p_rad_div", func)
     call diff_type_scenario_ref(structure_ref%p_neut_div, structure_new%p_neut_div, trim(name) // "%p_neut_div", func)
     call diff_type_scenario_ref(structure_ref%p_wall, structure_new%p_wall, trim(name) // "%p_wall", func)
     call diff_type_scenario_ref(structure_ref%wall_temp, structure_new%wall_temp, trim(name) // "%wall_temp", func)
     call diff_type_scenario_ref(structure_ref%wall_state, structure_new%wall_state, trim(name) // "%wall_state", func)
     call diff_type_scenario_ref(structure_ref%detach_state, structure_new%detach_state, trim(name) // "%detach_state", func)
     call diff_type_scenario_ref(structure_ref%pump_flux, structure_new%pump_flux, trim(name) // "%pump_flux", func)
     call diff_type_scenario_ref(structure_ref%p_rad_fw, structure_new%p_rad_fw, trim(name) // "%p_rad_fw", func)
     call diff_type_scenario_ref(structure_ref%p_cond_fw, structure_new%p_cond_fw, trim(name) // "%p_cond_fw", func)
     call diff_type_scenario_ref(structure_ref%div_wetted, structure_new%div_wetted, trim(name) // "%div_wetted", func)
     call diff_type_scenario_ref(structure_ref%gas_puff, structure_new%gas_puff, trim(name) // "%gas_puff", func)
     call diff_type_scenario_ref(structure_ref%ar_concentr, structure_new%ar_concentr, trim(name) // "%ar_concentr", func)
     call diff_type_scenario_ref(structure_ref%part_exhaust, structure_new%part_exhaust, trim(name) // "%part_exhaust", func)
     call diff_type_scenario_ref(structure_ref%f_inner, structure_new%f_inner, trim(name) // "%f_inner", func)
     call diff_type_scenario_ref(structure_ref%f_outer, structure_new%f_outer, trim(name) // "%f_outer", func)
     call diff_type_scenario_ref(structure_ref%f_pfr, structure_new%f_pfr, trim(name) // "%f_pfr", func)
     call diff_type_scenario_ref(structure_ref%f_rad_fw, structure_new%f_rad_fw, trim(name) // "%f_rad_fw", func)
     call diff_type_vecflt_type(structure_ref%q_div, structure_new%q_div, trim(name) // "%q_div", func)
     call diff_type_scenario_ref(structure_ref%p_cond_div, structure_new%p_cond_div, trim(name) // "%p_cond_div", func)
     call diff_type_float(structure_ref%pol_ext, structure_new%pol_ext, trim(name) // "%pol_ext", func)
     call diff_type_float(structure_ref%flux_exp, structure_new%flux_exp, trim(name) // "%flux_exp", func)
     call diff_type_float(structure_ref%tilt_angle, structure_new%tilt_angle, trim(name) // "%tilt_angle", func)
     call diff_type_float(structure_ref%n_div, structure_new%n_div, trim(name) // "%n_div", func)
     call diff_type_float(structure_ref%div_dz, structure_new%div_dz, trim(name) // "%div_dz", func)
     call diff_type_float(structure_ref%div_dro, structure_new%div_dro, trim(name) // "%div_dro", func)
     call diff_type_float(structure_ref%div_dri, structure_new%div_dri, trim(name) // "%div_dri", func)
     call diff_type_scenario_ref(structure_ref%p_nh_div, structure_new%p_nh_div, trim(name) // "%p_nh_div", func)
   end subroutine diff_type_scenario_lim_div_wall

   subroutine diff_arr_type_scenario_lim_div_wall(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_lim_div_wall), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_lim_div_wall(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_lim_div_wall

   subroutine diff_type_scenario_line_ave(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_line_ave), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%ne_line, structure_new%ne_line, trim(name) // "%ne_line", func)
     call diff_type_scenario_ref(structure_ref%zeff_line, structure_new%zeff_line, trim(name) // "%zeff_line", func)
     call diff_type_scenario_ref(structure_ref%ne_zeff_line, structure_new%ne_zeff_line, trim(name) // "%ne_zeff_line", func)
     call diff_type_scenario_ref(structure_ref%dne_line_dt, structure_new%dne_line_dt, trim(name) // "%dne_line_dt", func)
   end subroutine diff_type_scenario_line_ave

   subroutine diff_arr_type_scenario_line_ave(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_line_ave), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_line_ave(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_line_ave

   subroutine diff_type_scenario_neutron(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_neutron), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%ndd_tot, structure_new%ndd_tot, trim(name) // "%ndd_tot", func)
     call diff_type_scenario_ref(structure_ref%ndd_th, structure_new%ndd_th, trim(name) // "%ndd_th", func)
     call diff_type_scenario_ref(structure_ref%ndd_nbi_th, structure_new%ndd_nbi_th, trim(name) // "%ndd_nbi_th", func)
     call diff_type_scenario_ref(structure_ref%ndd_nbi_nbi, structure_new%ndd_nbi_nbi, trim(name) // "%ndd_nbi_nbi", func)
     call diff_type_scenario_ref(structure_ref%ndt_tot, structure_new%ndt_tot, trim(name) // "%ndt_tot", func)
     call diff_type_scenario_ref(structure_ref%ndt_th, structure_new%ndt_th, trim(name) // "%ndt_th", func)
   end subroutine diff_type_scenario_neutron

   subroutine diff_arr_type_scenario_neutron(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_neutron), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_neutron(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_neutron

   subroutine diff_type_scenario_ninety_five(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_ninety_five), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%q_95, structure_new%q_95, trim(name) // "%q_95", func)
     call diff_type_scenario_ref(structure_ref%elong_95, structure_new%elong_95, trim(name) // "%elong_95", func)
     call diff_type_scenario_ref(structure_ref%tria_95, structure_new%tria_95, trim(name) // "%tria_95", func)
     call diff_type_scenario_ref(structure_ref%tria_up_95, structure_new%tria_up_95, trim(name) // "%tria_up_95", func)
     call diff_type_scenario_ref(structure_ref%tria_lo_95, structure_new%tria_lo_95, trim(name) // "%tria_lo_95", func)
     call diff_type_scenario_ref(structure_ref%te_95, structure_new%te_95, trim(name) // "%te_95", func)
     call diff_type_scenario_ref(structure_ref%ti_95, structure_new%ti_95, trim(name) // "%ti_95", func)
     call diff_type_scenario_ref(structure_ref%ne_95, structure_new%ne_95, trim(name) // "%ne_95", func)
     call diff_type_scenario_ref(structure_ref%ni_95, structure_new%ni_95, trim(name) // "%ni_95", func)
     call diff_type_scenario_ref(structure_ref%phi_95, structure_new%phi_95, trim(name) // "%phi_95", func)
     call diff_type_scenario_ref(structure_ref%rho_95, structure_new%rho_95, trim(name) // "%rho_95", func)
     call diff_type_scenario_ref(structure_ref%vtor_95, structure_new%vtor_95, trim(name) // "%vtor_95", func)
   end subroutine diff_type_scenario_ninety_five

   subroutine diff_arr_type_scenario_ninety_five(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_ninety_five), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_ninety_five(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_ninety_five

   subroutine diff_type_scenario_pedestal(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_pedestal), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%te_ped, structure_new%te_ped, trim(name) // "%te_ped", func)
     call diff_type_scenario_ref(structure_ref%ti_ped, structure_new%ti_ped, trim(name) // "%ti_ped", func)
     call diff_type_scenario_ref(structure_ref%ne_ped, structure_new%ne_ped, trim(name) // "%ne_ped", func)
     call diff_type_scenario_ref(structure_ref%ni_ped, structure_new%ni_ped, trim(name) // "%ni_ped", func)
     call diff_type_scenario_ref(structure_ref%psi_ped, structure_new%psi_ped, trim(name) // "%psi_ped", func)
     call diff_type_scenario_ref(structure_ref%phi_ped, structure_new%phi_ped, trim(name) // "%phi_ped", func)
     call diff_type_scenario_ref(structure_ref%rho_ped, structure_new%rho_ped, trim(name) // "%rho_ped", func)
     call diff_type_scenario_ref(structure_ref%q_ped, structure_new%q_ped, trim(name) // "%q_ped", func)
     call diff_type_scenario_ref(structure_ref%pressure_ped, structure_new%pressure_ped, trim(name) // "%pressure_ped", func)
     call diff_type_scenario_ref(structure_ref%vtor_ped, structure_new%vtor_ped, trim(name) // "%vtor_ped", func)
   end subroutine diff_type_scenario_pedestal

   subroutine diff_arr_type_scenario_pedestal(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_pedestal), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_pedestal(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_pedestal

   subroutine diff_type_scenario_reactor(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_reactor), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%pnetwork, structure_new%pnetwork, trim(name) // "%pnetwork", func)
   end subroutine diff_type_scenario_reactor

   subroutine diff_arr_type_scenario_reactor(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_reactor), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_reactor(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_reactor

   subroutine diff_type_scenario_ref(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_ref), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_scenario_ref

   subroutine diff_arr_type_scenario_ref(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_ref), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_ref(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_ref

   subroutine diff_type_scenario_references(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_references), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%plh, structure_new%plh, trim(name) // "%plh", func)
     call diff_type_scenario_ref(structure_ref%picrh, structure_new%picrh, trim(name) // "%picrh", func)
     call diff_type_scenario_ref(structure_ref%pecrh, structure_new%pecrh, trim(name) // "%pecrh", func)
     call diff_type_scenario_ref(structure_ref%pnbi, structure_new%pnbi, trim(name) // "%pnbi", func)
     call diff_type_scenario_ref(structure_ref%ip, structure_new%ip, trim(name) // "%ip", func)
     call diff_type_scenario_ref(structure_ref%bvac_r, structure_new%bvac_r, trim(name) // "%bvac_r", func)
     call diff_type_scenario_ref(structure_ref%zeffl, structure_new%zeffl, trim(name) // "%zeffl", func)
     call diff_type_scenario_ref(structure_ref%nbar, structure_new%nbar, trim(name) // "%nbar", func)
     call diff_type_scenario_ref(structure_ref%xecrh, structure_new%xecrh, trim(name) // "%xecrh", func)
     call diff_type_scenario_ref(structure_ref%pol_flux, structure_new%pol_flux, trim(name) // "%pol_flux", func)
     call diff_type_scenario_ref(structure_ref%enhancement, structure_new%enhancement, trim(name) // "%enhancement", func)
     call diff_type_scenario_ref(structure_ref%isotopic, structure_new%isotopic, trim(name) // "%isotopic", func)
     call diff_type_scenario_ref(structure_ref%nbi_td_ratio, structure_new%nbi_td_ratio, trim(name) // "%nbi_td_ratio", func)
     call diff_type_scenario_ref(structure_ref%gas_puff, structure_new%gas_puff, trim(name) // "%gas_puff", func)
   end subroutine diff_type_scenario_references

   subroutine diff_arr_type_scenario_references(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_references), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_references(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_references

   subroutine diff_type_scenario_sol(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_sol), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%l_te_sol, structure_new%l_te_sol, trim(name) // "%l_te_sol", func)
     call diff_type_scenario_ref(structure_ref%l_ti_sol, structure_new%l_ti_sol, trim(name) // "%l_ti_sol", func)
     call diff_type_scenario_ref(structure_ref%l_ne_sol, structure_new%l_ne_sol, trim(name) // "%l_ne_sol", func)
     call diff_type_scenario_ref(structure_ref%l_ni_sol, structure_new%l_ni_sol, trim(name) // "%l_ni_sol", func)
     call diff_type_scenario_ref(structure_ref%l_qe_sol, structure_new%l_qe_sol, trim(name) // "%l_qe_sol", func)
     call diff_type_scenario_ref(structure_ref%l_qi_sol, structure_new%l_qi_sol, trim(name) // "%l_qi_sol", func)
     call diff_type_scenario_ref(structure_ref%p_rad_sol, structure_new%p_rad_sol, trim(name) // "%p_rad_sol", func)
     call diff_type_float(structure_ref%p_neut, structure_new%p_neut, trim(name) // "%p_neut", func)
     call diff_type_scenario_ref(structure_ref%gas_puff, structure_new%gas_puff, trim(name) // "%gas_puff", func)
     call diff_type_float(structure_ref%delta_r_in, structure_new%delta_r_in, trim(name) // "%delta_r_in", func)
     call diff_type_float(structure_ref%delta_r_out, structure_new%delta_r_out, trim(name) // "%delta_r_out", func)
     call diff_type_float(structure_ref%r_in, structure_new%r_in, trim(name) // "%r_in", func)
     call diff_type_float(structure_ref%r_out, structure_new%r_out, trim(name) // "%r_out", func)
     call diff_type_float(structure_ref%sol_width, structure_new%sol_width, trim(name) // "%sol_width", func)
   end subroutine diff_type_scenario_sol

   subroutine diff_arr_type_scenario_sol(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_sol), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_sol(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_sol

   subroutine diff_type_scenario_vol_ave(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_vol_ave), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_scenario_ref(structure_ref%te_ave, structure_new%te_ave, trim(name) // "%te_ave", func)
     call diff_type_scenario_ref(structure_ref%ti_ave, structure_new%ti_ave, trim(name) // "%ti_ave", func)
     call diff_type_scenario_ref(structure_ref%ne_ave, structure_new%ne_ave, trim(name) // "%ne_ave", func)
     call diff_type_scenario_ref(structure_ref%dne_ave_dt, structure_new%dne_ave_dt, trim(name) // "%dne_ave_dt", func)
     call diff_type_scenario_ref(structure_ref%ni_ave, structure_new%ni_ave, trim(name) // "%ni_ave", func)
     call diff_type_scenario_ref(structure_ref%zeff_ave, structure_new%zeff_ave, trim(name) // "%zeff_ave", func)
     call diff_type_scenario_ref(structure_ref%ti_o_te_ave, structure_new%ti_o_te_ave, trim(name) // "%ti_o_te_ave", func)
     call diff_type_scenario_ref(structure_ref%meff_ave, structure_new%meff_ave, trim(name) // "%meff_ave", func)
     call diff_type_scenario_ref(structure_ref%pellet_flux, structure_new%pellet_flux, trim(name) // "%pellet_flux", func)
     call diff_type_vecflt_type(structure_ref%nions_ave, structure_new%nions_ave, trim(name) // "%nions_ave", func)
     call diff_type_scenario_ref(structure_ref%omega_ave, structure_new%omega_ave, trim(name) // "%omega_ave", func)
   end subroutine diff_type_scenario_vol_ave

   subroutine diff_arr_type_scenario_vol_ave(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_scenario_vol_ave), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_scenario_vol_ave(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_scenario_vol_ave

   subroutine diff_type_setup_bprobe(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_bprobe), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_vecflt_type(structure_ref%polangle, structure_new%polangle, trim(name) // "%polangle", func)
     call diff_type_vecflt_type(structure_ref%torangle, structure_new%torangle, trim(name) // "%torangle", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
     call diff_type_vecflt_type(structure_ref%length, structure_new%length, trim(name) // "%length", func)
     call diff_type_vecint_type(structure_ref%turns, structure_new%turns, trim(name) // "%turns", func)
   end subroutine diff_type_setup_bprobe

   subroutine diff_arr_type_setup_bprobe(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_bprobe), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_setup_bprobe(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_setup_bprobe

   subroutine diff_type_setup_floops(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_floops), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_rzphi2D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_vecint_type(structure_ref%npoints, structure_new%npoints, trim(name) // "%npoints", func)
   end subroutine diff_type_setup_floops

   subroutine diff_arr_type_setup_floops(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_floops), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_setup_floops(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_setup_floops

   subroutine diff_type_setup_line(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_line), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1D(structure_ref%pivot_point, structure_new%pivot_point, trim(name) // "%pivot_point", func)
     call diff_type_vecflt_type(structure_ref%horchordang1, structure_new%horchordang1, trim(name) // "%horchordang1", func)
     call diff_type_vecflt_type(structure_ref%verchordang1, structure_new%verchordang1, trim(name) // "%verchordang1", func)
     call diff_type_vecflt_type(structure_ref%width, structure_new%width, trim(name) // "%width", func)
     call diff_type_rzphi1D(structure_ref%second_point, structure_new%second_point, trim(name) // "%second_point", func)
     call diff_type_vecflt_type(structure_ref%horchordang2, structure_new%horchordang2, trim(name) // "%horchordang2", func)
     call diff_type_vecflt_type(structure_ref%verchordang2, structure_new%verchordang2, trim(name) // "%verchordang2", func)
     call diff_type_rzphi1D(structure_ref%third_point, structure_new%third_point, trim(name) // "%third_point", func)
     call diff_type_integer(structure_ref%nchordpoints, structure_new%nchordpoints, trim(name) // "%nchordpoints", func)
   end subroutine diff_type_setup_line

   subroutine diff_arr_type_setup_line(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_line), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_setup_line(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_setup_line

   subroutine diff_type_setup_line_exp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_line_exp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1Dexperimental(structure_ref%pivot_point, structure_new%pivot_point, trim(name) // "%pivot_point", func)
     call diff_type_vecflt_type(structure_ref%horchordang1, structure_new%horchordang1, trim(name) // "%horchordang1", func)
     call diff_type_vecflt_type(structure_ref%verchordang1, structure_new%verchordang1, trim(name) // "%verchordang1", func)
     call diff_type_vecflt_type(structure_ref%width, structure_new%width, trim(name) // "%width", func)
     call diff_type_rzphi1Dexperimental(structure_ref%second_point, structure_new%second_point, trim(name) // "%second_point", func)
     call diff_type_vecflt_type(structure_ref%horchordang2, structure_new%horchordang2, trim(name) // "%horchordang2", func)
     call diff_type_vecflt_type(structure_ref%verchordang2, structure_new%verchordang2, trim(name) // "%verchordang2", func)
     call diff_type_rzphi1Dexperimental(structure_ref%third_point, structure_new%third_point, trim(name) // "%third_point", func)
     call diff_type_integer(structure_ref%nchordpoints, structure_new%nchordpoints, trim(name) // "%nchordpoints", func)
   end subroutine diff_type_setup_line_exp

   subroutine diff_arr_type_setup_line_exp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_setup_line_exp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_setup_line_exp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_setup_line_exp

   subroutine diff_type_shield(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_shield), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_shield_specs(structure_ref%inboard, structure_new%inboard, trim(name) // "%inboard", func)
     call diff_type_shield_specs(structure_ref%outboard, structure_new%outboard, trim(name) // "%outboard", func)
   end subroutine diff_type_shield

   subroutine diff_arr_type_shield(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_shield), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_shield(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_shield

   subroutine diff_type_shield_specs(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_shield_specs), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nmat, structure_new%nmat, trim(name) // "%nmat", func)
     call diff_type_vecflt_type(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_float(structure_ref%r1, structure_new%r1, trim(name) // "%r1", func)
     call diff_type_float(structure_ref%r2, structure_new%r2, trim(name) // "%r2", func)
     call diff_type_float(structure_ref%mass, structure_new%mass, trim(name) // "%mass", func)
   end subroutine diff_type_shield_specs

   subroutine diff_arr_type_shield_specs(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_shield_specs), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_shield_specs(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_shield_specs

   subroutine diff_type_simp_apert(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_simp_apert), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecflt_type(structure_ref%sizes, structure_new%sizes, trim(name) // "%sizes", func)
     call diff_type_float(structure_ref%angle, structure_new%angle, trim(name) // "%angle", func)
   end subroutine diff_type_simp_apert

   subroutine diff_arr_type_simp_apert(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_simp_apert), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_simp_apert(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_simp_apert

   subroutine diff_type_solcurdiag_sol_current(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_solcurdiag_sol_current), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_solcurdiag_sol_current_setup(structure_ref%setup, structure_new%setup, trim(name) // "%setup", func)
     call diff_type_exp0D(structure_ref%measure, structure_new%measure, trim(name) // "%measure", func)
   end subroutine diff_type_solcurdiag_sol_current

   subroutine diff_arr_type_solcurdiag_sol_current(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_solcurdiag_sol_current), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_solcurdiag_sol_current(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_solcurdiag_sol_current

   subroutine diff_type_solcurdiag_sol_current_setup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_solcurdiag_sol_current_setup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_integer(structure_ref%id, structure_new%id, trim(name) // "%id", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_integer(structure_ref%tiles_turn, structure_new%tiles_turn, trim(name) // "%tiles_turn", func)
   end subroutine diff_type_solcurdiag_sol_current_setup

   subroutine diff_arr_type_solcurdiag_sol_current_setup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_solcurdiag_sol_current_setup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_solcurdiag_sol_current_setup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_solcurdiag_sol_current_setup

   subroutine diff_type_source_imp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_imp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%exp, structure_new%exp, trim(name) // "%exp", func)
     call diff_type_matflt_type(structure_ref%imp, structure_new%imp, trim(name) // "%imp", func)
   end subroutine diff_type_source_imp

   subroutine diff_arr_type_source_imp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_imp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_source_imp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_source_imp

   subroutine diff_type_source_ion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_ion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%exp, structure_new%exp, trim(name) // "%exp", func)
     call diff_type_matflt_type(structure_ref%imp, structure_new%imp, trim(name) // "%imp", func)
   end subroutine diff_type_source_ion

   subroutine diff_arr_type_source_ion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_ion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_source_ion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_source_ion

   subroutine diff_type_source_rate(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_rate), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_complexgrid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_type_complexgrid_scalar(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecint_type(structure_ref%discrete, structure_new%discrete, trim(name) // "%discrete", func)
     call diff_type_parameters(structure_ref%parameters, structure_new%parameters, trim(name) // "%parameters", func)
   end subroutine diff_type_source_rate

   subroutine diff_arr_type_source_rate(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_rate), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_source_rate(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_source_rate

   subroutine diff_type_source_vec(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_vec), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%exp, structure_new%exp, trim(name) // "%exp", func)
     call diff_type_vecflt_type(structure_ref%imp, structure_new%imp, trim(name) // "%imp", func)
   end subroutine diff_type_source_vec

   subroutine diff_arr_type_source_vec(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_source_vec), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_source_vec(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_source_vec

   subroutine diff_type_sourceel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sourceel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_vecflt_type(structure_ref%integral, structure_new%integral, trim(name) // "%integral", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_sourceel

   subroutine diff_arr_type_sourceel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sourceel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sourceel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sourceel

   subroutine diff_type_sourceimp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sourceimp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_matflt_type(structure_ref%integral, structure_new%integral, trim(name) // "%integral", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_sourceimp

   subroutine diff_arr_type_sourceimp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sourceimp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sourceimp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sourceimp

   subroutine diff_type_sourceion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sourceion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
     call diff_type_matflt_type(structure_ref%integral, structure_new%integral, trim(name) // "%integral", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
   end subroutine diff_type_sourceion

   subroutine diff_arr_type_sourceion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sourceion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sourceion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sourceion

   subroutine diff_type_species_desc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_species_desc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_type_float(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_float(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_float(structure_ref%zmin, structure_new%zmin, trim(name) // "%zmin", func)
     call diff_type_float(structure_ref%zmax, structure_new%zmax, trim(name) // "%zmax", func)
   end subroutine diff_type_species_desc

   subroutine diff_arr_type_species_desc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_species_desc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_species_desc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_species_desc

   subroutine diff_type_species_reference(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_species_reference), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_integer(structure_ref%index, structure_new%index, trim(name) // "%index", func)
   end subroutine diff_type_species_reference

   subroutine diff_arr_type_species_reference(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_species_reference), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_species_reference(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_species_reference

   subroutine diff_type_spectral(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_spectral), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_msediag_emissivity(structure_ref%emissivity, structure_new%emissivity, trim(name) // "%emissivity", func)
     call diff_type_msediag_radiance(structure_ref%radiance, structure_new%radiance, trim(name) // "%radiance", func)
     call diff_type_codeparam(structure_ref%codeparam, structure_new%codeparam, trim(name) // "%codeparam", func)
   end subroutine diff_type_spectral

   subroutine diff_arr_type_spectral(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_spectral), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_spectral(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_spectral

   subroutine diff_type_spectrum(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_spectrum), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_launchs_phi_theta(structure_ref%phi_theta, structure_new%phi_theta, trim(name) // "%phi_theta", func)
     call diff_type_launchs_parallel(structure_ref%parallel, structure_new%parallel, trim(name) // "%parallel", func)
   end subroutine diff_type_spectrum

   subroutine diff_arr_type_spectrum(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_spectrum), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_spectrum(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_spectrum

   subroutine diff_type_spot(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_spot), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%size, structure_new%size, trim(name) // "%size", func)
     call diff_type_float(structure_ref%angle, structure_new%angle, trim(name) // "%angle", func)
   end subroutine diff_type_spot

   subroutine diff_arr_type_spot(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_spot), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_spot(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_spot

   subroutine diff_type_sputtering_neutrals(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sputtering_neutrals), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%physical, structure_new%physical, trim(name) // "%physical", func)
     call diff_type_vecflt_type(structure_ref%chemical, structure_new%chemical, trim(name) // "%chemical", func)
   end subroutine diff_type_sputtering_neutrals

   subroutine diff_arr_type_sputtering_neutrals(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_sputtering_neutrals), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_sputtering_neutrals(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_sputtering_neutrals

   subroutine diff_type_straps(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_straps), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp0D(structure_ref%current, structure_new%current, trim(name) // "%current", func)
     call diff_type_exp0D(structure_ref%phase, structure_new%phase, trim(name) // "%phase", func)
     call diff_type_float(structure_ref%phi_centre, structure_new%phi_centre, trim(name) // "%phi_centre", func)
     call diff_type_float(structure_ref%width, structure_new%width, trim(name) // "%width", func)
     call diff_type_float(structure_ref%dist2wall, structure_new%dist2wall, trim(name) // "%dist2wall", func)
     call diff_type_rz1D(structure_ref%coord_strap, structure_new%coord_strap, trim(name) // "%coord_strap", func)
   end subroutine diff_type_straps

   subroutine diff_arr_type_straps(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_straps), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_straps(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_straps

   subroutine diff_type_structure_cs(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_structure_cs), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%gaptf, structure_new%gaptf, trim(name) // "%gaptf", func)
     call diff_type_float(structure_ref%ri, structure_new%ri, trim(name) // "%ri", func)
     call diff_type_float(structure_ref%re, structure_new%re, trim(name) // "%re", func)
     call diff_type_float(structure_ref%jcable, structure_new%jcable, trim(name) // "%jcable", func)
     call diff_type_float(structure_ref%current_nom, structure_new%current_nom, trim(name) // "%current_nom", func)
     call diff_type_float(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_float(structure_ref%tiso, structure_new%tiso, trim(name) // "%tiso", func)
     call diff_type_float(structure_ref%nlay, structure_new%nlay, trim(name) // "%nlay", func)
   end subroutine diff_type_structure_cs

   subroutine diff_arr_type_structure_cs(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_structure_cs), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_structure_cs(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_structure_cs

   subroutine diff_type_t_series_cplx(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_t_series_cplx), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%time_wind, structure_new%time_wind, trim(name) // "%time_wind", func)
     call diff_type_vecflt_type(structure_ref%values_re, structure_new%values_re, trim(name) // "%values_re", func)
     call diff_type_vecflt_type(structure_ref%values_im, structure_new%values_im, trim(name) // "%values_im", func)
   end subroutine diff_type_t_series_cplx

   subroutine diff_arr_type_t_series_cplx(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_t_series_cplx), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_t_series_cplx(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_t_series_cplx

   subroutine diff_type_t_series_real(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_t_series_real), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%time_wind, structure_new%time_wind, trim(name) // "%time_wind", func)
     call diff_type_vecflt_type(structure_ref%values, structure_new%values, trim(name) // "%values", func)
   end subroutine diff_type_t_series_real

   subroutine diff_arr_type_t_series_real(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_t_series_real), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_t_series_real(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_t_series_real

   subroutine diff_type_table(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_table), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%filled, structure_new%filled, trim(name) // "%filled", func)
     call diff_type_float(structure_ref%table_0d, structure_new%table_0d, trim(name) // "%table_0d", func)
     call diff_type_vecflt_type(structure_ref%table_1d, structure_new%table_1d, trim(name) // "%table_1d", func)
     call diff_type_matflt_type(structure_ref%table_2d, structure_new%table_2d, trim(name) // "%table_2d", func)
     call diff_type_array3dflt_type(structure_ref%table_3d, structure_new%table_3d, trim(name) // "%table_3d", func)
     call diff_type_array4dflt_type(structure_ref%table_4d, structure_new%table_4d, trim(name) // "%table_4d", func)
     call diff_type_array5dflt_type(structure_ref%table_5d, structure_new%table_5d, trim(name) // "%table_5d", func)
     call diff_type_array6dflt_type(structure_ref%table_6d, structure_new%table_6d, trim(name) // "%table_6d", func)
     call diff_type_vecstring_type(structure_ref%coord1_str, structure_new%coord1_str, trim(name) // "%coord1_str", func)
     call diff_type_vecstring_type(structure_ref%coord2_str, structure_new%coord2_str, trim(name) // "%coord2_str", func)
     call diff_type_vecstring_type(structure_ref%coord3_str, structure_new%coord3_str, trim(name) // "%coord3_str", func)
     call diff_type_vecstring_type(structure_ref%coord4_str, structure_new%coord4_str, trim(name) // "%coord4_str", func)
     call diff_type_vecstring_type(structure_ref%coord5_str, structure_new%coord5_str, trim(name) // "%coord5_str", func)
     call diff_type_vecstring_type(structure_ref%coord6_str, structure_new%coord6_str, trim(name) // "%coord6_str", func)
     call diff_type_identifier(structure_ref%quality, structure_new%quality, trim(name) // "%quality", func)
   end subroutine diff_type_table

   subroutine diff_arr_type_table(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_table), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_table(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_table

   subroutine diff_type_tables(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tables), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%ndim, structure_new%ndim, trim(name) // "%ndim", func)
     call diff_type_integer(structure_ref%coord_index, structure_new%coord_index, trim(name) // "%coord_index", func)
     call diff_type_vecstring_type(structure_ref%result_label, structure_new%result_label, trim(name) // "%result_label", func)
     call diff_type_vecstring_type(structure_ref%result_unit, structure_new%result_unit, trim(name) // "%result_unit", func)
     call diff_type_integer(structure_ref%result_trans, structure_new%result_trans, trim(name) // "%result_trans", func)
     call diff_type_vecint_type(structure_ref%zmin, structure_new%zmin, trim(name) // "%zmin", func)
     call diff_type_vecint_type(structure_ref%zmax, structure_new%zmax, trim(name) // "%zmax", func)
     call diff_type_vecstring_type(structure_ref%state_label, structure_new%state_label, trim(name) // "%state_label", func)
     call diff_arr_type_table(structure_ref%table, structure_new%table, trim(name) // "%table", func)
     call diff_type_vecstring_type(structure_ref%data_source, structure_new%data_source, trim(name) // "%data_source", func)
     call diff_type_vecstring_type(structure_ref%data_provide, structure_new%data_provide, trim(name) // "%data_provide", func)
     call diff_type_vecstring_type(structure_ref%data_citation, structure_new%data_citation, trim(name) // "%data_citation", func)
   end subroutine diff_type_tables

   subroutine diff_arr_type_tables(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tables), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tables(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tables

   subroutine diff_type_tables_coord(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tables_coord), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_coords(structure_ref%coords, structure_new%coords, trim(name) // "%coords", func)
   end subroutine diff_type_tables_coord

   subroutine diff_arr_type_tables_coord(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tables_coord), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tables_coord(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tables_coord

   subroutine diff_type_temporary_nt(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_temporary_nt_0dr(structure_ref%float0d, structure_new%float0d, trim(name) // "%float0d", func)
     call diff_arr_type_temporary_nt_0di(structure_ref%integer0d, structure_new%integer0d, trim(name) // "%integer0d", func)
     call diff_arr_type_temporary_nt_0dc(structure_ref%complex0d, structure_new%complex0d, trim(name) // "%complex0d", func)
     call diff_arr_type_temporary_nt_0ds(structure_ref%string0d, structure_new%string0d, trim(name) // "%string0d", func)
     call diff_arr_type_temporary_nt_1dr(structure_ref%float1d, structure_new%float1d, trim(name) // "%float1d", func)
     call diff_arr_type_temporary_nt_1di(structure_ref%integer1d, structure_new%integer1d, trim(name) // "%integer1d", func)
     call diff_arr_type_temporary_nt_1dr(structure_ref%string1d, structure_new%string1d, trim(name) // "%string1d", func)
     call diff_arr_type_temporary_nt_1dc(structure_ref%complex1d, structure_new%complex1d, trim(name) // "%complex1d", func)
     call diff_arr_type_temporary_nt_2dr(structure_ref%float2d, structure_new%float2d, trim(name) // "%float2d", func)
     call diff_arr_type_temporary_nt_2di(structure_ref%integer2d, structure_new%integer2d, trim(name) // "%integer2d", func)
     call diff_arr_type_temporary_nt_2dc(structure_ref%complex2d, structure_new%complex2d, trim(name) // "%complex2d", func)
     call diff_arr_type_temporary_nt_3dr(structure_ref%float3d, structure_new%float3d, trim(name) // "%float3d", func)
     call diff_arr_type_temporary_nt_3di(structure_ref%integer3d, structure_new%integer3d, trim(name) // "%integer3d", func)
     call diff_arr_type_temporary_nt_3dc(structure_ref%complex3d, structure_new%complex3d, trim(name) // "%complex3d", func)
     call diff_arr_type_temporary_nt_4dr(structure_ref%float4d, structure_new%float4d, trim(name) // "%float4d", func)
   end subroutine diff_type_temporary_nt

   subroutine diff_arr_type_temporary_nt(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt

   subroutine diff_type_temporary_nt_0dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_cplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_0dc

   subroutine diff_arr_type_temporary_nt_0dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_0dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_0dc

   subroutine diff_type_temporary_nt_0di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_integer(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_0di

   subroutine diff_arr_type_temporary_nt_0di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_0di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_0di

   subroutine diff_type_temporary_nt_0dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_float(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_0dr

   subroutine diff_arr_type_temporary_nt_0dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_0dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_0dr

   subroutine diff_type_temporary_nt_0ds(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0ds), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecstring_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_0ds

   subroutine diff_arr_type_temporary_nt_0ds(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_0ds), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_0ds(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_0ds

   subroutine diff_type_temporary_nt_1dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_veccplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_1dc

   subroutine diff_arr_type_temporary_nt_1dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_1dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_1dc

   subroutine diff_type_temporary_nt_1di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecint_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_1di

   subroutine diff_arr_type_temporary_nt_1di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_1di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_1di

   subroutine diff_type_temporary_nt_1dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_1dr

   subroutine diff_arr_type_temporary_nt_1dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_1dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_1dr

   subroutine diff_type_temporary_nt_1ds(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1ds), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecstring_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_1ds

   subroutine diff_arr_type_temporary_nt_1ds(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_1ds), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_1ds(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_1ds

   subroutine diff_type_temporary_nt_2dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_2dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_matcplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_2dc

   subroutine diff_arr_type_temporary_nt_2dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_2dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_2dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_2dc

   subroutine diff_type_temporary_nt_2di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_2di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_matint_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_2di

   subroutine diff_arr_type_temporary_nt_2di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_2di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_2di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_2di

   subroutine diff_type_temporary_nt_2dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_2dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_2dr

   subroutine diff_arr_type_temporary_nt_2dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_2dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_2dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_2dr

   subroutine diff_type_temporary_nt_3dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_3dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array3dcplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_3dc

   subroutine diff_arr_type_temporary_nt_3dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_3dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_3dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_3dc

   subroutine diff_type_temporary_nt_3di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_3di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array3dint_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_3di

   subroutine diff_arr_type_temporary_nt_3di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_3di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_3di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_3di

   subroutine diff_type_temporary_nt_3dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_3dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array3dflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_3dr

   subroutine diff_arr_type_temporary_nt_3dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_3dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_3dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_3dr

   subroutine diff_type_temporary_nt_4dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_4dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array4dflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_nt_4dr

   subroutine diff_arr_type_temporary_nt_4dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_nt_4dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_nt_4dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_nt_4dr

   subroutine diff_type_temporary_t(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_temporary_t_0dr(structure_ref%float0d, structure_new%float0d, trim(name) // "%float0d", func)
     call diff_arr_type_temporary_t_0di(structure_ref%integer0d, structure_new%integer0d, trim(name) // "%integer0d", func)
     call diff_arr_type_temporary_t_0dc(structure_ref%complex0d, structure_new%complex0d, trim(name) // "%complex0d", func)
     call diff_arr_type_temporary_t_0ds(structure_ref%string0d, structure_new%string0d, trim(name) // "%string0d", func)
     call diff_arr_type_temporary_t_1dr(structure_ref%float1d, structure_new%float1d, trim(name) // "%float1d", func)
     call diff_arr_type_temporary_t_1di(structure_ref%integer1d, structure_new%integer1d, trim(name) // "%integer1d", func)
     call diff_arr_type_temporary_t_1dc(structure_ref%complex1d, structure_new%complex1d, trim(name) // "%complex1d", func)
     call diff_arr_type_temporary_t_2dr(structure_ref%float2d, structure_new%float2d, trim(name) // "%float2d", func)
     call diff_arr_type_temporary_t_2di(structure_ref%integer2d, structure_new%integer2d, trim(name) // "%integer2d", func)
     call diff_arr_type_temporary_t_2dc(structure_ref%complex2d, structure_new%complex2d, trim(name) // "%complex2d", func)
     call diff_arr_type_temporary_t_3dr(structure_ref%float3d, structure_new%float3d, trim(name) // "%float3d", func)
     call diff_arr_type_temporary_t_3di(structure_ref%integer3d, structure_new%integer3d, trim(name) // "%integer3d", func)
     call diff_arr_type_temporary_t_3dc(structure_ref%complex3d, structure_new%complex3d, trim(name) // "%complex3d", func)
     call diff_arr_type_temporary_t_4dr(structure_ref%float4d, structure_new%float4d, trim(name) // "%float4d", func)
   end subroutine diff_type_temporary_t

   subroutine diff_arr_type_temporary_t(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t

   subroutine diff_type_temporary_t_0dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_cplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_0dc

   subroutine diff_arr_type_temporary_t_0dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_0dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_0dc

   subroutine diff_type_temporary_t_0di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_integer(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_0di

   subroutine diff_arr_type_temporary_t_0di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_0di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_0di

   subroutine diff_type_temporary_t_0dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_float(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_0dr

   subroutine diff_arr_type_temporary_t_0dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_0dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_0dr

   subroutine diff_type_temporary_t_0ds(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0ds), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecstring_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_0ds

   subroutine diff_arr_type_temporary_t_0ds(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_0ds), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_0ds(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_0ds

   subroutine diff_type_temporary_t_1dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_1dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_veccplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_1dc

   subroutine diff_arr_type_temporary_t_1dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_1dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_1dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_1dc

   subroutine diff_type_temporary_t_1di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_1di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecint_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_1di

   subroutine diff_arr_type_temporary_t_1di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_1di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_1di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_1di

   subroutine diff_type_temporary_t_1dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_1dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_vecflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_1dr

   subroutine diff_arr_type_temporary_t_1dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_1dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_1dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_1dr

   subroutine diff_type_temporary_t_2dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_2dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_matcplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_2dc

   subroutine diff_arr_type_temporary_t_2dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_2dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_2dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_2dc

   subroutine diff_type_temporary_t_2di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_2di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_matint_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_2di

   subroutine diff_arr_type_temporary_t_2di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_2di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_2di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_2di

   subroutine diff_type_temporary_t_2dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_2dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_matflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_2dr

   subroutine diff_arr_type_temporary_t_2dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_2dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_2dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_2dr

   subroutine diff_type_temporary_t_3dc(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_3dc), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array3dcplx_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_3dc

   subroutine diff_arr_type_temporary_t_3dc(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_3dc), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_3dc(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_3dc

   subroutine diff_type_temporary_t_3di(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_3di), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array3dint_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_3di

   subroutine diff_arr_type_temporary_t_3di(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_3di), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_3di(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_3di

   subroutine diff_type_temporary_t_3dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_3dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array3dflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_3dr

   subroutine diff_arr_type_temporary_t_3dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_3dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_3dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_3dr

   subroutine diff_type_temporary_t_4dr(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_4dr), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%identifier, structure_new%identifier, trim(name) // "%identifier", func)
     call diff_type_array4dflt_type(structure_ref%value, structure_new%value, trim(name) // "%value", func)
   end subroutine diff_type_temporary_t_4dr

   subroutine diff_arr_type_temporary_t_4dr(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_temporary_t_4dr), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_temporary_t_4dr(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_temporary_t_4dr

   subroutine diff_type_tf_desc_tfcoils(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tf_desc_tfcoils), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_float(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_circularcoil(structure_ref%circularcoil, structure_new%circularcoil, trim(name) // "%circularcoil", func)
     call diff_type_planecoil(structure_ref%planecoil, structure_new%planecoil, trim(name) // "%planecoil", func)
     call diff_type_tf_structure(structure_ref%inboard, structure_new%inboard, trim(name) // "%inboard", func)
     call diff_type_tf_structure(structure_ref%outboard, structure_new%outboard, trim(name) // "%outboard", func)
   end subroutine diff_type_tf_desc_tfcoils

   subroutine diff_arr_type_tf_desc_tfcoils(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tf_desc_tfcoils), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tf_desc_tfcoils(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tf_desc_tfcoils

   subroutine diff_type_tf_desc_tfcoils_board(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tf_desc_tfcoils_board), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_tf_structure(structure_ref%structure, structure_new%structure, trim(name) // "%structure", func)
   end subroutine diff_type_tf_desc_tfcoils_board

   subroutine diff_arr_type_tf_desc_tfcoils_board(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tf_desc_tfcoils_board), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tf_desc_tfcoils_board(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tf_desc_tfcoils_board

   subroutine diff_type_tf_structure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tf_structure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%jcable, structure_new%jcable, trim(name) // "%jcable", func)
     call diff_type_float(structure_ref%tisotf, structure_new%tisotf, trim(name) // "%tisotf", func)
     call diff_type_float(structure_ref%efcasing, structure_new%efcasing, trim(name) // "%efcasing", func)
     call diff_type_float(structure_ref%escasing, structure_new%escasing, trim(name) // "%escasing", func)
     call diff_type_float(structure_ref%sigjackettf, structure_new%sigjackettf, trim(name) // "%sigjackettf", func)
     call diff_type_float(structure_ref%sigvaulttf, structure_new%sigvaulttf, trim(name) // "%sigvaulttf", func)
     call diff_type_float(structure_ref%ktf, structure_new%ktf, trim(name) // "%ktf", func)
     call diff_type_float(structure_ref%ritf, structure_new%ritf, trim(name) // "%ritf", func)
     call diff_type_float(structure_ref%riitf, structure_new%riitf, trim(name) // "%riitf", func)
     call diff_type_float(structure_ref%retf, structure_new%retf, trim(name) // "%retf", func)
     call diff_type_float(structure_ref%he_fraction, structure_new%he_fraction, trim(name) // "%he_fraction", func)
     call diff_type_float(structure_ref%ss_fraction, structure_new%ss_fraction, trim(name) // "%ss_fraction", func)
     call diff_type_float(structure_ref%pow_dens_wp, structure_new%pow_dens_wp, trim(name) // "%pow_dens_wp", func)
   end subroutine diff_type_tf_structure

   subroutine diff_arr_type_tf_structure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tf_structure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tf_structure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tf_structure

   subroutine diff_type_theta_info(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_theta_info), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%angl_type, structure_new%angl_type, trim(name) // "%angl_type", func)
     call diff_type_matflt_type(structure_ref%th2th_pol, structure_new%th2th_pol, trim(name) // "%th2th_pol", func)
   end subroutine diff_type_theta_info

   subroutine diff_arr_type_theta_info(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_theta_info), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_theta_info(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_theta_info

   subroutine diff_type_topo_regions(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_topo_regions), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%ind_omnigen, structure_new%ind_omnigen, trim(name) // "%ind_omnigen", func)
     call diff_type_array6dflt_type(structure_ref%dim1, structure_new%dim1, trim(name) // "%dim1", func)
     call diff_type_array6dflt_type(structure_ref%dim2, structure_new%dim2, trim(name) // "%dim2", func)
     call diff_type_array6dflt_type(structure_ref%dim3, structure_new%dim3, trim(name) // "%dim3", func)
     call diff_type_array6dflt_type(structure_ref%dim4, structure_new%dim4, trim(name) // "%dim4", func)
     call diff_type_array6dflt_type(structure_ref%dim5, structure_new%dim5, trim(name) // "%dim5", func)
     call diff_type_array6dflt_type(structure_ref%dim6, structure_new%dim6, trim(name) // "%dim6", func)
     call diff_type_array6dflt_type(structure_ref%jacobian, structure_new%jacobian, trim(name) // "%jacobian", func)
     call diff_type_array6dflt_type(structure_ref%distfunc, structure_new%distfunc, trim(name) // "%distfunc", func)
   end subroutine diff_type_topo_regions

   subroutine diff_arr_type_topo_regions(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_topo_regions), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_topo_regions(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_topo_regions

   subroutine diff_type_toroid_field(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_toroid_field), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%b0, structure_new%b0, trim(name) // "%b0", func)
     call diff_type_float(structure_ref%b0prime, structure_new%b0prime, trim(name) // "%b0prime", func)
     call diff_type_float(structure_ref%r0, structure_new%r0, trim(name) // "%r0", func)
     call diff_type_float(structure_ref%time, structure_new%time, trim(name) // "%time", func)
   end subroutine diff_type_toroid_field

   subroutine diff_arr_type_toroid_field(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_toroid_field), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_toroid_field(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_toroid_field

   subroutine diff_type_trace(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_trace), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%time_orb, structure_new%time_orb, trim(name) // "%time_orb", func)
     call diff_type_vecint_type(structure_ref%ntorb, structure_new%ntorb, trim(name) // "%ntorb", func)
     call diff_type_matflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_matflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_matflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_matflt_type(structure_ref%theta_b, structure_new%theta_b, trim(name) // "%theta_b", func)
     call diff_type_matflt_type(structure_ref%v_parallel, structure_new%v_parallel, trim(name) // "%v_parallel", func)
     call diff_type_matflt_type(structure_ref%v_perp, structure_new%v_perp, trim(name) // "%v_perp", func)
   end subroutine diff_type_trace

   subroutine diff_arr_type_trace(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_trace), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_trace(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_trace

   subroutine diff_type_transcoefel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%diff_eff, structure_new%diff_eff, trim(name) // "%diff_eff", func)
     call diff_type_vecflt_type(structure_ref%vconv_eff, structure_new%vconv_eff, trim(name) // "%vconv_eff", func)
     call diff_type_vecflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_offdiagel(structure_ref%off_diagonal, structure_new%off_diagonal, trim(name) // "%off_diagonal", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
   end subroutine diff_type_transcoefel

   subroutine diff_arr_type_transcoefel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_transcoefel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_transcoefel

   subroutine diff_type_transcoefimp(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefimp), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%diff_eff, structure_new%diff_eff, trim(name) // "%diff_eff", func)
     call diff_type_matflt_type(structure_ref%vconv_eff, structure_new%vconv_eff, trim(name) // "%vconv_eff", func)
     call diff_type_matflt_type(structure_ref%exchange, structure_new%exchange, trim(name) // "%exchange", func)
     call diff_type_matflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
   end subroutine diff_type_transcoefimp

   subroutine diff_arr_type_transcoefimp(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefimp), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_transcoefimp(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_transcoefimp

   subroutine diff_type_transcoefion(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefion), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%diff_eff, structure_new%diff_eff, trim(name) // "%diff_eff", func)
     call diff_type_matflt_type(structure_ref%vconv_eff, structure_new%vconv_eff, trim(name) // "%vconv_eff", func)
     call diff_type_matflt_type(structure_ref%exchange, structure_new%exchange, trim(name) // "%exchange", func)
     call diff_type_matflt_type(structure_ref%qgi, structure_new%qgi, trim(name) // "%qgi", func)
     call diff_type_matflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_offdiagion(structure_ref%off_diagonal, structure_new%off_diagonal, trim(name) // "%off_diagonal", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
   end subroutine diff_type_transcoefion

   subroutine diff_arr_type_transcoefion(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefion), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_transcoefion(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_transcoefion

   subroutine diff_type_transcoefvtor(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefvtor), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%diff_eff, structure_new%diff_eff, trim(name) // "%diff_eff", func)
     call diff_type_matflt_type(structure_ref%vconv_eff, structure_new%vconv_eff, trim(name) // "%vconv_eff", func)
     call diff_type_matflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_offdiagion(structure_ref%off_diagonal, structure_new%off_diagonal, trim(name) // "%off_diagonal", func)
     call diff_type_integer(structure_ref%flag, structure_new%flag, trim(name) // "%flag", func)
   end subroutine diff_type_transcoefvtor

   subroutine diff_arr_type_transcoefvtor(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_transcoefvtor), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_transcoefvtor(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_transcoefvtor

   subroutine diff_type_trap_type(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_trap_type), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%trap_id, structure_new%trap_id, trim(name) // "%trap_id", func)
     call diff_type_integer(structure_ref%compound, structure_new%compound, trim(name) // "%compound", func)
     call diff_type_integer(structure_ref%gas_species, structure_new%gas_species, trim(name) // "%gas_species", func)
     call diff_type_float(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
     call diff_type_matflt_type(structure_ref%fill_factor, structure_new%fill_factor, trim(name) // "%fill_factor", func)
     call diff_type_matflt_type(structure_ref%density, structure_new%density, trim(name) // "%density", func)
   end subroutine diff_type_trap_type

   subroutine diff_arr_type_trap_type(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_trap_type), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_trap_type(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_trap_type

   subroutine diff_type_trianglexyz(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_trianglexyz), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_xyz0D(structure_ref%point1, structure_new%point1, trim(name) // "%point1", func)
     call diff_type_xyz0D(structure_ref%point2, structure_new%point2, trim(name) // "%point2", func)
     call diff_type_xyz0D(structure_ref%point3, structure_new%point3, trim(name) // "%point3", func)
   end subroutine diff_type_trianglexyz

   subroutine diff_arr_type_trianglexyz(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_trianglexyz), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_trianglexyz(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_trianglexyz

   subroutine diff_type_tsmeasure(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tsmeasure), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_exp1D(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_exp1D(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
   end subroutine diff_type_tsmeasure

   subroutine diff_arr_type_tsmeasure(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tsmeasure), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tsmeasure(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tsmeasure

   subroutine diff_type_tssetup(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tssetup), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rzphi1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_tssetup

   subroutine diff_arr_type_tssetup(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_tssetup), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_tssetup(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_tssetup

   subroutine diff_type_turbcomposition(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbcomposition), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%amn, structure_new%amn, trim(name) // "%amn", func)
     call diff_type_vecflt_type(structure_ref%zn, structure_new%zn, trim(name) // "%zn", func)
     call diff_type_vecflt_type(structure_ref%zion, structure_new%zion, trim(name) // "%zion", func)
     call diff_type_vecflt_type(structure_ref%ie_mass, structure_new%ie_mass, trim(name) // "%ie_mass", func)
   end subroutine diff_type_turbcomposition

   subroutine diff_arr_type_turbcomposition(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbcomposition), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbcomposition(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbcomposition

   subroutine diff_type_turbcoordsys(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbcoordsys), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%grid_type, structure_new%grid_type, trim(name) // "%grid_type", func)
     call diff_type_turbgrid(structure_ref%turbgrid, structure_new%turbgrid, trim(name) // "%turbgrid", func)
     call diff_type_matflt_type(structure_ref%jacobian, structure_new%jacobian, trim(name) // "%jacobian", func)
     call diff_type_matflt_type(structure_ref%g_11, structure_new%g_11, trim(name) // "%g_11", func)
     call diff_type_matflt_type(structure_ref%g_12, structure_new%g_12, trim(name) // "%g_12", func)
     call diff_type_matflt_type(structure_ref%g_13, structure_new%g_13, trim(name) // "%g_13", func)
     call diff_type_matflt_type(structure_ref%g_22, structure_new%g_22, trim(name) // "%g_22", func)
     call diff_type_matflt_type(structure_ref%g_23, structure_new%g_23, trim(name) // "%g_23", func)
     call diff_type_matflt_type(structure_ref%g_33, structure_new%g_33, trim(name) // "%g_33", func)
     call diff_type_rzphi3D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
   end subroutine diff_type_turbcoordsys

   subroutine diff_arr_type_turbcoordsys(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbcoordsys), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbcoordsys(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbcoordsys

   subroutine diff_type_turbenv1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbenv1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%vor, structure_new%vor, trim(name) // "%vor", func)
     call diff_type_vecflt_type(structure_ref%jpl, structure_new%jpl, trim(name) // "%jpl", func)
     call diff_type_vecflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_vecflt_type(structure_ref%he, structure_new%he, trim(name) // "%he", func)
     call diff_type_vecflt_type(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_matflt_type(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_matflt_type(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_matflt_type(structure_ref%ui, structure_new%ui, trim(name) // "%ui", func)
     call diff_type_vecflt_type(structure_ref%fe, structure_new%fe, trim(name) // "%fe", func)
     call diff_type_vecflt_type(structure_ref%qe, structure_new%qe, trim(name) // "%qe", func)
     call diff_type_matflt_type(structure_ref%qi, structure_new%qi, trim(name) // "%qi", func)
     call diff_type_vecflt_type(structure_ref%me, structure_new%me, trim(name) // "%me", func)
     call diff_type_matflt_type(structure_ref%mi, structure_new%mi, trim(name) // "%mi", func)
   end subroutine diff_type_turbenv1d

   subroutine diff_arr_type_turbenv1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbenv1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbenv1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbenv1d

   subroutine diff_type_turbgrid(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbgrid), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%dim1, structure_new%dim1, trim(name) // "%dim1", func)
     call diff_type_vecflt_type(structure_ref%dim2, structure_new%dim2, trim(name) // "%dim2", func)
     call diff_type_vecflt_type(structure_ref%dim3, structure_new%dim3, trim(name) // "%dim3", func)
     call diff_type_vecflt_type(structure_ref%dim_v1, structure_new%dim_v1, trim(name) // "%dim_v1", func)
     call diff_type_vecflt_type(structure_ref%dim_v2, structure_new%dim_v2, trim(name) // "%dim_v2", func)
   end subroutine diff_type_turbgrid

   subroutine diff_arr_type_turbgrid(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbgrid), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbgrid(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbgrid

   subroutine diff_type_turbspec1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbspec1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%kperp, structure_new%kperp, trim(name) // "%kperp", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%vor, structure_new%vor, trim(name) // "%vor", func)
     call diff_type_vecflt_type(structure_ref%b, structure_new%b, trim(name) // "%b", func)
     call diff_type_vecflt_type(structure_ref%jpl, structure_new%jpl, trim(name) // "%jpl", func)
     call diff_type_vecflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_vecflt_type(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_matflt_type(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_vecflt_type(structure_ref%fe, structure_new%fe, trim(name) // "%fe", func)
     call diff_type_vecflt_type(structure_ref%qe, structure_new%qe, trim(name) // "%qe", func)
     call diff_type_matflt_type(structure_ref%qi, structure_new%qi, trim(name) // "%qi", func)
     call diff_type_vecflt_type(structure_ref%me, structure_new%me, trim(name) // "%me", func)
     call diff_type_matflt_type(structure_ref%mi, structure_new%mi, trim(name) // "%mi", func)
   end subroutine diff_type_turbspec1d

   subroutine diff_arr_type_turbspec1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbspec1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbspec1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbspec1d

   subroutine diff_type_turbvar0d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar0d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%dtime_type, structure_new%dtime_type, trim(name) // "%dtime_type", func)
     call diff_type_vecflt_type(structure_ref%dtime, structure_new%dtime, trim(name) // "%dtime", func)
     call diff_type_vecflt_type(structure_ref%en_exb, structure_new%en_exb, trim(name) // "%en_exb", func)
     call diff_type_vecflt_type(structure_ref%en_mag, structure_new%en_mag, trim(name) // "%en_mag", func)
     call diff_type_vecflt_type(structure_ref%en_el_th, structure_new%en_el_th, trim(name) // "%en_el_th", func)
     call diff_type_matflt_type(structure_ref%en_ion_th, structure_new%en_ion_th, trim(name) // "%en_ion_th", func)
     call diff_type_vecflt_type(structure_ref%en_el_par, structure_new%en_el_par, trim(name) // "%en_el_par", func)
     call diff_type_matflt_type(structure_ref%en_ion_par, structure_new%en_ion_par, trim(name) // "%en_ion_par", func)
     call diff_type_vecflt_type(structure_ref%en_tot, structure_new%en_tot, trim(name) // "%en_tot", func)
     call diff_type_vecflt_type(structure_ref%fl_el, structure_new%fl_el, trim(name) // "%fl_el", func)
     call diff_type_vecflt_type(structure_ref%fl_heatel, structure_new%fl_heatel, trim(name) // "%fl_heatel", func)
     call diff_type_matflt_type(structure_ref%fl_ion, structure_new%fl_ion, trim(name) // "%fl_ion", func)
     call diff_type_matflt_type(structure_ref%fl_heation, structure_new%fl_heation, trim(name) // "%fl_heation", func)
     call diff_type_vecflt_type(structure_ref%fl_magel, structure_new%fl_magel, trim(name) // "%fl_magel", func)
     call diff_type_vecflt_type(structure_ref%fl_magheatel, structure_new%fl_magheatel, trim(name) // "%fl_magheatel", func)
     call diff_type_matflt_type(structure_ref%fl_magion, structure_new%fl_magion, trim(name) // "%fl_magion", func)
     call diff_type_matflt_type(structure_ref%flmagheation, structure_new%flmagheation, trim(name) // "%flmagheation", func)
   end subroutine diff_type_turbvar0d

   subroutine diff_arr_type_turbvar0d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar0d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbvar0d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbvar0d

   subroutine diff_type_turbvar1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%er, structure_new%er, trim(name) // "%er", func)
     call diff_type_vecflt_type(structure_ref%vor, structure_new%vor, trim(name) // "%vor", func)
     call diff_type_vecflt_type(structure_ref%apl, structure_new%apl, trim(name) // "%apl", func)
     call diff_type_vecflt_type(structure_ref%jpl, structure_new%jpl, trim(name) // "%jpl", func)
     call diff_type_vecflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_vecflt_type(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_matflt_type(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_matflt_type(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_matflt_type(structure_ref%ui, structure_new%ui, trim(name) // "%ui", func)
   end subroutine diff_type_turbvar1d

   subroutine diff_arr_type_turbvar1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbvar1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbvar1d

   subroutine diff_type_turbvar2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
     call diff_type_matflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_matflt_type(structure_ref%apl, structure_new%apl, trim(name) // "%apl", func)
     call diff_type_matflt_type(structure_ref%jpl, structure_new%jpl, trim(name) // "%jpl", func)
     call diff_type_matflt_type(structure_ref%vor, structure_new%vor, trim(name) // "%vor", func)
     call diff_type_matflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
     call diff_type_matflt_type(structure_ref%te, structure_new%te, trim(name) // "%te", func)
     call diff_type_array3dflt_type(structure_ref%ni, structure_new%ni, trim(name) // "%ni", func)
     call diff_type_array3dflt_type(structure_ref%ti, structure_new%ti, trim(name) // "%ti", func)
     call diff_type_array3dflt_type(structure_ref%ui, structure_new%ui, trim(name) // "%ui", func)
   end subroutine diff_type_turbvar2d

   subroutine diff_arr_type_turbvar2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbvar2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbvar2d

   subroutine diff_type_turbvar3d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar3d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array3dflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_array3dflt_type(structure_ref%vor, structure_new%vor, trim(name) // "%vor", func)
     call diff_type_array3dflt_type(structure_ref%jpl, structure_new%jpl, trim(name) // "%jpl", func)
     call diff_type_array3dflt_type(structure_ref%ne, structure_new%ne, trim(name) // "%ne", func)
   end subroutine diff_type_turbvar3d

   subroutine diff_arr_type_turbvar3d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar3d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbvar3d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbvar3d

   subroutine diff_type_turbvar4d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar4d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array4dflt_type(structure_ref%fe, structure_new%fe, trim(name) // "%fe", func)
     call diff_type_array5dflt_type(structure_ref%fi, structure_new%fi, trim(name) // "%fi", func)
   end subroutine diff_type_turbvar4d

   subroutine diff_arr_type_turbvar4d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar4d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbvar4d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbvar4d

   subroutine diff_type_turbvar5d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar5d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_array5dflt_type(structure_ref%fe, structure_new%fe, trim(name) // "%fe", func)
     call diff_type_array6dflt_type(structure_ref%fi, structure_new%fi, trim(name) // "%fi", func)
   end subroutine diff_type_turbvar5d

   subroutine diff_arr_type_turbvar5d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_turbvar5d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_turbvar5d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_turbvar5d

   subroutine diff_type_version_ind(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_version_ind), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%description, structure_new%description, trim(name) // "%description", func)
     call diff_type_vecstring_type(structure_ref%releasedate, structure_new%releasedate, trim(name) // "%releasedate", func)
     call diff_arr_type_data_release(structure_ref%data_release, structure_new%data_release, trim(name) // "%data_release", func)
   end subroutine diff_type_version_ind

   subroutine diff_arr_type_version_ind(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_version_ind), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_version_ind(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_version_ind

   subroutine diff_type_wall2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%wall_id, structure_new%wall_id, trim(name) // "%wall_id", func)
     call diff_type_wall_limiter(structure_ref%limiter, structure_new%limiter, trim(name) // "%limiter", func)
     call diff_type_wall_vessel(structure_ref%vessel, structure_new%vessel, trim(name) // "%vessel", func)
     call diff_arr_type_plasmaComplexType(structure_ref%plasma, structure_new%plasma, trim(name) // "%plasma", func)
     call diff_arr_type_wall_unitsComplexType(structure_ref%wall_state, structure_new%wall_state, trim(name) // "%wall_state", func)
   end subroutine diff_type_wall2d

   subroutine diff_arr_type_wall2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall2d

   subroutine diff_type_wall2d_mhd(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall2d_mhd), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_mhd_res_wall2d(structure_ref%res_wall, structure_new%res_wall, trim(name) // "%res_wall", func)
     call diff_type_mhd_ideal_wall2d(structure_ref%ideal_wall, structure_new%ideal_wall, trim(name) // "%ideal_wall", func)
   end subroutine diff_type_wall2d_mhd

   subroutine diff_arr_type_wall2d_mhd(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall2d_mhd), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall2d_mhd(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall2d_mhd

   subroutine diff_type_wall3d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall3d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%wall_id, structure_new%wall_id, trim(name) // "%wall_id", func)
     call diff_type_complexgrid(structure_ref%grid, structure_new%grid, trim(name) // "%grid", func)
     call diff_arr_type_plasmaComplexType(structure_ref%plasma, structure_new%plasma, trim(name) // "%plasma", func)
     call diff_arr_type_wall_unitsComplexType(structure_ref%wall_state, structure_new%wall_state, trim(name) // "%wall_state", func)
     call diff_type_integer(structure_ref%basis_index, structure_new%basis_index, trim(name) // "%basis_index", func)
   end subroutine diff_type_wall3d

   subroutine diff_arr_type_wall3d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall3d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall3d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall3d

   subroutine diff_type_wall_blocks(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_blocks), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_wall_blocks_unit(structure_ref%blocks_unit, structure_new%blocks_unit, trim(name) // "%blocks_unit", func)
   end subroutine diff_type_wall_blocks

   subroutine diff_arr_type_wall_blocks(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_blocks), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_blocks(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_blocks

   subroutine diff_type_wall_blocks_unit(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_blocks_unit), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_float(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
     call diff_type_float(structure_ref%permeability, structure_new%permeability, trim(name) // "%permeability", func)
     call diff_type_float(structure_ref%j_phi, structure_new%j_phi, trim(name) // "%j_phi", func)
     call diff_type_float(structure_ref%resistance, structure_new%resistance, trim(name) // "%resistance", func)
   end subroutine diff_type_wall_blocks_unit

   subroutine diff_arr_type_wall_blocks_unit(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_blocks_unit), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_blocks_unit(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_blocks_unit

   subroutine diff_type_wall_limiter(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_limiter), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%limiter_id, structure_new%limiter_id, trim(name) // "%limiter_id", func)
     call diff_arr_type_limiter_unit(structure_ref%limiter_unit, structure_new%limiter_unit, trim(name) // "%limiter_unit", func)
   end subroutine diff_type_wall_limiter

   subroutine diff_arr_type_wall_limiter(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_limiter), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_limiter(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_limiter

   subroutine diff_type_wall_types(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_types), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%label, structure_new%label, trim(name) // "%label", func)
     call diff_arr_type_wall_types_layers(structure_ref%layers, structure_new%layers, trim(name) // "%layers", func)
   end subroutine diff_type_wall_types

   subroutine diff_arr_type_wall_types(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_types), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_types(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_types

   subroutine diff_type_wall_types_layers(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_types_layers), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%thickness, structure_new%thickness, trim(name) // "%thickness", func)
     call diff_type_vecflt_type(structure_ref%chem_comp, structure_new%chem_comp, trim(name) // "%chem_comp", func)
   end subroutine diff_type_wall_types_layers

   subroutine diff_arr_type_wall_types_layers(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_types_layers), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_types_layers(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_types_layers

   subroutine diff_type_wall_unitsComplexType(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_unitsComplexType), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%wall_type, structure_new%wall_type, trim(name) // "%wall_type", func)
     call diff_type_integer(structure_ref%n_depo_layer, structure_new%n_depo_layer, trim(name) // "%n_depo_layer", func)
     call diff_arr_type_wall_unitsComplexType_layers(structure_ref%layers, structure_new%layers, trim(name) // "%layers", func)
     call diff_type_complexgrid_scalar(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
     call diff_type_complexgrid_scalar(structure_ref%permeability, structure_new%permeability, trim(name) // "%permeability", func)
     call diff_type_complexgrid_vector(structure_ref%j, structure_new%j, trim(name) // "%j", func)
   end subroutine diff_type_wall_unitsComplexType

   subroutine diff_arr_type_wall_unitsComplexType(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_unitsComplexType), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_unitsComplexType(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_unitsComplexType

   subroutine diff_type_wall_unitsComplexType_layers(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_unitsComplexType_layers), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecint_type(structure_ref%elements, structure_new%elements, trim(name) // "%elements", func)
     call diff_type_vecint_type(structure_ref%gases, structure_new%gases, trim(name) // "%gases", func)
     call diff_type_vecint_type(structure_ref%compounds, structure_new%compounds, trim(name) // "%compounds", func)
     call diff_type_matflt_type(structure_ref%density, structure_new%density, trim(name) // "%density", func)
     call diff_type_matflt_type(structure_ref%dx, structure_new%dx, trim(name) // "%dx", func)
     call diff_type_vecflt_type(structure_ref%thickness, structure_new%thickness, trim(name) // "%thickness", func)
     call diff_type_array3dflt_type(structure_ref%roughness, structure_new%roughness, trim(name) // "%roughness", func)
     call diff_type_array3dflt_type(structure_ref%porosity, structure_new%porosity, trim(name) // "%porosity", func)
     call diff_type_matflt_type(structure_ref%dpa, structure_new%dpa, trim(name) // "%dpa", func)
     call diff_type_matflt_type(structure_ref%temperature, structure_new%temperature, trim(name) // "%temperature", func)
     call diff_type_array3dflt_type(structure_ref%element_frac, structure_new%element_frac, trim(name) // "%element_frac", func)
     call diff_type_array3dflt_type(structure_ref%chem_comp, structure_new%chem_comp, trim(name) // "%chem_comp", func)
     call diff_type_array4dflt_type(structure_ref%bulk_D, structure_new%bulk_D, trim(name) // "%bulk_D", func)
     call diff_type_array4dflt_type(structure_ref%surface_D, structure_new%surface_D, trim(name) // "%surface_D", func)
     call diff_type_array4dflt_type(structure_ref%bulk_solute, structure_new%bulk_solute, trim(name) // "%bulk_solute", func)
     call diff_type_array4dflt_type(structure_ref%surf_solute, structure_new%surf_solute, trim(name) // "%surf_solute", func)
     call diff_type_array3dflt_type(structure_ref%pore_content, structure_new%pore_content, trim(name) // "%pore_content", func)
     call diff_arr_type_trap_type(structure_ref%trap_type, structure_new%trap_type, trim(name) // "%trap_type", func)
   end subroutine diff_type_wall_unitsComplexType_layers

   subroutine diff_arr_type_wall_unitsComplexType_layers(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_unitsComplexType_layers), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_unitsComplexType_layers(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_unitsComplexType_layers

   subroutine diff_type_wall_vessel(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_vessel), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_identifier(structure_ref%vessel_id, structure_new%vessel_id, trim(name) // "%vessel_id", func)
     call diff_arr_type_wall_vessel_unit(structure_ref%vessel_unit, structure_new%vessel_unit, trim(name) // "%vessel_unit", func)
   end subroutine diff_type_wall_vessel

   subroutine diff_arr_type_wall_vessel(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_vessel), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_vessel(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_vessel

   subroutine diff_type_wall_vessel_annular(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_vessel_annular), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_rz1D(structure_ref%inside, structure_new%inside, trim(name) // "%inside", func)
     call diff_type_rz1D(structure_ref%outside, structure_new%outside, trim(name) // "%outside", func)
     call diff_type_float(structure_ref%eta, structure_new%eta, trim(name) // "%eta", func)
     call diff_type_float(structure_ref%permeability, structure_new%permeability, trim(name) // "%permeability", func)
   end subroutine diff_type_wall_vessel_annular

   subroutine diff_arr_type_wall_vessel_annular(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_vessel_annular), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_vessel_annular(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_vessel_annular

   subroutine diff_type_wall_vessel_unit(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_vessel_unit), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_wall_vessel_annular(structure_ref%annular, structure_new%annular, trim(name) // "%annular", func)
     call diff_type_wall_blocks(structure_ref%blocks, structure_new%blocks, trim(name) // "%blocks", func)
     call diff_type_wall_wall2d_vessel_radial_build(structure_ref%radial_build, structure_new%radial_build, trim(name) // "%radial_build", func)
   end subroutine diff_type_wall_vessel_unit

   subroutine diff_arr_type_wall_vessel_unit(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_vessel_unit), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_vessel_unit(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_vessel_unit

   subroutine diff_type_wall_wall0d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_wall0d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%pumping_speed, structure_new%pumping_speed, trim(name) // "%pumping_speed", func)
     call diff_type_vecflt_type(structure_ref%gas_puff, structure_new%gas_puff, trim(name) // "%gas_puff", func)
     call diff_type_vecflt_type(structure_ref%wall_inventory, structure_new%wall_inventory, trim(name) // "%wall_inventory", func)
     call diff_type_vecflt_type(structure_ref%recycling_coefficient, structure_new%recycling_coefficient, trim(name) // "%recycling_coefficient", func)
     call diff_type_float(structure_ref%wall_temperature, structure_new%wall_temperature, trim(name) // "%wall_temperature", func)
     call diff_type_float(structure_ref%power_from_plasma, structure_new%power_from_plasma, trim(name) // "%power_from_plasma", func)
     call diff_type_float(structure_ref%power_to_cooling, structure_new%power_to_cooling, trim(name) // "%power_to_cooling", func)
     call diff_type_wall_wall0d_plasma(structure_ref%plasma, structure_new%plasma, trim(name) // "%plasma", func)
   end subroutine diff_type_wall_wall0d

   subroutine diff_arr_type_wall_wall0d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_wall0d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_wall0d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_wall0d

   subroutine diff_type_wall_wall0d_plasma(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_wall0d_plasma), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matint_type(structure_ref%species_index, structure_new%species_index, trim(name) // "%species_index", func)
     call diff_type_vecflt_type(structure_ref%flux, structure_new%flux, trim(name) // "%flux", func)
     call diff_type_vecflt_type(structure_ref%energy, structure_new%energy, trim(name) // "%energy", func)
   end subroutine diff_type_wall_wall0d_plasma

   subroutine diff_arr_type_wall_wall0d_plasma(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_wall0d_plasma), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_wall0d_plasma(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_wall0d_plasma

   subroutine diff_type_wall_wall2d_vessel_radial_build(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_wall2d_vessel_radial_build), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%r1_inb, structure_new%r1_inb, trim(name) // "%r1_inb", func)
     call diff_type_float(structure_ref%r2_inb, structure_new%r2_inb, trim(name) // "%r2_inb", func)
     call diff_type_float(structure_ref%r1_outb, structure_new%r1_outb, trim(name) // "%r1_outb", func)
     call diff_type_float(structure_ref%r2_outb, structure_new%r2_outb, trim(name) // "%r2_outb", func)
     call diff_type_float(structure_ref%raddim, structure_new%raddim, trim(name) // "%raddim", func)
     call diff_type_float(structure_ref%nmat, structure_new%nmat, trim(name) // "%nmat", func)
     call diff_type_vecflt_type(structure_ref%composition, structure_new%composition, trim(name) // "%composition", func)
     call diff_type_float(structure_ref%pow_dens_inb, structure_new%pow_dens_inb, trim(name) // "%pow_dens_inb", func)
     call diff_type_float(structure_ref%pow_dens_outb, structure_new%pow_dens_outb, trim(name) // "%pow_dens_outb", func)
     call diff_type_float(structure_ref%fn_flux_inb, structure_new%fn_flux_inb, trim(name) // "%fn_flux_inb", func)
     call diff_type_float(structure_ref%fn_flux_outb, structure_new%fn_flux_outb, trim(name) // "%fn_flux_outb", func)
   end subroutine diff_type_wall_wall2d_vessel_radial_build

   subroutine diff_arr_type_wall_wall2d_vessel_radial_build(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_wall_wall2d_vessel_radial_build), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_wall_wall2d_vessel_radial_build(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_wall_wall2d_vessel_radial_build

   subroutine diff_type_waveguides(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waveguides), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%nwm_theta, structure_new%nwm_theta, trim(name) // "%nwm_theta", func)
     call diff_type_integer(structure_ref%nwm_phi, structure_new%nwm_phi, trim(name) // "%nwm_phi", func)
     call diff_type_vecint_type(structure_ref%mask, structure_new%mask, trim(name) // "%mask", func)
     call diff_type_integer(structure_ref%npwbm_phi, structure_new%npwbm_phi, trim(name) // "%npwbm_phi", func)
     call diff_type_integer(structure_ref%npwe_phi, structure_new%npwe_phi, trim(name) // "%npwe_phi", func)
     call diff_type_float(structure_ref%sw_theta, structure_new%sw_theta, trim(name) // "%sw_theta", func)
     call diff_type_float(structure_ref%hw_theta, structure_new%hw_theta, trim(name) // "%hw_theta", func)
     call diff_type_float(structure_ref%bwa, structure_new%bwa, trim(name) // "%bwa", func)
     call diff_type_float(structure_ref%biwp, structure_new%biwp, trim(name) // "%biwp", func)
     call diff_type_float(structure_ref%bewp, structure_new%bewp, trim(name) // "%bewp", func)
     call diff_type_vecflt_type(structure_ref%e_phi, structure_new%e_phi, trim(name) // "%e_phi", func)
     call diff_type_vecflt_type(structure_ref%scl, structure_new%scl, trim(name) // "%scl", func)
   end subroutine diff_type_waveguides

   subroutine diff_arr_type_waveguides(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waveguides), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waveguides(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waveguides

   subroutine diff_type_waves_global_param(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_global_param), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%name, structure_new%name, trim(name) // "%name", func)
     call diff_type_vecstring_type(structure_ref%type, structure_new%type, trim(name) // "%type", func)
     call diff_type_vecint_type(structure_ref%f_assumption, structure_new%f_assumption, trim(name) // "%f_assumption", func)
     call diff_type_integer(structure_ref%code_type, structure_new%code_type, trim(name) // "%code_type", func)
     call diff_type_float(structure_ref%frequency, structure_new%frequency, trim(name) // "%frequency", func)
     call diff_type_vecint_type(structure_ref%ntor, structure_new%ntor, trim(name) // "%ntor", func)
     call diff_type_float(structure_ref%power_tot, structure_new%power_tot, trim(name) // "%power_tot", func)
     call diff_type_vecflt_type(structure_ref%p_frac_ntor, structure_new%p_frac_ntor, trim(name) // "%p_frac_ntor", func)
     call diff_type_float(structure_ref%pow_e, structure_new%pow_e, trim(name) // "%pow_e", func)
     call diff_type_vecflt_type(structure_ref%pow_i, structure_new%pow_i, trim(name) // "%pow_i", func)
     call diff_type_matflt_type(structure_ref%pow_z, structure_new%pow_z, trim(name) // "%pow_z", func)
     call diff_type_float(structure_ref%pow_fe, structure_new%pow_fe, trim(name) // "%pow_fe", func)
     call diff_type_vecflt_type(structure_ref%pow_fi, structure_new%pow_fi, trim(name) // "%pow_fi", func)
     call diff_type_matflt_type(structure_ref%pow_fz, structure_new%pow_fz, trim(name) // "%pow_fz", func)
     call diff_type_vecflt_type(structure_ref%pow_ntor_e, structure_new%pow_ntor_e, trim(name) // "%pow_ntor_e", func)
     call diff_type_matflt_type(structure_ref%pow_ntor_i, structure_new%pow_ntor_i, trim(name) // "%pow_ntor_i", func)
     call diff_type_array3dflt_type(structure_ref%pow_ntor_z, structure_new%pow_ntor_z, trim(name) // "%pow_ntor_z", func)
     call diff_type_vecflt_type(structure_ref%pow_ntor_fe, structure_new%pow_ntor_fe, trim(name) // "%pow_ntor_fe", func)
     call diff_type_matflt_type(structure_ref%pow_ntor_fi, structure_new%pow_ntor_fi, trim(name) // "%pow_ntor_fi", func)
     call diff_type_array3dflt_type(structure_ref%pow_ntor_fz, structure_new%pow_ntor_fz, trim(name) // "%pow_ntor_fz", func)
     call diff_type_float(structure_ref%cur_tor, structure_new%cur_tor, trim(name) // "%cur_tor", func)
     call diff_type_vecflt_type(structure_ref%cur_tor_ntor, structure_new%cur_tor_ntor, trim(name) // "%cur_tor_ntor", func)
     call diff_type_rz0D(structure_ref%mag_axis, structure_new%mag_axis, trim(name) // "%mag_axis", func)
     call diff_type_b0r0(structure_ref%toroid_field, structure_new%toroid_field, trim(name) // "%toroid_field", func)
   end subroutine diff_type_waves_global_param

   subroutine diff_arr_type_waves_global_param(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_global_param), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_global_param(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_global_param

   subroutine diff_type_waves_grid_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_grid_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_vecflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%volume, structure_new%volume, trim(name) // "%volume", func)
     call diff_type_vecflt_type(structure_ref%area, structure_new%area, trim(name) // "%area", func)
   end subroutine diff_type_waves_grid_1d

   subroutine diff_arr_type_waves_grid_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_grid_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_grid_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_grid_1d

   subroutine diff_type_waves_grid_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_grid_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_integer(structure_ref%grid_type, structure_new%grid_type, trim(name) // "%grid_type", func)
     call diff_type_matflt_type(structure_ref%rho_tor_norm, structure_new%rho_tor_norm, trim(name) // "%rho_tor_norm", func)
     call diff_type_matflt_type(structure_ref%rho_tor, structure_new%rho_tor, trim(name) // "%rho_tor", func)
     call diff_type_matflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_matflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
     call diff_type_matflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_matflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_theta_info(structure_ref%theta_info, structure_new%theta_info, trim(name) // "%theta_info", func)
   end subroutine diff_type_waves_grid_2d

   subroutine diff_arr_type_waves_grid_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_grid_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_grid_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_grid_2d

   subroutine diff_type_waves_profiles_1d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_profiles_1d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%powd_tot, structure_new%powd_tot, trim(name) // "%powd_tot", func)
     call diff_type_vecflt_type(structure_ref%powd_e, structure_new%powd_e, trim(name) // "%powd_e", func)
     call diff_type_matflt_type(structure_ref%powd_i, structure_new%powd_i, trim(name) // "%powd_i", func)
     call diff_type_array3dflt_type(structure_ref%powd_z, structure_new%powd_z, trim(name) // "%powd_z", func)
     call diff_type_vecflt_type(structure_ref%powd_fe, structure_new%powd_fe, trim(name) // "%powd_fe", func)
     call diff_type_matflt_type(structure_ref%powd_fi, structure_new%powd_fi, trim(name) // "%powd_fi", func)
     call diff_type_array3dflt_type(structure_ref%powd_fz, structure_new%powd_fz, trim(name) // "%powd_fz", func)
     call diff_type_matflt_type(structure_ref%powd_ntor, structure_new%powd_ntor, trim(name) // "%powd_ntor", func)
     call diff_type_matflt_type(structure_ref%powd_ntor_e, structure_new%powd_ntor_e, trim(name) // "%powd_ntor_e", func)
     call diff_type_array3dflt_type(structure_ref%powd_ntor_i, structure_new%powd_ntor_i, trim(name) // "%powd_ntor_i", func)
     call diff_type_array4dflt_type(structure_ref%powd_ntor_z, structure_new%powd_ntor_z, trim(name) // "%powd_ntor_z", func)
     call diff_type_matflt_type(structure_ref%powd_ntor_fe, structure_new%powd_ntor_fe, trim(name) // "%powd_ntor_fe", func)
     call diff_type_array3dflt_type(structure_ref%powd_ntor_fi, structure_new%powd_ntor_fi, trim(name) // "%powd_ntor_fi", func)
     call diff_type_array4dflt_type(structure_ref%powd_ntor_fz, structure_new%powd_ntor_fz, trim(name) // "%powd_ntor_fz", func)
     call diff_type_vecflt_type(structure_ref%curd_tor, structure_new%curd_tor, trim(name) // "%curd_tor", func)
     call diff_type_matflt_type(structure_ref%curd_torntor, structure_new%curd_torntor, trim(name) // "%curd_torntor", func)
     call diff_type_vecflt_type(structure_ref%pow_tot, structure_new%pow_tot, trim(name) // "%pow_tot", func)
     call diff_type_vecflt_type(structure_ref%pow_e, structure_new%pow_e, trim(name) // "%pow_e", func)
     call diff_type_matflt_type(structure_ref%pow_i, structure_new%pow_i, trim(name) // "%pow_i", func)
     call diff_type_array3dflt_type(structure_ref%pow_z, structure_new%pow_z, trim(name) // "%pow_z", func)
     call diff_type_vecflt_type(structure_ref%pow_fe, structure_new%pow_fe, trim(name) // "%pow_fe", func)
     call diff_type_matflt_type(structure_ref%pow_fi, structure_new%pow_fi, trim(name) // "%pow_fi", func)
     call diff_type_array3dflt_type(structure_ref%pow_fz, structure_new%pow_fz, trim(name) // "%pow_fz", func)
     call diff_type_matflt_type(structure_ref%pow_ntor, structure_new%pow_ntor, trim(name) // "%pow_ntor", func)
     call diff_type_matflt_type(structure_ref%pow_ntor_e, structure_new%pow_ntor_e, trim(name) // "%pow_ntor_e", func)
     call diff_type_array3dflt_type(structure_ref%pow_ntor_i, structure_new%pow_ntor_i, trim(name) // "%pow_ntor_i", func)
     call diff_type_array3dflt_type(structure_ref%pow_ntor_z, structure_new%pow_ntor_z, trim(name) // "%pow_ntor_z", func)
     call diff_type_matflt_type(structure_ref%pow_ntor_fe, structure_new%pow_ntor_fe, trim(name) // "%pow_ntor_fe", func)
     call diff_type_array3dflt_type(structure_ref%pow_ntor_fi, structure_new%pow_ntor_fi, trim(name) // "%pow_ntor_fi", func)
     call diff_type_array3dflt_type(structure_ref%pow_ntor_fz, structure_new%pow_ntor_fz, trim(name) // "%pow_ntor_fz", func)
     call diff_type_vecflt_type(structure_ref%curd_par, structure_new%curd_par, trim(name) // "%curd_par", func)
     call diff_type_matflt_type(structure_ref%curd_parntor, structure_new%curd_parntor, trim(name) // "%curd_parntor", func)
     call diff_type_vecflt_type(structure_ref%cur_tor, structure_new%cur_tor, trim(name) // "%cur_tor", func)
     call diff_type_matflt_type(structure_ref%cur_tor_ntor, structure_new%cur_tor_ntor, trim(name) // "%cur_tor_ntor", func)
     call diff_type_matflt_type(structure_ref%e_plus_ave, structure_new%e_plus_ave, trim(name) // "%e_plus_ave", func)
     call diff_type_matflt_type(structure_ref%e_minus_ave, structure_new%e_minus_ave, trim(name) // "%e_minus_ave", func)
     call diff_type_matflt_type(structure_ref%e_para_ave, structure_new%e_para_ave, trim(name) // "%e_para_ave", func)
     call diff_type_matflt_type(structure_ref%k_perp_ave, structure_new%k_perp_ave, trim(name) // "%k_perp_ave", func)
   end subroutine diff_type_waves_profiles_1d

   subroutine diff_arr_type_waves_profiles_1d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_profiles_1d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_profiles_1d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_profiles_1d

   subroutine diff_type_waves_profiles_2d(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_profiles_2d), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_matflt_type(structure_ref%powd_tot, structure_new%powd_tot, trim(name) // "%powd_tot", func)
     call diff_type_matflt_type(structure_ref%powd_e, structure_new%powd_e, trim(name) // "%powd_e", func)
     call diff_type_array3dflt_type(structure_ref%powd_i, structure_new%powd_i, trim(name) // "%powd_i", func)
     call diff_type_array4dflt_type(structure_ref%powd_z, structure_new%powd_z, trim(name) // "%powd_z", func)
     call diff_type_matflt_type(structure_ref%powd_fe, structure_new%powd_fe, trim(name) // "%powd_fe", func)
     call diff_type_array3dflt_type(structure_ref%powd_fi, structure_new%powd_fi, trim(name) // "%powd_fi", func)
     call diff_type_array4dflt_type(structure_ref%powd_fz, structure_new%powd_fz, trim(name) // "%powd_fz", func)
     call diff_type_array3dflt_type(structure_ref%powd_ntor, structure_new%powd_ntor, trim(name) // "%powd_ntor", func)
     call diff_type_array3dflt_type(structure_ref%powd_ntor_e, structure_new%powd_ntor_e, trim(name) // "%powd_ntor_e", func)
     call diff_type_array4dflt_type(structure_ref%powd_ntor_i, structure_new%powd_ntor_i, trim(name) // "%powd_ntor_i", func)
     call diff_type_array5dflt_type(structure_ref%powd_ntor_z, structure_new%powd_ntor_z, trim(name) // "%powd_ntor_z", func)
     call diff_type_array3dflt_type(structure_ref%powd_ntor_fe, structure_new%powd_ntor_fe, trim(name) // "%powd_ntor_fe", func)
     call diff_type_array4dflt_type(structure_ref%powd_ntor_fi, structure_new%powd_ntor_fi, trim(name) // "%powd_ntor_fi", func)
     call diff_type_array5dflt_type(structure_ref%powd_ntor_fz, structure_new%powd_ntor_fz, trim(name) // "%powd_ntor_fz", func)
     call diff_type_array5dflt_type(structure_ref%powd_iharm, structure_new%powd_iharm, trim(name) // "%powd_iharm", func)
   end subroutine diff_type_waves_profiles_2d

   subroutine diff_arr_type_waves_profiles_2d(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_profiles_2d), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_profiles_2d(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_profiles_2d

   subroutine diff_type_waves_rtposition(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_rtposition), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%r, structure_new%r, trim(name) // "%r", func)
     call diff_type_vecflt_type(structure_ref%z, structure_new%z, trim(name) // "%z", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
     call diff_type_vecflt_type(structure_ref%psi, structure_new%psi, trim(name) // "%psi", func)
     call diff_type_vecflt_type(structure_ref%theta, structure_new%theta, trim(name) // "%theta", func)
   end subroutine diff_type_waves_rtposition

   subroutine diff_arr_type_waves_rtposition(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_rtposition), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_rtposition(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_rtposition

   subroutine diff_type_waves_rtwavevector(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_rtwavevector), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%kr, structure_new%kr, trim(name) // "%kr", func)
     call diff_type_vecflt_type(structure_ref%kz, structure_new%kz, trim(name) // "%kz", func)
     call diff_type_vecflt_type(structure_ref%kphi, structure_new%kphi, trim(name) // "%kphi", func)
     call diff_type_vecflt_type(structure_ref%npar, structure_new%npar, trim(name) // "%npar", func)
     call diff_type_vecflt_type(structure_ref%nperp, structure_new%nperp, trim(name) // "%nperp", func)
     call diff_type_vecflt_type(structure_ref%ntor, structure_new%ntor, trim(name) // "%ntor", func)
     call diff_type_integer(structure_ref%var_ntor, structure_new%var_ntor, trim(name) // "%var_ntor", func)
   end subroutine diff_type_waves_rtwavevector

   subroutine diff_arr_type_waves_rtwavevector(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_waves_rtwavevector), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_waves_rtwavevector(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_waves_rtwavevector

   subroutine diff_type_weighted_markers(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_weighted_markers), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_arr_type_identifier(structure_ref%variable_ids, structure_new%variable_ids, trim(name) // "%variable_ids", func)
     call diff_type_matflt_type(structure_ref%coord, structure_new%coord, trim(name) // "%coord", func)
     call diff_type_vecflt_type(structure_ref%weight, structure_new%weight, trim(name) // "%weight", func)
   end subroutine diff_type_weighted_markers

   subroutine diff_arr_type_weighted_markers(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_weighted_markers), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_weighted_markers(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_weighted_markers

   subroutine diff_type_whatref(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_whatref), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecstring_type(structure_ref%user, structure_new%user, trim(name) // "%user", func)
     call diff_type_vecstring_type(structure_ref%machine, structure_new%machine, trim(name) // "%machine", func)
     call diff_type_integer(structure_ref%shot, structure_new%shot, trim(name) // "%shot", func)
     call diff_type_integer(structure_ref%run, structure_new%run, trim(name) // "%run", func)
     call diff_type_integer(structure_ref%occurrence, structure_new%occurrence, trim(name) // "%occurrence", func)
   end subroutine diff_type_whatref

   subroutine diff_arr_type_whatref(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_whatref), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_whatref(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_whatref

   subroutine diff_type_width(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_width), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_vecflt_type(structure_ref%dtheta, structure_new%dtheta, trim(name) // "%dtheta", func)
     call diff_type_vecflt_type(structure_ref%phi, structure_new%phi, trim(name) // "%phi", func)
   end subroutine diff_type_width

   subroutine diff_arr_type_width(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_width), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_width(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_width

   subroutine diff_type_xpts(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_xpts), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_rz1D(structure_ref%position, structure_new%position, trim(name) // "%position", func)
     call diff_type_vecstring_type(structure_ref%source, structure_new%source, trim(name) // "%source", func)
     call diff_type_vecflt_type(structure_ref%weight, structure_new%weight, trim(name) // "%weight", func)
     call diff_type_vecflt_type(structure_ref%sigma, structure_new%sigma, trim(name) // "%sigma", func)
     call diff_type_vecflt_type(structure_ref%calculated, structure_new%calculated, trim(name) // "%calculated", func)
     call diff_type_vecflt_type(structure_ref%chi2, structure_new%chi2, trim(name) // "%chi2", func)
   end subroutine diff_type_xpts

   subroutine diff_arr_type_xpts(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_xpts), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_xpts(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_xpts

   subroutine diff_type_xyz0D(structure_ref, structure_new, name, func)

     use euitm_schemas
     implicit none

     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_xyz0D), intent(in) :: structure_ref, structure_new
     character(len = *), intent(in) :: name

     call diff_type_float(structure_ref%x, structure_new%x, trim(name) // "%x", func)
     call diff_type_float(structure_ref%y, structure_new%y, trim(name) // "%y", func)
     call diff_type_float(structure_ref%z, structure_new%z, trim(name) // "%z", func)
   end subroutine diff_type_xyz0D

   subroutine diff_arr_type_xyz0D(structure_ref, structure_new, name, func)
 
     use euitm_schemas
     implicit none
 
     interface
       function func(diff_counter, error_level, &
        reference_field_float, new_field_float, &
        reference_field_array3dflt_type, new_field_array3dflt_type, &
        reference_field_array4dflt_type, new_field_array4dflt_type, &
        reference_field_array5dflt_type, new_field_array5dflt_type, &
        reference_field_array6dflt_type, new_field_array6dflt_type, &
        reference_field_array7dflt_type, new_field_array7dflt_type, &
        reference_field_matflt_type, new_field_matflt_type, &
        reference_field_vecflt_type, new_field_vecflt_type) &
        result (f_string)
        use euitm_schemas
         real(euitm_r8), intent(in), optional :: reference_field_float, new_field_float
         real(euitm_r8), dimension(:, :, :), pointer, optional :: reference_field_array3dflt_type, new_field_array3dflt_type
         real(euitm_r8), dimension(:, :, :, :), pointer, optional :: reference_field_array4dflt_type, new_field_array4dflt_type
         real(euitm_r8), dimension(:, :, :, :, :), pointer, optional :: reference_field_array5dflt_type, new_field_array5dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :), pointer, optional :: reference_field_array6dflt_type, new_field_array6dflt_type
         real(euitm_r8), dimension(:, :, :, :, :, :, :), pointer, optional :: reference_field_array7dflt_type, new_field_array7dflt_type
         real(euitm_r8), dimension(:, :), pointer, optional :: reference_field_matflt_type, new_field_matflt_type
         real(euitm_r8), dimension(:), pointer, optional :: reference_field_vecflt_type, new_field_vecflt_type
         integer :: diff_counter
         real(euitm_r8) :: error_level
         character(len = 132) :: f_string
       end function func
     end interface

     type (type_xyz0D), pointer :: structure_ref(:), structure_new(:)
     character(len = *), intent(in) :: name
     integer :: i
 
     if (associated(structure_ref)) then
       if (associated(structure_new)) then
         if (size(structure_ref) == size(structure_new)) then
           do i = 1, size(structure_ref)
             call diff_type_xyz0D(structure_ref(i),structure_new(i), name, func)
           end do
         else
           diff_counter = diff_counter + 1
           if (verbose > 1) then
             write(iu6, *) trim(adjustl(name))
             write(iu6, *) 'has different size in reference and new CPO'
           end if
         end if
       else
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in new CPO'
         end if
       end if
     else
       if (associated(structure_new)) then
         diff_counter = diff_counter + 1
         if (verbose > 1) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in reference CPO'
         end if
       else
         if (verbose > 2) then
           write(iu6, *) trim(adjustl(name))
           write(iu6, *) 'is not defined in either CPO'
         end if
       end if
     end if

   end subroutine diff_arr_type_xyz0D


 end module diff_structures
