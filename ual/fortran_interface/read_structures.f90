 module read_structures
 !------------------------------------------------------------------
 ! module for granular reading of itm structures
 ! from file
 !------------------------------------------------------------------

   use euitm_schemas

   interface read_cpo
      module procedure read_type_integer
      module procedure read_type_float
      module procedure read_type_complex
      module procedure read_type_array3dcplx_type
      module procedure read_type_array3dflt_type
      module procedure read_type_array3dint_type
      module procedure read_type_array4dflt_type
      module procedure read_type_array5dflt_type
      module procedure read_type_array6dflt_type
      module procedure read_type_array7dflt_type
      module procedure read_type_matcplx_type
      module procedure read_type_matflt_type
      module procedure read_type_matint_type
      module procedure read_type_veccplx_type
      module procedure read_type_vecflt_type
      module procedure read_type_vecint_type
      module procedure read_type_vecstring_type
      module procedure read_type_amns
      module procedure read_arr_type_amns
      module procedure read_type_antennas
      module procedure read_arr_type_antennas
      module procedure read_type_bb_shield
      module procedure read_arr_type_bb_shield
      module procedure read_type_compositionc
      module procedure read_arr_type_compositionc
      module procedure read_type_coredelta
      module procedure read_arr_type_coredelta
      module procedure read_type_corefast
      module procedure read_arr_type_corefast
      module procedure read_type_coreimpur
      module procedure read_arr_type_coreimpur
      module procedure read_type_coreneutrals
      module procedure read_arr_type_coreneutrals
      module procedure read_type_coreprof
      module procedure read_arr_type_coreprof
      module procedure read_type_coresource
      module procedure read_arr_type_coresource
      module procedure read_type_coretransp
      module procedure read_arr_type_coretransp
      module procedure read_type_cxdiag
      module procedure read_arr_type_cxdiag
      module procedure read_type_distribution
      module procedure read_arr_type_distribution
      module procedure read_type_distsource
      module procedure read_arr_type_distsource
      module procedure read_type_ecediag
      module procedure read_arr_type_ecediag
      module procedure read_type_edge
      module procedure read_arr_type_edge
      module procedure read_type_efcc
      module procedure read_arr_type_efcc
      module procedure read_type_equilibrium
      module procedure read_arr_type_equilibrium
      module procedure read_type_fusiondiag
      module procedure read_arr_type_fusiondiag
      module procedure read_type_halphadiag
      module procedure read_arr_type_halphadiag
      module procedure read_type_heat_sources
      module procedure read_arr_type_heat_sources
      module procedure read_type_interfdiag
      module procedure read_arr_type_interfdiag
      module procedure read_type_ironmodel
      module procedure read_arr_type_ironmodel
      module procedure read_type_langmuirdiag
      module procedure read_arr_type_langmuirdiag
      module procedure read_type_launchs
      module procedure read_arr_type_launchs
      module procedure read_type_lithiumdiag
      module procedure read_arr_type_lithiumdiag
      module procedure read_type_magdiag
      module procedure read_arr_type_magdiag
      module procedure read_type_mhd
      module procedure read_arr_type_mhd
      module procedure read_type_msediag
      module procedure read_arr_type_msediag
      module procedure read_type_nbi
      module procedure read_arr_type_nbi
      module procedure read_type_neoclassic
      module procedure read_arr_type_neoclassic
      module procedure read_type_ntm
      module procedure read_arr_type_ntm
      module procedure read_type_orbit
      module procedure read_arr_type_orbit
      module procedure read_type_pellets
      module procedure read_arr_type_pellets
      module procedure read_type_pfsystems
      module procedure read_arr_type_pfsystems
      module procedure read_type_polardiag
      module procedure read_arr_type_polardiag
      module procedure read_type_power_conv
      module procedure read_arr_type_power_conv
      module procedure read_type_reflectomet
      module procedure read_arr_type_reflectomet
      module procedure read_type_rfadiag
      module procedure read_arr_type_rfadiag
      module procedure read_type_sawteeth
      module procedure read_arr_type_sawteeth
      module procedure read_type_scenario
      module procedure read_arr_type_scenario
      module procedure read_type_solcurdiag
      module procedure read_arr_type_solcurdiag
      module procedure read_type_temporary
      module procedure read_arr_type_temporary
      module procedure read_type_topinfo
      module procedure read_arr_type_topinfo
      module procedure read_type_toroidfield
      module procedure read_arr_type_toroidfield
      module procedure read_type_tsdiag
      module procedure read_arr_type_tsdiag
      module procedure read_type_turbulence
      module procedure read_arr_type_turbulence
      module procedure read_type_wall
      module procedure read_arr_type_wall
      module procedure read_type_waves
      module procedure read_arr_type_waves
      module procedure read_type_amns_constituentType
      module procedure read_arr_type_amns_constituentType
      module procedure read_type_amns_processType
      module procedure read_arr_type_amns_processType
      module procedure read_type_antenna_ec
      module procedure read_arr_type_antenna_ec
      module procedure read_type_antenna_ic
      module procedure read_arr_type_antenna_ic
      module procedure read_type_antenna_lh
      module procedure read_arr_type_antenna_lh
      module procedure read_type_antennaic_setup
      module procedure read_arr_type_antennaic_setup
      module procedure read_type_antennalh_setup
      module procedure read_arr_type_antennalh_setup
      module procedure read_type_b0r0
      module procedure read_arr_type_b0r0
      module procedure read_type_bb
      module procedure read_arr_type_bb
      module procedure read_type_bb_dimension
      module procedure read_arr_type_bb_dimension
      module procedure read_type_bb_geometry
      module procedure read_arr_type_bb_geometry
      module procedure read_type_bb_specs
      module procedure read_arr_type_bb_specs
      module procedure read_type_beamletgroup
      module procedure read_arr_type_beamletgroup
      module procedure read_type_beamlets
      module procedure read_arr_type_beamlets
      module procedure read_type_beamtracing
      module procedure read_arr_type_beamtracing
      module procedure read_type_boundary
      module procedure read_arr_type_boundary
      module procedure read_type_boundary_neutrals
      module procedure read_arr_type_boundary_neutrals
      module procedure read_type_boundaryel
      module procedure read_arr_type_boundaryel
      module procedure read_type_boundaryimp
      module procedure read_arr_type_boundaryimp
      module procedure read_type_boundaryion
      module procedure read_arr_type_boundaryion
      module procedure read_type_bpol_probes
      module procedure read_arr_type_bpol_probes
      module procedure read_type_calorimetry_heat_source
      module procedure read_arr_type_calorimetry_heat_source
      module procedure read_type_circuits
      module procedure read_arr_type_circuits
      module procedure read_type_circularcoil
      module procedure read_arr_type_circularcoil
      module procedure read_type_clusters
      module procedure read_arr_type_clusters
      module procedure read_type_codeparam
      module procedure read_arr_type_codeparam
      module procedure read_type_coefficients_neutrals
      module procedure read_arr_type_coefficients_neutrals
      module procedure read_type_coherentwave
      module procedure read_arr_type_coherentwave
      module procedure read_type_coil
      module procedure read_arr_type_coil
      module procedure read_type_com
      module procedure read_arr_type_com
      module procedure read_type_complexgrid
      module procedure read_arr_type_complexgrid
      module procedure read_type_complexgrid_geo_global
      module procedure read_arr_type_complexgrid_geo_global
      module procedure read_type_complexgrid_indexlist
      module procedure read_arr_type_complexgrid_indexlist
      module procedure read_type_complexgrid_metric
      module procedure read_arr_type_complexgrid_metric
      module procedure read_type_complexgrid_objectlist
      module procedure read_arr_type_complexgrid_objectlist
      module procedure read_type_complexgrid_scalar
      module procedure read_arr_type_complexgrid_scalar
      module procedure read_type_complexgrid_scalar_cplx
      module procedure read_arr_type_complexgrid_scalar_cplx
      module procedure read_type_complexgrid_scalar_int
      module procedure read_arr_type_complexgrid_scalar_int
      module procedure read_type_complexgrid_scalar_simplestruct
      module procedure read_arr_type_complexgrid_scalar_simplestruct
      module procedure read_type_complexgrid_space
      module procedure read_arr_type_complexgrid_space
      module procedure read_type_complexgrid_subgrid
      module procedure read_arr_type_complexgrid_subgrid
      module procedure read_type_complexgrid_vector
      module procedure read_arr_type_complexgrid_vector
      module procedure read_type_complexgrid_vector_simplestruct
      module procedure read_arr_type_complexgrid_vector_simplestruct
      module procedure read_type_composition
      module procedure read_arr_type_composition
      module procedure read_type_composition_neutrals
      module procedure read_arr_type_composition_neutrals
      module procedure read_type_composition_neutrals_neutcomp
      module procedure read_arr_type_composition_neutrals_neutcomp
      module procedure read_type_composition_neutralscomp
      module procedure read_arr_type_composition_neutralscomp
      module procedure read_type_compositions_type
      module procedure read_arr_type_compositions_type
      module procedure read_type_compound_desc
      module procedure read_arr_type_compound_desc
      module procedure read_type_coord_sys
      module procedure read_arr_type_coord_sys
      module procedure read_type_coordinates
      module procedure read_arr_type_coordinates
      module procedure read_type_coords
      module procedure read_arr_type_coords
      module procedure read_type_coredelta_values
      module procedure read_arr_type_coredelta_values
      module procedure read_type_coredelta_values_impurity
      module procedure read_arr_type_coredelta_values_impurity
      module procedure read_type_corefast_values
      module procedure read_arr_type_corefast_values
      module procedure read_type_corefield
      module procedure read_arr_type_corefield
      module procedure read_type_corefieldion
      module procedure read_arr_type_corefieldion
      module procedure read_type_corefieldneutral
      module procedure read_arr_type_corefieldneutral
      module procedure read_type_corefieldneutrale
      module procedure read_arr_type_corefieldneutrale
      module procedure read_type_corefieldneutralv
      module procedure read_arr_type_corefieldneutralv
      module procedure read_type_corefieldneutralv0
      module procedure read_arr_type_corefieldneutralv0
      module procedure read_type_coreimpurdiag_sum_radiation
      module procedure read_arr_type_coreimpurdiag_sum_radiation
      module procedure read_type_coreimpurediag_energy
      module procedure read_arr_type_coreimpurediag_energy
      module procedure read_type_coreimpurediag_radiation
      module procedure read_arr_type_coreimpurediag_radiation
      module procedure read_type_coreimpurediag_sum
      module procedure read_arr_type_coreimpurediag_sum
      module procedure read_type_coreimpurediag_sum_energy
      module procedure read_arr_type_coreimpurediag_sum_energy
      module procedure read_type_coreimpurediag_type
      module procedure read_arr_type_coreimpurediag_type
      module procedure read_type_coreimpurediagprof_type
      module procedure read_arr_type_coreimpurediagprof_type
      module procedure read_type_coreimpurediagsum_type
      module procedure read_arr_type_coreimpurediagsum_type
      module procedure read_type_coreneutrals_atomlist
      module procedure read_arr_type_coreneutrals_atomlist
      module procedure read_type_coreneutrals_neutraltype
      module procedure read_arr_type_coreneutrals_neutraltype
      module procedure read_type_coreprofile
      module procedure read_arr_type_coreprofile
      module procedure read_type_coreprofion
      module procedure read_arr_type_coreprofion
      module procedure read_type_coresource_values
      module procedure read_arr_type_coresource_values
      module procedure read_type_coretransel
      module procedure read_arr_type_coretransel
      module procedure read_type_coretransimp
      module procedure read_arr_type_coretransimp
      module procedure read_type_coretransion
      module procedure read_arr_type_coretransion
      module procedure read_type_coretransp_values
      module procedure read_arr_type_coretransp_values
      module procedure read_type_current
      module procedure read_arr_type_current
      module procedure read_type_cxmeasure
      module procedure read_arr_type_cxmeasure
      module procedure read_type_cxsetup
      module procedure read_arr_type_cxsetup
      module procedure read_type_data_release
      module procedure read_arr_type_data_release
      module procedure read_type_datainfo
      module procedure read_arr_type_datainfo
      module procedure read_type_desc_coils
      module procedure read_arr_type_desc_coils
      module procedure read_type_desc_impur
      module procedure read_arr_type_desc_impur
      module procedure read_type_desc_iron
      module procedure read_arr_type_desc_iron
      module procedure read_type_desc_pfcoils
      module procedure read_arr_type_desc_pfcoils
      module procedure read_type_desc_supply
      module procedure read_arr_type_desc_supply
      module procedure read_type_diag_func
      module procedure read_arr_type_diag_func
      module procedure read_type_dist_collisional_transfer_0d
      module procedure read_arr_type_dist_collisional_transfer_0d
      module procedure read_type_dist_collisional_transfer_1d
      module procedure read_arr_type_dist_collisional_transfer_1d
      module procedure read_type_dist_collisional_transfer_2d
      module procedure read_arr_type_dist_collisional_transfer_2d
      module procedure read_type_dist_distrivec_distfunc_fexp_param
      module procedure read_arr_type_dist_distrivec_distfunc_fexp_param
      module procedure read_type_dist_ff
      module procedure read_arr_type_dist_ff
      module procedure read_type_dist_func
      module procedure read_arr_type_dist_func
      module procedure read_type_dist_geometry_0d
      module procedure read_arr_type_dist_geometry_0d
      module procedure read_type_dist_geometry_1d
      module procedure read_arr_type_dist_geometry_1d
      module procedure read_type_dist_geometry_2d
      module procedure read_arr_type_dist_geometry_2d
      module procedure read_type_dist_global_param
      module procedure read_arr_type_dist_global_param
      module procedure read_type_dist_global_param_collisions_z
      module procedure read_arr_type_dist_global_param_collisions_z
      module procedure read_type_dist_grid_info
      module procedure read_arr_type_dist_grid_info
      module procedure read_type_dist_profile_values_1d
      module procedure read_arr_type_dist_profile_values_1d
      module procedure read_type_dist_profile_values_2d
      module procedure read_arr_type_dist_profile_values_2d
      module procedure read_type_dist_profiles2d_collisions_z
      module procedure read_arr_type_dist_profiles2d_collisions_z
      module procedure read_type_dist_profiles_1d
      module procedure read_arr_type_dist_profiles_1d
      module procedure read_type_dist_profiles_1d_collisions_z
      module procedure read_arr_type_dist_profiles_1d_collisions_z
      module procedure read_type_dist_profiles_2d
      module procedure read_arr_type_dist_profiles_2d
      module procedure read_type_dist_sources_0d
      module procedure read_arr_type_dist_sources_0d
      module procedure read_type_dist_sources_1d
      module procedure read_arr_type_dist_sources_1d
      module procedure read_type_dist_sources_reference
      module procedure read_arr_type_dist_sources_reference
      module procedure read_type_dist_state_0d
      module procedure read_arr_type_dist_state_0d
      module procedure read_type_dist_state_1d
      module procedure read_arr_type_dist_state_1d
      module procedure read_type_dist_state_2d
      module procedure read_arr_type_dist_state_2d
      module procedure read_type_dist_thermalised_1d
      module procedure read_arr_type_dist_thermalised_1d
      module procedure read_type_distri_vec
      module procedure read_arr_type_distri_vec
      module procedure read_type_distsource_global_param
      module procedure read_arr_type_distsource_global_param
      module procedure read_type_distsource_line_src_prof
      module procedure read_arr_type_distsource_line_src_prof
      module procedure read_type_distsource_profiles_1d
      module procedure read_arr_type_distsource_profiles_1d
      module procedure read_type_distsource_profiles_2d
      module procedure read_arr_type_distsource_profiles_2d
      module procedure read_type_distsource_source
      module procedure read_arr_type_distsource_source
      module procedure read_type_divergence
      module procedure read_arr_type_divergence
      module procedure read_type_e_components
      module procedure read_arr_type_e_components
      module procedure read_type_ecemeasure
      module procedure read_arr_type_ecemeasure
      module procedure read_type_ecesetup
      module procedure read_arr_type_ecesetup
      module procedure read_type_edge_fluid
      module procedure read_arr_type_edge_fluid
      module procedure read_type_edge_fluid_scalar
      module procedure read_arr_type_edge_fluid_scalar
      module procedure read_type_edge_fluid_scalar_simplestruct
      module procedure read_arr_type_edge_fluid_scalar_simplestruct
      module procedure read_type_edge_fluid_scalar_transpcoeff
      module procedure read_arr_type_edge_fluid_scalar_transpcoeff
      module procedure read_type_edge_fluid_vector
      module procedure read_arr_type_edge_fluid_vector
      module procedure read_type_edge_fluid_vector_simplestruct
      module procedure read_arr_type_edge_fluid_vector_simplestruct
      module procedure read_type_edge_kinetic
      module procedure read_arr_type_edge_kinetic
      module procedure read_type_edge_kinetic_distribution
      module procedure read_arr_type_edge_kinetic_distribution
      module procedure read_type_edges
      module procedure read_arr_type_edges
      module procedure read_type_edgespecies
      module procedure read_arr_type_edgespecies
      module procedure read_type_element_desc
      module procedure read_arr_type_element_desc
      module procedure read_type_entry_def
      module procedure read_arr_type_entry_def
      module procedure read_type_enum_instance
      module procedure read_arr_type_enum_instance
      module procedure read_type_eqconstraint
      module procedure read_arr_type_eqconstraint
      module procedure read_type_eqgeometry
      module procedure read_arr_type_eqgeometry
      module procedure read_type_eqmes0D
      module procedure read_arr_type_eqmes0D
      module procedure read_type_eqmes1D
      module procedure read_arr_type_eqmes1D
      module procedure read_type_equatorial_plane
      module procedure read_arr_type_equatorial_plane
      module procedure read_type_equilibrium_profiles2d_grid
      module procedure read_arr_type_equilibrium_profiles2d_grid
      module procedure read_type_equilibrium_profiles_2d
      module procedure read_arr_type_equilibrium_profiles_2d
      module procedure read_type_exp0D
      module procedure read_arr_type_exp0D
      module procedure read_type_exp1D
      module procedure read_arr_type_exp1D
      module procedure read_type_exp2D
      module procedure read_arr_type_exp2D
      module procedure read_type_f_expansion
      module procedure read_arr_type_f_expansion
      module procedure read_type_fast_thermal_separation_filter
      module procedure read_arr_type_fast_thermal_separation_filter
      module procedure read_type_filter
      module procedure read_arr_type_filter
      module procedure read_type_flat_polygon
      module procedure read_arr_type_flat_polygon
      module procedure read_type_flush
      module procedure read_arr_type_flush
      module procedure read_type_flux_loops
      module procedure read_arr_type_flux_loops
      module procedure read_type_fluxel
      module procedure read_arr_type_fluxel
      module procedure read_type_fluximp
      module procedure read_arr_type_fluximp
      module procedure read_type_fluxion
      module procedure read_arr_type_fluxion
      module procedure read_type_focussing
      module procedure read_arr_type_focussing
      module procedure read_type_fullwave
      module procedure read_arr_type_fullwave
      module procedure read_type_fusiondiag_colli_3d
      module procedure read_arr_type_fusiondiag_colli_3d
      module procedure read_type_fusiondiag_colli_circ
      module procedure read_arr_type_fusiondiag_colli_circ
      module procedure read_type_fusiondiag_colli_poly
      module procedure read_arr_type_fusiondiag_colli_poly
      module procedure read_type_fusiondiag_collimator
      module procedure read_arr_type_fusiondiag_collimator
      module procedure read_type_fusiondiag_colliunit_circ
      module procedure read_arr_type_fusiondiag_colliunit_circ
      module procedure read_type_fusiondiag_colliunit_poly
      module procedure read_arr_type_fusiondiag_colliunit_poly
      module procedure read_type_fusiondiag_counts
      module procedure read_arr_type_fusiondiag_counts
      module procedure read_type_fusiondiag_ct_chords
      module procedure read_arr_type_fusiondiag_ct_chords
      module procedure read_type_fusiondiag_ct_energy
      module procedure read_arr_type_fusiondiag_ct_energy
      module procedure read_type_fusiondiag_detect_ct_energy
      module procedure read_arr_type_fusiondiag_detect_ct_energy
      module procedure read_type_fusiondiag_emissivity1d
      module procedure read_arr_type_fusiondiag_emissivity1d
      module procedure read_type_fusiondiag_emissivity2d
      module procedure read_arr_type_fusiondiag_emissivity2d
      module procedure read_type_fusiondiag_fus_product
      module procedure read_arr_type_fusiondiag_fus_product
      module procedure read_type_fusiondiag_spec1d
      module procedure read_arr_type_fusiondiag_spec1d
      module procedure read_type_fusiondiag_spec2d
      module procedure read_arr_type_fusiondiag_spec2d
      module procedure read_type_fusiondiag_voxels
      module procedure read_arr_type_fusiondiag_voxels
      module procedure read_type_geom
      module procedure read_arr_type_geom
      module procedure read_type_geom_iron
      module procedure read_arr_type_geom_iron
      module procedure read_type_global_param
      module procedure read_arr_type_global_param
      module procedure read_type_globalparam
      module procedure read_arr_type_globalparam
      module procedure read_type_halpha_setup
      module procedure read_arr_type_halpha_setup
      module procedure read_type_hcll
      module procedure read_arr_type_hcll
      module procedure read_type_hcll_bb
      module procedure read_arr_type_hcll_bb
      module procedure read_type_hcllbb_specs
      module procedure read_arr_type_hcllbb_specs
      module procedure read_type_holes
      module procedure read_arr_type_holes
      module procedure read_type_identifier
      module procedure read_arr_type_identifier
      module procedure read_type_impcoeff
      module procedure read_arr_type_impcoeff
      module procedure read_type_impurities
      module procedure read_arr_type_impurities
      module procedure read_type_impurity_type
      module procedure read_arr_type_impurity_type
      module procedure read_type_inj_spec
      module procedure read_arr_type_inj_spec
      module procedure read_type_ions
      module procedure read_arr_type_ions
      module procedure read_type_isoflux
      module procedure read_arr_type_isoflux
      module procedure read_type_jni
      module procedure read_arr_type_jni
      module procedure read_type_lang_derived
      module procedure read_arr_type_lang_derived
      module procedure read_type_lang_measure
      module procedure read_arr_type_lang_measure
      module procedure read_type_launchangles
      module procedure read_arr_type_launchangles
      module procedure read_type_launchs_parallel
      module procedure read_arr_type_launchs_parallel
      module procedure read_type_launchs_phi_theta
      module procedure read_arr_type_launchs_phi_theta
      module procedure read_type_launchs_rfbeam
      module procedure read_arr_type_launchs_rfbeam
      module procedure read_type_launchs_rfbeam_phaseellipse
      module procedure read_arr_type_launchs_rfbeam_phaseellipse
      module procedure read_type_launchs_rfbeam_spot
      module procedure read_arr_type_launchs_rfbeam_spot
      module procedure read_type_launchsignal
      module procedure read_arr_type_launchsignal
      module procedure read_type_limiter_unit
      module procedure read_arr_type_limiter_unit
      module procedure read_type_limits
      module procedure read_arr_type_limits
      module procedure read_type_lineintegraldiag
      module procedure read_arr_type_lineintegraldiag
      module procedure read_type_lithmeasure
      module procedure read_arr_type_lithmeasure
      module procedure read_type_lithsetup
      module procedure read_arr_type_lithsetup
      module procedure read_type_local
      module procedure read_arr_type_local
      module procedure read_type_mag_axis
      module procedure read_arr_type_mag_axis
      module procedure read_type_magnet_iron
      module procedure read_arr_type_magnet_iron
      module procedure read_type_magnetise
      module procedure read_arr_type_magnetise
      module procedure read_type_mat_lim
      module procedure read_arr_type_mat_lim
      module procedure read_type_mdinfo
      module procedure read_arr_type_mdinfo
      module procedure read_type_mhd_ideal_wall2d
      module procedure read_arr_type_mhd_ideal_wall2d
      module procedure read_type_mhd_mode
      module procedure read_arr_type_mhd_mode
      module procedure read_type_mhd_plasma
      module procedure read_arr_type_mhd_plasma
      module procedure read_type_mhd_res_wall2d
      module procedure read_arr_type_mhd_res_wall2d
      module procedure read_type_mhd_vacuum
      module procedure read_arr_type_mhd_vacuum
      module procedure read_type_mhd_vector
      module procedure read_arr_type_mhd_vector
      module procedure read_type_mode_lipb
      module procedure read_arr_type_mode_lipb
      module procedure read_type_mode_mech
      module procedure read_arr_type_mode_mech
      module procedure read_type_mode_neutr
      module procedure read_arr_type_mode_neutr
      module procedure read_type_mode_th_hyd
      module procedure read_arr_type_mode_th_hyd
      module procedure read_type_mode_therm
      module procedure read_arr_type_mode_therm
      module procedure read_type_mode_tritium
      module procedure read_arr_type_mode_tritium
      module procedure read_type_modules
      module procedure read_arr_type_modules
      module procedure read_type_msediag_emiss_chord
      module procedure read_arr_type_msediag_emiss_chord
      module procedure read_type_msediag_emissivity
      module procedure read_arr_type_msediag_emissivity
      module procedure read_type_msediag_polarization
      module procedure read_arr_type_msediag_polarization
      module procedure read_type_msediag_radia_chord
      module procedure read_arr_type_msediag_radia_chord
      module procedure read_type_msediag_radiance
      module procedure read_arr_type_msediag_radiance
      module procedure read_type_msediag_setup
      module procedure read_arr_type_msediag_setup
      module procedure read_type_msediag_setup_polarimetry
      module procedure read_arr_type_msediag_setup_polarimetry
      module procedure read_type_msediag_stokes
      module procedure read_arr_type_msediag_stokes
      module procedure read_type_nbi_nbi_unit_wall
      module procedure read_arr_type_nbi_nbi_unit_wall
      module procedure read_type_nbi_nbi_unit_wall_surface
      module procedure read_arr_type_nbi_nbi_unit_wall_surface
      module procedure read_type_nbi_unit
      module procedure read_arr_type_nbi_unit
      module procedure read_type_ne_transp
      module procedure read_arr_type_ne_transp
      module procedure read_type_neoclassic_impurity
      module procedure read_arr_type_neoclassic_impurity
      module procedure read_type_neut_results
      module procedure read_arr_type_neut_results
      module procedure read_type_neutral_complex_type
      module procedure read_arr_type_neutral_complex_type
      module procedure read_type_neutro_resul
      module procedure read_arr_type_neutro_resul
      module procedure read_type_ni_transp
      module procedure read_arr_type_ni_transp
      module procedure read_type_ntm_mode
      module procedure read_arr_type_ntm_mode
      module procedure read_type_ntm_mode_evolution
      module procedure read_arr_type_ntm_mode_evolution
      module procedure read_type_ntm_mode_evolution_island
      module procedure read_arr_type_ntm_mode_evolution_island
      module procedure read_type_ntm_mode_full_evol
      module procedure read_arr_type_ntm_mode_full_evol
      module procedure read_type_ntm_mode_full_evol_island
      module procedure read_arr_type_ntm_mode_full_evol_island
      module procedure read_type_ntm_mode_onset
      module procedure read_arr_type_ntm_mode_onset
      module procedure read_type_nuclei
      module procedure read_arr_type_nuclei
      module procedure read_type_objects
      module procedure read_arr_type_objects
      module procedure read_type_offdiagel
      module procedure read_arr_type_offdiagel
      module procedure read_type_offdiagion
      module procedure read_arr_type_offdiagion
      module procedure read_type_omnigen_surf
      module procedure read_arr_type_omnigen_surf
      module procedure read_type_orbit_global_param
      module procedure read_arr_type_orbit_global_param
      module procedure read_type_orbit_midplane
      module procedure read_arr_type_orbit_midplane
      module procedure read_type_orbit_pos
      module procedure read_arr_type_orbit_pos
      module procedure read_type_orbit_special_pos
      module procedure read_arr_type_orbit_special_pos
      module procedure read_type_orbit_turning_pts
      module procedure read_arr_type_orbit_turning_pts
      module procedure read_type_origin
      module procedure read_arr_type_origin
      module procedure read_type_param
      module procedure read_arr_type_param
      module procedure read_type_parameters
      module procedure read_arr_type_parameters
      module procedure read_type_pellet
      module procedure read_arr_type_pellet
      module procedure read_type_pellet_angles
      module procedure read_arr_type_pellet_angles
      module procedure read_type_pellet_deposition
      module procedure read_arr_type_pellet_deposition
      module procedure read_type_pellet_elements
      module procedure read_arr_type_pellet_elements
      module procedure read_type_pellet_geometry
      module procedure read_arr_type_pellet_geometry
      module procedure read_type_pellet_impurity
      module procedure read_arr_type_pellet_impurity
      module procedure read_type_pellet_pathprofiles
      module procedure read_arr_type_pellet_pathprofiles
      module procedure read_type_pellet_shape
      module procedure read_arr_type_pellet_shape
      module procedure read_type_permeability
      module procedure read_arr_type_permeability
      module procedure read_type_pfcircuits
      module procedure read_arr_type_pfcircuits
      module procedure read_type_pfcoils
      module procedure read_arr_type_pfcoils
      module procedure read_type_pfelement
      module procedure read_arr_type_pfelement
      module procedure read_type_pfgeometry
      module procedure read_arr_type_pfgeometry
      module procedure read_type_pfpageometry
      module procedure read_arr_type_pfpageometry
      module procedure read_type_pfpassive
      module procedure read_arr_type_pfpassive
      module procedure read_type_pfpassive_current
      module procedure read_arr_type_pfpassive_current
      module procedure read_type_pfsupplies
      module procedure read_arr_type_pfsupplies
      module procedure read_type_phaseellipse
      module procedure read_arr_type_phaseellipse
      module procedure read_type_planecoil
      module procedure read_arr_type_planecoil
      module procedure read_type_plasmaComplexType
      module procedure read_arr_type_plasmaComplexType
      module procedure read_type_plasmaedge
      module procedure read_arr_type_plasmaedge
      module procedure read_type_pol_decomp
      module procedure read_arr_type_pol_decomp
      module procedure read_type_polarimetry
      module procedure read_arr_type_polarimetry
      module procedure read_type_polarization
      module procedure read_arr_type_polarization
      module procedure read_type_power_conv_component
      module procedure read_arr_type_power_conv_component
      module procedure read_type_power_exchange
      module procedure read_arr_type_power_exchange
      module procedure read_type_powerflow
      module procedure read_arr_type_powerflow
      module procedure read_type_profiles1d
      module procedure read_arr_type_profiles1d
      module procedure read_type_profiles_1d
      module procedure read_arr_type_profiles_1d
      module procedure read_type_psi
      module procedure read_arr_type_psi
      module procedure read_type_putinfo
      module procedure read_arr_type_putinfo
      module procedure read_type_q
      module procedure read_arr_type_q
      module procedure read_type_reacprodType
      module procedure read_arr_type_reacprodType
      module procedure read_type_react
      module procedure read_arr_type_react
      module procedure read_type_rectanglexyz
      module procedure read_arr_type_rectanglexyz
      module procedure read_type_recycling_neutrals
      module procedure read_arr_type_recycling_neutrals
      module procedure read_type_reduced
      module procedure read_arr_type_reduced
      module procedure read_type_refl_receive
      module procedure read_arr_type_refl_receive
      module procedure read_type_reflectometry_antennas
      module procedure read_arr_type_reflectometry_antennas
      module procedure read_type_reflectometry_radfield
      module procedure read_arr_type_reflectometry_radfield
      module procedure read_type_reflectometry_radfield_gaussian
      module procedure read_arr_type_reflectometry_radfield_gaussian
      module procedure read_type_reflectometry_radifield_efield
      module procedure read_arr_type_reflectometry_radifield_efield
      module procedure read_type_reggrid
      module procedure read_arr_type_reggrid
      module procedure read_type_rfameasure
      module procedure read_arr_type_rfameasure
      module procedure read_type_rfasetup
      module procedure read_arr_type_rfasetup
      module procedure read_type_rfbeam
      module procedure read_arr_type_rfbeam
      module procedure read_type_rz0D
      module procedure read_arr_type_rz0D
      module procedure read_type_rz1D
      module procedure read_arr_type_rz1D
      module procedure read_type_rz1D_npoints
      module procedure read_arr_type_rz1D_npoints
      module procedure read_type_rz1Dexp
      module procedure read_arr_type_rz1Dexp
      module procedure read_type_rz2D
      module procedure read_arr_type_rz2D
      module procedure read_type_rz3D
      module procedure read_arr_type_rz3D
      module procedure read_type_rzphi0D
      module procedure read_arr_type_rzphi0D
      module procedure read_type_rzphi1D
      module procedure read_arr_type_rzphi1D
      module procedure read_type_rzphi1Dexp
      module procedure read_arr_type_rzphi1Dexp
      module procedure read_type_rzphi1Dexperimental
      module procedure read_arr_type_rzphi1Dexperimental
      module procedure read_type_rzphi2D
      module procedure read_arr_type_rzphi2D
      module procedure read_type_rzphi3D
      module procedure read_arr_type_rzphi3D
      module procedure read_type_rzphidrdzdphi1D
      module procedure read_arr_type_rzphidrdzdphi1D
      module procedure read_type_sawteeth_diags
      module procedure read_arr_type_sawteeth_diags
      module procedure read_type_sawteeth_profiles1d
      module procedure read_arr_type_sawteeth_profiles1d
      module procedure read_type_scenario_centre
      module procedure read_arr_type_scenario_centre
      module procedure read_type_scenario_composition
      module procedure read_arr_type_scenario_composition
      module procedure read_type_scenario_configuration
      module procedure read_arr_type_scenario_configuration
      module procedure read_type_scenario_confinement
      module procedure read_arr_type_scenario_confinement
      module procedure read_type_scenario_currents
      module procedure read_arr_type_scenario_currents
      module procedure read_type_scenario_edge
      module procedure read_arr_type_scenario_edge
      module procedure read_type_scenario_energy
      module procedure read_arr_type_scenario_energy
      module procedure read_type_scenario_global
      module procedure read_arr_type_scenario_global
      module procedure read_type_scenario_heat_power
      module procedure read_arr_type_scenario_heat_power
      module procedure read_type_scenario_int
      module procedure read_arr_type_scenario_int
      module procedure read_type_scenario_itb
      module procedure read_arr_type_scenario_itb
      module procedure read_type_scenario_lim_div_wall
      module procedure read_arr_type_scenario_lim_div_wall
      module procedure read_type_scenario_line_ave
      module procedure read_arr_type_scenario_line_ave
      module procedure read_type_scenario_neutron
      module procedure read_arr_type_scenario_neutron
      module procedure read_type_scenario_ninety_five
      module procedure read_arr_type_scenario_ninety_five
      module procedure read_type_scenario_pedestal
      module procedure read_arr_type_scenario_pedestal
      module procedure read_type_scenario_reactor
      module procedure read_arr_type_scenario_reactor
      module procedure read_type_scenario_ref
      module procedure read_arr_type_scenario_ref
      module procedure read_type_scenario_references
      module procedure read_arr_type_scenario_references
      module procedure read_type_scenario_sol
      module procedure read_arr_type_scenario_sol
      module procedure read_type_scenario_vol_ave
      module procedure read_arr_type_scenario_vol_ave
      module procedure read_type_setup_bprobe
      module procedure read_arr_type_setup_bprobe
      module procedure read_type_setup_floops
      module procedure read_arr_type_setup_floops
      module procedure read_type_setup_line
      module procedure read_arr_type_setup_line
      module procedure read_type_setup_line_exp
      module procedure read_arr_type_setup_line_exp
      module procedure read_type_shield
      module procedure read_arr_type_shield
      module procedure read_type_shield_specs
      module procedure read_arr_type_shield_specs
      module procedure read_type_simp_apert
      module procedure read_arr_type_simp_apert
      module procedure read_type_solcurdiag_sol_current
      module procedure read_arr_type_solcurdiag_sol_current
      module procedure read_type_solcurdiag_sol_current_setup
      module procedure read_arr_type_solcurdiag_sol_current_setup
      module procedure read_type_source_imp
      module procedure read_arr_type_source_imp
      module procedure read_type_source_ion
      module procedure read_arr_type_source_ion
      module procedure read_type_source_rate
      module procedure read_arr_type_source_rate
      module procedure read_type_source_vec
      module procedure read_arr_type_source_vec
      module procedure read_type_sourceel
      module procedure read_arr_type_sourceel
      module procedure read_type_sourceimp
      module procedure read_arr_type_sourceimp
      module procedure read_type_sourceion
      module procedure read_arr_type_sourceion
      module procedure read_type_species_desc
      module procedure read_arr_type_species_desc
      module procedure read_type_species_reference
      module procedure read_arr_type_species_reference
      module procedure read_type_spectral
      module procedure read_arr_type_spectral
      module procedure read_type_spectrum
      module procedure read_arr_type_spectrum
      module procedure read_type_spot
      module procedure read_arr_type_spot
      module procedure read_type_sputtering_neutrals
      module procedure read_arr_type_sputtering_neutrals
      module procedure read_type_straps
      module procedure read_arr_type_straps
      module procedure read_type_structure_cs
      module procedure read_arr_type_structure_cs
      module procedure read_type_t_series_cplx
      module procedure read_arr_type_t_series_cplx
      module procedure read_type_t_series_real
      module procedure read_arr_type_t_series_real
      module procedure read_type_table
      module procedure read_arr_type_table
      module procedure read_type_tables
      module procedure read_arr_type_tables
      module procedure read_type_tables_coord
      module procedure read_arr_type_tables_coord
      module procedure read_type_temporary_nt
      module procedure read_arr_type_temporary_nt
      module procedure read_type_temporary_nt_0dc
      module procedure read_arr_type_temporary_nt_0dc
      module procedure read_type_temporary_nt_0di
      module procedure read_arr_type_temporary_nt_0di
      module procedure read_type_temporary_nt_0dr
      module procedure read_arr_type_temporary_nt_0dr
      module procedure read_type_temporary_nt_0ds
      module procedure read_arr_type_temporary_nt_0ds
      module procedure read_type_temporary_nt_1dc
      module procedure read_arr_type_temporary_nt_1dc
      module procedure read_type_temporary_nt_1di
      module procedure read_arr_type_temporary_nt_1di
      module procedure read_type_temporary_nt_1dr
      module procedure read_arr_type_temporary_nt_1dr
      module procedure read_type_temporary_nt_1ds
      module procedure read_arr_type_temporary_nt_1ds
      module procedure read_type_temporary_nt_2dc
      module procedure read_arr_type_temporary_nt_2dc
      module procedure read_type_temporary_nt_2di
      module procedure read_arr_type_temporary_nt_2di
      module procedure read_type_temporary_nt_2dr
      module procedure read_arr_type_temporary_nt_2dr
      module procedure read_type_temporary_nt_3dc
      module procedure read_arr_type_temporary_nt_3dc
      module procedure read_type_temporary_nt_3di
      module procedure read_arr_type_temporary_nt_3di
      module procedure read_type_temporary_nt_3dr
      module procedure read_arr_type_temporary_nt_3dr
      module procedure read_type_temporary_nt_4dr
      module procedure read_arr_type_temporary_nt_4dr
      module procedure read_type_temporary_t
      module procedure read_arr_type_temporary_t
      module procedure read_type_temporary_t_0dc
      module procedure read_arr_type_temporary_t_0dc
      module procedure read_type_temporary_t_0di
      module procedure read_arr_type_temporary_t_0di
      module procedure read_type_temporary_t_0dr
      module procedure read_arr_type_temporary_t_0dr
      module procedure read_type_temporary_t_0ds
      module procedure read_arr_type_temporary_t_0ds
      module procedure read_type_temporary_t_1dc
      module procedure read_arr_type_temporary_t_1dc
      module procedure read_type_temporary_t_1di
      module procedure read_arr_type_temporary_t_1di
      module procedure read_type_temporary_t_1dr
      module procedure read_arr_type_temporary_t_1dr
      module procedure read_type_temporary_t_2dc
      module procedure read_arr_type_temporary_t_2dc
      module procedure read_type_temporary_t_2di
      module procedure read_arr_type_temporary_t_2di
      module procedure read_type_temporary_t_2dr
      module procedure read_arr_type_temporary_t_2dr
      module procedure read_type_temporary_t_3dc
      module procedure read_arr_type_temporary_t_3dc
      module procedure read_type_temporary_t_3di
      module procedure read_arr_type_temporary_t_3di
      module procedure read_type_temporary_t_3dr
      module procedure read_arr_type_temporary_t_3dr
      module procedure read_type_temporary_t_4dr
      module procedure read_arr_type_temporary_t_4dr
      module procedure read_type_tf_desc_tfcoils
      module procedure read_arr_type_tf_desc_tfcoils
      module procedure read_type_tf_desc_tfcoils_board
      module procedure read_arr_type_tf_desc_tfcoils_board
      module procedure read_type_tf_structure
      module procedure read_arr_type_tf_structure
      module procedure read_type_theta_info
      module procedure read_arr_type_theta_info
      module procedure read_type_topo_regions
      module procedure read_arr_type_topo_regions
      module procedure read_type_toroid_field
      module procedure read_arr_type_toroid_field
      module procedure read_type_trace
      module procedure read_arr_type_trace
      module procedure read_type_transcoefel
      module procedure read_arr_type_transcoefel
      module procedure read_type_transcoefimp
      module procedure read_arr_type_transcoefimp
      module procedure read_type_transcoefion
      module procedure read_arr_type_transcoefion
      module procedure read_type_transcoefvtor
      module procedure read_arr_type_transcoefvtor
      module procedure read_type_trap_type
      module procedure read_arr_type_trap_type
      module procedure read_type_trianglexyz
      module procedure read_arr_type_trianglexyz
      module procedure read_type_tsmeasure
      module procedure read_arr_type_tsmeasure
      module procedure read_type_tssetup
      module procedure read_arr_type_tssetup
      module procedure read_type_turbcomposition
      module procedure read_arr_type_turbcomposition
      module procedure read_type_turbcoordsys
      module procedure read_arr_type_turbcoordsys
      module procedure read_type_turbenv1d
      module procedure read_arr_type_turbenv1d
      module procedure read_type_turbgrid
      module procedure read_arr_type_turbgrid
      module procedure read_type_turbspec1d
      module procedure read_arr_type_turbspec1d
      module procedure read_type_turbvar0d
      module procedure read_arr_type_turbvar0d
      module procedure read_type_turbvar1d
      module procedure read_arr_type_turbvar1d
      module procedure read_type_turbvar2d
      module procedure read_arr_type_turbvar2d
      module procedure read_type_turbvar3d
      module procedure read_arr_type_turbvar3d
      module procedure read_type_turbvar4d
      module procedure read_arr_type_turbvar4d
      module procedure read_type_turbvar5d
      module procedure read_arr_type_turbvar5d
      module procedure read_type_version_ind
      module procedure read_arr_type_version_ind
      module procedure read_type_wall2d
      module procedure read_arr_type_wall2d
      module procedure read_type_wall2d_mhd
      module procedure read_arr_type_wall2d_mhd
      module procedure read_type_wall3d
      module procedure read_arr_type_wall3d
      module procedure read_type_wall_blocks
      module procedure read_arr_type_wall_blocks
      module procedure read_type_wall_blocks_unit
      module procedure read_arr_type_wall_blocks_unit
      module procedure read_type_wall_limiter
      module procedure read_arr_type_wall_limiter
      module procedure read_type_wall_types
      module procedure read_arr_type_wall_types
      module procedure read_type_wall_types_layers
      module procedure read_arr_type_wall_types_layers
      module procedure read_type_wall_unitsComplexType
      module procedure read_arr_type_wall_unitsComplexType
      module procedure read_type_wall_unitsComplexType_layers
      module procedure read_arr_type_wall_unitsComplexType_layers
      module procedure read_type_wall_vessel
      module procedure read_arr_type_wall_vessel
      module procedure read_type_wall_vessel_annular
      module procedure read_arr_type_wall_vessel_annular
      module procedure read_type_wall_vessel_unit
      module procedure read_arr_type_wall_vessel_unit
      module procedure read_type_wall_wall0d
      module procedure read_arr_type_wall_wall0d
      module procedure read_type_wall_wall0d_plasma
      module procedure read_arr_type_wall_wall0d_plasma
      module procedure read_type_wall_wall2d_vessel_radial_build
      module procedure read_arr_type_wall_wall2d_vessel_radial_build
      module procedure read_type_waveguides
      module procedure read_arr_type_waveguides
      module procedure read_type_waves_global_param
      module procedure read_arr_type_waves_global_param
      module procedure read_type_waves_grid_1d
      module procedure read_arr_type_waves_grid_1d
      module procedure read_type_waves_grid_2d
      module procedure read_arr_type_waves_grid_2d
      module procedure read_type_waves_profiles_1d
      module procedure read_arr_type_waves_profiles_1d
      module procedure read_type_waves_profiles_2d
      module procedure read_arr_type_waves_profiles_2d
      module procedure read_type_waves_rtposition
      module procedure read_arr_type_waves_rtposition
      module procedure read_type_waves_rtwavevector
      module procedure read_arr_type_waves_rtwavevector
      module procedure read_type_weighted_markers
      module procedure read_arr_type_weighted_markers
      module procedure read_type_whatref
      module procedure read_arr_type_whatref
      module procedure read_type_width
      module procedure read_arr_type_width
      module procedure read_type_xpts
      module procedure read_arr_type_xpts
      module procedure read_type_xyz0D
      module procedure read_arr_type_xyz0D
   end interface
 
   integer, parameter, private :: iu6 = 6
   integer, private :: verbose = 0
   integer, private :: in_cpo = 9
   character(len = 16), private :: version_tag = '4.10b.10'
   character(len = 16), private :: version = '4.10b'
   logical :: strict_match = .true.

   private :: convert_linebreaks

 contains


   function get_in_cpo() result(f_get_in_cpo)

     implicit none

     integer :: f_get_in_cpo

     f_get_in_cpo = in_cpo

   end function get_in_cpo

   subroutine open_read_file(unit_no, file_name)

     implicit none

     integer, intent(in) :: unit_no
     character(len = *), intent(in) :: file_name
     character(len = 132) :: line
     character(len = 16) :: read_version = 'undef'

     integer :: ios

     in_cpo = unit_no

     open(unit = in_cpo, file = file_name, status = 'old', &
      form = 'formatted', action = 'read', iostat = ios)

     if (ios /= 0) then
       write(iu6, *) 'Error opening ', file_name
       stop
     end if

     read(in_cpo, '(a)') line
     if (index(line, 'schema version') /= 0) then
       read_version = line(index(line, 'schema version') + 15 &
        : index(line, 'schema version') + 31)
     end if

     if (strict_match .and. read_version(1 : scan(read_version, '.', .true.) - 1) /= version) then
       write(iu6, *) 'ERROR: major versions of read and write routines differ!'
       stop
     end if
     
     if (read_version /= version_tag) then
       write(iu6, *) 'WARNING: minor versions of read and write routines differ!'
     end if
     
     if (verbose > 0) then
       write(iu6, *) 'using schema version ', version_tag
     end if

   end subroutine open_read_file

   subroutine close_read_file

     close(in_cpo)

   end subroutine close_read_file

   subroutine set_read_verbosity(verbosity)

     implicit none

     integer, intent(in) :: verbosity

     if (verbosity < 0) then
       verbose = 0
     else
       verbose = verbosity
     end if

   end subroutine set_read_verbosity

   subroutine set_strict_match(value)

     implicit none

     logical, intent(in) :: value

     strict_match = value

   end subroutine set_strict_match

   !> Convert linebreak characters in a string to a dummy character.
   !> This is required to work around a problem with formatted output of 
   !> strings containing linebreaks
   !> direction = .true. converts linebreaks -> dummy
   !> direction = .false. converts dummy -> linebreaks
   subroutine convert_linebreaks(strs, direction)
     implicit none
     character(132), dimension(:), intent(inout) :: strs
     logical, intent(in) :: direction

     ! internal
     integer :: i, is

     do is = 1, size(strs)
       do i = 1, 132
         if (direction) then
           if (strs(is)(i:i) == achar(10)) strs(is)(i:i) = achar(254)
         else
           if (strs(is)(i:i) == achar(254)) strs(is)(i:i) = achar(10)
         end if
       end do
     end do
   end subroutine convert_linebreaks

   subroutine read_type_integer(structure_out, name)

     implicit none

     integer, intent(inout) :: structure_out
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       read(in_cpo, *) structure_out
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if

   end subroutine read_type_integer

   subroutine read_type_float(structure_out, name)

     implicit none

     real(euitm_r8) :: structure_out
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       read(in_cpo, *) structure_out
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if

   end subroutine read_type_float

   subroutine read_type_complex(structure_out, name)

     implicit none

     complex(euitm_r8) :: structure_out
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       read(in_cpo, *) structure_out
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if

   end subroutine read_type_complex

   subroutine read_type_array3dcplx_type(structure_out, name)
 
     implicit none

     complex(euitm_r8), pointer :: structure_out(:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 3) then
         read(in_cpo, *) n1, n2, n3
         allocate(structure_out(n1, n2, n3))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array3dcplx_type

   subroutine read_type_array3dflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 3) then
         read(in_cpo, *) n1, n2, n3
         allocate(structure_out(n1, n2, n3))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array3dflt_type

   subroutine read_type_array3dint_type(structure_out, name)
 
     implicit none

     integer, pointer :: structure_out(:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 3) then
         read(in_cpo, *) n1, n2, n3
         allocate(structure_out(n1, n2, n3))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array3dint_type

   subroutine read_type_array4dflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:,:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3, n4
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 4) then
         read(in_cpo, *) n1, n2, n3, n4
         allocate(structure_out(n1, n2, n3, n4))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array4dflt_type

   subroutine read_type_array5dflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:,:,:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3, n4, n5
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 5) then
         read(in_cpo, *) n1, n2, n3, n4, n5
         allocate(structure_out(n1, n2, n3, n4, n5))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array5dflt_type

   subroutine read_type_array6dflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:,:,:,:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3, n4, n5, n6
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 6) then
         read(in_cpo, *) n1, n2, n3, n4, n5, n6
         allocate(structure_out(n1, n2, n3, n4, n5, n6))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array6dflt_type

   subroutine read_type_array7dflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:,:,:,:,:,:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2, n3, n4, n5, n6, n7
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 7) then
         read(in_cpo, *) n1, n2, n3, n4, n5, n6, n7
         allocate(structure_out(n1, n2, n3, n4, n5, n6, n7))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_array7dflt_type

   subroutine read_type_matcplx_type(structure_out, name)
 
     implicit none

     complex(euitm_r8), pointer :: structure_out(:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 2) then
         read(in_cpo, *) n1, n2
         allocate(structure_out(n1, n2))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_matcplx_type

   subroutine read_type_matflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 2) then
         read(in_cpo, *) n1, n2
         allocate(structure_out(n1, n2))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_matflt_type

   subroutine read_type_matint_type(structure_out, name)
 
     implicit none

     integer, pointer :: structure_out(:,:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1, n2
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 2) then
         read(in_cpo, *) n1, n2
         allocate(structure_out(n1, n2))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_matint_type

   subroutine read_type_veccplx_type(structure_out, name)
 
     implicit none

     complex(euitm_r8), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_veccplx_type

   subroutine read_type_vecflt_type(structure_out, name)
 
     implicit none

     real(euitm_r8), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_vecflt_type

   subroutine read_type_vecint_type(structure_out, name)
 
     implicit none

     integer, pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, *) structure_out
       
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_vecint_type

   subroutine read_type_vecstring_type(structure_out, name)
 
     implicit none

     character(len = 132), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i
 
     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if
       
       read(in_cpo, "(a132)") structure_out
       call convert_linebreaks(structure_out, .false.)
       if (verbose > 0) &
        write(iu6, *) 'read ', trim(adjustl(name))
     end if
 
   end subroutine read_type_vecstring_type

   subroutine read_type_amns(structure_out, name)

     implicit none

     type (type_amns), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%version, trim(adjustl(name)) // '%version')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_arr_type_amns_processType(structure_out%process, trim(adjustl(name)) // '%process')
     call read_arr_type_tables(structure_out%tables, trim(adjustl(name)) // '%tables')
     call read_arr_type_tables_coord(structure_out%tables_coord, trim(adjustl(name)) // '%tables_coord')
     call read_arr_type_version_ind(structure_out%version_ind, trim(adjustl(name)) // '%version_ind')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_amns

   subroutine read_arr_type_amns(structure_out, name)

     implicit none

     type (type_amns), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_amns(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_amns

   subroutine read_type_antennas(structure_out, name)

     implicit none

     type (type_antennas), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_antenna_ec(structure_out%antenna_ec, trim(adjustl(name)) // '%antenna_ec')
     call read_arr_type_antenna_ic(structure_out%antenna_ic, trim(adjustl(name)) // '%antenna_ic')
     call read_arr_type_antenna_lh(structure_out%antenna_lh, trim(adjustl(name)) // '%antenna_lh')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_antennas

   subroutine read_arr_type_antennas(structure_out, name)

     implicit none

     type (type_antennas), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_antennas(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_antennas

   subroutine read_type_bb_shield(structure_out, name)

     implicit none

     type (type_bb_shield), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_limits(structure_out%limits, trim(adjustl(name)) // '%limits')
     call read_type_float(structure_out%li6_enrich, trim(adjustl(name)) // '%li6_enrich')
     call read_type_geom(structure_out%geom, trim(adjustl(name)) // '%geom')
     call read_type_neut_results(structure_out%neut_results, trim(adjustl(name)) // '%neut_results')
     call read_type_shield(structure_out%shield, trim(adjustl(name)) // '%shield')
     call read_type_bb(structure_out%bb, trim(adjustl(name)) // '%bb')
     call read_type_hcll(structure_out%hcll, trim(adjustl(name)) // '%hcll')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_bb_shield

   subroutine read_arr_type_bb_shield(structure_out, name)

     implicit none

     type (type_bb_shield), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_bb_shield(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_bb_shield

   subroutine read_type_compositionc(structure_out, name)

     implicit none

     type (type_compositionc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_compositionc

   subroutine read_arr_type_compositionc(structure_out, name)

     implicit none

     type (type_compositionc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_compositionc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_compositionc

   subroutine read_type_coredelta(structure_out, name)

     implicit none

     type (type_coredelta), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_arr_type_coredelta_values(structure_out%values, trim(adjustl(name)) // '%values')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_coredelta

   subroutine read_arr_type_coredelta(structure_out, name)

     implicit none

     type (type_coredelta), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coredelta(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coredelta

   subroutine read_type_corefast(structure_out, name)

     implicit none

     type (type_corefast), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')
     call read_arr_type_corefast_values(structure_out%values, trim(adjustl(name)) // '%values')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_corefast

   subroutine read_arr_type_corefast(structure_out, name)

     implicit none

     type (type_corefast), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefast(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefast

   subroutine read_type_coreimpur(structure_out, name)

     implicit none

     type (type_coreimpur), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecint_type(structure_out%flag, trim(adjustl(name)) // '%flag')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_vecstring_type(structure_out%atomic_data, trim(adjustl(name)) // '%atomic_data')
     call read_arr_type_impurity_type(structure_out%impurity, trim(adjustl(name)) // '%impurity')
     call read_type_coreimpurediag_type(structure_out%diagnostic, trim(adjustl(name)) // '%diagnostic')
     call read_type_coreimpurediag_sum(structure_out%diagnosticsum, trim(adjustl(name)) // '%diagnosticsum')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_coreimpur

   subroutine read_arr_type_coreimpur(structure_out, name)

     implicit none

     type (type_coreimpur), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpur(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpur

   subroutine read_type_coreneutrals(structure_out, name)

     implicit none

     type (type_coreneutrals), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_composition_neutrals(structure_out%neutcompo, trim(adjustl(name)) // '%neutcompo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_arr_type_neutral_complex_type(structure_out%profiles, trim(adjustl(name)) // '%profiles')
     call read_arr_type_coefficients_neutrals(structure_out%ioncoeff, trim(adjustl(name)) // '%ioncoeff')
     call read_arr_type_impcoeff(structure_out%impcoeff, trim(adjustl(name)) // '%impcoeff')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_coreneutrals

   subroutine read_arr_type_coreneutrals(structure_out, name)

     implicit none

     type (type_coreneutrals), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreneutrals(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreneutrals

   subroutine read_type_coreprof(structure_out, name)

     implicit none

     type (type_coreprof), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%drho_dt, trim(adjustl(name)) // '%drho_dt')
     call read_type_toroid_field(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_psi(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_corefield(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_corefieldion(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_corefield(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_corefieldion(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_corefieldion(structure_out%vtor, trim(adjustl(name)) // '%vtor')
     call read_type_profiles1d(structure_out%profiles1d, trim(adjustl(name)) // '%profiles1d')
     call read_type_globalparam(structure_out%globalparam, trim(adjustl(name)) // '%globalparam')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_coreprof

   subroutine read_arr_type_coreprof(structure_out, name)

     implicit none

     type (type_coreprof), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreprof(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreprof

   subroutine read_type_coresource(structure_out, name)

     implicit none

     type (type_coresource), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')
     call read_arr_type_coresource_values(structure_out%values, trim(adjustl(name)) // '%values')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_coresource

   subroutine read_arr_type_coresource(structure_out, name)

     implicit none

     type (type_coresource), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coresource(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coresource

   subroutine read_type_coretransp(structure_out, name)

     implicit none

     type (type_coretransp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_arr_type_coretransp_values(structure_out%values, trim(adjustl(name)) // '%values')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_coretransp

   subroutine read_arr_type_coretransp(structure_out, name)

     implicit none

     type (type_coretransp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coretransp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coretransp

   subroutine read_type_cxdiag(structure_out, name)

     implicit none

     type (type_cxdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_cxsetup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_cxmeasure(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_cxdiag

   subroutine read_arr_type_cxdiag(structure_out, name)

     implicit none

     type (type_cxdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_cxdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_cxdiag

   subroutine read_type_distribution(structure_out, name)

     implicit none

     type (type_distribution), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_arr_type_distri_vec(structure_out%distri_vec, trim(adjustl(name)) // '%distri_vec')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_distribution

   subroutine read_arr_type_distribution(structure_out, name)

     implicit none

     type (type_distribution), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distribution(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distribution

   subroutine read_type_distsource(structure_out, name)

     implicit none

     type (type_distsource), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_arr_type_distsource_source(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_distsource

   subroutine read_arr_type_distsource(structure_out, name)

     implicit none

     type (type_distsource), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distsource(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distsource

   subroutine read_type_ecediag(structure_out, name)

     implicit none

     type (type_ecediag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_ecesetup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_ecemeasure(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_ecediag

   subroutine read_arr_type_ecediag(structure_out, name)

     implicit none

     type (type_ecediag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ecediag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ecediag

   subroutine read_type_edge(structure_out, name)

     implicit none

     type (type_edge), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_complexgrid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_arr_type_species_desc(structure_out%species, trim(adjustl(name)) // '%species')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_edge_fluid(structure_out%fluid, trim(adjustl(name)) // '%fluid')
     call read_type_edge_kinetic(structure_out%kinetic, trim(adjustl(name)) // '%kinetic')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_edge

   subroutine read_arr_type_edge(structure_out, name)

     implicit none

     type (type_edge), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge

   subroutine read_type_efcc(structure_out, name)

     implicit none

     type (type_efcc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_coil(structure_out%coil, trim(adjustl(name)) // '%coil')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_efcc

   subroutine read_arr_type_efcc(structure_out, name)

     implicit none

     type (type_efcc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_efcc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_efcc

   subroutine read_type_equilibrium(structure_out, name)

     implicit none

     type (type_equilibrium), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_eqconstraint(structure_out%eqconstraint, trim(adjustl(name)) // '%eqconstraint')
     call read_type_eqgeometry(structure_out%eqgeometry, trim(adjustl(name)) // '%eqgeometry')
     call read_type_flush(structure_out%flush, trim(adjustl(name)) // '%flush')
     call read_type_global_param(structure_out%global_param, trim(adjustl(name)) // '%global_param')
     call read_type_profiles_1d(structure_out%profiles_1d, trim(adjustl(name)) // '%profiles_1d')
     call read_arr_type_equilibrium_profiles_2d(structure_out%profiles_2d, trim(adjustl(name)) // '%profiles_2d')
     call read_type_coord_sys(structure_out%coord_sys, trim(adjustl(name)) // '%coord_sys')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_equilibrium

   subroutine read_arr_type_equilibrium(structure_out, name)

     implicit none

     type (type_equilibrium), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_equilibrium(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_equilibrium

   subroutine read_type_fusiondiag(structure_out, name)

     implicit none

     type (type_fusiondiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_fusiondiag_fus_product(structure_out%fus_product, trim(adjustl(name)) // '%fus_product')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_fusiondiag

   subroutine read_arr_type_fusiondiag(structure_out, name)

     implicit none

     type (type_fusiondiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag

   subroutine read_type_halphadiag(structure_out, name)

     implicit none

     type (type_halphadiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_halpha_setup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_exp1D(structure_out%intensity, trim(adjustl(name)) // '%intensity')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_halphadiag

   subroutine read_arr_type_halphadiag(structure_out, name)

     implicit none

     type (type_halphadiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_halphadiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_halphadiag

   subroutine read_type_heat_sources(structure_out, name)

     implicit none

     type (type_heat_sources), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_calorimetry_heat_source(structure_out%sources, trim(adjustl(name)) // '%sources')
     call read_arr_type_calorimetry_heat_source(structure_out%sinks, trim(adjustl(name)) // '%sinks')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_heat_sources

   subroutine read_arr_type_heat_sources(structure_out, name)

     implicit none

     type (type_heat_sources), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_heat_sources(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_heat_sources

   subroutine read_type_interfdiag(structure_out, name)

     implicit none

     type (type_interfdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%expression, trim(adjustl(name)) // '%expression')
     call read_type_setup_line(structure_out%setup_line, trim(adjustl(name)) // '%setup_line')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_interfdiag

   subroutine read_arr_type_interfdiag(structure_out, name)

     implicit none

     type (type_interfdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_interfdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_interfdiag

   subroutine read_type_ironmodel(structure_out, name)

     implicit none

     type (type_ironmodel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_desc_iron(structure_out%desc_iron, trim(adjustl(name)) // '%desc_iron')
     call read_type_magnetise(structure_out%magnetise, trim(adjustl(name)) // '%magnetise')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_ironmodel

   subroutine read_arr_type_ironmodel(structure_out, name)

     implicit none

     type (type_ironmodel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ironmodel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ironmodel

   subroutine read_type_langmuirdiag(structure_out, name)

     implicit none

     type (type_langmuirdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_lang_measure(structure_out%potential, trim(adjustl(name)) // '%potential')
     call read_type_lang_measure(structure_out%bias, trim(adjustl(name)) // '%bias')
     call read_type_lang_measure(structure_out%jsat, trim(adjustl(name)) // '%jsat')
     call read_type_lang_derived(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_lang_derived(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_lang_derived(structure_out%machpar, trim(adjustl(name)) // '%machpar')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_langmuirdiag

   subroutine read_arr_type_langmuirdiag(structure_out, name)

     implicit none

     type (type_langmuirdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_langmuirdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_langmuirdiag

   subroutine read_type_launchs(structure_out, name)

     implicit none

     type (type_launchs), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_vecint_type(structure_out%mode, trim(adjustl(name)) // '%mode')
     call read_type_rzphi1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_spectrum(structure_out%spectrum, trim(adjustl(name)) // '%spectrum')
     call read_type_launchs_rfbeam(structure_out%beam, trim(adjustl(name)) // '%beam')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_launchs

   subroutine read_arr_type_launchs(structure_out, name)

     implicit none

     type (type_launchs), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchs(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchs

   subroutine read_type_lithiumdiag(structure_out, name)

     implicit none

     type (type_lithiumdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_lithsetup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_lithmeasure(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_lithiumdiag

   subroutine read_arr_type_lithiumdiag(structure_out, name)

     implicit none

     type (type_lithiumdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_lithiumdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_lithiumdiag

   subroutine read_type_magdiag(structure_out, name)

     implicit none

     type (type_magdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_exp0D(structure_out%ip, trim(adjustl(name)) // '%ip')
     call read_type_exp0D(structure_out%diamagflux, trim(adjustl(name)) // '%diamagflux')
     call read_type_exp0D(structure_out%diamagener, trim(adjustl(name)) // '%diamagener')
     call read_type_flux_loops(structure_out%flux_loops, trim(adjustl(name)) // '%flux_loops')
     call read_type_bpol_probes(structure_out%bpol_probes, trim(adjustl(name)) // '%bpol_probes')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_magdiag

   subroutine read_arr_type_magdiag(structure_out, name)

     implicit none

     type (type_magdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_magdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_magdiag

   subroutine read_type_mhd(structure_out, name)

     implicit none

     type (type_mhd), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')
     call read_arr_type_mhd_mode(structure_out%n, trim(adjustl(name)) // '%n')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_mhd

   subroutine read_arr_type_mhd(structure_out, name)

     implicit none

     type (type_mhd), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd

   subroutine read_type_msediag(structure_out, name)

     implicit none

     type (type_msediag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_polarimetry(structure_out%polarimetry, trim(adjustl(name)) // '%polarimetry')
     call read_type_spectral(structure_out%spectral, trim(adjustl(name)) // '%spectral')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_msediag

   subroutine read_arr_type_msediag(structure_out, name)

     implicit none

     type (type_msediag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag

   subroutine read_type_nbi(structure_out, name)

     implicit none

     type (type_nbi), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_nbi_unit(structure_out%nbi_unit, trim(adjustl(name)) // '%nbi_unit')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_nbi

   subroutine read_arr_type_nbi(structure_out, name)

     implicit none

     type (type_nbi), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_nbi(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_nbi

   subroutine read_type_neoclassic(structure_out, name)

     implicit none

     type (type_neoclassic), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_desc_impur(structure_out%desc_impur, trim(adjustl(name)) // '%desc_impur')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_transcoefion(structure_out%ni_neo, trim(adjustl(name)) // '%ni_neo')
     call read_type_transcoefel(structure_out%ne_neo, trim(adjustl(name)) // '%ne_neo')
     call read_arr_type_transcoefimp(structure_out%nz_neo, trim(adjustl(name)) // '%nz_neo')
     call read_type_transcoefion(structure_out%ti_neo, trim(adjustl(name)) // '%ti_neo')
     call read_type_transcoefel(structure_out%te_neo, trim(adjustl(name)) // '%te_neo')
     call read_arr_type_transcoefimp(structure_out%tz_neo, trim(adjustl(name)) // '%tz_neo')
     call read_type_transcoefel(structure_out%mtor_neo, trim(adjustl(name)) // '%mtor_neo')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_vecflt_type(structure_out%jboot, trim(adjustl(name)) // '%jboot')
     call read_type_vecflt_type(structure_out%er, trim(adjustl(name)) // '%er')
     call read_type_matflt_type(structure_out%vpol, trim(adjustl(name)) // '%vpol')
     call read_type_matflt_type(structure_out%vtor, trim(adjustl(name)) // '%vtor')
     call read_type_matflt_type(structure_out%mach, trim(adjustl(name)) // '%mach')
     call read_type_vecflt_type(structure_out%utheta_e, trim(adjustl(name)) // '%utheta_e')
     call read_type_matflt_type(structure_out%utheta_i, trim(adjustl(name)) // '%utheta_i')
     call read_type_matflt_type(structure_out%viscosity_par, trim(adjustl(name)) // '%viscosity_par')
     call read_arr_type_neoclassic_impurity(structure_out%impurity, trim(adjustl(name)) // '%impurity')
     call read_type_array3dflt_type(structure_out%fext, trim(adjustl(name)) // '%fext')
     call read_type_vecflt_type(structure_out%jext, trim(adjustl(name)) // '%jext')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_neoclassic

   subroutine read_arr_type_neoclassic(structure_out, name)

     implicit none

     type (type_neoclassic), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_neoclassic(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_neoclassic

   subroutine read_type_ntm(structure_out, name)

     implicit none

     type (type_ntm), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_ntm_mode(structure_out%mode, trim(adjustl(name)) // '%mode')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_ntm

   subroutine read_arr_type_ntm(structure_out, name)

     implicit none

     type (type_ntm), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm

   subroutine read_type_orbit(structure_out, name)

     implicit none

     type (type_orbit), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_com(structure_out%com, trim(adjustl(name)) // '%com')
     call read_type_trace(structure_out%trace, trim(adjustl(name)) // '%trace')
     call read_type_orbit_global_param(structure_out%global_param, trim(adjustl(name)) // '%global_param')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_orbit

   subroutine read_arr_type_orbit(structure_out, name)

     implicit none

     type (type_orbit), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_orbit(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_orbit

   subroutine read_type_pellets(structure_out, name)

     implicit none

     type (type_pellets), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_arr_type_pellet(structure_out%pellet, trim(adjustl(name)) // '%pellet')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_pellets

   subroutine read_arr_type_pellets(structure_out, name)

     implicit none

     type (type_pellets), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellets(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellets

   subroutine read_type_pfsystems(structure_out, name)

     implicit none

     type (type_pfsystems), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_pfcoils(structure_out%pfcoils, trim(adjustl(name)) // '%pfcoils')
     call read_type_pfpassive(structure_out%pfpassive, trim(adjustl(name)) // '%pfpassive')
     call read_type_pfcircuits(structure_out%pfcircuits, trim(adjustl(name)) // '%pfcircuits')
     call read_type_pfsupplies(structure_out%pfsupplies, trim(adjustl(name)) // '%pfsupplies')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_pfsystems

   subroutine read_arr_type_pfsystems(structure_out, name)

     implicit none

     type (type_pfsystems), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfsystems(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfsystems

   subroutine read_type_polardiag(structure_out, name)

     implicit none

     type (type_polardiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%expression, trim(adjustl(name)) // '%expression')
     call read_type_setup_line(structure_out%setup_line, trim(adjustl(name)) // '%setup_line')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_polardiag

   subroutine read_arr_type_polardiag(structure_out, name)

     implicit none

     type (type_polardiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_polardiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_polardiag

   subroutine read_type_power_conv(structure_out, name)

     implicit none

     type (type_power_conv), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%cycle_type, trim(adjustl(name)) // '%cycle_type')
     call read_arr_type_circuits(structure_out%circuits, trim(adjustl(name)) // '%circuits')
     call read_type_float(structure_out%power_recirc, trim(adjustl(name)) // '%power_recirc')
     call read_type_float(structure_out%power_net, trim(adjustl(name)) // '%power_net')
     call read_type_float(structure_out%power_int, trim(adjustl(name)) // '%power_int')
     call read_type_float(structure_out%efficiency, trim(adjustl(name)) // '%efficiency')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_power_conv

   subroutine read_arr_type_power_conv(structure_out, name)

     implicit none

     type (type_power_conv), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_power_conv(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_power_conv

   subroutine read_type_reflectomet(structure_out, name)

     implicit none

     type (type_reflectomet), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_refl_receive(structure_out%refl_receive, trim(adjustl(name)) // '%refl_receive')
     call read_arr_type_reflectometry_antennas(structure_out%antennas, trim(adjustl(name)) // '%antennas')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_reflectomet

   subroutine read_arr_type_reflectomet(structure_out, name)

     implicit none

     type (type_reflectomet), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reflectomet(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reflectomet

   subroutine read_type_rfadiag(structure_out, name)

     implicit none

     type (type_rfadiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_rfasetup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_rfameasure(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_rfadiag

   subroutine read_arr_type_rfadiag(structure_out, name)

     implicit none

     type (type_rfadiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rfadiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rfadiag

   subroutine read_type_sawteeth(structure_out, name)

     implicit none

     type (type_sawteeth), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_integer(structure_out%crash_trig, trim(adjustl(name)) // '%crash_trig')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_sawteeth_profiles1d(structure_out%profiles1d, trim(adjustl(name)) // '%profiles1d')
     call read_type_sawteeth_diags(structure_out%diags, trim(adjustl(name)) // '%diags')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_sawteeth

   subroutine read_arr_type_sawteeth(structure_out, name)

     implicit none

     type (type_sawteeth), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sawteeth(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sawteeth

   subroutine read_type_scenario(structure_out, name)

     implicit none

     type (type_scenario), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_scenario_centre(structure_out%centre, trim(adjustl(name)) // '%centre')
     call read_type_scenario_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_scenario_configuration(structure_out%configs, trim(adjustl(name)) // '%configs')
     call read_type_scenario_confinement(structure_out%confinement, trim(adjustl(name)) // '%confinement')
     call read_type_scenario_currents(structure_out%currents, trim(adjustl(name)) // '%currents')
     call read_type_scenario_edge(structure_out%edge, trim(adjustl(name)) // '%edge')
     call read_type_scenario_energy(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_eqgeometry(structure_out%eqgeometry, trim(adjustl(name)) // '%eqgeometry')
     call read_type_scenario_global(structure_out%global_param, trim(adjustl(name)) // '%global_param')
     call read_type_scenario_heat_power(structure_out%heat_power, trim(adjustl(name)) // '%heat_power')
     call read_type_scenario_itb(structure_out%itb, trim(adjustl(name)) // '%itb')
     call read_type_scenario_lim_div_wall(structure_out%lim_div_wall, trim(adjustl(name)) // '%lim_div_wall')
     call read_type_scenario_line_ave(structure_out%line_ave, trim(adjustl(name)) // '%line_ave')
     call read_type_scenario_neutron(structure_out%neutron, trim(adjustl(name)) // '%neutron')
     call read_type_scenario_ninety_five(structure_out%ninety_five, trim(adjustl(name)) // '%ninety_five')
     call read_type_scenario_pedestal(structure_out%pedestal, trim(adjustl(name)) // '%pedestal')
     call read_type_scenario_references(structure_out%references, trim(adjustl(name)) // '%references')
     call read_type_scenario_reactor(structure_out%reactor, trim(adjustl(name)) // '%reactor')
     call read_type_scenario_sol(structure_out%sol, trim(adjustl(name)) // '%sol')
     call read_type_scenario_vol_ave(structure_out%vol_ave, trim(adjustl(name)) // '%vol_ave')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_scenario

   subroutine read_arr_type_scenario(structure_out, name)

     implicit none

     type (type_scenario), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario

   subroutine read_type_solcurdiag(structure_out, name)

     implicit none

     type (type_solcurdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_solcurdiag_sol_current(structure_out%sol_current, trim(adjustl(name)) // '%sol_current')
     call read_arr_type_clusters(structure_out%clusters, trim(adjustl(name)) // '%clusters')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_solcurdiag

   subroutine read_arr_type_solcurdiag(structure_out, name)

     implicit none

     type (type_solcurdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_solcurdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_solcurdiag

   subroutine read_type_temporary(structure_out, name)

     implicit none

     type (type_temporary), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_temporary_nt(structure_out%non_timed, trim(adjustl(name)) // '%non_timed')
     call read_type_temporary_t(structure_out%timed, trim(adjustl(name)) // '%timed')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_temporary

   subroutine read_arr_type_temporary(structure_out, name)

     implicit none

     type (type_temporary), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary

   subroutine read_type_topinfo(structure_out, name)

     implicit none

     type (type_topinfo), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%dataprovider, trim(adjustl(name)) // '%dataprovider')
     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')
     call read_type_vecstring_type(structure_out%firstputdate, trim(adjustl(name)) // '%firstputdate')
     call read_type_vecstring_type(structure_out%lastupdate, trim(adjustl(name)) // '%lastupdate')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecstring_type(structure_out%comment, trim(adjustl(name)) // '%comment')
     call read_type_vecstring_type(structure_out%dataversion, trim(adjustl(name)) // '%dataversion')
     call read_type_vecstring_type(structure_out%workflow, trim(adjustl(name)) // '%workflow')
     call read_type_entry_def(structure_out%entry, trim(adjustl(name)) // '%entry')
     call read_type_entry_def(structure_out%parent_entry, trim(adjustl(name)) // '%parent_entry')
     call read_type_mdinfo(structure_out%mdinfo, trim(adjustl(name)) // '%mdinfo')

   end subroutine read_type_topinfo

   subroutine read_arr_type_topinfo(structure_out, name)

     implicit none

     type (type_topinfo), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_topinfo(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_topinfo

   subroutine read_type_toroidfield(structure_out, name)

     implicit none

     type (type_toroidfield), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_tf_desc_tfcoils(structure_out%desc_tfcoils, trim(adjustl(name)) // '%desc_tfcoils')
     call read_type_integer(structure_out%nturns, trim(adjustl(name)) // '%nturns')
     call read_type_integer(structure_out%ncoils, trim(adjustl(name)) // '%ncoils')
     call read_type_exp0D(structure_out%current, trim(adjustl(name)) // '%current')
     call read_type_exp0D(structure_out%bvac_r, trim(adjustl(name)) // '%bvac_r')
     call read_type_float(structure_out%r0, trim(adjustl(name)) // '%r0')
     call read_type_float(structure_out%p_cryo, trim(adjustl(name)) // '%p_cryo')
     call read_type_float(structure_out%wp_nh_max, trim(adjustl(name)) // '%wp_nh_max')
     call read_type_float(structure_out%tfc_nh, trim(adjustl(name)) // '%tfc_nh')
     call read_type_float(structure_out%neut_flux_inb, trim(adjustl(name)) // '%neut_flux_inb')
     call read_type_float(structure_out%neut_flux_outb, trim(adjustl(name)) // '%neut_flux_outb')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_toroidfield

   subroutine read_arr_type_toroidfield(structure_out, name)

     implicit none

     type (type_toroidfield), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_toroidfield(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_toroidfield

   subroutine read_type_tsdiag(structure_out, name)

     implicit none

     type (type_tsdiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_tssetup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_tsmeasure(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_tsdiag

   subroutine read_arr_type_tsdiag(structure_out, name)

     implicit none

     type (type_tsdiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tsdiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tsdiag

   subroutine read_type_turbulence(structure_out, name)

     implicit none

     type (type_turbulence), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_turbcomposition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_turbcoordsys(structure_out%coordsys, trim(adjustl(name)) // '%coordsys')
     call read_type_turbvar0d(structure_out%var0d, trim(adjustl(name)) // '%var0d')
     call read_type_turbvar1d(structure_out%var1d, trim(adjustl(name)) // '%var1d')
     call read_type_turbvar2d(structure_out%var2d, trim(adjustl(name)) // '%var2d')
     call read_type_turbvar3d(structure_out%var3d, trim(adjustl(name)) // '%var3d')
     call read_type_turbvar4d(structure_out%var4d, trim(adjustl(name)) // '%var4d')
     call read_type_turbvar5d(structure_out%var5d, trim(adjustl(name)) // '%var5d')
     call read_type_turbspec1d(structure_out%spec1d, trim(adjustl(name)) // '%spec1d')
     call read_type_turbenv1d(structure_out%env1d, trim(adjustl(name)) // '%env1d')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_turbulence

   subroutine read_arr_type_turbulence(structure_out, name)

     implicit none

     type (type_turbulence), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbulence(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbulence

   subroutine read_type_wall(structure_out, name)

     implicit none

     type (type_wall), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_wall_wall0d(structure_out%wall0d, trim(adjustl(name)) // '%wall0d')
     call read_type_wall2d_mhd(structure_out%wall2d_mhd, trim(adjustl(name)) // '%wall2d_mhd')
     call read_arr_type_wall2d(structure_out%wall2d, trim(adjustl(name)) // '%wall2d')
     call read_arr_type_wall3d(structure_out%wall3d, trim(adjustl(name)) // '%wall3d')
     call read_arr_type_wall_types(structure_out%wall_types, trim(adjustl(name)) // '%wall_types')
     call read_arr_type_compound_desc(structure_out%compounds, trim(adjustl(name)) // '%compounds')
     call read_arr_type_element_desc(structure_out%elements, trim(adjustl(name)) // '%elements')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_wall

   subroutine read_arr_type_wall(structure_out, name)

     implicit none

     type (type_wall), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall

   subroutine read_type_waves(structure_out, name)

     implicit none

     type (type_waves), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_arr_type_coherentwave(structure_out%coherentwave, trim(adjustl(name)) // '%coherentwave')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_waves

   subroutine read_arr_type_waves(structure_out, name)

     implicit none

     type (type_waves), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves

   subroutine read_type_amns_constituentType(structure_out, name)

     implicit none

     type (type_amns_constituentType), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_type_integer(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_integer(structure_out%mn, trim(adjustl(name)) // '%mn')
     call read_type_float(structure_out%multiplicity, trim(adjustl(name)) // '%multiplicity')

   end subroutine read_type_amns_constituentType

   subroutine read_arr_type_amns_constituentType(structure_out, name)
 
     implicit none
 
     type (type_amns_constituentType), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_amns_constituentType(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_amns_constituentType

   subroutine read_type_amns_processType(structure_out, name)

     implicit none

     type (type_amns_processType), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%proc_label, trim(adjustl(name)) // '%proc_label')
     call read_arr_type_reacprodType(structure_out%reactant, trim(adjustl(name)) // '%reactant')
     call read_arr_type_reacprodType(structure_out%product, trim(adjustl(name)) // '%product')
     call read_type_vecstring_type(structure_out%sup_string, trim(adjustl(name)) // '%sup_string')
     call read_type_vecflt_type(structure_out%sup_real, trim(adjustl(name)) // '%sup_real')
     call read_type_vecint_type(structure_out%sup_int, trim(adjustl(name)) // '%sup_int')
     call read_type_identifier(structure_out%quality, trim(adjustl(name)) // '%quality')
     call read_type_vecstring_type(structure_out%err_proc_label, trim(adjustl(name)) // '%err_proc_label')

   end subroutine read_type_amns_processType

   subroutine read_arr_type_amns_processType(structure_out, name)
 
     implicit none
 
     type (type_amns_processType), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_amns_processType(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_amns_processType

   subroutine read_type_antenna_ec(structure_out, name)

     implicit none

     type (type_antenna_ec), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_exp0D(structure_out%power, trim(adjustl(name)) // '%power')
     call read_type_integer(structure_out%mode, trim(adjustl(name)) // '%mode')
     call read_type_rzphi0D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_launchangles(structure_out%launchangles, trim(adjustl(name)) // '%launchangles')
     call read_type_rfbeam(structure_out%beam, trim(adjustl(name)) // '%beam')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_antenna_ec

   subroutine read_arr_type_antenna_ec(structure_out, name)
 
     implicit none
 
     type (type_antenna_ec), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_antenna_ec(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_antenna_ec

   subroutine read_type_antenna_ic(structure_out, name)

     implicit none

     type (type_antenna_ic), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_exp0D(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_exp0D(structure_out%power, trim(adjustl(name)) // '%power')
     call read_type_vecint_type(structure_out%ntor, trim(adjustl(name)) // '%ntor')
     call read_type_vecflt_type(structure_out%power_ntor, trim(adjustl(name)) // '%power_ntor')
     call read_type_antennaic_setup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_antenna_ic

   subroutine read_arr_type_antenna_ic(structure_out, name)
 
     implicit none
 
     type (type_antenna_ic), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_antenna_ic(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_antenna_ic

   subroutine read_type_antenna_lh(structure_out, name)

     implicit none

     type (type_antenna_lh), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_exp0D(structure_out%power, trim(adjustl(name)) // '%power')
     call read_type_float(structure_out%n_par, trim(adjustl(name)) // '%n_par')
     call read_type_rzphi0D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_antennalh_setup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_plasmaedge(structure_out%plasmaedge, trim(adjustl(name)) // '%plasmaedge')
     call read_type_rfbeam(structure_out%beam, trim(adjustl(name)) // '%beam')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_antenna_lh

   subroutine read_arr_type_antenna_lh(structure_out, name)
 
     implicit none
 
     type (type_antenna_lh), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_antenna_lh(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_antenna_lh

   subroutine read_type_antennaic_setup(structure_out, name)

     implicit none

     type (type_antennaic_setup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_straps(structure_out%straps, trim(adjustl(name)) // '%straps')
     call read_type_current(structure_out%current, trim(adjustl(name)) // '%current')

   end subroutine read_type_antennaic_setup

   subroutine read_arr_type_antennaic_setup(structure_out, name)
 
     implicit none
 
     type (type_antennaic_setup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_antennaic_setup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_antennaic_setup

   subroutine read_type_antennalh_setup(structure_out, name)

     implicit none

     type (type_antennalh_setup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_modules(structure_out%modules, trim(adjustl(name)) // '%modules')

   end subroutine read_type_antennalh_setup

   subroutine read_arr_type_antennalh_setup(structure_out, name)
 
     implicit none
 
     type (type_antennalh_setup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_antennalh_setup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_antennalh_setup

   subroutine read_type_b0r0(structure_out, name)

     implicit none

     type (type_b0r0), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%r0, trim(adjustl(name)) // '%r0')
     call read_type_float(structure_out%b0, trim(adjustl(name)) // '%b0')

   end subroutine read_type_b0r0

   subroutine read_arr_type_b0r0(structure_out, name)
 
     implicit none
 
     type (type_b0r0), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_b0r0(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_b0r0

   subroutine read_type_bb(structure_out, name)

     implicit none

     type (type_bb), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%nb_bb, trim(adjustl(name)) // '%nb_bb')
     call read_type_float(structure_out%nb_bb_polcut, trim(adjustl(name)) // '%nb_bb_polcut')
     call read_type_float(structure_out%teta_bb, trim(adjustl(name)) // '%teta_bb')
     call read_type_float(structure_out%tbr, trim(adjustl(name)) // '%tbr')
     call read_type_neutro_resul(structure_out%neutro_resul, trim(adjustl(name)) // '%neutro_resul')
     call read_type_bb_specs(structure_out%inboard, trim(adjustl(name)) // '%inboard')
     call read_type_bb_specs(structure_out%outboard, trim(adjustl(name)) // '%outboard')

   end subroutine read_type_bb

   subroutine read_arr_type_bb(structure_out, name)
 
     implicit none
 
     type (type_bb), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_bb(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_bb

   subroutine read_type_bb_dimension(structure_out, name)

     implicit none

     type (type_bb_dimension), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%radial, trim(adjustl(name)) // '%radial')
     call read_type_vecflt_type(structure_out%toroidal, trim(adjustl(name)) // '%toroidal')
     call read_type_vecflt_type(structure_out%poloidal, trim(adjustl(name)) // '%poloidal')

   end subroutine read_type_bb_dimension

   subroutine read_arr_type_bb_dimension(structure_out, name)
 
     implicit none
 
     type (type_bb_dimension), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_bb_dimension(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_bb_dimension

   subroutine read_type_bb_geometry(structure_out, name)

     implicit none

     type (type_bb_geometry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%dr_fw, trim(adjustl(name)) // '%dr_fw')
     call read_type_float(structure_out%dr_bz, trim(adjustl(name)) // '%dr_bz')
     call read_type_float(structure_out%dr_bp, trim(adjustl(name)) // '%dr_bp')
     call read_type_vecflt_type(structure_out%dr_bp_plates, trim(adjustl(name)) // '%dr_bp_plates')
     call read_type_vecflt_type(structure_out%dr_bp_he, trim(adjustl(name)) // '%dr_bp_he')
     call read_type_float(structure_out%dr_man, trim(adjustl(name)) // '%dr_man')
     call read_type_float(structure_out%dt_sw, trim(adjustl(name)) // '%dt_sw')
     call read_type_float(structure_out%dt_bz, trim(adjustl(name)) // '%dt_bz')
     call read_type_float(structure_out%dp_bz, trim(adjustl(name)) // '%dp_bz')
     call read_type_bb_dimension(structure_out%top_cap_dim, trim(adjustl(name)) // '%top_cap_dim')
     call read_type_bb_dimension(structure_out%bot_cap_dim, trim(adjustl(name)) // '%bot_cap_dim')
     call read_type_float(structure_out%a_fw_ch, trim(adjustl(name)) // '%a_fw_ch')
     call read_type_float(structure_out%b_fw_ch, trim(adjustl(name)) // '%b_fw_ch')
     call read_type_float(structure_out%td_tc_ch, trim(adjustl(name)) // '%td_tc_ch')
     call read_type_float(structure_out%rd_tc_ch, trim(adjustl(name)) // '%rd_tc_ch')
     call read_type_float(structure_out%td_bc_ch, trim(adjustl(name)) // '%td_bc_ch')
     call read_type_float(structure_out%rd_bc_ch, trim(adjustl(name)) // '%rd_bc_ch')
     call read_type_float(structure_out%n_fw_ch, trim(adjustl(name)) // '%n_fw_ch')
     call read_type_float(structure_out%n_fw_circ, trim(adjustl(name)) // '%n_fw_circ')
     call read_type_float(structure_out%a_sg_ch, trim(adjustl(name)) // '%a_sg_ch')
     call read_type_float(structure_out%b_sg_ch, trim(adjustl(name)) // '%b_sg_ch')
     call read_type_float(structure_out%n_sg_ch, trim(adjustl(name)) // '%n_sg_ch')
     call read_type_float(structure_out%sg_thick, trim(adjustl(name)) // '%sg_thick')
     call read_type_float(structure_out%sg_weld, trim(adjustl(name)) // '%sg_weld')
     call read_type_float(structure_out%sg_in_out, trim(adjustl(name)) // '%sg_in_out')
     call read_type_float(structure_out%r_sg_cp, trim(adjustl(name)) // '%r_sg_cp')
     call read_type_float(structure_out%cp_tor_gap, trim(adjustl(name)) // '%cp_tor_gap')
     call read_type_float(structure_out%a_cp_ch, trim(adjustl(name)) // '%a_cp_ch')
     call read_type_float(structure_out%b_cp_ch, trim(adjustl(name)) // '%b_cp_ch')
     call read_type_float(structure_out%n_cp_ch, trim(adjustl(name)) // '%n_cp_ch')
     call read_type_float(structure_out%cp_thick, trim(adjustl(name)) // '%cp_thick')
     call read_type_float(structure_out%n_pol_bu, trim(adjustl(name)) // '%n_pol_bu')
     call read_type_float(structure_out%n_tor_bu, trim(adjustl(name)) // '%n_tor_bu')
     call read_type_float(structure_out%n_cp_bu, trim(adjustl(name)) // '%n_cp_bu')
     call read_type_float(structure_out%cp_in_out, trim(adjustl(name)) // '%cp_in_out')
     call read_type_float(structure_out%he_man_tck, trim(adjustl(name)) // '%he_man_tck')
     call read_type_float(structure_out%man_tck, trim(adjustl(name)) // '%man_tck')
     call read_type_float(structure_out%pbli_bptb_od, trim(adjustl(name)) // '%pbli_bptb_od')
     call read_type_float(structure_out%pbli_bptb_id, trim(adjustl(name)) // '%pbli_bptb_id')
     call read_type_float(structure_out%he_bptb_od, trim(adjustl(name)) // '%he_bptb_od')
     call read_type_float(structure_out%he_bptb_id, trim(adjustl(name)) // '%he_bptb_id')
     call read_type_float(structure_out%dr_max_fw, trim(adjustl(name)) // '%dr_max_fw')
     call read_type_float(structure_out%dr_fwpl, trim(adjustl(name)) // '%dr_fwpl')

   end subroutine read_type_bb_geometry

   subroutine read_arr_type_bb_geometry(structure_out, name)
 
     implicit none
 
     type (type_bb_geometry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_bb_geometry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_bb_geometry

   subroutine read_type_bb_specs(structure_out, name)

     implicit none

     type (type_bb_specs), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%nbb, trim(adjustl(name)) // '%nbb')
     call read_type_float(structure_out%r1, trim(adjustl(name)) // '%r1')
     call read_type_float(structure_out%r2, trim(adjustl(name)) // '%r2')
     call read_type_bb_dimension(structure_out%dimension, trim(adjustl(name)) // '%dimension')

   end subroutine read_type_bb_specs

   subroutine read_arr_type_bb_specs(structure_out, name)
 
     implicit none
 
     type (type_bb_specs), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_bb_specs(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_bb_specs

   subroutine read_type_beamletgroup(structure_out, name)

     implicit none

     type (type_beamletgroup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi0D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_float(structure_out%tang_rad, trim(adjustl(name)) // '%tang_rad')
     call read_type_float(structure_out%angle, trim(adjustl(name)) // '%angle')
     call read_type_integer(structure_out%direction, trim(adjustl(name)) // '%direction')
     call read_type_float(structure_out%width_horiz, trim(adjustl(name)) // '%width_horiz')
     call read_type_float(structure_out%width_vert, trim(adjustl(name)) // '%width_vert')
     call read_type_focussing(structure_out%focussing, trim(adjustl(name)) // '%focussing')
     call read_type_divergence(structure_out%divergence, trim(adjustl(name)) // '%divergence')
     call read_type_beamlets(structure_out%beamlets, trim(adjustl(name)) // '%beamlets')

   end subroutine read_type_beamletgroup

   subroutine read_arr_type_beamletgroup(structure_out, name)
 
     implicit none
 
     type (type_beamletgroup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_beamletgroup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_beamletgroup

   subroutine read_type_beamlets(structure_out, name)

     implicit none

     type (type_beamlets), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_vecflt_type(structure_out%tang_rad_blt, trim(adjustl(name)) // '%tang_rad_blt')
     call read_type_vecflt_type(structure_out%angle_blt, trim(adjustl(name)) // '%angle_blt')
     call read_type_vecflt_type(structure_out%pow_frc_blt, trim(adjustl(name)) // '%pow_frc_blt')

   end subroutine read_type_beamlets

   subroutine read_arr_type_beamlets(structure_out, name)
 
     implicit none
 
     type (type_beamlets), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_beamlets(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_beamlets

   subroutine read_type_beamtracing(structure_out, name)

     implicit none

     type (type_beamtracing), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%npoints, trim(adjustl(name)) // '%npoints')
     call read_type_float(structure_out%power, trim(adjustl(name)) // '%power')
     call read_type_vecflt_type(structure_out%dnpar, trim(adjustl(name)) // '%dnpar')
     call read_type_vecflt_type(structure_out%length, trim(adjustl(name)) // '%length')
     call read_type_waves_rtposition(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_waves_rtwavevector(structure_out%wavevector, trim(adjustl(name)) // '%wavevector')
     call read_type_polarization(structure_out%polarization, trim(adjustl(name)) // '%polarization')
     call read_type_powerflow(structure_out%powerflow, trim(adjustl(name)) // '%powerflow')

   end subroutine read_type_beamtracing

   subroutine read_arr_type_beamtracing(structure_out, name)
 
     implicit none
 
     type (type_beamtracing), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_beamtracing(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_beamtracing

   subroutine read_type_boundary(structure_out, name)

     implicit none

     type (type_boundary), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_float(structure_out%rho, trim(adjustl(name)) // '%rho')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_boundary

   subroutine read_arr_type_boundary(structure_out, name)
 
     implicit none
 
     type (type_boundary), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_boundary(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_boundary

   subroutine read_type_boundary_neutrals(structure_out, name)

     implicit none

     type (type_boundary_neutrals), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_integer(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_float(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')

   end subroutine read_type_boundary_neutrals

   subroutine read_arr_type_boundary_neutrals(structure_out, name)
 
     implicit none
 
     type (type_boundary_neutrals), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_boundary_neutrals(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_boundary_neutrals

   subroutine read_type_boundaryel(structure_out, name)

     implicit none

     type (type_boundaryel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_float(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')

   end subroutine read_type_boundaryel

   subroutine read_arr_type_boundaryel(structure_out, name)
 
     implicit none
 
     type (type_boundaryel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_boundaryel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_boundaryel

   subroutine read_type_boundaryimp(structure_out, name)

     implicit none

     type (type_boundaryimp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecint_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%rho, trim(adjustl(name)) // '%rho')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_boundaryimp

   subroutine read_arr_type_boundaryimp(structure_out, name)
 
     implicit none
 
     type (type_boundaryimp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_boundaryimp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_boundaryimp

   subroutine read_type_boundaryion(structure_out, name)

     implicit none

     type (type_boundaryion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecint_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')

   end subroutine read_type_boundaryion

   subroutine read_arr_type_boundaryion(structure_out, name)
 
     implicit none
 
     type (type_boundaryion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_boundaryion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_boundaryion

   subroutine read_type_bpol_probes(structure_out, name)

     implicit none

     type (type_bpol_probes), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_setup_bprobe(structure_out%setup_bprobe, trim(adjustl(name)) // '%setup_bprobe')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_bpol_probes

   subroutine read_arr_type_bpol_probes(structure_out, name)
 
     implicit none
 
     type (type_bpol_probes), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_bpol_probes(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_bpol_probes

   subroutine read_type_calorimetry_heat_source(structure_out, name)

     implicit none

     type (type_calorimetry_heat_source), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_float(structure_out%temp_in, trim(adjustl(name)) // '%temp_in')
     call read_type_float(structure_out%temp_out, trim(adjustl(name)) // '%temp_out')
     call read_type_float(structure_out%press_in, trim(adjustl(name)) // '%press_in')
     call read_type_float(structure_out%press_out, trim(adjustl(name)) // '%press_out')
     call read_type_float(structure_out%flow, trim(adjustl(name)) // '%flow')
     call read_type_float(structure_out%power, trim(adjustl(name)) // '%power')

   end subroutine read_type_calorimetry_heat_source

   subroutine read_arr_type_calorimetry_heat_source(structure_out, name)
 
     implicit none
 
     type (type_calorimetry_heat_source), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_calorimetry_heat_source(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_calorimetry_heat_source

   subroutine read_type_circuits(structure_out, name)

     implicit none

     type (type_circuits), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_power_conv_component(structure_out%component, trim(adjustl(name)) // '%component')
     call read_type_float(structure_out%power_net, trim(adjustl(name)) // '%power_net')
     call read_type_float(structure_out%power_int, trim(adjustl(name)) // '%power_int')
     call read_type_float(structure_out%efficiency, trim(adjustl(name)) // '%efficiency')

   end subroutine read_type_circuits

   subroutine read_arr_type_circuits(structure_out, name)
 
     implicit none
 
     type (type_circuits), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_circuits(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_circuits

   subroutine read_type_circularcoil(structure_out, name)

     implicit none

     type (type_circularcoil), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz0D(structure_out%centre, trim(adjustl(name)) // '%centre')
     call read_type_float(structure_out%hlength, trim(adjustl(name)) // '%hlength')
     call read_type_float(structure_out%radialhwidth, trim(adjustl(name)) // '%radialhwidth')

   end subroutine read_type_circularcoil

   subroutine read_arr_type_circularcoil(structure_out, name)
 
     implicit none
 
     type (type_circularcoil), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_circularcoil(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_circularcoil

   subroutine read_type_clusters(structure_out, name)

     implicit none

     type (type_clusters), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_integer(structure_out%start, trim(adjustl(name)) // '%start')
     call read_type_integer(structure_out%finish, trim(adjustl(name)) // '%finish')

   end subroutine read_type_clusters

   subroutine read_arr_type_clusters(structure_out, name)
 
     implicit none
 
     type (type_clusters), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_clusters(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_clusters

   subroutine read_type_codeparam(structure_out, name)

     implicit none

     type (type_codeparam), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%codename, trim(adjustl(name)) // '%codename')
     call read_type_vecstring_type(structure_out%codeversion, trim(adjustl(name)) // '%codeversion')
     call read_type_vecstring_type(structure_out%parameters, trim(adjustl(name)) // '%parameters')
     call read_type_vecstring_type(structure_out%output_diag, trim(adjustl(name)) // '%output_diag')
     call read_type_integer(structure_out%output_flag, trim(adjustl(name)) // '%output_flag')

   end subroutine read_type_codeparam

   subroutine read_arr_type_codeparam(structure_out, name)
 
     implicit none
 
     type (type_codeparam), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_codeparam(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_codeparam

   subroutine read_type_coefficients_neutrals(structure_out, name)

     implicit none

     type (type_coefficients_neutrals), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_recycling_neutrals(structure_out%recycling, trim(adjustl(name)) // '%recycling')
     call read_type_sputtering_neutrals(structure_out%sputtering, trim(adjustl(name)) // '%sputtering')

   end subroutine read_type_coefficients_neutrals

   subroutine read_arr_type_coefficients_neutrals(structure_out, name)
 
     implicit none
 
     type (type_coefficients_neutrals), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coefficients_neutrals(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coefficients_neutrals

   subroutine read_type_coherentwave(structure_out, name)

     implicit none

     type (type_coherentwave), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_enum_instance(structure_out%wave_id, trim(adjustl(name)) // '%wave_id')
     call read_type_composition(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_compositions_type(structure_out%compositions, trim(adjustl(name)) // '%compositions')
     call read_type_waves_global_param(structure_out%global_param, trim(adjustl(name)) // '%global_param')
     call read_type_waves_grid_1d(structure_out%grid_1d, trim(adjustl(name)) // '%grid_1d')
     call read_type_waves_grid_2d(structure_out%grid_2d, trim(adjustl(name)) // '%grid_2d')
     call read_type_waves_profiles_1d(structure_out%profiles_1d, trim(adjustl(name)) // '%profiles_1d')
     call read_type_waves_profiles_2d(structure_out%profiles_2d, trim(adjustl(name)) // '%profiles_2d')
     call read_arr_type_beamtracing(structure_out%beamtracing, trim(adjustl(name)) // '%beamtracing')
     call read_type_fullwave(structure_out%fullwave, trim(adjustl(name)) // '%fullwave')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_coherentwave

   subroutine read_arr_type_coherentwave(structure_out, name)
 
     implicit none
 
     type (type_coherentwave), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coherentwave(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coherentwave

   subroutine read_type_coil(structure_out, name)

     implicit none

     type (type_coil), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_desc_coils(structure_out%desc_coils, trim(adjustl(name)) // '%desc_coils')
     call read_type_exp1D(structure_out%coilcurrent, trim(adjustl(name)) // '%coilcurrent')
     call read_type_exp1D(structure_out%coilvoltage, trim(adjustl(name)) // '%coilvoltage')

   end subroutine read_type_coil

   subroutine read_arr_type_coil(structure_out, name)
 
     implicit none
 
     type (type_coil), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coil(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coil

   subroutine read_type_com(structure_out, name)

     implicit none

     type (type_com), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_float(structure_out%zion, trim(adjustl(name)) // '%zion')
     call read_type_vecflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_vecflt_type(structure_out%magn_mom, trim(adjustl(name)) // '%magn_mom')
     call read_type_vecflt_type(structure_out%p_phi, trim(adjustl(name)) // '%p_phi')
     call read_type_vecint_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')

   end subroutine read_type_com

   subroutine read_arr_type_com(structure_out, name)
 
     implicit none
 
     type (type_com), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_com(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_com

   subroutine read_type_complexgrid(structure_out, name)

     implicit none

     type (type_complexgrid), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%uid, trim(adjustl(name)) // '%uid')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_arr_type_complexgrid_space(structure_out%spaces, trim(adjustl(name)) // '%spaces')
     call read_arr_type_complexgrid_subgrid(structure_out%subgrids, trim(adjustl(name)) // '%subgrids')
     call read_type_complexgrid_metric(structure_out%metric, trim(adjustl(name)) // '%metric')
     call read_arr_type_complexgrid_geo_global(structure_out%geo, trim(adjustl(name)) // '%geo')
     call read_arr_type_complexgrid_vector(structure_out%bases, trim(adjustl(name)) // '%bases')

   end subroutine read_type_complexgrid

   subroutine read_arr_type_complexgrid(structure_out, name)
 
     implicit none
 
     type (type_complexgrid), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid

   subroutine read_type_complexgrid_geo_global(structure_out, name)

     implicit none

     type (type_complexgrid_geo_global), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%geotype, trim(adjustl(name)) // '%geotype')
     call read_type_vecstring_type(structure_out%geotypeid, trim(adjustl(name)) // '%geotypeid')
     call read_type_vecint_type(structure_out%coordtype, trim(adjustl(name)) // '%coordtype')
     call read_arr_type_complexgrid_scalar(structure_out%geo_matrix, trim(adjustl(name)) // '%geo_matrix')
     call read_arr_type_complexgrid_scalar(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_complexgrid_geo_global

   subroutine read_arr_type_complexgrid_geo_global(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_geo_global), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_geo_global(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_geo_global

   subroutine read_type_complexgrid_indexlist(structure_out, name)

     implicit none

     type (type_complexgrid_indexlist), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%range, trim(adjustl(name)) // '%range')
     call read_type_vecint_type(structure_out%ind, trim(adjustl(name)) // '%ind')

   end subroutine read_type_complexgrid_indexlist

   subroutine read_arr_type_complexgrid_indexlist(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_indexlist), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_indexlist(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_indexlist

   subroutine read_type_complexgrid_metric(structure_out, name)

     implicit none

     type (type_complexgrid_metric), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_complexgrid_scalar(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_arr_type_complexgrid_scalar(structure_out%g11, trim(adjustl(name)) // '%g11')
     call read_arr_type_complexgrid_scalar(structure_out%g12, trim(adjustl(name)) // '%g12')
     call read_arr_type_complexgrid_scalar(structure_out%g13, trim(adjustl(name)) // '%g13')
     call read_arr_type_complexgrid_scalar(structure_out%g22, trim(adjustl(name)) // '%g22')
     call read_arr_type_complexgrid_scalar(structure_out%g23, trim(adjustl(name)) // '%g23')
     call read_arr_type_complexgrid_scalar(structure_out%g33, trim(adjustl(name)) // '%g33')
     call read_arr_type_complexgrid_scalar(structure_out%jacobian, trim(adjustl(name)) // '%jacobian')

   end subroutine read_type_complexgrid_metric

   subroutine read_arr_type_complexgrid_metric(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_metric), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_metric(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_metric

   subroutine read_type_complexgrid_objectlist(structure_out, name)

     implicit none

     type (type_complexgrid_objectlist), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%cls, trim(adjustl(name)) // '%cls')
     call read_arr_type_complexgrid_indexlist(structure_out%indset, trim(adjustl(name)) // '%indset')
     call read_type_matint_type(structure_out%ind, trim(adjustl(name)) // '%ind')

   end subroutine read_type_complexgrid_objectlist

   subroutine read_arr_type_complexgrid_objectlist(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_objectlist), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_objectlist(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_objectlist

   subroutine read_type_complexgrid_scalar(structure_out, name)

     implicit none

     type (type_complexgrid_scalar), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%griduid, trim(adjustl(name)) // '%griduid')
     call read_type_integer(structure_out%subgrid, trim(adjustl(name)) // '%subgrid')
     call read_type_vecflt_type(structure_out%scalar, trim(adjustl(name)) // '%scalar')
     call read_type_matflt_type(structure_out%vector, trim(adjustl(name)) // '%vector')
     call read_type_array3dflt_type(structure_out%matrix, trim(adjustl(name)) // '%matrix')

   end subroutine read_type_complexgrid_scalar

   subroutine read_arr_type_complexgrid_scalar(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_scalar), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_scalar(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_scalar

   subroutine read_type_complexgrid_scalar_cplx(structure_out, name)

     implicit none

     type (type_complexgrid_scalar_cplx), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%griduid, trim(adjustl(name)) // '%griduid')
     call read_type_integer(structure_out%subgrid, trim(adjustl(name)) // '%subgrid')
     call read_type_veccplx_type(structure_out%scalar, trim(adjustl(name)) // '%scalar')
     call read_type_matcplx_type(structure_out%vector, trim(adjustl(name)) // '%vector')
     call read_type_array3dcplx_type(structure_out%matrix, trim(adjustl(name)) // '%matrix')

   end subroutine read_type_complexgrid_scalar_cplx

   subroutine read_arr_type_complexgrid_scalar_cplx(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_scalar_cplx), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_scalar_cplx(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_scalar_cplx

   subroutine read_type_complexgrid_scalar_int(structure_out, name)

     implicit none

     type (type_complexgrid_scalar_int), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%griduid, trim(adjustl(name)) // '%griduid')
     call read_type_integer(structure_out%subgrid, trim(adjustl(name)) // '%subgrid')
     call read_type_vecint_type(structure_out%scalar, trim(adjustl(name)) // '%scalar')
     call read_type_matint_type(structure_out%vector, trim(adjustl(name)) // '%vector')
     call read_type_array3dint_type(structure_out%matrix, trim(adjustl(name)) // '%matrix')

   end subroutine read_type_complexgrid_scalar_int

   subroutine read_arr_type_complexgrid_scalar_int(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_scalar_int), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_scalar_int(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_scalar_int

   subroutine read_type_complexgrid_scalar_simplestruct(structure_out, name)

     implicit none

     type (type_complexgrid_scalar_simplestruct), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%subgrid, trim(adjustl(name)) // '%subgrid')
     call read_type_vecflt_type(structure_out%scalar, trim(adjustl(name)) // '%scalar')
     call read_type_matflt_type(structure_out%vector, trim(adjustl(name)) // '%vector')
     call read_type_array3dflt_type(structure_out%matrix, trim(adjustl(name)) // '%matrix')

   end subroutine read_type_complexgrid_scalar_simplestruct

   subroutine read_arr_type_complexgrid_scalar_simplestruct(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_scalar_simplestruct), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_scalar_simplestruct(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_scalar_simplestruct

   subroutine read_type_complexgrid_space(structure_out, name)

     implicit none

     type (type_complexgrid_space), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%geotype, trim(adjustl(name)) // '%geotype')
     call read_type_vecstring_type(structure_out%geotypeid, trim(adjustl(name)) // '%geotypeid')
     call read_type_matint_type(structure_out%coordtype, trim(adjustl(name)) // '%coordtype')
     call read_arr_type_objects(structure_out%objects, trim(adjustl(name)) // '%objects')
     call read_type_vecint_type(structure_out%xpoints, trim(adjustl(name)) // '%xpoints')

   end subroutine read_type_complexgrid_space

   subroutine read_arr_type_complexgrid_space(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_space), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_space(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_space

   subroutine read_type_complexgrid_subgrid(structure_out, name)

     implicit none

     type (type_complexgrid_subgrid), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_arr_type_complexgrid_objectlist(structure_out%list, trim(adjustl(name)) // '%list')

   end subroutine read_type_complexgrid_subgrid

   subroutine read_arr_type_complexgrid_subgrid(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_subgrid), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_subgrid(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_subgrid

   subroutine read_type_complexgrid_vector(structure_out, name)

     implicit none

     type (type_complexgrid_vector), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%griduid, trim(adjustl(name)) // '%griduid')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_arr_type_complexgrid_scalar(structure_out%comp, trim(adjustl(name)) // '%comp')
     call read_type_vecint_type(structure_out%align, trim(adjustl(name)) // '%align')
     call read_type_vecstring_type(structure_out%alignid, trim(adjustl(name)) // '%alignid')
     call read_type_integer(structure_out%basis, trim(adjustl(name)) // '%basis')

   end subroutine read_type_complexgrid_vector

   subroutine read_arr_type_complexgrid_vector(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_vector), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_vector(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_vector

   subroutine read_type_complexgrid_vector_simplestruct(structure_out, name)

     implicit none

     type (type_complexgrid_vector_simplestruct), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_arr_type_complexgrid_scalar(structure_out%comp, trim(adjustl(name)) // '%comp')
     call read_type_vecint_type(structure_out%align, trim(adjustl(name)) // '%align')
     call read_type_vecstring_type(structure_out%alignid, trim(adjustl(name)) // '%alignid')

   end subroutine read_type_complexgrid_vector_simplestruct

   subroutine read_arr_type_complexgrid_vector_simplestruct(structure_out, name)
 
     implicit none
 
     type (type_complexgrid_vector_simplestruct), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_complexgrid_vector_simplestruct(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_complexgrid_vector_simplestruct

   subroutine read_type_composition(structure_out, name)

     implicit none

     type (type_composition), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_vecflt_type(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_vecflt_type(structure_out%zion, trim(adjustl(name)) // '%zion')
     call read_type_vecint_type(structure_out%imp_flag, trim(adjustl(name)) // '%imp_flag')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_composition

   subroutine read_arr_type_composition(structure_out, name)
 
     implicit none
 
     type (type_composition), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_composition(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_composition

   subroutine read_type_composition_neutrals(structure_out, name)

     implicit none

     type (type_composition_neutrals), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_coreneutrals_atomlist(structure_out%atomlist, trim(adjustl(name)) // '%atomlist')
     call read_arr_type_composition_neutralscomp(structure_out%neutral, trim(adjustl(name)) // '%neutral')

   end subroutine read_type_composition_neutrals

   subroutine read_arr_type_composition_neutrals(structure_out, name)
 
     implicit none
 
     type (type_composition_neutrals), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_composition_neutrals(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_composition_neutrals

   subroutine read_type_composition_neutrals_neutcomp(structure_out, name)

     implicit none

     type (type_composition_neutrals_neutcomp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nucindex, trim(adjustl(name)) // '%nucindex')
     call read_type_integer(structure_out%multiplicity, trim(adjustl(name)) // '%multiplicity')

   end subroutine read_type_composition_neutrals_neutcomp

   subroutine read_arr_type_composition_neutrals_neutcomp(structure_out, name)
 
     implicit none
 
     type (type_composition_neutrals_neutcomp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_composition_neutrals_neutcomp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_composition_neutrals_neutcomp

   subroutine read_type_composition_neutralscomp(structure_out, name)

     implicit none

     type (type_composition_neutralscomp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_composition_neutrals_neutcomp(structure_out%neutcomp, trim(adjustl(name)) // '%neutcomp')
     call read_arr_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_composition_neutralscomp

   subroutine read_arr_type_composition_neutralscomp(structure_out, name)
 
     implicit none
 
     type (type_composition_neutralscomp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_composition_neutralscomp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_composition_neutralscomp

   subroutine read_type_compositions_type(structure_out, name)

     implicit none

     type (type_compositions_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_nuclei(structure_out%nuclei, trim(adjustl(name)) // '%nuclei')
     call read_arr_type_ions(structure_out%ions, trim(adjustl(name)) // '%ions')
     call read_arr_type_impurities(structure_out%impurities, trim(adjustl(name)) // '%impurities')
     call read_arr_type_composition_neutralscomp(structure_out%neutralscomp, trim(adjustl(name)) // '%neutralscomp')
     call read_arr_type_edgespecies(structure_out%edgespecies, trim(adjustl(name)) // '%edgespecies')
     call read_type_identifier(structure_out%signature, trim(adjustl(name)) // '%signature')

   end subroutine read_type_compositions_type

   subroutine read_arr_type_compositions_type(structure_out, name)
 
     implicit none
 
     type (type_compositions_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_compositions_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_compositions_type

   subroutine read_type_compound_desc(structure_out, name)

     implicit none

     type (type_compound_desc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_type_vecflt_type(structure_out%stochiometry, trim(adjustl(name)) // '%stochiometry')
     call read_type_float(structure_out%density, trim(adjustl(name)) // '%density')
     call read_type_float(structure_out%heat_cap, trim(adjustl(name)) // '%heat_cap')
     call read_type_vecflt_type(structure_out%heat_cond, trim(adjustl(name)) // '%heat_cond')
     call read_type_matflt_type(structure_out%surf_recrate, trim(adjustl(name)) // '%surf_recrate')

   end subroutine read_type_compound_desc

   subroutine read_arr_type_compound_desc(structure_out, name)
 
     implicit none
 
     type (type_compound_desc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_compound_desc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_compound_desc

   subroutine read_type_coord_sys(structure_out, name)

     implicit none

     type (type_coord_sys), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%grid_type, trim(adjustl(name)) // '%grid_type')
     call read_type_reggrid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_type_matflt_type(structure_out%jacobian, trim(adjustl(name)) // '%jacobian')
     call read_type_matflt_type(structure_out%g_11, trim(adjustl(name)) // '%g_11')
     call read_type_matflt_type(structure_out%g_12, trim(adjustl(name)) // '%g_12')
     call read_type_matflt_type(structure_out%g_13, trim(adjustl(name)) // '%g_13')
     call read_type_matflt_type(structure_out%g_22, trim(adjustl(name)) // '%g_22')
     call read_type_matflt_type(structure_out%g_23, trim(adjustl(name)) // '%g_23')
     call read_type_matflt_type(structure_out%g_33, trim(adjustl(name)) // '%g_33')
     call read_type_rz2D(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_coord_sys

   subroutine read_arr_type_coord_sys(structure_out, name)
 
     implicit none
 
     type (type_coord_sys), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coord_sys(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coord_sys

   subroutine read_type_coordinates(structure_out, name)

     implicit none

     type (type_coordinates), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_coordinates

   subroutine read_arr_type_coordinates(structure_out, name)
 
     implicit none
 
     type (type_coordinates), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coordinates(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coordinates

   subroutine read_type_coords(structure_out, name)

     implicit none

     type (type_coords), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%coord, trim(adjustl(name)) // '%coord')
     call read_type_vecstring_type(structure_out%coord_label, trim(adjustl(name)) // '%coord_label')
     call read_type_vecint_type(structure_out%extrap_type, trim(adjustl(name)) // '%extrap_type')
     call read_type_integer(structure_out%interp_type, trim(adjustl(name)) // '%interp_type')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_type_vecstring_type(structure_out%unit, trim(adjustl(name)) // '%unit')
     call read_type_integer(structure_out%transform, trim(adjustl(name)) // '%transform')
     call read_type_integer(structure_out%spacing, trim(adjustl(name)) // '%spacing')

   end subroutine read_type_coords

   subroutine read_arr_type_coords(structure_out, name)
 
     implicit none
 
     type (type_coords), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coords(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coords

   subroutine read_type_coredelta_values(structure_out, name)

     implicit none

     type (type_coredelta_values), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%deltaid, trim(adjustl(name)) // '%deltaid')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%delta_psi, trim(adjustl(name)) // '%delta_psi')
     call read_type_vecflt_type(structure_out%delta_te, trim(adjustl(name)) // '%delta_te')
     call read_type_matflt_type(structure_out%delta_ti, trim(adjustl(name)) // '%delta_ti')
     call read_type_vecflt_type(structure_out%delta_ne, trim(adjustl(name)) // '%delta_ne')
     call read_type_matflt_type(structure_out%delta_ni, trim(adjustl(name)) // '%delta_ni')
     call read_arr_type_coredelta_values_impurity(structure_out%impurity, trim(adjustl(name)) // '%impurity')
     call read_type_matflt_type(structure_out%delta_vtor, trim(adjustl(name)) // '%delta_vtor')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_coredelta_values

   subroutine read_arr_type_coredelta_values(structure_out, name)
 
     implicit none
 
     type (type_coredelta_values), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coredelta_values(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coredelta_values

   subroutine read_type_coredelta_values_impurity(structure_out, name)

     implicit none

     type (type_coredelta_values_impurity), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%delta_tz, trim(adjustl(name)) // '%delta_tz')
     call read_type_matflt_type(structure_out%delta_nz, trim(adjustl(name)) // '%delta_nz')

   end subroutine read_type_coredelta_values_impurity

   subroutine read_arr_type_coredelta_values_impurity(structure_out, name)
 
     implicit none
 
     type (type_coredelta_values_impurity), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coredelta_values_impurity(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coredelta_values_impurity

   subroutine read_type_corefast_values(structure_out, name)

     implicit none

     type (type_corefast_values), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%fastid, trim(adjustl(name)) // '%fastid')
     call read_type_fast_thermal_separation_filter(structure_out%filter, trim(adjustl(name)) // '%filter')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%j, trim(adjustl(name)) // '%j')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_matflt_type(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_vecflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_matflt_type(structure_out%nz, trim(adjustl(name)) // '%nz')
     call read_type_matflt_type(structure_out%pi, trim(adjustl(name)) // '%pi')
     call read_type_vecflt_type(structure_out%pe, trim(adjustl(name)) // '%pe')
     call read_type_matflt_type(structure_out%pz, trim(adjustl(name)) // '%pz')
     call read_type_matflt_type(structure_out%pi_para, trim(adjustl(name)) // '%pi_para')
     call read_type_vecflt_type(structure_out%pe_para, trim(adjustl(name)) // '%pe_para')
     call read_type_matflt_type(structure_out%pz_para, trim(adjustl(name)) // '%pz_para')
     call read_type_matflt_type(structure_out%ui, trim(adjustl(name)) // '%ui')
     call read_type_matflt_type(structure_out%uz, trim(adjustl(name)) // '%uz')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_corefast_values

   subroutine read_arr_type_corefast_values(structure_out, name)
 
     implicit none
 
     type (type_corefast_values), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefast_values(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefast_values

   subroutine read_type_corefield(structure_out, name)

     implicit none

     type (type_corefield), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%ddrho, trim(adjustl(name)) // '%ddrho')
     call read_type_vecflt_type(structure_out%d2drho2, trim(adjustl(name)) // '%d2drho2')
     call read_type_vecflt_type(structure_out%ddt, trim(adjustl(name)) // '%ddt')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')
     call read_type_boundaryel(structure_out%boundary, trim(adjustl(name)) // '%boundary')
     call read_type_sourceel(structure_out%source_term, trim(adjustl(name)) // '%source_term')
     call read_type_coretransel(structure_out%transp_coef, trim(adjustl(name)) // '%transp_coef')
     call read_type_fluxel(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_vecflt_type(structure_out%flux_dv_surf, trim(adjustl(name)) // '%flux_dv_surf')
     call read_type_vecflt_type(structure_out%time_deriv, trim(adjustl(name)) // '%time_deriv')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_corefield

   subroutine read_arr_type_corefield(structure_out, name)
 
     implicit none
 
     type (type_corefield), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefield(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefield

   subroutine read_type_corefieldion(structure_out, name)

     implicit none

     type (type_corefieldion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_matflt_type(structure_out%ddrho, trim(adjustl(name)) // '%ddrho')
     call read_type_matflt_type(structure_out%d2drho2, trim(adjustl(name)) // '%d2drho2')
     call read_type_matflt_type(structure_out%ddt, trim(adjustl(name)) // '%ddt')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecint_type(structure_out%flag, trim(adjustl(name)) // '%flag')
     call read_type_boundaryion(structure_out%boundary, trim(adjustl(name)) // '%boundary')
     call read_type_sourceion(structure_out%source_term, trim(adjustl(name)) // '%source_term')
     call read_type_coretransion(structure_out%transp_coef, trim(adjustl(name)) // '%transp_coef')
     call read_type_fluxion(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_matflt_type(structure_out%flux_dv_surf, trim(adjustl(name)) // '%flux_dv_surf')
     call read_type_matflt_type(structure_out%time_deriv, trim(adjustl(name)) // '%time_deriv')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_corefieldion

   subroutine read_arr_type_corefieldion(structure_out, name)
 
     implicit none
 
     type (type_corefieldion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefieldion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefieldion

   subroutine read_type_corefieldneutral(structure_out, name)

     implicit none

     type (type_corefieldneutral), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_boundary_neutrals(structure_out%boundary, trim(adjustl(name)) // '%boundary')

   end subroutine read_type_corefieldneutral

   subroutine read_arr_type_corefieldneutral(structure_out, name)
 
     implicit none
 
     type (type_corefieldneutral), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefieldneutral(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefieldneutral

   subroutine read_type_corefieldneutrale(structure_out, name)

     implicit none

     type (type_corefieldneutrale), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_boundary_neutrals(structure_out%boundary, trim(adjustl(name)) // '%boundary')

   end subroutine read_type_corefieldneutrale

   subroutine read_arr_type_corefieldneutrale(structure_out, name)
 
     implicit none
 
     type (type_corefieldneutrale), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefieldneutrale(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefieldneutrale

   subroutine read_type_corefieldneutralv(structure_out, name)

     implicit none

     type (type_corefieldneutralv), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_boundary_neutrals(structure_out%boundary, trim(adjustl(name)) // '%boundary')

   end subroutine read_type_corefieldneutralv

   subroutine read_arr_type_corefieldneutralv(structure_out, name)
 
     implicit none
 
     type (type_corefieldneutralv), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefieldneutralv(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefieldneutralv

   subroutine read_type_corefieldneutralv0(structure_out, name)

     implicit none

     type (type_corefieldneutralv0), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_corefieldneutralv(structure_out%toroidal, trim(adjustl(name)) // '%toroidal')
     call read_type_corefieldneutralv(structure_out%poloidal, trim(adjustl(name)) // '%poloidal')
     call read_type_corefieldneutralv(structure_out%radial, trim(adjustl(name)) // '%radial')

   end subroutine read_type_corefieldneutralv0

   subroutine read_arr_type_corefieldneutralv0(structure_out, name)
 
     implicit none
 
     type (type_corefieldneutralv0), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_corefieldneutralv0(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_corefieldneutralv0

   subroutine read_type_coreimpurdiag_sum_radiation(structure_out, name)

     implicit none

     type (type_coreimpurdiag_sum_radiation), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreimpurediagsum_type(structure_out%line_rad, trim(adjustl(name)) // '%line_rad')
     call read_type_coreimpurediagsum_type(structure_out%brem_radrec, trim(adjustl(name)) // '%brem_radrec')
     call read_type_coreimpurediagsum_type(structure_out%sum, trim(adjustl(name)) // '%sum')

   end subroutine read_type_coreimpurdiag_sum_radiation

   subroutine read_arr_type_coreimpurdiag_sum_radiation(structure_out, name)
 
     implicit none
 
     type (type_coreimpurdiag_sum_radiation), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurdiag_sum_radiation(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurdiag_sum_radiation

   subroutine read_type_coreimpurediag_energy(structure_out, name)

     implicit none

     type (type_coreimpurediag_energy), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreimpurediagprof_type(structure_out%ionization, trim(adjustl(name)) // '%ionization')
     call read_type_coreimpurediagprof_type(structure_out%recombin, trim(adjustl(name)) // '%recombin')
     call read_type_coreimpurediagprof_type(structure_out%sum, trim(adjustl(name)) // '%sum')

   end subroutine read_type_coreimpurediag_energy

   subroutine read_arr_type_coreimpurediag_energy(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediag_energy), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediag_energy(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediag_energy

   subroutine read_type_coreimpurediag_radiation(structure_out, name)

     implicit none

     type (type_coreimpurediag_radiation), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreimpurediagprof_type(structure_out%line_rad, trim(adjustl(name)) // '%line_rad')
     call read_type_coreimpurediagprof_type(structure_out%brem_radrec, trim(adjustl(name)) // '%brem_radrec')
     call read_type_coreimpurediagprof_type(structure_out%sum, trim(adjustl(name)) // '%sum')

   end subroutine read_type_coreimpurediag_radiation

   subroutine read_arr_type_coreimpurediag_radiation(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediag_radiation), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediag_radiation(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediag_radiation

   subroutine read_type_coreimpurediag_sum(structure_out, name)

     implicit none

     type (type_coreimpurediag_sum), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreimpurdiag_sum_radiation(structure_out%radiation, trim(adjustl(name)) // '%radiation')
     call read_type_coreimpurediag_sum_energy(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_coreimpurediag_sum

   subroutine read_arr_type_coreimpurediag_sum(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediag_sum), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediag_sum(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediag_sum

   subroutine read_type_coreimpurediag_sum_energy(structure_out, name)

     implicit none

     type (type_coreimpurediag_sum_energy), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreimpurediagsum_type(structure_out%ionization, trim(adjustl(name)) // '%ionization')
     call read_type_coreimpurediagsum_type(structure_out%recombin, trim(adjustl(name)) // '%recombin')
     call read_type_coreimpurediagsum_type(structure_out%sum, trim(adjustl(name)) // '%sum')

   end subroutine read_type_coreimpurediag_sum_energy

   subroutine read_arr_type_coreimpurediag_sum_energy(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediag_sum_energy), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediag_sum_energy(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediag_sum_energy

   subroutine read_type_coreimpurediag_type(structure_out, name)

     implicit none

     type (type_coreimpurediag_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreimpurediag_radiation(structure_out%radiation, trim(adjustl(name)) // '%radiation')
     call read_type_coreimpurediag_energy(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_coreimpurediag_type

   subroutine read_arr_type_coreimpurediag_type(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediag_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediag_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediag_type

   subroutine read_type_coreimpurediagprof_type(structure_out, name)

     implicit none

     type (type_coreimpurediagprof_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%profile, trim(adjustl(name)) // '%profile')
     call read_type_matflt_type(structure_out%integral, trim(adjustl(name)) // '%integral')

   end subroutine read_type_coreimpurediagprof_type

   subroutine read_arr_type_coreimpurediagprof_type(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediagprof_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediagprof_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediagprof_type

   subroutine read_type_coreimpurediagsum_type(structure_out, name)

     implicit none

     type (type_coreimpurediagsum_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%profile, trim(adjustl(name)) // '%profile')
     call read_type_vecflt_type(structure_out%integral, trim(adjustl(name)) // '%integral')

   end subroutine read_type_coreimpurediagsum_type

   subroutine read_arr_type_coreimpurediagsum_type(structure_out, name)
 
     implicit none
 
     type (type_coreimpurediagsum_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreimpurediagsum_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreimpurediagsum_type

   subroutine read_type_coreneutrals_atomlist(structure_out, name)

     implicit none

     type (type_coreneutrals_atomlist), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_float(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_identifier(structure_out%ionimptype, trim(adjustl(name)) // '%ionimptype')
     call read_type_integer(structure_out%ionimpindex, trim(adjustl(name)) // '%ionimpindex')

   end subroutine read_type_coreneutrals_atomlist

   subroutine read_arr_type_coreneutrals_atomlist(structure_out, name)
 
     implicit none
 
     type (type_coreneutrals_atomlist), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreneutrals_atomlist(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreneutrals_atomlist

   subroutine read_type_coreneutrals_neutraltype(structure_out, name)

     implicit none

     type (type_coreneutrals_neutraltype), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_corefieldneutral(structure_out%n0, trim(adjustl(name)) // '%n0')
     call read_type_corefieldneutrale(structure_out%t0, trim(adjustl(name)) // '%t0')
     call read_type_corefieldneutralv0(structure_out%v0, trim(adjustl(name)) // '%v0')

   end subroutine read_type_coreneutrals_neutraltype

   subroutine read_arr_type_coreneutrals_neutraltype(structure_out, name)
 
     implicit none
 
     type (type_coreneutrals_neutraltype), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreneutrals_neutraltype(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreneutrals_neutraltype

   subroutine read_type_coreprofile(structure_out, name)

     implicit none

     type (type_coreprofile), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_coreprofile

   subroutine read_arr_type_coreprofile(structure_out, name)
 
     implicit none
 
     type (type_coreprofile), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreprofile(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreprofile

   subroutine read_type_coreprofion(structure_out, name)

     implicit none

     type (type_coreprofion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_coreprofion

   subroutine read_arr_type_coreprofion(structure_out, name)
 
     implicit none
 
     type (type_coreprofion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coreprofion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coreprofion

   subroutine read_type_coresource_values(structure_out, name)

     implicit none

     type (type_coresource_values), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%sourceid, trim(adjustl(name)) // '%sourceid')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%j, trim(adjustl(name)) // '%j')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_source_ion(structure_out%si, trim(adjustl(name)) // '%si')
     call read_type_source_vec(structure_out%se, trim(adjustl(name)) // '%se')
     call read_arr_type_source_imp(structure_out%sz, trim(adjustl(name)) // '%sz')
     call read_type_source_ion(structure_out%qi, trim(adjustl(name)) // '%qi')
     call read_type_source_vec(structure_out%qe, trim(adjustl(name)) // '%qe')
     call read_arr_type_source_imp(structure_out%qz, trim(adjustl(name)) // '%qz')
     call read_type_source_ion(structure_out%ui, trim(adjustl(name)) // '%ui')
     call read_type_source_vec(structure_out%ujxb, trim(adjustl(name)) // '%ujxb')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_coresource_values

   subroutine read_arr_type_coresource_values(structure_out, name)
 
     implicit none
 
     type (type_coresource_values), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coresource_values(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coresource_values

   subroutine read_type_coretransel(structure_out, name)

     implicit none

     type (type_coretransel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%diff, trim(adjustl(name)) // '%diff')
     call read_type_vecflt_type(structure_out%vconv, trim(adjustl(name)) // '%vconv')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_coretransel

   subroutine read_arr_type_coretransel(structure_out, name)
 
     implicit none
 
     type (type_coretransel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coretransel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coretransel

   subroutine read_type_coretransimp(structure_out, name)

     implicit none

     type (type_coretransimp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%diff, trim(adjustl(name)) // '%diff')
     call read_type_matflt_type(structure_out%vconv, trim(adjustl(name)) // '%vconv')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_coretransimp

   subroutine read_arr_type_coretransimp(structure_out, name)
 
     implicit none
 
     type (type_coretransimp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coretransimp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coretransimp

   subroutine read_type_coretransion(structure_out, name)

     implicit none

     type (type_coretransion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%diff, trim(adjustl(name)) // '%diff')
     call read_type_matflt_type(structure_out%vconv, trim(adjustl(name)) // '%vconv')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_coretransion

   subroutine read_arr_type_coretransion(structure_out, name)
 
     implicit none
 
     type (type_coretransion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coretransion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coretransion

   subroutine read_type_coretransp_values(structure_out, name)

     implicit none

     type (type_coretransp_values), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%transportid, trim(adjustl(name)) // '%transportid')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_ni_transp(structure_out%ni_transp, trim(adjustl(name)) // '%ni_transp')
     call read_type_ne_transp(structure_out%ne_transp, trim(adjustl(name)) // '%ne_transp')
     call read_arr_type_transcoefimp(structure_out%nz_transp, trim(adjustl(name)) // '%nz_transp')
     call read_type_transcoefion(structure_out%ti_transp, trim(adjustl(name)) // '%ti_transp')
     call read_type_transcoefel(structure_out%te_transp, trim(adjustl(name)) // '%te_transp')
     call read_arr_type_transcoefimp(structure_out%tz_transp, trim(adjustl(name)) // '%tz_transp')
     call read_type_transcoefvtor(structure_out%vtor_transp, trim(adjustl(name)) // '%vtor_transp')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_coretransp_values

   subroutine read_arr_type_coretransp_values(structure_out, name)
 
     implicit none
 
     type (type_coretransp_values), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_coretransp_values(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_coretransp_values

   subroutine read_type_current(structure_out, name)

     implicit none

     type (type_current), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%mpol, trim(adjustl(name)) // '%mpol')
     call read_type_vecint_type(structure_out%ntor, trim(adjustl(name)) // '%ntor')
     call read_type_exp1D(structure_out%spectrum, trim(adjustl(name)) // '%spectrum')
     call read_type_rz0D(structure_out%rz_reference, trim(adjustl(name)) // '%rz_reference')

   end subroutine read_type_current

   subroutine read_arr_type_current(structure_out, name)
 
     implicit none
 
     type (type_current), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_current(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_current

   subroutine read_type_cxmeasure(structure_out, name)

     implicit none

     type (type_cxmeasure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_exp1D(structure_out%vtor, trim(adjustl(name)) // '%vtor')
     call read_type_exp1D(structure_out%vpol, trim(adjustl(name)) // '%vpol')

   end subroutine read_type_cxmeasure

   subroutine read_arr_type_cxmeasure(structure_out, name)
 
     implicit none
 
     type (type_cxmeasure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_cxmeasure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_cxmeasure

   subroutine read_type_cxsetup(structure_out, name)

     implicit none

     type (type_cxsetup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_vecflt_type(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_rzphi1Dexp(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_cxsetup

   subroutine read_arr_type_cxsetup(structure_out, name)
 
     implicit none
 
     type (type_cxsetup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_cxsetup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_cxsetup

   subroutine read_type_data_release(structure_out, name)

     implicit none

     type (type_data_release), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%shot, trim(adjustl(name)) // '%shot')
     call read_type_integer(structure_out%run, trim(adjustl(name)) // '%run')
     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')

   end subroutine read_type_data_release

   subroutine read_arr_type_data_release(structure_out, name)
 
     implicit none
 
     type (type_data_release), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_data_release(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_data_release

   subroutine read_type_datainfo(structure_out, name)

     implicit none

     type (type_datainfo), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%dataprovider, trim(adjustl(name)) // '%dataprovider')
     call read_type_vecstring_type(structure_out%putdate, trim(adjustl(name)) // '%putdate')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecstring_type(structure_out%comment, trim(adjustl(name)) // '%comment')
     call read_type_integer(structure_out%cocos, trim(adjustl(name)) // '%cocos')
     call read_type_integer(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_integer(structure_out%isref, trim(adjustl(name)) // '%isref')
     call read_type_whatref(structure_out%whatref, trim(adjustl(name)) // '%whatref')
     call read_type_putinfo(structure_out%putinfo, trim(adjustl(name)) // '%putinfo')

   end subroutine read_type_datainfo

   subroutine read_arr_type_datainfo(structure_out, name)
 
     implicit none
 
     type (type_datainfo), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_datainfo(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_datainfo

   subroutine read_type_desc_coils(structure_out, name)

     implicit none

     type (type_desc_coils), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_float(structure_out%res, trim(adjustl(name)) // '%res')
     call read_type_integer(structure_out%nturns, trim(adjustl(name)) // '%nturns')
     call read_type_vecstring_type(structure_out%closed, trim(adjustl(name)) // '%closed')
     call read_arr_type_edges(structure_out%edges, trim(adjustl(name)) // '%edges')

   end subroutine read_type_desc_coils

   subroutine read_arr_type_desc_coils(structure_out, name)
 
     implicit none
 
     type (type_desc_coils), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_desc_coils(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_desc_coils

   subroutine read_type_desc_impur(structure_out, name)

     implicit none

     type (type_desc_impur), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_vecint_type(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_vecint_type(structure_out%i_ion, trim(adjustl(name)) // '%i_ion')
     call read_type_vecint_type(structure_out%nzimp, trim(adjustl(name)) // '%nzimp')
     call read_type_matint_type(structure_out%zmin, trim(adjustl(name)) // '%zmin')
     call read_type_matint_type(structure_out%zmax, trim(adjustl(name)) // '%zmax')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_desc_impur

   subroutine read_arr_type_desc_impur(structure_out, name)
 
     implicit none
 
     type (type_desc_impur), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_desc_impur(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_desc_impur

   subroutine read_type_desc_iron(structure_out, name)

     implicit none

     type (type_desc_iron), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_permeability(structure_out%permeability, trim(adjustl(name)) // '%permeability')
     call read_type_geom_iron(structure_out%geom_iron, trim(adjustl(name)) // '%geom_iron')

   end subroutine read_type_desc_iron

   subroutine read_arr_type_desc_iron(structure_out, name)
 
     implicit none
 
     type (type_desc_iron), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_desc_iron(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_desc_iron

   subroutine read_type_desc_pfcoils(structure_out, name)

     implicit none

     type (type_desc_pfcoils), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_vecflt_type(structure_out%res, trim(adjustl(name)) // '%res')
     call read_type_vecflt_type(structure_out%emax, trim(adjustl(name)) // '%emax')
     call read_type_structure_cs(structure_out%structure_cs, trim(adjustl(name)) // '%structure_cs')
     call read_type_float(structure_out%pol_flux_cs, trim(adjustl(name)) // '%pol_flux_cs')
     call read_type_vecint_type(structure_out%nelement, trim(adjustl(name)) // '%nelement')
     call read_type_pfelement(structure_out%pfelement, trim(adjustl(name)) // '%pfelement')

   end subroutine read_type_desc_pfcoils

   subroutine read_arr_type_desc_pfcoils(structure_out, name)
 
     implicit none
 
     type (type_desc_pfcoils), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_desc_pfcoils(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_desc_pfcoils

   subroutine read_type_desc_supply(structure_out, name)

     implicit none

     type (type_desc_supply), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_vecstring_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%delay, trim(adjustl(name)) // '%delay')
     call read_type_filter(structure_out%filter, trim(adjustl(name)) // '%filter')
     call read_type_vecflt_type(structure_out%imin, trim(adjustl(name)) // '%imin')
     call read_type_vecflt_type(structure_out%imax, trim(adjustl(name)) // '%imax')
     call read_type_vecflt_type(structure_out%res, trim(adjustl(name)) // '%res')
     call read_type_vecflt_type(structure_out%umin, trim(adjustl(name)) // '%umin')
     call read_type_vecflt_type(structure_out%umax, trim(adjustl(name)) // '%umax')
     call read_type_vecflt_type(structure_out%emax, trim(adjustl(name)) // '%emax')

   end subroutine read_type_desc_supply

   subroutine read_arr_type_desc_supply(structure_out, name)
 
     implicit none
 
     type (type_desc_supply), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_desc_supply(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_desc_supply

   subroutine read_type_diag_func(structure_out, name)

     implicit none

     type (type_diag_func), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')
     call read_type_matflt_type(structure_out%transf_mat, trim(adjustl(name)) // '%transf_mat')

   end subroutine read_type_diag_func

   subroutine read_arr_type_diag_func(structure_out, name)
 
     implicit none
 
     type (type_diag_func), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_diag_func(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_diag_func

   subroutine read_type_dist_collisional_transfer_0d(structure_out, name)

     implicit none

     type (type_dist_collisional_transfer_0d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%power_th, trim(adjustl(name)) // '%power_th')
     call read_type_float(structure_out%power_fast, trim(adjustl(name)) // '%power_fast')
     call read_type_float(structure_out%torque_th, trim(adjustl(name)) // '%torque_th')
     call read_type_float(structure_out%torque_fast, trim(adjustl(name)) // '%torque_fast')

   end subroutine read_type_dist_collisional_transfer_0d

   subroutine read_arr_type_dist_collisional_transfer_0d(structure_out, name)
 
     implicit none
 
     type (type_dist_collisional_transfer_0d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_collisional_transfer_0d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_collisional_transfer_0d

   subroutine read_type_dist_collisional_transfer_1d(structure_out, name)

     implicit none

     type (type_dist_collisional_transfer_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%power_th, trim(adjustl(name)) // '%power_th')
     call read_type_vecflt_type(structure_out%power_fast, trim(adjustl(name)) // '%power_fast')
     call read_type_vecflt_type(structure_out%torque_th, trim(adjustl(name)) // '%torque_th')
     call read_type_vecflt_type(structure_out%torque_fast, trim(adjustl(name)) // '%torque_fast')

   end subroutine read_type_dist_collisional_transfer_1d

   subroutine read_arr_type_dist_collisional_transfer_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_collisional_transfer_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_collisional_transfer_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_collisional_transfer_1d

   subroutine read_type_dist_collisional_transfer_2d(structure_out, name)

     implicit none

     type (type_dist_collisional_transfer_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%power_th, trim(adjustl(name)) // '%power_th')
     call read_type_matflt_type(structure_out%power_fast, trim(adjustl(name)) // '%power_fast')
     call read_type_matflt_type(structure_out%torque_th, trim(adjustl(name)) // '%torque_th')
     call read_type_matflt_type(structure_out%torque_fast, trim(adjustl(name)) // '%torque_fast')

   end subroutine read_type_dist_collisional_transfer_2d

   subroutine read_arr_type_dist_collisional_transfer_2d(structure_out, name)
 
     implicit none
 
     type (type_dist_collisional_transfer_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_collisional_transfer_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_collisional_transfer_2d

   subroutine read_type_dist_distrivec_distfunc_fexp_param(structure_out, name)

     implicit none

     type (type_dist_distrivec_distfunc_fexp_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_equatorial_plane(structure_out%equatorial, trim(adjustl(name)) // '%equatorial')
     call read_type_vecflt_type(structure_out%temperature, trim(adjustl(name)) // '%temperature')

   end subroutine read_type_dist_distrivec_distfunc_fexp_param

   subroutine read_arr_type_dist_distrivec_distfunc_fexp_param(structure_out, name)
 
     implicit none
 
     type (type_dist_distrivec_distfunc_fexp_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_distrivec_distfunc_fexp_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_distrivec_distfunc_fexp_param

   subroutine read_type_dist_ff(structure_out, name)

     implicit none

     type (type_dist_ff), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_grid_info(structure_out%grid_info, trim(adjustl(name)) // '%grid_info')
     call read_arr_type_topo_regions(structure_out%topo_regions, trim(adjustl(name)) // '%topo_regions')

   end subroutine read_type_dist_ff

   subroutine read_arr_type_dist_ff(structure_out, name)
 
     implicit none
 
     type (type_dist_ff), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_ff(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_ff

   subroutine read_type_dist_func(structure_out, name)

     implicit none

     type (type_dist_func), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%is_delta_f, trim(adjustl(name)) // '%is_delta_f')
     call read_type_weighted_markers(structure_out%markers, trim(adjustl(name)) // '%markers')
     call read_arr_type_dist_ff(structure_out%f_expan_topo, trim(adjustl(name)) // '%f_expan_topo')
     call read_arr_type_f_expansion(structure_out%f_expansion, trim(adjustl(name)) // '%f_expansion')

   end subroutine read_type_dist_func

   subroutine read_arr_type_dist_func(structure_out, name)
 
     implicit none
 
     type (type_dist_func), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_func(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_func

   subroutine read_type_dist_geometry_0d(structure_out, name)

     implicit none

     type (type_dist_geometry_0d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz0D(structure_out%mag_axis, trim(adjustl(name)) // '%mag_axis')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')

   end subroutine read_type_dist_geometry_0d

   subroutine read_arr_type_dist_geometry_0d(structure_out, name)
 
     implicit none
 
     type (type_dist_geometry_0d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_geometry_0d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_geometry_0d

   subroutine read_type_dist_geometry_1d(structure_out, name)

     implicit none

     type (type_dist_geometry_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')

   end subroutine read_type_dist_geometry_1d

   subroutine read_arr_type_dist_geometry_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_geometry_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_geometry_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_geometry_1d

   subroutine read_type_dist_geometry_2d(structure_out, name)

     implicit none

     type (type_dist_geometry_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%coord_type, trim(adjustl(name)) // '%coord_type')
     call read_type_matflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_matflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_matflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_matflt_type(structure_out%theta_geom, trim(adjustl(name)) // '%theta_geom')
     call read_type_matflt_type(structure_out%theta_strt, trim(adjustl(name)) // '%theta_strt')

   end subroutine read_type_dist_geometry_2d

   subroutine read_arr_type_dist_geometry_2d(structure_out, name)
 
     implicit none
 
     type (type_dist_geometry_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_geometry_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_geometry_2d

   subroutine read_type_dist_global_param(structure_out, name)

     implicit none

     type (type_dist_global_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_geometry_0d(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_dist_state_0d(structure_out%state, trim(adjustl(name)) // '%state')
     call read_type_dist_collisional_transfer_0d(structure_out%collisions_e, trim(adjustl(name)) // '%collisions_e')
     call read_arr_type_dist_collisional_transfer_0d(structure_out%collisions_i, trim(adjustl(name)) // '%collisions_i')
     call read_arr_type_dist_global_param_collisions_z(structure_out%collisions_z, trim(adjustl(name)) // '%collisions_z')
     call read_arr_type_dist_sources_0d(structure_out%sources, trim(adjustl(name)) // '%sources')

   end subroutine read_type_dist_global_param

   subroutine read_arr_type_dist_global_param(structure_out, name)
 
     implicit none
 
     type (type_dist_global_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_global_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_global_param

   subroutine read_type_dist_global_param_collisions_z(structure_out, name)

     implicit none

     type (type_dist_global_param_collisions_z), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_dist_collisional_transfer_0d(structure_out%charge_state, trim(adjustl(name)) // '%charge_state')

   end subroutine read_type_dist_global_param_collisions_z

   subroutine read_arr_type_dist_global_param_collisions_z(structure_out, name)
 
     implicit none
 
     type (type_dist_global_param_collisions_z), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_global_param_collisions_z(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_global_param_collisions_z

   subroutine read_type_dist_grid_info(structure_out, name)

     implicit none

     type (type_dist_grid_info), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%grid_type, trim(adjustl(name)) // '%grid_type')
     call read_type_integer(structure_out%ngriddim, trim(adjustl(name)) // '%ngriddim')
     call read_type_vecint_type(structure_out%grid_coord, trim(adjustl(name)) // '%grid_coord')
     call read_type_integer(structure_out%thin_orbits, trim(adjustl(name)) // '%thin_orbits')
     call read_type_vecstring_type(structure_out%topology, trim(adjustl(name)) // '%topology')
     call read_arr_type_omnigen_surf(structure_out%omnigen_surf, trim(adjustl(name)) // '%omnigen_surf')

   end subroutine read_type_dist_grid_info

   subroutine read_arr_type_dist_grid_info(structure_out, name)
 
     implicit none
 
     type (type_dist_grid_info), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_grid_info(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_grid_info

   subroutine read_type_dist_profile_values_1d(structure_out, name)

     implicit none

     type (type_dist_profile_values_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_state_1d(structure_out%state, trim(adjustl(name)) // '%state')
     call read_type_dist_collisional_transfer_1d(structure_out%collisions_e, trim(adjustl(name)) // '%collisions_e')
     call read_arr_type_dist_collisional_transfer_1d(structure_out%collisions_i, trim(adjustl(name)) // '%collisions_i')
     call read_arr_type_dist_profiles_1d_collisions_z(structure_out%collisions_z, trim(adjustl(name)) // '%collisions_z')
     call read_arr_type_dist_sources_1d(structure_out%sources, trim(adjustl(name)) // '%sources')

   end subroutine read_type_dist_profile_values_1d

   subroutine read_arr_type_dist_profile_values_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_profile_values_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_profile_values_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_profile_values_1d

   subroutine read_type_dist_profile_values_2d(structure_out, name)

     implicit none

     type (type_dist_profile_values_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_state_2d(structure_out%state, trim(adjustl(name)) // '%state')
     call read_type_dist_collisional_transfer_2d(structure_out%collisions_e, trim(adjustl(name)) // '%collisions_e')
     call read_arr_type_dist_collisional_transfer_2d(structure_out%collisions_i, trim(adjustl(name)) // '%collisions_i')
     call read_arr_type_dist_profiles2d_collisions_z(structure_out%collisions_z, trim(adjustl(name)) // '%collisions_z')

   end subroutine read_type_dist_profile_values_2d

   subroutine read_arr_type_dist_profile_values_2d(structure_out, name)
 
     implicit none
 
     type (type_dist_profile_values_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_profile_values_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_profile_values_2d

   subroutine read_type_dist_profiles2d_collisions_z(structure_out, name)

     implicit none

     type (type_dist_profiles2d_collisions_z), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_dist_collisional_transfer_2d(structure_out%charge_state, trim(adjustl(name)) // '%charge_state')

   end subroutine read_type_dist_profiles2d_collisions_z

   subroutine read_arr_type_dist_profiles2d_collisions_z(structure_out, name)
 
     implicit none
 
     type (type_dist_profiles2d_collisions_z), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_profiles2d_collisions_z(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_profiles2d_collisions_z

   subroutine read_type_dist_profiles_1d(structure_out, name)

     implicit none

     type (type_dist_profiles_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_geometry_1d(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_dist_state_1d(structure_out%state, trim(adjustl(name)) // '%state')
     call read_type_dist_collisional_transfer_1d(structure_out%collisions_e, trim(adjustl(name)) // '%collisions_e')
     call read_arr_type_dist_collisional_transfer_1d(structure_out%collisions_i, trim(adjustl(name)) // '%collisions_i')
     call read_arr_type_dist_profiles_1d_collisions_z(structure_out%collisions_z, trim(adjustl(name)) // '%collisions_z')
     call read_type_dist_thermalised_1d(structure_out%thermalised, trim(adjustl(name)) // '%thermalised')
     call read_arr_type_dist_sources_1d(structure_out%sources, trim(adjustl(name)) // '%sources')
     call read_type_dist_profile_values_1d(structure_out%trapped, trim(adjustl(name)) // '%trapped')
     call read_type_dist_profile_values_1d(structure_out%co_passing, trim(adjustl(name)) // '%co_passing')
     call read_type_dist_profile_values_1d(structure_out%cntr_passing, trim(adjustl(name)) // '%cntr_passing')

   end subroutine read_type_dist_profiles_1d

   subroutine read_arr_type_dist_profiles_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_profiles_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_profiles_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_profiles_1d

   subroutine read_type_dist_profiles_1d_collisions_z(structure_out, name)

     implicit none

     type (type_dist_profiles_1d_collisions_z), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_dist_collisional_transfer_1d(structure_out%charge_state, trim(adjustl(name)) // '%charge_state')

   end subroutine read_type_dist_profiles_1d_collisions_z

   subroutine read_arr_type_dist_profiles_1d_collisions_z(structure_out, name)
 
     implicit none
 
     type (type_dist_profiles_1d_collisions_z), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_profiles_1d_collisions_z(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_profiles_1d_collisions_z

   subroutine read_type_dist_profiles_2d(structure_out, name)

     implicit none

     type (type_dist_profiles_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_geometry_2d(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_dist_state_2d(structure_out%state, trim(adjustl(name)) // '%state')
     call read_type_dist_collisional_transfer_2d(structure_out%collisions_e, trim(adjustl(name)) // '%collisions_e')
     call read_arr_type_dist_collisional_transfer_2d(structure_out%collisions_i, trim(adjustl(name)) // '%collisions_i')
     call read_arr_type_dist_profiles2d_collisions_z(structure_out%collisions_z, trim(adjustl(name)) // '%collisions_z')
     call read_type_dist_profile_values_2d(structure_out%trapped, trim(adjustl(name)) // '%trapped')
     call read_type_dist_profile_values_2d(structure_out%co_passing, trim(adjustl(name)) // '%co_passing')
     call read_type_dist_profile_values_2d(structure_out%cntr_passing, trim(adjustl(name)) // '%cntr_passing')

   end subroutine read_type_dist_profiles_2d

   subroutine read_arr_type_dist_profiles_2d(structure_out, name)
 
     implicit none
 
     type (type_dist_profiles_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_profiles_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_profiles_2d

   subroutine read_type_dist_sources_0d(structure_out, name)

     implicit none

     type (type_dist_sources_0d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_sources_reference(structure_out%source_ref, trim(adjustl(name)) // '%source_ref')
     call read_type_float(structure_out%particle, trim(adjustl(name)) // '%particle')
     call read_type_float(structure_out%momentum, trim(adjustl(name)) // '%momentum')
     call read_type_float(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_dist_sources_0d

   subroutine read_arr_type_dist_sources_0d(structure_out, name)
 
     implicit none
 
     type (type_dist_sources_0d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_sources_0d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_sources_0d

   subroutine read_type_dist_sources_1d(structure_out, name)

     implicit none

     type (type_dist_sources_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_dist_sources_reference(structure_out%source_ref, trim(adjustl(name)) // '%source_ref')
     call read_type_vecflt_type(structure_out%particle, trim(adjustl(name)) // '%particle')
     call read_type_vecflt_type(structure_out%momentum, trim(adjustl(name)) // '%momentum')
     call read_type_vecflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_dist_sources_1d

   subroutine read_arr_type_dist_sources_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_sources_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_sources_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_sources_1d

   subroutine read_type_dist_sources_reference(structure_out, name)

     implicit none

     type (type_dist_sources_reference), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecint_type(structure_out%index_waveid, trim(adjustl(name)) // '%index_waveid')
     call read_type_vecint_type(structure_out%index_srcid, trim(adjustl(name)) // '%index_srcid')

   end subroutine read_type_dist_sources_reference

   subroutine read_arr_type_dist_sources_reference(structure_out, name)
 
     implicit none
 
     type (type_dist_sources_reference), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_sources_reference(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_sources_reference

   subroutine read_type_dist_state_0d(structure_out, name)

     implicit none

     type (type_dist_state_0d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%n_particles, trim(adjustl(name)) // '%n_particles')
     call read_type_float(structure_out%n_part_fast, trim(adjustl(name)) // '%n_part_fast')
     call read_type_float(structure_out%enrg, trim(adjustl(name)) // '%enrg')
     call read_type_float(structure_out%enrg_fast, trim(adjustl(name)) // '%enrg_fast')
     call read_type_float(structure_out%enrg_fast_pa, trim(adjustl(name)) // '%enrg_fast_pa')
     call read_type_float(structure_out%momentm_fast, trim(adjustl(name)) // '%momentm_fast')
     call read_type_float(structure_out%current_dr, trim(adjustl(name)) // '%current_dr')
     call read_type_float(structure_out%torque_jrxb, trim(adjustl(name)) // '%torque_jrxb')

   end subroutine read_type_dist_state_0d

   subroutine read_arr_type_dist_state_0d(structure_out, name)
 
     implicit none
 
     type (type_dist_state_0d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_state_0d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_state_0d

   subroutine read_type_dist_state_1d(structure_out, name)

     implicit none

     type (type_dist_state_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%dens, trim(adjustl(name)) // '%dens')
     call read_type_vecflt_type(structure_out%dens_fast, trim(adjustl(name)) // '%dens_fast')
     call read_type_vecflt_type(structure_out%pres, trim(adjustl(name)) // '%pres')
     call read_type_vecflt_type(structure_out%pres_fast, trim(adjustl(name)) // '%pres_fast')
     call read_type_vecflt_type(structure_out%pres_fast_pa, trim(adjustl(name)) // '%pres_fast_pa')
     call read_type_vecflt_type(structure_out%momentm_fast, trim(adjustl(name)) // '%momentm_fast')
     call read_type_vecflt_type(structure_out%current, trim(adjustl(name)) // '%current')
     call read_type_vecflt_type(structure_out%current_fast, trim(adjustl(name)) // '%current_fast')
     call read_type_vecflt_type(structure_out%torque_jrxb, trim(adjustl(name)) // '%torque_jrxb')

   end subroutine read_type_dist_state_1d

   subroutine read_arr_type_dist_state_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_state_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_state_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_state_1d

   subroutine read_type_dist_state_2d(structure_out, name)

     implicit none

     type (type_dist_state_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%dens, trim(adjustl(name)) // '%dens')
     call read_type_matflt_type(structure_out%dens_fast, trim(adjustl(name)) // '%dens_fast')
     call read_type_matflt_type(structure_out%pres, trim(adjustl(name)) // '%pres')
     call read_type_matflt_type(structure_out%pres_fast, trim(adjustl(name)) // '%pres_fast')
     call read_type_matflt_type(structure_out%pres_fast_pa, trim(adjustl(name)) // '%pres_fast_pa')
     call read_type_matflt_type(structure_out%momentm_fast, trim(adjustl(name)) // '%momentm_fast')
     call read_type_matflt_type(structure_out%current, trim(adjustl(name)) // '%current')
     call read_type_matflt_type(structure_out%current_fast, trim(adjustl(name)) // '%current_fast')
     call read_type_matflt_type(structure_out%torque_jrxb, trim(adjustl(name)) // '%torque_jrxb')

   end subroutine read_type_dist_state_2d

   subroutine read_arr_type_dist_state_2d(structure_out, name)
 
     implicit none
 
     type (type_dist_state_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_state_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_state_2d

   subroutine read_type_dist_thermalised_1d(structure_out, name)

     implicit none

     type (type_dist_thermalised_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%particle, trim(adjustl(name)) // '%particle')
     call read_type_vecflt_type(structure_out%momentum, trim(adjustl(name)) // '%momentum')
     call read_type_vecflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_dist_thermalised_1d

   subroutine read_arr_type_dist_thermalised_1d(structure_out, name)
 
     implicit none
 
     type (type_dist_thermalised_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_dist_thermalised_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_dist_thermalised_1d

   subroutine read_type_distri_vec(structure_out, name)

     implicit none

     type (type_distri_vec), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_enum_instance(structure_out%wave_id, trim(adjustl(name)) // '%wave_id')
     call read_arr_type_enum_instance(structure_out%source_id, trim(adjustl(name)) // '%source_id')
     call read_type_species_reference(structure_out%species, trim(adjustl(name)) // '%species')
     call read_type_integer(structure_out%gyro_type, trim(adjustl(name)) // '%gyro_type')
     call read_type_fast_thermal_separation_filter(structure_out%fast_filter, trim(adjustl(name)) // '%fast_filter')
     call read_type_dist_global_param(structure_out%global_param, trim(adjustl(name)) // '%global_param')
     call read_type_dist_profiles_1d(structure_out%profiles_1d, trim(adjustl(name)) // '%profiles_1d')
     call read_type_dist_profiles_2d(structure_out%profiles_2d, trim(adjustl(name)) // '%profiles_2d')
     call read_type_dist_func(structure_out%dist_func, trim(adjustl(name)) // '%dist_func')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_distri_vec

   subroutine read_arr_type_distri_vec(structure_out, name)
 
     implicit none
 
     type (type_distri_vec), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distri_vec(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distri_vec

   subroutine read_type_distsource_global_param(structure_out, name)

     implicit none

     type (type_distsource_global_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp0D(structure_out%src_pow, trim(adjustl(name)) // '%src_pow')
     call read_type_exp0D(structure_out%src_rate, trim(adjustl(name)) // '%src_rate')
     call read_type_rz0D(structure_out%mag_axis, trim(adjustl(name)) // '%mag_axis')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')

   end subroutine read_type_distsource_global_param

   subroutine read_arr_type_distsource_global_param(structure_out, name)
 
     implicit none
 
     type (type_distsource_global_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distsource_global_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distsource_global_param

   subroutine read_type_distsource_line_src_prof(structure_out, name)

     implicit none

     type (type_distsource_line_src_prof), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%R, trim(adjustl(name)) // '%R')
     call read_type_vecflt_type(structure_out%Z, trim(adjustl(name)) // '%Z')
     call read_type_vecflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')
     call read_type_vecflt_type(structure_out%theta_id, trim(adjustl(name)) // '%theta_id')
     call read_type_matflt_type(structure_out%th2th_pol, trim(adjustl(name)) // '%th2th_pol')
     call read_type_vecflt_type(structure_out%pitch, trim(adjustl(name)) // '%pitch')
     call read_type_vecflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_vecflt_type(structure_out%ang_momentum, trim(adjustl(name)) // '%ang_momentum')
     call read_type_vecflt_type(structure_out%src_rate, trim(adjustl(name)) // '%src_rate')

   end subroutine read_type_distsource_line_src_prof

   subroutine read_arr_type_distsource_line_src_prof(structure_out, name)
 
     implicit none
 
     type (type_distsource_line_src_prof), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distsource_line_src_prof(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distsource_line_src_prof

   subroutine read_type_distsource_profiles_1d(structure_out, name)

     implicit none

     type (type_distsource_profiles_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_exp1D(structure_out%pow_den, trim(adjustl(name)) // '%pow_den')
     call read_type_exp1D(structure_out%trq_den, trim(adjustl(name)) // '%trq_den')
     call read_type_exp1D(structure_out%src_rate, trim(adjustl(name)) // '%src_rate')

   end subroutine read_type_distsource_profiles_1d

   subroutine read_arr_type_distsource_profiles_1d(structure_out, name)
 
     implicit none
 
     type (type_distsource_profiles_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distsource_profiles_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distsource_profiles_1d

   subroutine read_type_distsource_profiles_2d(structure_out, name)

     implicit none

     type (type_distsource_profiles_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%grid_coord, trim(adjustl(name)) // '%grid_coord')
     call read_type_matflt_type(structure_out%dim1, trim(adjustl(name)) // '%dim1')
     call read_type_matflt_type(structure_out%dim2, trim(adjustl(name)) // '%dim2')
     call read_type_matflt_type(structure_out%g11, trim(adjustl(name)) // '%g11')
     call read_type_matflt_type(structure_out%g12, trim(adjustl(name)) // '%g12')
     call read_type_matflt_type(structure_out%g21, trim(adjustl(name)) // '%g21')
     call read_type_matflt_type(structure_out%g22, trim(adjustl(name)) // '%g22')
     call read_type_exp2D(structure_out%pow_den, trim(adjustl(name)) // '%pow_den')
     call read_type_exp2D(structure_out%src_rate, trim(adjustl(name)) // '%src_rate')

   end subroutine read_type_distsource_profiles_2d

   subroutine read_arr_type_distsource_profiles_2d(structure_out, name)
 
     implicit none
 
     type (type_distsource_profiles_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distsource_profiles_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distsource_profiles_2d

   subroutine read_type_distsource_source(structure_out, name)

     implicit none

     type (type_distsource_source), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_enum_instance(structure_out%source_id, trim(adjustl(name)) // '%source_id')
     call read_type_species_reference(structure_out%species, trim(adjustl(name)) // '%species')
     call read_type_integer(structure_out%gyro_type, trim(adjustl(name)) // '%gyro_type')
     call read_type_distsource_global_param(structure_out%global_param, trim(adjustl(name)) // '%global_param')
     call read_type_distsource_profiles_1d(structure_out%profiles_1d, trim(adjustl(name)) // '%profiles_1d')
     call read_type_distsource_profiles_2d(structure_out%profiles_2d, trim(adjustl(name)) // '%profiles_2d')
     call read_arr_type_distsource_line_src_prof(structure_out%line_srcprof, trim(adjustl(name)) // '%line_srcprof')
     call read_type_source_rate(structure_out%source_rate, trim(adjustl(name)) // '%source_rate')
     call read_type_weighted_markers(structure_out%markers, trim(adjustl(name)) // '%markers')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_distsource_source

   subroutine read_arr_type_distsource_source(structure_out, name)
 
     implicit none
 
     type (type_distsource_source), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_distsource_source(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_distsource_source

   subroutine read_type_divergence(structure_out, name)

     implicit none

     type (type_divergence), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%frac_divcomp, trim(adjustl(name)) // '%frac_divcomp')
     call read_type_vecflt_type(structure_out%div_vert, trim(adjustl(name)) // '%div_vert')
     call read_type_vecflt_type(structure_out%div_horiz, trim(adjustl(name)) // '%div_horiz')

   end subroutine read_type_divergence

   subroutine read_arr_type_divergence(structure_out, name)
 
     implicit none
 
     type (type_divergence), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_divergence(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_divergence

   subroutine read_type_e_components(structure_out, name)

     implicit none

     type (type_e_components), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_complexgrid_scalar_cplx(structure_out%e_plus, trim(adjustl(name)) // '%e_plus')
     call read_type_complexgrid_scalar_cplx(structure_out%e_minus, trim(adjustl(name)) // '%e_minus')
     call read_type_complexgrid_scalar_cplx(structure_out%e_para, trim(adjustl(name)) // '%e_para')
     call read_type_complexgrid_scalar_cplx(structure_out%e_norm, trim(adjustl(name)) // '%e_norm')
     call read_type_complexgrid_scalar_cplx(structure_out%e_binorm, trim(adjustl(name)) // '%e_binorm')
     call read_type_complexgrid_scalar_cplx(structure_out%b_norm, trim(adjustl(name)) // '%b_norm')
     call read_type_complexgrid_scalar_cplx(structure_out%b_binorm, trim(adjustl(name)) // '%b_binorm')
     call read_type_complexgrid_scalar_cplx(structure_out%b_para, trim(adjustl(name)) // '%b_para')
     call read_type_complexgrid_scalar_cplx(structure_out%k_perp, trim(adjustl(name)) // '%k_perp')

   end subroutine read_type_e_components

   subroutine read_arr_type_e_components(structure_out, name)
 
     implicit none
 
     type (type_e_components), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_e_components(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_e_components

   subroutine read_type_ecemeasure(structure_out, name)

     implicit none

     type (type_ecemeasure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%harmonic, trim(adjustl(name)) // '%harmonic')
     call read_type_rzphi1Dexp(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_exp1D(structure_out%te, trim(adjustl(name)) // '%te')

   end subroutine read_type_ecemeasure

   subroutine read_arr_type_ecemeasure(structure_out, name)
 
     implicit none
 
     type (type_ecemeasure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ecemeasure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ecemeasure

   subroutine read_type_ecesetup(structure_out, name)

     implicit none

     type (type_ecesetup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_setup_line_exp(structure_out%los, trim(adjustl(name)) // '%los')

   end subroutine read_type_ecesetup

   subroutine read_arr_type_ecesetup(structure_out, name)
 
     implicit none
 
     type (type_ecesetup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ecesetup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ecesetup

   subroutine read_type_edge_fluid(structure_out, name)

     implicit none

     type (type_edge_fluid), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_edge_fluid_scalar_simplestruct(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_arr_type_edge_fluid_scalar(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_edge_fluid_vector_simplestruct(structure_out%ve, trim(adjustl(name)) // '%ve')
     call read_arr_type_edge_fluid_vector(structure_out%vi, trim(adjustl(name)) // '%vi')
     call read_type_edge_fluid_scalar_simplestruct(structure_out%te, trim(adjustl(name)) // '%te')
     call read_arr_type_edge_fluid_scalar(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_edge_fluid_vector_simplestruct(structure_out%te_aniso, trim(adjustl(name)) // '%te_aniso')
     call read_arr_type_edge_fluid_vector(structure_out%ti_aniso, trim(adjustl(name)) // '%ti_aniso')
     call read_type_edge_fluid_scalar_simplestruct(structure_out%po, trim(adjustl(name)) // '%po')
     call read_type_edge_fluid_vector_simplestruct(structure_out%j, trim(adjustl(name)) // '%j')
     call read_arr_type_complexgrid_vector(structure_out%b, trim(adjustl(name)) // '%b')

   end subroutine read_type_edge_fluid

   subroutine read_arr_type_edge_fluid(structure_out, name)
 
     implicit none
 
     type (type_edge_fluid), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_fluid(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_fluid

   subroutine read_type_edge_fluid_scalar(structure_out, name)

     implicit none

     type (type_edge_fluid_scalar), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_complexgrid_scalar(structure_out%value, trim(adjustl(name)) // '%value')
     call read_arr_type_complexgrid_scalar(structure_out%bndvalue, trim(adjustl(name)) // '%bndvalue')
     call read_arr_type_complexgrid_vector(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_arr_type_complexgrid_vector(structure_out%bndflux, trim(adjustl(name)) // '%bndflux')
     call read_arr_type_edge_fluid_scalar_transpcoeff(structure_out%transpcoeff, trim(adjustl(name)) // '%transpcoeff')
     call read_arr_type_complexgrid_scalar(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_edge_fluid_scalar

   subroutine read_arr_type_edge_fluid_scalar(structure_out, name)
 
     implicit none
 
     type (type_edge_fluid_scalar), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_fluid_scalar(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_fluid_scalar

   subroutine read_type_edge_fluid_scalar_simplestruct(structure_out, name)

     implicit none

     type (type_edge_fluid_scalar_simplestruct), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_complexgrid_scalar(structure_out%value, trim(adjustl(name)) // '%value')
     call read_arr_type_complexgrid_scalar(structure_out%bndvalue, trim(adjustl(name)) // '%bndvalue')
     call read_arr_type_complexgrid_vector(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_arr_type_complexgrid_vector(structure_out%bndflux, trim(adjustl(name)) // '%bndflux')
     call read_arr_type_edge_fluid_scalar_transpcoeff(structure_out%transpcoeff, trim(adjustl(name)) // '%transpcoeff')
     call read_arr_type_complexgrid_scalar(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_edge_fluid_scalar_simplestruct

   subroutine read_arr_type_edge_fluid_scalar_simplestruct(structure_out, name)
 
     implicit none
 
     type (type_edge_fluid_scalar_simplestruct), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_fluid_scalar_simplestruct(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_fluid_scalar_simplestruct

   subroutine read_type_edge_fluid_scalar_transpcoeff(structure_out, name)

     implicit none

     type (type_edge_fluid_scalar_transpcoeff), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_complexgrid_vector_simplestruct(structure_out%d, trim(adjustl(name)) // '%d')
     call read_type_complexgrid_vector_simplestruct(structure_out%v, trim(adjustl(name)) // '%v')

   end subroutine read_type_edge_fluid_scalar_transpcoeff

   subroutine read_arr_type_edge_fluid_scalar_transpcoeff(structure_out, name)
 
     implicit none
 
     type (type_edge_fluid_scalar_transpcoeff), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_fluid_scalar_transpcoeff(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_fluid_scalar_transpcoeff

   subroutine read_type_edge_fluid_vector(structure_out, name)

     implicit none

     type (type_edge_fluid_vector), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%griduid, trim(adjustl(name)) // '%griduid')
     call read_type_integer(structure_out%basis, trim(adjustl(name)) // '%basis')
     call read_type_vecint_type(structure_out%align, trim(adjustl(name)) // '%align')
     call read_type_vecstring_type(structure_out%alignid, trim(adjustl(name)) // '%alignid')
     call read_arr_type_edge_fluid_scalar(structure_out%comps, trim(adjustl(name)) // '%comps')

   end subroutine read_type_edge_fluid_vector

   subroutine read_arr_type_edge_fluid_vector(structure_out, name)
 
     implicit none
 
     type (type_edge_fluid_vector), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_fluid_vector(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_fluid_vector

   subroutine read_type_edge_fluid_vector_simplestruct(structure_out, name)

     implicit none

     type (type_edge_fluid_vector_simplestruct), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%griduid, trim(adjustl(name)) // '%griduid')
     call read_type_integer(structure_out%basis, trim(adjustl(name)) // '%basis')
     call read_arr_type_edge_fluid_scalar(structure_out%comps, trim(adjustl(name)) // '%comps')
     call read_type_vecint_type(structure_out%align, trim(adjustl(name)) // '%align')
     call read_type_vecstring_type(structure_out%alignid, trim(adjustl(name)) // '%alignid')

   end subroutine read_type_edge_fluid_vector_simplestruct

   subroutine read_arr_type_edge_fluid_vector_simplestruct(structure_out, name)
 
     implicit none
 
     type (type_edge_fluid_vector_simplestruct), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_fluid_vector_simplestruct(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_fluid_vector_simplestruct

   subroutine read_type_edge_kinetic(structure_out, name)

     implicit none

     type (type_edge_kinetic), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_edge_kinetic_distribution(structure_out%f, trim(adjustl(name)) // '%f')

   end subroutine read_type_edge_kinetic

   subroutine read_arr_type_edge_kinetic(structure_out, name)
 
     implicit none
 
     type (type_edge_kinetic), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_kinetic(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_kinetic

   subroutine read_type_edge_kinetic_distribution(structure_out, name)

     implicit none

     type (type_edge_kinetic_distribution), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_complexgrid_scalar(structure_out%value, trim(adjustl(name)) // '%value')
     call read_arr_type_complexgrid_scalar(structure_out%bndvalue, trim(adjustl(name)) // '%bndvalue')
     call read_arr_type_complexgrid_vector(structure_out%fluxes, trim(adjustl(name)) // '%fluxes')
     call read_arr_type_complexgrid_scalar(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_edge_kinetic_distribution

   subroutine read_arr_type_edge_kinetic_distribution(structure_out, name)
 
     implicit none
 
     type (type_edge_kinetic_distribution), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edge_kinetic_distribution(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edge_kinetic_distribution

   subroutine read_type_edges(structure_out, name)

     implicit none

     type (type_edges), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1D(structure_out%edge_rzphi, trim(adjustl(name)) // '%edge_rzphi')

   end subroutine read_type_edges

   subroutine read_arr_type_edges(structure_out, name)
 
     implicit none
 
     type (type_edges), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edges(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edges

   subroutine read_type_edgespecies(structure_out, name)

     implicit none

     type (type_edgespecies), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nucindex, trim(adjustl(name)) // '%nucindex')
     call read_type_float(structure_out%zmin, trim(adjustl(name)) // '%zmin')
     call read_type_float(structure_out%zmax, trim(adjustl(name)) // '%zmax')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_edgespecies

   subroutine read_arr_type_edgespecies(structure_out, name)
 
     implicit none
 
     type (type_edgespecies), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_edgespecies(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_edgespecies

   subroutine read_type_element_desc(structure_out, name)

     implicit none

     type (type_element_desc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nucindex, trim(adjustl(name)) // '%nucindex')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_type_float(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')

   end subroutine read_type_element_desc

   subroutine read_arr_type_element_desc(structure_out, name)
 
     implicit none
 
     type (type_element_desc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_element_desc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_element_desc

   subroutine read_type_entry_def(structure_out, name)

     implicit none

     type (type_entry_def), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%user, trim(adjustl(name)) // '%user')
     call read_type_vecstring_type(structure_out%machine, trim(adjustl(name)) // '%machine')
     call read_type_integer(structure_out%shot, trim(adjustl(name)) // '%shot')
     call read_type_integer(structure_out%run, trim(adjustl(name)) // '%run')

   end subroutine read_type_entry_def

   subroutine read_arr_type_entry_def(structure_out, name)
 
     implicit none
 
     type (type_entry_def), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_entry_def(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_entry_def

   subroutine read_type_enum_instance(structure_out, name)

     implicit none

     type (type_enum_instance), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_integer(structure_out%index, trim(adjustl(name)) // '%index')

   end subroutine read_type_enum_instance

   subroutine read_arr_type_enum_instance(structure_out, name)
 
     implicit none
 
     type (type_enum_instance), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_enum_instance(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_enum_instance

   subroutine read_type_eqconstraint(structure_out, name)

     implicit none

     type (type_eqconstraint), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_eqmes1D(structure_out%bpol, trim(adjustl(name)) // '%bpol')
     call read_type_eqmes0D(structure_out%bvac_r, trim(adjustl(name)) // '%bvac_r')
     call read_type_eqmes0D(structure_out%diamagflux, trim(adjustl(name)) // '%diamagflux')
     call read_type_eqmes1D(structure_out%faraday, trim(adjustl(name)) // '%faraday')
     call read_type_eqmes1D(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_eqmes0D(structure_out%i_plasma, trim(adjustl(name)) // '%i_plasma')
     call read_type_isoflux(structure_out%isoflux, trim(adjustl(name)) // '%isoflux')
     call read_type_eqmes1D(structure_out%jsurf, trim(adjustl(name)) // '%jsurf')
     call read_type_magnet_iron(structure_out%magnet_iron, trim(adjustl(name)) // '%magnet_iron')
     call read_type_eqmes1D(structure_out%mse, trim(adjustl(name)) // '%mse')
     call read_type_eqmes1D(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_eqmes1D(structure_out%pfcurrent, trim(adjustl(name)) // '%pfcurrent')
     call read_type_eqmes1D(structure_out%pressure, trim(adjustl(name)) // '%pressure')
     call read_type_q(structure_out%q, trim(adjustl(name)) // '%q')
     call read_type_xpts(structure_out%xpts, trim(adjustl(name)) // '%xpts')

   end subroutine read_type_eqconstraint

   subroutine read_arr_type_eqconstraint(structure_out, name)
 
     implicit none
 
     type (type_eqconstraint), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_eqconstraint(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_eqconstraint

   subroutine read_type_eqgeometry(structure_out, name)

     implicit none

     type (type_eqgeometry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%boundarytype, trim(adjustl(name)) // '%boundarytype')
     call read_arr_type_rz1Dexp(structure_out%boundary, trim(adjustl(name)) // '%boundary')
     call read_type_rz0D(structure_out%geom_axis, trim(adjustl(name)) // '%geom_axis')
     call read_type_float(structure_out%a_minor, trim(adjustl(name)) // '%a_minor')
     call read_type_float(structure_out%elongation, trim(adjustl(name)) // '%elongation')
     call read_type_float(structure_out%elong_upper, trim(adjustl(name)) // '%elong_upper')
     call read_type_float(structure_out%elong_lower, trim(adjustl(name)) // '%elong_lower')
     call read_type_float(structure_out%tria_upper, trim(adjustl(name)) // '%tria_upper')
     call read_type_float(structure_out%tria_lower, trim(adjustl(name)) // '%tria_lower')
     call read_arr_type_rz1Dexp(structure_out%xpts, trim(adjustl(name)) // '%xpts')
     call read_type_rz0D(structure_out%left_low_st, trim(adjustl(name)) // '%left_low_st')
     call read_type_rz0D(structure_out%right_low_st, trim(adjustl(name)) // '%right_low_st')
     call read_type_rz0D(structure_out%left_up_st, trim(adjustl(name)) // '%left_up_st')
     call read_type_rz0D(structure_out%right_up_st, trim(adjustl(name)) // '%right_up_st')
     call read_type_rz0D(structure_out%active_limit, trim(adjustl(name)) // '%active_limit')
     call read_type_float(structure_out%ang_lcms_upo, trim(adjustl(name)) // '%ang_lcms_upo')
     call read_type_float(structure_out%ang_lcms_upi, trim(adjustl(name)) // '%ang_lcms_upi')
     call read_type_float(structure_out%ang_lcms_lwo, trim(adjustl(name)) // '%ang_lcms_lwo')
     call read_type_float(structure_out%ang_lcms_lwi, trim(adjustl(name)) // '%ang_lcms_lwi')

   end subroutine read_type_eqgeometry

   subroutine read_arr_type_eqgeometry(structure_out, name)
 
     implicit none
 
     type (type_eqgeometry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_eqgeometry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_eqgeometry

   subroutine read_type_eqmes0D(structure_out, name)

     implicit none

     type (type_eqmes0D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%measured, trim(adjustl(name)) // '%measured')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_integer(structure_out%exact, trim(adjustl(name)) // '%exact')
     call read_type_float(structure_out%weight, trim(adjustl(name)) // '%weight')
     call read_type_float(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_float(structure_out%calculated, trim(adjustl(name)) // '%calculated')
     call read_type_float(structure_out%chi2, trim(adjustl(name)) // '%chi2')

   end subroutine read_type_eqmes0D

   subroutine read_arr_type_eqmes0D(structure_out, name)
 
     implicit none
 
     type (type_eqmes0D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_eqmes0D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_eqmes0D

   subroutine read_type_eqmes1D(structure_out, name)

     implicit none

     type (type_eqmes1D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%measured, trim(adjustl(name)) // '%measured')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')
     call read_type_vecint_type(structure_out%exact, trim(adjustl(name)) // '%exact')
     call read_type_vecflt_type(structure_out%weight, trim(adjustl(name)) // '%weight')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_vecflt_type(structure_out%calculated, trim(adjustl(name)) // '%calculated')
     call read_type_vecflt_type(structure_out%chi2, trim(adjustl(name)) // '%chi2')

   end subroutine read_type_eqmes1D

   subroutine read_arr_type_eqmes1D(structure_out, name)
 
     implicit none
 
     type (type_eqmes1D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_eqmes1D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_eqmes1D

   subroutine read_type_equatorial_plane(structure_out, name)

     implicit none

     type (type_equatorial_plane), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_vecflt_type(structure_out%s, trim(adjustl(name)) // '%s')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%b_mod, trim(adjustl(name)) // '%b_mod')

   end subroutine read_type_equatorial_plane

   subroutine read_arr_type_equatorial_plane(structure_out, name)
 
     implicit none
 
     type (type_equatorial_plane), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_equatorial_plane(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_equatorial_plane

   subroutine read_type_equilibrium_profiles2d_grid(structure_out, name)

     implicit none

     type (type_equilibrium_profiles2d_grid), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%dim1, trim(adjustl(name)) // '%dim1')
     call read_type_vecflt_type(structure_out%dim2, trim(adjustl(name)) // '%dim2')
     call read_type_matint_type(structure_out%connect, trim(adjustl(name)) // '%connect')

   end subroutine read_type_equilibrium_profiles2d_grid

   subroutine read_arr_type_equilibrium_profiles2d_grid(structure_out, name)
 
     implicit none
 
     type (type_equilibrium_profiles2d_grid), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_equilibrium_profiles2d_grid(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_equilibrium_profiles2d_grid

   subroutine read_type_equilibrium_profiles_2d(structure_out, name)

     implicit none

     type (type_equilibrium_profiles_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%grid_type, trim(adjustl(name)) // '%grid_type')
     call read_type_equilibrium_profiles2d_grid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_type_matflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_matflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_matflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')
     call read_type_matflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_matflt_type(structure_out%jphi, trim(adjustl(name)) // '%jphi')
     call read_type_matflt_type(structure_out%jpar, trim(adjustl(name)) // '%jpar')
     call read_type_matflt_type(structure_out%br, trim(adjustl(name)) // '%br')
     call read_type_matflt_type(structure_out%bz, trim(adjustl(name)) // '%bz')
     call read_type_matflt_type(structure_out%bphi, trim(adjustl(name)) // '%bphi')
     call read_type_matflt_type(structure_out%vphi, trim(adjustl(name)) // '%vphi')
     call read_type_matflt_type(structure_out%vtheta, trim(adjustl(name)) // '%vtheta')
     call read_type_matflt_type(structure_out%rho_mass, trim(adjustl(name)) // '%rho_mass')
     call read_type_matflt_type(structure_out%pressure, trim(adjustl(name)) // '%pressure')
     call read_type_matflt_type(structure_out%temperature, trim(adjustl(name)) // '%temperature')

   end subroutine read_type_equilibrium_profiles_2d

   subroutine read_arr_type_equilibrium_profiles_2d(structure_out, name)
 
     implicit none
 
     type (type_equilibrium_profiles_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_equilibrium_profiles_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_equilibrium_profiles_2d

   subroutine read_type_exp0D(structure_out, name)

     implicit none

     type (type_exp0D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_float(structure_out%abserror, trim(adjustl(name)) // '%abserror')
     call read_type_float(structure_out%relerror, trim(adjustl(name)) // '%relerror')

   end subroutine read_type_exp0D

   subroutine read_arr_type_exp0D(structure_out, name)
 
     implicit none
 
     type (type_exp0D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_exp0D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_exp0D

   subroutine read_type_exp1D(structure_out, name)

     implicit none

     type (type_exp1D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%abserror, trim(adjustl(name)) // '%abserror')
     call read_type_vecflt_type(structure_out%relerror, trim(adjustl(name)) // '%relerror')

   end subroutine read_type_exp1D

   subroutine read_arr_type_exp1D(structure_out, name)
 
     implicit none
 
     type (type_exp1D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_exp1D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_exp1D

   subroutine read_type_exp2D(structure_out, name)

     implicit none

     type (type_exp2D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_matflt_type(structure_out%abserror, trim(adjustl(name)) // '%abserror')
     call read_type_matflt_type(structure_out%relerror, trim(adjustl(name)) // '%relerror')

   end subroutine read_type_exp2D

   subroutine read_arr_type_exp2D(structure_out, name)
 
     implicit none
 
     type (type_exp2D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_exp2D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_exp2D

   subroutine read_type_f_expansion(structure_out, name)

     implicit none

     type (type_f_expansion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_complexgrid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_type_complexgrid_scalar(structure_out%values, trim(adjustl(name)) // '%values')
     call read_type_dist_distrivec_distfunc_fexp_param(structure_out%parameters, trim(adjustl(name)) // '%parameters')

   end subroutine read_type_f_expansion

   subroutine read_arr_type_f_expansion(structure_out, name)
 
     implicit none
 
     type (type_f_expansion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_f_expansion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_f_expansion

   subroutine read_type_fast_thermal_separation_filter(structure_out, name)

     implicit none

     type (type_fast_thermal_separation_filter), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%method, trim(adjustl(name)) // '%method')
     call read_type_vecflt_type(structure_out%energy_sep, trim(adjustl(name)) // '%energy_sep')

   end subroutine read_type_fast_thermal_separation_filter

   subroutine read_arr_type_fast_thermal_separation_filter(structure_out, name)
 
     implicit none
 
     type (type_fast_thermal_separation_filter), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fast_thermal_separation_filter(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fast_thermal_separation_filter

   subroutine read_type_filter(structure_out, name)

     implicit none

     type (type_filter), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%num, trim(adjustl(name)) // '%num')
     call read_type_matflt_type(structure_out%den, trim(adjustl(name)) // '%den')

   end subroutine read_type_filter

   subroutine read_arr_type_filter(structure_out, name)
 
     implicit none
 
     type (type_filter), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_filter(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_filter

   subroutine read_type_flat_polygon(structure_out, name)

     implicit none

     type (type_flat_polygon), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_xyz0D(structure_out%origin, trim(adjustl(name)) // '%origin')
     call read_type_xyz0D(structure_out%basis1, trim(adjustl(name)) // '%basis1')
     call read_type_xyz0D(structure_out%basis2, trim(adjustl(name)) // '%basis2')
     call read_type_vecflt_type(structure_out%coord1, trim(adjustl(name)) // '%coord1')
     call read_type_vecflt_type(structure_out%coord2, trim(adjustl(name)) // '%coord2')

   end subroutine read_type_flat_polygon

   subroutine read_arr_type_flat_polygon(structure_out, name)
 
     implicit none
 
     type (type_flat_polygon), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_flat_polygon(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_flat_polygon

   subroutine read_type_flush(structure_out, name)

     implicit none

     type (type_flush), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_matflt_type(structure_out%coef, trim(adjustl(name)) // '%coef')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_flush

   subroutine read_arr_type_flush(structure_out, name)
 
     implicit none
 
     type (type_flush), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_flush(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_flush

   subroutine read_type_flux_loops(structure_out, name)

     implicit none

     type (type_flux_loops), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_setup_floops(structure_out%setup_floops, trim(adjustl(name)) // '%setup_floops')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_flux_loops

   subroutine read_arr_type_flux_loops(structure_out, name)
 
     implicit none
 
     type (type_flux_loops), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_flux_loops(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_flux_loops

   subroutine read_type_fluxel(structure_out, name)

     implicit none

     type (type_fluxel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%flux_dv, trim(adjustl(name)) // '%flux_dv')
     call read_type_vecflt_type(structure_out%flux_interp, trim(adjustl(name)) // '%flux_interp')

   end subroutine read_type_fluxel

   subroutine read_arr_type_fluxel(structure_out, name)
 
     implicit none
 
     type (type_fluxel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fluxel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fluxel

   subroutine read_type_fluximp(structure_out, name)

     implicit none

     type (type_fluximp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%flux_dv, trim(adjustl(name)) // '%flux_dv')
     call read_type_matflt_type(structure_out%flux_interp, trim(adjustl(name)) // '%flux_interp')

   end subroutine read_type_fluximp

   subroutine read_arr_type_fluximp(structure_out, name)
 
     implicit none
 
     type (type_fluximp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fluximp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fluximp

   subroutine read_type_fluxion(structure_out, name)

     implicit none

     type (type_fluxion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%flux_dv, trim(adjustl(name)) // '%flux_dv')
     call read_type_matflt_type(structure_out%flux_interp, trim(adjustl(name)) // '%flux_interp')

   end subroutine read_type_fluxion

   subroutine read_arr_type_fluxion(structure_out, name)
 
     implicit none
 
     type (type_fluxion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fluxion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fluxion

   subroutine read_type_focussing(structure_out, name)

     implicit none

     type (type_focussing), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%focal_len_hz, trim(adjustl(name)) // '%focal_len_hz')
     call read_type_float(structure_out%focal_len_vc, trim(adjustl(name)) // '%focal_len_vc')
     call read_type_float(structure_out%width_min_hz, trim(adjustl(name)) // '%width_min_hz')
     call read_type_float(structure_out%width_min_vc, trim(adjustl(name)) // '%width_min_vc')

   end subroutine read_type_focussing

   subroutine read_arr_type_focussing(structure_out, name)
 
     implicit none
 
     type (type_focussing), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_focussing(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_focussing

   subroutine read_type_fullwave(structure_out, name)

     implicit none

     type (type_fullwave), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_complexgrid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_type_e_components(structure_out%e_components, trim(adjustl(name)) // '%e_components')
     call read_type_pol_decomp(structure_out%pol_decomp, trim(adjustl(name)) // '%pol_decomp')
     call read_type_local(structure_out%local, trim(adjustl(name)) // '%local')

   end subroutine read_type_fullwave

   subroutine read_arr_type_fullwave(structure_out, name)
 
     implicit none
 
     type (type_fullwave), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fullwave(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fullwave

   subroutine read_type_fusiondiag_colli_3d(structure_out, name)

     implicit none

     type (type_fusiondiag_colli_3d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_arr_type_fusiondiag_voxels(structure_out%voxels, trim(adjustl(name)) // '%voxels')

   end subroutine read_type_fusiondiag_colli_3d

   subroutine read_arr_type_fusiondiag_colli_3d(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_colli_3d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_colli_3d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_colli_3d

   subroutine read_type_fusiondiag_colli_circ(structure_out, name)

     implicit none

     type (type_fusiondiag_colli_circ), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_setup_line(structure_out%setup_line, trim(adjustl(name)) // '%setup_line')
     call read_arr_type_fusiondiag_colliunit_circ(structure_out%colliunit, trim(adjustl(name)) // '%colliunit')

   end subroutine read_type_fusiondiag_colli_circ

   subroutine read_arr_type_fusiondiag_colli_circ(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_colli_circ), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_colli_circ(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_colli_circ

   subroutine read_type_fusiondiag_colli_poly(structure_out, name)

     implicit none

     type (type_fusiondiag_colli_poly), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_setup_line(structure_out%setup_line, trim(adjustl(name)) // '%setup_line')
     call read_arr_type_fusiondiag_colliunit_poly(structure_out%colliunit, trim(adjustl(name)) // '%colliunit')

   end subroutine read_type_fusiondiag_colli_poly

   subroutine read_arr_type_fusiondiag_colli_poly(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_colli_poly), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_colli_poly(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_colli_poly

   subroutine read_type_fusiondiag_collimator(structure_out, name)

     implicit none

     type (type_fusiondiag_collimator), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_fusiondiag_colli_circ(structure_out%colli_circ, trim(adjustl(name)) // '%colli_circ')
     call read_arr_type_fusiondiag_colli_poly(structure_out%colli_poly, trim(adjustl(name)) // '%colli_poly')
     call read_arr_type_fusiondiag_colli_3d(structure_out%colli_3d, trim(adjustl(name)) // '%colli_3d')

   end subroutine read_type_fusiondiag_collimator

   subroutine read_arr_type_fusiondiag_collimator(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_collimator), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_collimator(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_collimator

   subroutine read_type_fusiondiag_colliunit_circ(structure_out, name)

     implicit none

     type (type_fusiondiag_colliunit_circ), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%radius, trim(adjustl(name)) // '%radius')
     call read_type_rzphi1D(structure_out%centre, trim(adjustl(name)) // '%centre')

   end subroutine read_type_fusiondiag_colliunit_circ

   subroutine read_arr_type_fusiondiag_colliunit_circ(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_colliunit_circ), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_colliunit_circ(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_colliunit_circ

   subroutine read_type_fusiondiag_colliunit_poly(structure_out, name)

     implicit none

     type (type_fusiondiag_colliunit_poly), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%dimension, trim(adjustl(name)) // '%dimension')
     call read_type_rzphi2D(structure_out%nodes, trim(adjustl(name)) // '%nodes')

   end subroutine read_type_fusiondiag_colliunit_poly

   subroutine read_arr_type_fusiondiag_colliunit_poly(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_colliunit_poly), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_colliunit_poly(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_colliunit_poly

   subroutine read_type_fusiondiag_counts(structure_out, name)

     implicit none

     type (type_fusiondiag_counts), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%units, trim(adjustl(name)) // '%units')
     call read_arr_type_fusiondiag_ct_chords(structure_out%ct_chords, trim(adjustl(name)) // '%ct_chords')
     call read_arr_type_fusiondiag_ct_energy(structure_out%ct_energy, trim(adjustl(name)) // '%ct_energy')
     call read_arr_type_fusiondiag_detect_ct_energy(structure_out%detect_ct, trim(adjustl(name)) // '%detect_ct')

   end subroutine read_type_fusiondiag_counts

   subroutine read_arr_type_fusiondiag_counts(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_counts), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_counts(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_counts

   subroutine read_type_fusiondiag_ct_chords(structure_out, name)

     implicit none

     type (type_fusiondiag_ct_chords), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_exp0D(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_fusiondiag_ct_chords

   subroutine read_arr_type_fusiondiag_ct_chords(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_ct_chords), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_ct_chords(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_ct_chords

   subroutine read_type_fusiondiag_ct_energy(structure_out, name)

     implicit none

     type (type_fusiondiag_ct_energy), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_fusiondiag_ct_energy

   subroutine read_arr_type_fusiondiag_ct_energy(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_ct_energy), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_ct_energy(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_ct_energy

   subroutine read_type_fusiondiag_detect_ct_energy(structure_out, name)

     implicit none

     type (type_fusiondiag_detect_ct_energy), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_diag_func(structure_out%diag_func, trim(adjustl(name)) // '%diag_func')

   end subroutine read_type_fusiondiag_detect_ct_energy

   subroutine read_arr_type_fusiondiag_detect_ct_energy(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_detect_ct_energy), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_detect_ct_energy(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_detect_ct_energy

   subroutine read_type_fusiondiag_emissivity1d(structure_out, name)

     implicit none

     type (type_fusiondiag_emissivity1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%units, trim(adjustl(name)) // '%units')
     call read_type_exp1D(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_exp1D(structure_out%z, trim(adjustl(name)) // '%z')
     call read_arr_type_fusiondiag_spec1d(structure_out%spec1d, trim(adjustl(name)) // '%spec1d')

   end subroutine read_type_fusiondiag_emissivity1d

   subroutine read_arr_type_fusiondiag_emissivity1d(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_emissivity1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_emissivity1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_emissivity1d

   subroutine read_type_fusiondiag_emissivity2d(structure_out, name)

     implicit none

     type (type_fusiondiag_emissivity2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%units, trim(adjustl(name)) // '%units')
     call read_type_exp2D(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_exp2D(structure_out%z, trim(adjustl(name)) // '%z')
     call read_arr_type_fusiondiag_spec2d(structure_out%spec2d, trim(adjustl(name)) // '%spec2d')

   end subroutine read_type_fusiondiag_emissivity2d

   subroutine read_arr_type_fusiondiag_emissivity2d(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_emissivity2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_emissivity2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_emissivity2d

   subroutine read_type_fusiondiag_fus_product(structure_out, name)

     implicit none

     type (type_fusiondiag_fus_product), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%product, trim(adjustl(name)) // '%product')
     call read_type_vecstring_type(structure_out%reaction, trim(adjustl(name)) // '%reaction')
     call read_type_fusiondiag_collimator(structure_out%collimator, trim(adjustl(name)) // '%collimator')
     call read_type_fusiondiag_counts(structure_out%counts, trim(adjustl(name)) // '%counts')
     call read_type_fusiondiag_emissivity1d(structure_out%emissivity1d, trim(adjustl(name)) // '%emissivity1d')
     call read_type_fusiondiag_emissivity2d(structure_out%emissivity2d, trim(adjustl(name)) // '%emissivity2d')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_fusiondiag_fus_product

   subroutine read_arr_type_fusiondiag_fus_product(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_fus_product), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_fus_product(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_fus_product

   subroutine read_type_fusiondiag_spec1d(structure_out, name)

     implicit none

     type (type_fusiondiag_spec1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp0D(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_fusiondiag_spec1d

   subroutine read_arr_type_fusiondiag_spec1d(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_spec1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_spec1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_spec1d

   subroutine read_type_fusiondiag_spec2d(structure_out, name)

     implicit none

     type (type_fusiondiag_spec2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp0D(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_exp2D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_fusiondiag_spec2d

   subroutine read_arr_type_fusiondiag_spec2d(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_spec2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_spec2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_spec2d

   subroutine read_type_fusiondiag_voxels(structure_out, name)

     implicit none

     type (type_fusiondiag_voxels), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi0D(structure_out%centre, trim(adjustl(name)) // '%centre')
     call read_type_rzphi0D(structure_out%direction, trim(adjustl(name)) // '%direction')
     call read_type_float(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_float(structure_out%solid_angle, trim(adjustl(name)) // '%solid_angle')

   end subroutine read_type_fusiondiag_voxels

   subroutine read_arr_type_fusiondiag_voxels(structure_out, name)
 
     implicit none
 
     type (type_fusiondiag_voxels), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_fusiondiag_voxels(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_fusiondiag_voxels

   subroutine read_type_geom(structure_out, name)

     implicit none

     type (type_geom), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%dr_bb_sh_ib, trim(adjustl(name)) // '%dr_bb_sh_ib')
     call read_type_float(structure_out%dr_sh_vv_ib, trim(adjustl(name)) // '%dr_sh_vv_ib')
     call read_type_float(structure_out%dr_bb_sh_ob, trim(adjustl(name)) // '%dr_bb_sh_ob')
     call read_type_float(structure_out%dr_sh_vv_ob, trim(adjustl(name)) // '%dr_sh_vv_ob')
     call read_type_float(structure_out%dr_bb__sh_ib, trim(adjustl(name)) // '%dr_bb__sh_ib')
     call read_type_float(structure_out%dr_bb__sh_ob, trim(adjustl(name)) // '%dr_bb__sh_ob')
     call read_type_float(structure_out%delta_int, trim(adjustl(name)) // '%delta_int')

   end subroutine read_type_geom

   subroutine read_arr_type_geom(structure_out, name)
 
     implicit none
 
     type (type_geom), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_geom(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_geom

   subroutine read_type_geom_iron(structure_out, name)

     implicit none

     type (type_geom_iron), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%npoints, trim(adjustl(name)) // '%npoints')
     call read_type_rz2D(structure_out%rzcoordinate, trim(adjustl(name)) // '%rzcoordinate')

   end subroutine read_type_geom_iron

   subroutine read_arr_type_geom_iron(structure_out, name)
 
     implicit none
 
     type (type_geom_iron), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_geom_iron(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_geom_iron

   subroutine read_type_global_param(structure_out, name)

     implicit none

     type (type_global_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%beta_pol, trim(adjustl(name)) // '%beta_pol')
     call read_type_float(structure_out%beta_tor, trim(adjustl(name)) // '%beta_tor')
     call read_type_float(structure_out%beta_normal, trim(adjustl(name)) // '%beta_normal')
     call read_type_float(structure_out%i_plasma, trim(adjustl(name)) // '%i_plasma')
     call read_type_float(structure_out%li, trim(adjustl(name)) // '%li')
     call read_type_float(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_float(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_float(structure_out%psi_ax, trim(adjustl(name)) // '%psi_ax')
     call read_type_float(structure_out%psi_bound, trim(adjustl(name)) // '%psi_bound')
     call read_type_mag_axis(structure_out%mag_axis, trim(adjustl(name)) // '%mag_axis')
     call read_type_float(structure_out%q_95, trim(adjustl(name)) // '%q_95')
     call read_type_float(structure_out%q_min, trim(adjustl(name)) // '%q_min')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')
     call read_type_float(structure_out%w_mhd, trim(adjustl(name)) // '%w_mhd')
     call read_type_float(structure_out%gamma, trim(adjustl(name)) // '%gamma')

   end subroutine read_type_global_param

   subroutine read_arr_type_global_param(structure_out, name)
 
     implicit none
 
     type (type_global_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_global_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_global_param

   subroutine read_type_globalparam(structure_out, name)

     implicit none

     type (type_globalparam), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%current_tot, trim(adjustl(name)) // '%current_tot')
     call read_type_float(structure_out%current_bnd, trim(adjustl(name)) // '%current_bnd')
     call read_type_float(structure_out%current_ni, trim(adjustl(name)) // '%current_ni')
     call read_type_float(structure_out%vloop, trim(adjustl(name)) // '%vloop')
     call read_type_float(structure_out%li, trim(adjustl(name)) // '%li')
     call read_type_float(structure_out%beta_tor, trim(adjustl(name)) // '%beta_tor')
     call read_type_float(structure_out%beta_normal, trim(adjustl(name)) // '%beta_normal')
     call read_type_float(structure_out%beta_pol, trim(adjustl(name)) // '%beta_pol')
     call read_type_float(structure_out%w_dia, trim(adjustl(name)) // '%w_dia')
     call read_type_rz0D(structure_out%geom_axis, trim(adjustl(name)) // '%geom_axis')

   end subroutine read_type_globalparam

   subroutine read_arr_type_globalparam(structure_out, name)
 
     implicit none
 
     type (type_globalparam), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_globalparam(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_globalparam

   subroutine read_type_halpha_setup(structure_out, name)

     implicit none

     type (type_halpha_setup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_rzphi1D(structure_out%pivot_point, trim(adjustl(name)) // '%pivot_point')
     call read_type_vecflt_type(structure_out%horchordang, trim(adjustl(name)) // '%horchordang')
     call read_type_vecflt_type(structure_out%verchordang, trim(adjustl(name)) // '%verchordang')
     call read_type_rzphi1D(structure_out%second_point, trim(adjustl(name)) // '%second_point')
     call read_type_exp1D(structure_out%solidangle, trim(adjustl(name)) // '%solidangle')

   end subroutine read_type_halpha_setup

   subroutine read_arr_type_halpha_setup(structure_out, name)
 
     implicit none
 
     type (type_halpha_setup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_halpha_setup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_halpha_setup

   subroutine read_type_hcll(structure_out, name)

     implicit none

     type (type_hcll), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_mat_lim(structure_out%mat_lim, trim(adjustl(name)) // '%mat_lim')
     call read_type_hcll_bb(structure_out%hcll_bb, trim(adjustl(name)) // '%hcll_bb')

   end subroutine read_type_hcll

   subroutine read_arr_type_hcll(structure_out, name)
 
     implicit none
 
     type (type_hcll), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_hcll(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_hcll

   subroutine read_type_hcll_bb(structure_out, name)

     implicit none

     type (type_hcll_bb), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%bb_lifetime, trim(adjustl(name)) // '%bb_lifetime')
     call read_type_float(structure_out%he_inl_t, trim(adjustl(name)) // '%he_inl_t')
     call read_type_float(structure_out%he_fr, trim(adjustl(name)) // '%he_fr')
     call read_type_float(structure_out%he_inl_p, trim(adjustl(name)) // '%he_inl_p')
     call read_type_float(structure_out%loca_des_p, trim(adjustl(name)) // '%loca_des_p')
     call read_type_float(structure_out%he_dp, trim(adjustl(name)) // '%he_dp')
     call read_type_float(structure_out%lipb_dp, trim(adjustl(name)) // '%lipb_dp')
     call read_type_react(structure_out%react, trim(adjustl(name)) // '%react')
     call read_type_hcllbb_specs(structure_out%inboard, trim(adjustl(name)) // '%inboard')
     call read_type_hcllbb_specs(structure_out%outboard, trim(adjustl(name)) // '%outboard')

   end subroutine read_type_hcll_bb

   subroutine read_arr_type_hcll_bb(structure_out, name)
 
     implicit none
 
     type (type_hcll_bb), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_hcll_bb(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_hcll_bb

   subroutine read_type_hcllbb_specs(structure_out, name)

     implicit none

     type (type_hcllbb_specs), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%mass, trim(adjustl(name)) // '%mass')
     call read_type_vecflt_type(structure_out%dr, trim(adjustl(name)) // '%dr')
     call read_type_vecflt_type(structure_out%mat, trim(adjustl(name)) // '%mat')
     call read_type_matflt_type(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_bb_geometry(structure_out%mod_geom, trim(adjustl(name)) // '%mod_geom')
     call read_type_mode_neutr(structure_out%mod_neutr, trim(adjustl(name)) // '%mod_neutr')
     call read_type_mode_therm(structure_out%mod_therm, trim(adjustl(name)) // '%mod_therm')
     call read_type_mode_th_hyd(structure_out%mod_th_hyd, trim(adjustl(name)) // '%mod_th_hyd')
     call read_type_mode_mech(structure_out%mod_mech, trim(adjustl(name)) // '%mod_mech')
     call read_type_mode_lipb(structure_out%mod_lipb, trim(adjustl(name)) // '%mod_lipb')
     call read_type_mode_tritium(structure_out%mod_tritium, trim(adjustl(name)) // '%mod_tritium')

   end subroutine read_type_hcllbb_specs

   subroutine read_arr_type_hcllbb_specs(structure_out, name)
 
     implicit none
 
     type (type_hcllbb_specs), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_hcllbb_specs(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_hcllbb_specs

   subroutine read_type_holes(structure_out, name)

     implicit none

     type (type_holes), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%n_holes, trim(adjustl(name)) // '%n_holes')
     call read_type_coordinates(structure_out%coordinates, trim(adjustl(name)) // '%coordinates')
     call read_type_width(structure_out%width, trim(adjustl(name)) // '%width')
     call read_type_vecflt_type(structure_out%eta, trim(adjustl(name)) // '%eta')

   end subroutine read_type_holes

   subroutine read_arr_type_holes(structure_out, name)
 
     implicit none
 
     type (type_holes), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_holes(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_holes

   subroutine read_type_identifier(structure_out, name)

     implicit none

     type (type_identifier), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')
     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')

   end subroutine read_type_identifier

   subroutine read_arr_type_identifier(structure_out, name)
 
     implicit none
 
     type (type_identifier), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_identifier(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_identifier

   subroutine read_type_impcoeff(structure_out, name)

     implicit none

     type (type_impcoeff), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_coefficients_neutrals(structure_out%chargestate, trim(adjustl(name)) // '%chargestate')

   end subroutine read_type_impcoeff

   subroutine read_arr_type_impcoeff(structure_out, name)
 
     implicit none
 
     type (type_impcoeff), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_impcoeff(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_impcoeff

   subroutine read_type_impurities(structure_out, name)

     implicit none

     type (type_impurities), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nucindex, trim(adjustl(name)) // '%nucindex')
     call read_type_integer(structure_out%i_ion, trim(adjustl(name)) // '%i_ion')
     call read_type_integer(structure_out%nzimp, trim(adjustl(name)) // '%nzimp')
     call read_type_vecflt_type(structure_out%zmin, trim(adjustl(name)) // '%zmin')
     call read_type_vecflt_type(structure_out%zmax, trim(adjustl(name)) // '%zmax')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_impurities

   subroutine read_arr_type_impurities(structure_out, name)
 
     implicit none
 
     type (type_impurities), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_impurities(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_impurities

   subroutine read_type_impurity_type(structure_out, name)

     implicit none

     type (type_impurity_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_matflt_type(structure_out%zsq, trim(adjustl(name)) // '%zsq')
     call read_type_matflt_type(structure_out%nz, trim(adjustl(name)) // '%nz')
     call read_type_matflt_type(structure_out%tz, trim(adjustl(name)) // '%tz')
     call read_type_sourceimp(structure_out%source_term, trim(adjustl(name)) // '%source_term')
     call read_type_boundaryimp(structure_out%boundary, trim(adjustl(name)) // '%boundary')
     call read_type_coretransimp(structure_out%transp_coef, trim(adjustl(name)) // '%transp_coef')
     call read_type_fluximp(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_matflt_type(structure_out%time_deriv, trim(adjustl(name)) // '%time_deriv')
     call read_type_coreimpurediag_type(structure_out%diagnostic, trim(adjustl(name)) // '%diagnostic')

   end subroutine read_type_impurity_type

   subroutine read_arr_type_impurity_type(structure_out, name)
 
     implicit none
 
     type (type_impurity_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_impurity_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_impurity_type

   subroutine read_type_inj_spec(structure_out, name)

     implicit none

     type (type_inj_spec), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_float(structure_out%zn, trim(adjustl(name)) // '%zn')

   end subroutine read_type_inj_spec

   subroutine read_arr_type_inj_spec(structure_out, name)
 
     implicit none
 
     type (type_inj_spec), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_inj_spec(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_inj_spec

   subroutine read_type_ions(structure_out, name)

     implicit none

     type (type_ions), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nucindex, trim(adjustl(name)) // '%nucindex')
     call read_type_float(structure_out%zion, trim(adjustl(name)) // '%zion')
     call read_type_integer(structure_out%imp_flag, trim(adjustl(name)) // '%imp_flag')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_ions

   subroutine read_arr_type_ions(structure_out, name)
 
     implicit none
 
     type (type_ions), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ions(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ions

   subroutine read_type_isoflux(structure_out, name)

     implicit none

     type (type_isoflux), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecflt_type(structure_out%weight, trim(adjustl(name)) // '%weight')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_vecflt_type(structure_out%calculated, trim(adjustl(name)) // '%calculated')
     call read_type_vecflt_type(structure_out%chi2, trim(adjustl(name)) // '%chi2')

   end subroutine read_type_isoflux

   subroutine read_arr_type_isoflux(structure_out, name)
 
     implicit none
 
     type (type_isoflux), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_isoflux(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_isoflux

   subroutine read_type_jni(structure_out, name)

     implicit none

     type (type_jni), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%integral, trim(adjustl(name)) // '%integral')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_jni

   subroutine read_arr_type_jni(structure_out, name)
 
     implicit none
 
     type (type_jni), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_jni(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_jni

   subroutine read_type_lang_derived(structure_out, name)

     implicit none

     type (type_lang_derived), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_rzphi1Dexp(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_lang_derived

   subroutine read_arr_type_lang_derived(structure_out, name)
 
     implicit none
 
     type (type_lang_derived), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_lang_derived(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_lang_derived

   subroutine read_type_lang_measure(structure_out, name)

     implicit none

     type (type_lang_measure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%direction, trim(adjustl(name)) // '%direction')
     call read_type_exp1D(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_rzphi1Dexp(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_lang_measure

   subroutine read_arr_type_lang_measure(structure_out, name)
 
     implicit none
 
     type (type_lang_measure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_lang_measure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_lang_measure

   subroutine read_type_launchangles(structure_out, name)

     implicit none

     type (type_launchangles), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%alpha, trim(adjustl(name)) // '%alpha')
     call read_type_float(structure_out%beta, trim(adjustl(name)) // '%beta')

   end subroutine read_type_launchangles

   subroutine read_arr_type_launchangles(structure_out, name)
 
     implicit none
 
     type (type_launchangles), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchangles(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchangles

   subroutine read_type_launchs_parallel(structure_out, name)

     implicit none

     type (type_launchs_parallel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%nn_par, trim(adjustl(name)) // '%nn_par')
     call read_type_matflt_type(structure_out%n_par, trim(adjustl(name)) // '%n_par')
     call read_type_vecflt_type(structure_out%power, trim(adjustl(name)) // '%power')

   end subroutine read_type_launchs_parallel

   subroutine read_arr_type_launchs_parallel(structure_out, name)
 
     implicit none
 
     type (type_launchs_parallel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchs_parallel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchs_parallel

   subroutine read_type_launchs_phi_theta(structure_out, name)

     implicit none

     type (type_launchs_phi_theta), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%nn_phi, trim(adjustl(name)) // '%nn_phi')
     call read_type_vecint_type(structure_out%nn_theta, trim(adjustl(name)) // '%nn_theta')
     call read_type_matflt_type(structure_out%n_phi, trim(adjustl(name)) // '%n_phi')
     call read_type_matflt_type(structure_out%n_theta, trim(adjustl(name)) // '%n_theta')
     call read_type_array3dflt_type(structure_out%power, trim(adjustl(name)) // '%power')

   end subroutine read_type_launchs_phi_theta

   subroutine read_arr_type_launchs_phi_theta(structure_out, name)
 
     implicit none
 
     type (type_launchs_phi_theta), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchs_phi_theta(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchs_phi_theta

   subroutine read_type_launchs_rfbeam(structure_out, name)

     implicit none

     type (type_launchs_rfbeam), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_launchs_rfbeam_spot(structure_out%spot, trim(adjustl(name)) // '%spot')
     call read_type_launchs_rfbeam_phaseellipse(structure_out%phaseellipse, trim(adjustl(name)) // '%phaseellipse')

   end subroutine read_type_launchs_rfbeam

   subroutine read_arr_type_launchs_rfbeam(structure_out, name)
 
     implicit none
 
     type (type_launchs_rfbeam), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchs_rfbeam(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchs_rfbeam

   subroutine read_type_launchs_rfbeam_phaseellipse(structure_out, name)

     implicit none

     type (type_launchs_rfbeam_phaseellipse), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%invcurvrad, trim(adjustl(name)) // '%invcurvrad')
     call read_type_vecflt_type(structure_out%angle, trim(adjustl(name)) // '%angle')

   end subroutine read_type_launchs_rfbeam_phaseellipse

   subroutine read_arr_type_launchs_rfbeam_phaseellipse(structure_out, name)
 
     implicit none
 
     type (type_launchs_rfbeam_phaseellipse), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchs_rfbeam_phaseellipse(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchs_rfbeam_phaseellipse

   subroutine read_type_launchs_rfbeam_spot(structure_out, name)

     implicit none

     type (type_launchs_rfbeam_spot), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%waist, trim(adjustl(name)) // '%waist')
     call read_type_vecflt_type(structure_out%angle, trim(adjustl(name)) // '%angle')

   end subroutine read_type_launchs_rfbeam_spot

   subroutine read_arr_type_launchs_rfbeam_spot(structure_out, name)
 
     implicit none
 
     type (type_launchs_rfbeam_spot), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchs_rfbeam_spot(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchs_rfbeam_spot

   subroutine read_type_launchsignal(structure_out, name)

     implicit none

     type (type_launchsignal), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%time_launch, trim(adjustl(name)) // '%time_launch')
     call read_type_vecflt_type(structure_out%freq, trim(adjustl(name)) // '%freq')
     call read_type_vecflt_type(structure_out%amplitude, trim(adjustl(name)) // '%amplitude')
     call read_type_vecflt_type(structure_out%phase, trim(adjustl(name)) // '%phase')

   end subroutine read_type_launchsignal

   subroutine read_arr_type_launchsignal(structure_out, name)
 
     implicit none
 
     type (type_launchsignal), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_launchsignal(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_launchsignal

   subroutine read_type_limiter_unit(structure_out, name)

     implicit none

     type (type_limiter_unit), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%closed, trim(adjustl(name)) // '%closed')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_float(structure_out%eta, trim(adjustl(name)) // '%eta')
     call read_type_float(structure_out%delta, trim(adjustl(name)) // '%delta')
     call read_type_float(structure_out%permeability, trim(adjustl(name)) // '%permeability')

   end subroutine read_type_limiter_unit

   subroutine read_arr_type_limiter_unit(structure_out, name)
 
     implicit none
 
     type (type_limiter_unit), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_limiter_unit(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_limiter_unit

   subroutine read_type_limits(structure_out, name)

     implicit none

     type (type_limits), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%fw_dpa, trim(adjustl(name)) // '%fw_dpa')
     call read_type_float(structure_out%he_appm, trim(adjustl(name)) // '%he_appm')
     call read_type_float(structure_out%ins_dose, trim(adjustl(name)) // '%ins_dose')
     call read_type_float(structure_out%fn_flu, trim(adjustl(name)) // '%fn_flu')
     call read_type_float(structure_out%dpa_cu, trim(adjustl(name)) // '%dpa_cu')
     call read_type_float(structure_out%wp_nh, trim(adjustl(name)) // '%wp_nh')

   end subroutine read_type_limits

   subroutine read_arr_type_limits(structure_out, name)
 
     implicit none
 
     type (type_limits), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_limits(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_limits

   subroutine read_type_lineintegraldiag(structure_out, name)

     implicit none

     type (type_lineintegraldiag), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_datainfo(structure_out%datainfo, trim(adjustl(name)) // '%datainfo')
     call read_type_vecstring_type(structure_out%expression, trim(adjustl(name)) // '%expression')
     call read_type_setup_line(structure_out%setup_line, trim(adjustl(name)) // '%setup_line')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_lineintegraldiag

   subroutine read_arr_type_lineintegraldiag(structure_out, name)
 
     implicit none
 
     type (type_lineintegraldiag), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_lineintegraldiag(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_lineintegraldiag

   subroutine read_type_lithmeasure(structure_out, name)

     implicit none

     type (type_lithmeasure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%ne, trim(adjustl(name)) // '%ne')

   end subroutine read_type_lithmeasure

   subroutine read_arr_type_lithmeasure(structure_out, name)
 
     implicit none
 
     type (type_lithmeasure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_lithmeasure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_lithmeasure

   subroutine read_type_lithsetup(structure_out, name)

     implicit none

     type (type_lithsetup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1D(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_lithsetup

   subroutine read_arr_type_lithsetup(structure_out, name)
 
     implicit none
 
     type (type_lithsetup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_lithsetup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_lithsetup

   subroutine read_type_local(structure_out, name)

     implicit none

     type (type_local), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%e_plus, trim(adjustl(name)) // '%e_plus')
     call read_type_array3dflt_type(structure_out%e_plus_ph, trim(adjustl(name)) // '%e_plus_ph')
     call read_type_array3dflt_type(structure_out%e_minus, trim(adjustl(name)) // '%e_minus')
     call read_type_array3dflt_type(structure_out%e_minus_ph, trim(adjustl(name)) // '%e_minus_ph')
     call read_type_array3dint_type(structure_out%e_norm, trim(adjustl(name)) // '%e_norm')
     call read_type_array3dflt_type(structure_out%enorm_ph, trim(adjustl(name)) // '%enorm_ph')
     call read_type_array3dflt_type(structure_out%e_binorm, trim(adjustl(name)) // '%e_binorm')
     call read_type_array3dflt_type(structure_out%e_binorm_ph, trim(adjustl(name)) // '%e_binorm_ph')
     call read_type_array3dflt_type(structure_out%e_para, trim(adjustl(name)) // '%e_para')
     call read_type_array3dflt_type(structure_out%e_para_ph, trim(adjustl(name)) // '%e_para_ph')
     call read_type_array3dflt_type(structure_out%b_norm, trim(adjustl(name)) // '%b_norm')
     call read_type_array3dflt_type(structure_out%b_norm_ph, trim(adjustl(name)) // '%b_norm_ph')
     call read_type_array3dflt_type(structure_out%b_binorm, trim(adjustl(name)) // '%b_binorm')
     call read_type_array3dflt_type(structure_out%b_binorm_ph, trim(adjustl(name)) // '%b_binorm_ph')
     call read_type_array3dflt_type(structure_out%b_para, trim(adjustl(name)) // '%b_para')
     call read_type_array3dflt_type(structure_out%b_para_ph, trim(adjustl(name)) // '%b_para_ph')
     call read_type_array3dflt_type(structure_out%k_perp, trim(adjustl(name)) // '%k_perp')

   end subroutine read_type_local

   subroutine read_arr_type_local(structure_out, name)
 
     implicit none
 
     type (type_local), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_local(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_local

   subroutine read_type_mag_axis(structure_out, name)

     implicit none

     type (type_mag_axis), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz0D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_float(structure_out%bphi, trim(adjustl(name)) // '%bphi')
     call read_type_float(structure_out%q, trim(adjustl(name)) // '%q')

   end subroutine read_type_mag_axis

   subroutine read_arr_type_mag_axis(structure_out, name)
 
     implicit none
 
     type (type_mag_axis), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mag_axis(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mag_axis

   subroutine read_type_magnet_iron(structure_out, name)

     implicit none

     type (type_magnet_iron), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_eqmes1D(structure_out%mr, trim(adjustl(name)) // '%mr')
     call read_type_eqmes1D(structure_out%mz, trim(adjustl(name)) // '%mz')

   end subroutine read_type_magnet_iron

   subroutine read_arr_type_magnet_iron(structure_out, name)
 
     implicit none
 
     type (type_magnet_iron), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_magnet_iron(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_magnet_iron

   subroutine read_type_magnetise(structure_out, name)

     implicit none

     type (type_magnetise), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%mr, trim(adjustl(name)) // '%mr')
     call read_type_exp1D(structure_out%mz, trim(adjustl(name)) // '%mz')

   end subroutine read_type_magnetise

   subroutine read_arr_type_magnetise(structure_out, name)
 
     implicit none
 
     type (type_magnetise), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_magnetise(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_magnetise

   subroutine read_type_mat_lim(structure_out, name)

     implicit none

     type (type_mat_lim), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%cool_t_lim, trim(adjustl(name)) // '%cool_t_lim')
     call read_type_float(structure_out%steel_t_lim, trim(adjustl(name)) // '%steel_t_lim')
     call read_type_float(structure_out%lipb_t_lim, trim(adjustl(name)) // '%lipb_t_lim')

   end subroutine read_type_mat_lim

   subroutine read_arr_type_mat_lim(structure_out, name)
 
     implicit none
 
     type (type_mat_lim), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mat_lim(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mat_lim

   subroutine read_type_mdinfo(structure_out, name)

     implicit none

     type (type_mdinfo), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%shot_min, trim(adjustl(name)) // '%shot_min')
     call read_type_integer(structure_out%shot_max, trim(adjustl(name)) // '%shot_max')
     call read_type_entry_def(structure_out%md_entry, trim(adjustl(name)) // '%md_entry')

   end subroutine read_type_mdinfo

   subroutine read_arr_type_mdinfo(structure_out, name)
 
     implicit none
 
     type (type_mdinfo), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mdinfo(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mdinfo

   subroutine read_type_mhd_ideal_wall2d(structure_out, name)

     implicit none

     type (type_mhd_ideal_wall2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%walltype, trim(adjustl(name)) // '%walltype')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_mhd_ideal_wall2d

   subroutine read_arr_type_mhd_ideal_wall2d(structure_out, name)
 
     implicit none
 
     type (type_mhd_ideal_wall2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd_ideal_wall2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd_ideal_wall2d

   subroutine read_type_mhd_mode(structure_out, name)

     implicit none

     type (type_mhd_mode), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%modenum, trim(adjustl(name)) // '%modenum')
     call read_type_float(structure_out%growthrate, trim(adjustl(name)) // '%growthrate')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_mhd_plasma(structure_out%plasma, trim(adjustl(name)) // '%plasma')
     call read_type_mhd_vacuum(structure_out%vacuum, trim(adjustl(name)) // '%vacuum')

   end subroutine read_type_mhd_mode

   subroutine read_arr_type_mhd_mode(structure_out, name)
 
     implicit none
 
     type (type_mhd_mode), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd_mode(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd_mode

   subroutine read_type_mhd_plasma(structure_out, name)

     implicit none

     type (type_mhd_plasma), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_matflt_type(structure_out%m, trim(adjustl(name)) // '%m')
     call read_type_matcplx_type(structure_out%disp_perp, trim(adjustl(name)) // '%disp_perp')
     call read_type_matcplx_type(structure_out%disp_par, trim(adjustl(name)) // '%disp_par')
     call read_type_vecflt_type(structure_out%tau_alfven, trim(adjustl(name)) // '%tau_alfven')
     call read_type_vecflt_type(structure_out%tau_res, trim(adjustl(name)) // '%tau_res')
     call read_type_coord_sys(structure_out%coord_sys, trim(adjustl(name)) // '%coord_sys')
     call read_type_mhd_vector(structure_out%a_pert, trim(adjustl(name)) // '%a_pert')
     call read_type_mhd_vector(structure_out%b_pert, trim(adjustl(name)) // '%b_pert')
     call read_type_mhd_vector(structure_out%v_pert, trim(adjustl(name)) // '%v_pert')
     call read_type_matcplx_type(structure_out%p_pert, trim(adjustl(name)) // '%p_pert')
     call read_type_matcplx_type(structure_out%rho_mass_per, trim(adjustl(name)) // '%rho_mass_per')
     call read_type_matcplx_type(structure_out%temp_per, trim(adjustl(name)) // '%temp_per')

   end subroutine read_type_mhd_plasma

   subroutine read_arr_type_mhd_plasma(structure_out, name)
 
     implicit none
 
     type (type_mhd_plasma), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd_plasma(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd_plasma

   subroutine read_type_mhd_res_wall2d(structure_out, name)

     implicit none

     type (type_mhd_res_wall2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%walltype, trim(adjustl(name)) // '%walltype')
     call read_type_float(structure_out%delta, trim(adjustl(name)) // '%delta')
     call read_type_float(structure_out%eta, trim(adjustl(name)) // '%eta')
     call read_type_integer(structure_out%npoloidal, trim(adjustl(name)) // '%npoloidal')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_holes(structure_out%holes, trim(adjustl(name)) // '%holes')

   end subroutine read_type_mhd_res_wall2d

   subroutine read_arr_type_mhd_res_wall2d(structure_out, name)
 
     implicit none
 
     type (type_mhd_res_wall2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd_res_wall2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd_res_wall2d

   subroutine read_type_mhd_vacuum(structure_out, name)

     implicit none

     type (type_mhd_vacuum), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%m, trim(adjustl(name)) // '%m')
     call read_type_coord_sys(structure_out%coord_sys, trim(adjustl(name)) // '%coord_sys')
     call read_type_mhd_vector(structure_out%a_pert, trim(adjustl(name)) // '%a_pert')
     call read_type_mhd_vector(structure_out%b_pert, trim(adjustl(name)) // '%b_pert')

   end subroutine read_type_mhd_vacuum

   subroutine read_arr_type_mhd_vacuum(structure_out, name)
 
     implicit none
 
     type (type_mhd_vacuum), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd_vacuum(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd_vacuum

   subroutine read_type_mhd_vector(structure_out, name)

     implicit none

     type (type_mhd_vector), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matcplx_type(structure_out%coord1, trim(adjustl(name)) // '%coord1')
     call read_type_matcplx_type(structure_out%coord2, trim(adjustl(name)) // '%coord2')
     call read_type_matcplx_type(structure_out%coord3, trim(adjustl(name)) // '%coord3')

   end subroutine read_type_mhd_vector

   subroutine read_arr_type_mhd_vector(structure_out, name)
 
     implicit none
 
     type (type_mhd_vector), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mhd_vector(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mhd_vector

   subroutine read_type_mode_lipb(structure_out, name)

     implicit none

     type (type_mode_lipb), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%lp_rec_day, trim(adjustl(name)) // '%lp_rec_day')
     call read_type_vecflt_type(structure_out%bb_lp_fr, trim(adjustl(name)) // '%bb_lp_fr')
     call read_type_float(structure_out%lp_inl_p, trim(adjustl(name)) // '%lp_inl_p')
     call read_type_float(structure_out%bu_dp_lp, trim(adjustl(name)) // '%bu_dp_lp')
     call read_type_float(structure_out%man_dp_lp, trim(adjustl(name)) // '%man_dp_lp')
     call read_type_float(structure_out%tot_dp_lp, trim(adjustl(name)) // '%tot_dp_lp')
     call read_type_float(structure_out%bu_lp_ave_t, trim(adjustl(name)) // '%bu_lp_ave_t')
     call read_type_float(structure_out%bu_lp_max_t, trim(adjustl(name)) // '%bu_lp_max_t')

   end subroutine read_type_mode_lipb

   subroutine read_arr_type_mode_lipb(structure_out, name)
 
     implicit none
 
     type (type_mode_lipb), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mode_lipb(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mode_lipb

   subroutine read_type_mode_mech(structure_out, name)

     implicit none

     type (type_mode_mech), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%fw_min_ts_mg, trim(adjustl(name)) // '%fw_min_ts_mg')
     call read_type_float(structure_out%fw_min_bd_mg, trim(adjustl(name)) // '%fw_min_bd_mg')
     call read_type_float(structure_out%sg_min_ts_mg, trim(adjustl(name)) // '%sg_min_ts_mg')
     call read_type_float(structure_out%sg_min_bd_mg, trim(adjustl(name)) // '%sg_min_bd_mg')
     call read_type_float(structure_out%cp_min_ts_mg, trim(adjustl(name)) // '%cp_min_ts_mg')
     call read_type_float(structure_out%cp_min_bd_mg, trim(adjustl(name)) // '%cp_min_bd_mg')
     call read_type_float(structure_out%min_ts_mg_ac, trim(adjustl(name)) // '%min_ts_mg_ac')
     call read_type_float(structure_out%min_bd_mg_ac, trim(adjustl(name)) // '%min_bd_mg_ac')

   end subroutine read_type_mode_mech

   subroutine read_arr_type_mode_mech(structure_out, name)
 
     implicit none
 
     type (type_mode_mech), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mode_mech(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mode_mech

   subroutine read_type_mode_neutr(structure_out, name)

     implicit none

     type (type_mode_neutr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%pd_rad, trim(adjustl(name)) // '%pd_rad')
     call read_type_vecflt_type(structure_out%lipb_coef_pd, trim(adjustl(name)) // '%lipb_coef_pd')
     call read_type_vecflt_type(structure_out%steel_coef_pd, trim(adjustl(name)) // '%steel_coef_pd')
     call read_type_power_exchange(structure_out%pow_exchange, trim(adjustl(name)) // '%pow_exchange')

   end subroutine read_type_mode_neutr

   subroutine read_arr_type_mode_neutr(structure_out, name)
 
     implicit none
 
     type (type_mode_neutr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mode_neutr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mode_neutr

   subroutine read_type_mode_th_hyd(structure_out, name)

     implicit none

     type (type_mode_th_hyd), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%fw_dp_he, trim(adjustl(name)) // '%fw_dp_he')
     call read_type_float(structure_out%sg_dp_he, trim(adjustl(name)) // '%sg_dp_he')
     call read_type_float(structure_out%cp_dp_he, trim(adjustl(name)) // '%cp_dp_he')
     call read_type_float(structure_out%man_dp_he, trim(adjustl(name)) // '%man_dp_he')
     call read_type_float(structure_out%tot_dp_he, trim(adjustl(name)) // '%tot_dp_he')
     call read_type_float(structure_out%bp_dp_he, trim(adjustl(name)) // '%bp_dp_he')
     call read_type_float(structure_out%circ_dp_he, trim(adjustl(name)) // '%circ_dp_he')

   end subroutine read_type_mode_th_hyd

   subroutine read_arr_type_mode_th_hyd(structure_out, name)
 
     implicit none
 
     type (type_mode_th_hyd), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mode_th_hyd(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mode_th_hyd

   subroutine read_type_mode_therm(structure_out, name)

     implicit none

     type (type_mode_therm), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%he_fr, trim(adjustl(name)) // '%he_fr')
     call read_type_float(structure_out%perc_bp_he, trim(adjustl(name)) // '%perc_bp_he')
     call read_type_float(structure_out%he_out_t, trim(adjustl(name)) // '%he_out_t')
     call read_type_float(structure_out%fw_he_out_t, trim(adjustl(name)) // '%fw_he_out_t')
     call read_type_float(structure_out%sg_he_out_t, trim(adjustl(name)) // '%sg_he_out_t')
     call read_type_float(structure_out%cp_he_out_t, trim(adjustl(name)) // '%cp_he_out_t')
     call read_type_float(structure_out%fw_st_max_t, trim(adjustl(name)) // '%fw_st_max_t')
     call read_type_float(structure_out%sg_st_max_t, trim(adjustl(name)) // '%sg_st_max_t')
     call read_type_float(structure_out%cp_st_max_t, trim(adjustl(name)) // '%cp_st_max_t')

   end subroutine read_type_mode_therm

   subroutine read_arr_type_mode_therm(structure_out, name)
 
     implicit none
 
     type (type_mode_therm), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mode_therm(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mode_therm

   subroutine read_type_mode_tritium(structure_out, name)

     implicit none

     type (type_mode_tritium), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%t_conc_lipb, trim(adjustl(name)) // '%t_conc_lipb')
     call read_type_float(structure_out%t_conc_he, trim(adjustl(name)) // '%t_conc_he')

   end subroutine read_type_mode_tritium

   subroutine read_arr_type_mode_tritium(structure_out, name)
 
     implicit none
 
     type (type_mode_tritium), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_mode_tritium(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_mode_tritium

   subroutine read_type_modules(structure_out, name)

     implicit none

     type (type_modules), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nma_theta, trim(adjustl(name)) // '%nma_theta')
     call read_type_integer(structure_out%nma_phi, trim(adjustl(name)) // '%nma_phi')
     call read_type_vecint_type(structure_out%ima_theta, trim(adjustl(name)) // '%ima_theta')
     call read_type_vecint_type(structure_out%ima_phi, trim(adjustl(name)) // '%ima_phi')
     call read_type_float(structure_out%sm_theta, trim(adjustl(name)) // '%sm_theta')
     call read_type_exp1D(structure_out%amplitude, trim(adjustl(name)) // '%amplitude')
     call read_type_exp1D(structure_out%phase, trim(adjustl(name)) // '%phase')
     call read_type_waveguides(structure_out%waveguides, trim(adjustl(name)) // '%waveguides')

   end subroutine read_type_modules

   subroutine read_arr_type_modules(structure_out, name)
 
     implicit none
 
     type (type_modules), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_modules(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_modules

   subroutine read_type_msediag_emiss_chord(structure_out, name)

     implicit none

     type (type_msediag_emiss_chord), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_rzphi1D(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_arr_type_msediag_polarization(structure_out%polarization, trim(adjustl(name)) // '%polarization')
     call read_type_vecflt_type(structure_out%quantiaxis, trim(adjustl(name)) // '%quantiaxis')

   end subroutine read_type_msediag_emiss_chord

   subroutine read_arr_type_msediag_emiss_chord(structure_out, name)
 
     implicit none
 
     type (type_msediag_emiss_chord), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_emiss_chord(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_emiss_chord

   subroutine read_type_msediag_emissivity(structure_out, name)

     implicit none

     type (type_msediag_emissivity), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%wavelength, trim(adjustl(name)) // '%wavelength')
     call read_arr_type_msediag_emiss_chord(structure_out%emiss_chord, trim(adjustl(name)) // '%emiss_chord')

   end subroutine read_type_msediag_emissivity

   subroutine read_arr_type_msediag_emissivity(structure_out, name)
 
     implicit none
 
     type (type_msediag_emissivity), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_emissivity(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_emissivity

   subroutine read_type_msediag_polarization(structure_out, name)

     implicit none

     type (type_msediag_polarization), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_matflt_type(structure_out%spec_emiss, trim(adjustl(name)) // '%spec_emiss')

   end subroutine read_type_msediag_polarization

   subroutine read_arr_type_msediag_polarization(structure_out, name)
 
     implicit none
 
     type (type_msediag_polarization), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_polarization(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_polarization

   subroutine read_type_msediag_radia_chord(structure_out, name)

     implicit none

     type (type_msediag_radia_chord), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_msediag_setup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_arr_type_msediag_stokes(structure_out%stokes, trim(adjustl(name)) // '%stokes')
     call read_type_exp1D(structure_out%totradiance, trim(adjustl(name)) // '%totradiance')

   end subroutine read_type_msediag_radia_chord

   subroutine read_arr_type_msediag_radia_chord(structure_out, name)
 
     implicit none
 
     type (type_msediag_radia_chord), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_radia_chord(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_radia_chord

   subroutine read_type_msediag_radiance(structure_out, name)

     implicit none

     type (type_msediag_radiance), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%wavelength, trim(adjustl(name)) // '%wavelength')
     call read_arr_type_msediag_radia_chord(structure_out%radia_chord, trim(adjustl(name)) // '%radia_chord')

   end subroutine read_type_msediag_radiance

   subroutine read_arr_type_msediag_radiance(structure_out, name)
 
     implicit none
 
     type (type_msediag_radiance), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_radiance(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_radiance

   subroutine read_type_msediag_setup(structure_out, name)

     implicit none

     type (type_msediag_setup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi0D(structure_out%pivot_point, trim(adjustl(name)) // '%pivot_point')
     call read_type_float(structure_out%horchordang, trim(adjustl(name)) // '%horchordang')
     call read_type_float(structure_out%verchordang, trim(adjustl(name)) // '%verchordang')
     call read_type_rzphi0D(structure_out%second_point, trim(adjustl(name)) // '%second_point')

   end subroutine read_type_msediag_setup

   subroutine read_arr_type_msediag_setup(structure_out, name)
 
     implicit none
 
     type (type_msediag_setup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_setup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_setup

   subroutine read_type_msediag_setup_polarimetry(structure_out, name)

     implicit none

     type (type_msediag_setup_polarimetry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphidrdzdphi1D(structure_out%rzgamma, trim(adjustl(name)) // '%rzgamma')
     call read_type_matflt_type(structure_out%geom_coef, trim(adjustl(name)) // '%geom_coef')

   end subroutine read_type_msediag_setup_polarimetry

   subroutine read_arr_type_msediag_setup_polarimetry(structure_out, name)
 
     implicit none
 
     type (type_msediag_setup_polarimetry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_setup_polarimetry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_setup_polarimetry

   subroutine read_type_msediag_stokes(structure_out, name)

     implicit none

     type (type_msediag_stokes), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_matflt_type(structure_out%vector, trim(adjustl(name)) // '%vector')

   end subroutine read_type_msediag_stokes

   subroutine read_arr_type_msediag_stokes(structure_out, name)
 
     implicit none
 
     type (type_msediag_stokes), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_msediag_stokes(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_msediag_stokes

   subroutine read_type_nbi_nbi_unit_wall(structure_out, name)

     implicit none

     type (type_nbi_nbi_unit_wall), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_nbi_nbi_unit_wall_surface(structure_out%surface, trim(adjustl(name)) // '%surface')
     call read_arr_type_flat_polygon(structure_out%collimator, trim(adjustl(name)) // '%collimator')

   end subroutine read_type_nbi_nbi_unit_wall

   subroutine read_arr_type_nbi_nbi_unit_wall(structure_out, name)
 
     implicit none
 
     type (type_nbi_nbi_unit_wall), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_nbi_nbi_unit_wall(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_nbi_nbi_unit_wall

   subroutine read_type_nbi_nbi_unit_wall_surface(structure_out, name)

     implicit none

     type (type_nbi_nbi_unit_wall_surface), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_trianglexyz(structure_out%triangle, trim(adjustl(name)) // '%triangle')
     call read_arr_type_rectanglexyz(structure_out%rectangle, trim(adjustl(name)) // '%rectangle')

   end subroutine read_type_nbi_nbi_unit_wall_surface

   subroutine read_arr_type_nbi_nbi_unit_wall_surface(structure_out, name)
 
     implicit none
 
     type (type_nbi_nbi_unit_wall_surface), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_nbi_nbi_unit_wall_surface(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_nbi_nbi_unit_wall_surface

   subroutine read_type_nbi_unit(structure_out, name)

     implicit none

     type (type_nbi_unit), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_inj_spec(structure_out%inj_spec, trim(adjustl(name)) // '%inj_spec')
     call read_type_exp0D(structure_out%pow_unit, trim(adjustl(name)) // '%pow_unit')
     call read_type_exp0D(structure_out%inj_eng_unit, trim(adjustl(name)) // '%inj_eng_unit')
     call read_type_exp1D(structure_out%beamcurrfrac, trim(adjustl(name)) // '%beamcurrfrac')
     call read_type_exp1D(structure_out%beampowrfrac, trim(adjustl(name)) // '%beampowrfrac')
     call read_arr_type_beamletgroup(structure_out%beamletgroup, trim(adjustl(name)) // '%beamletgroup')
     call read_type_nbi_nbi_unit_wall(structure_out%wall, trim(adjustl(name)) // '%wall')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_nbi_unit

   subroutine read_arr_type_nbi_unit(structure_out, name)
 
     implicit none
 
     type (type_nbi_unit), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_nbi_unit(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_nbi_unit

   subroutine read_type_ne_transp(structure_out, name)

     implicit none

     type (type_ne_transp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%diff_eff, trim(adjustl(name)) // '%diff_eff')
     call read_type_matflt_type(structure_out%vconv_eff, trim(adjustl(name)) // '%vconv_eff')
     call read_type_vecflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_offdiagel(structure_out%off_diagonal, trim(adjustl(name)) // '%off_diagonal')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')

   end subroutine read_type_ne_transp

   subroutine read_arr_type_ne_transp(structure_out, name)
 
     implicit none
 
     type (type_ne_transp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ne_transp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ne_transp

   subroutine read_type_neoclassic_impurity(structure_out, name)

     implicit none

     type (type_neoclassic_impurity), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%utheta_z, trim(adjustl(name)) // '%utheta_z')

   end subroutine read_type_neoclassic_impurity

   subroutine read_arr_type_neoclassic_impurity(structure_out, name)
 
     implicit none
 
     type (type_neoclassic_impurity), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_neoclassic_impurity(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_neoclassic_impurity

   subroutine read_type_neut_results(structure_out, name)

     implicit none

     type (type_neut_results), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%tbr_bk, trim(adjustl(name)) // '%tbr_bk')
     call read_type_float(structure_out%tbr_bk_inb, trim(adjustl(name)) // '%tbr_bk_inb')
     call read_type_float(structure_out%tbr_bk_outb, trim(adjustl(name)) // '%tbr_bk_outb')
     call read_type_float(structure_out%me_bk, trim(adjustl(name)) // '%me_bk')
     call read_type_float(structure_out%me_shield, trim(adjustl(name)) // '%me_shield')
     call read_type_float(structure_out%he_appm_res, trim(adjustl(name)) // '%he_appm_res')
     call read_type_float(structure_out%ins_dose_max, trim(adjustl(name)) // '%ins_dose_max')
     call read_type_float(structure_out%fn_flu_max, trim(adjustl(name)) // '%fn_flu_max')
     call read_type_float(structure_out%dpa_cu_max, trim(adjustl(name)) // '%dpa_cu_max')
     call read_type_float(structure_out%fn_flux_bz, trim(adjustl(name)) // '%fn_flux_bz')
     call read_type_float(structure_out%fn_flux_bp, trim(adjustl(name)) // '%fn_flux_bp')
     call read_type_float(structure_out%fn_flux_man, trim(adjustl(name)) // '%fn_flux_man')
     call read_type_float(structure_out%fn_flux_sh, trim(adjustl(name)) // '%fn_flux_sh')
     call read_type_float(structure_out%p_nh_bk, trim(adjustl(name)) // '%p_nh_bk')
     call read_type_float(structure_out%p_nh_sh, trim(adjustl(name)) // '%p_nh_sh')

   end subroutine read_type_neut_results

   subroutine read_arr_type_neut_results(structure_out, name)
 
     implicit none
 
     type (type_neut_results), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_neut_results(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_neut_results

   subroutine read_type_neutral_complex_type(structure_out, name)

     implicit none

     type (type_neutral_complex_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_coreneutrals_neutraltype(structure_out%neutraltype, trim(adjustl(name)) // '%neutraltype')
     call read_type_vecflt_type(structure_out%prad0, trim(adjustl(name)) // '%prad0')

   end subroutine read_type_neutral_complex_type

   subroutine read_arr_type_neutral_complex_type(structure_out, name)
 
     implicit none
 
     type (type_neutral_complex_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_neutral_complex_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_neutral_complex_type

   subroutine read_type_neutro_resul(structure_out, name)

     implicit none

     type (type_neutro_resul), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%nwl_max, trim(adjustl(name)) // '%nwl_max')
     call read_type_vecflt_type(structure_out%nwl_pol_prof, trim(adjustl(name)) // '%nwl_pol_prof')

   end subroutine read_type_neutro_resul

   subroutine read_arr_type_neutro_resul(structure_out, name)
 
     implicit none
 
     type (type_neutro_resul), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_neutro_resul(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_neutro_resul

   subroutine read_type_ni_transp(structure_out, name)

     implicit none

     type (type_ni_transp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%diff_eff, trim(adjustl(name)) // '%diff_eff')
     call read_type_array3dflt_type(structure_out%vconv_eff, trim(adjustl(name)) // '%vconv_eff')
     call read_type_matflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_offdiagion(structure_out%off_diagonal, trim(adjustl(name)) // '%off_diagonal')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')

   end subroutine read_type_ni_transp

   subroutine read_arr_type_ni_transp(structure_out, name)
 
     implicit none
 
     type (type_ni_transp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ni_transp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ni_transp

   subroutine read_type_ntm_mode(structure_out, name)

     implicit none

     type (type_ntm_mode), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_ntm_mode_onset(structure_out%onset, trim(adjustl(name)) // '%onset')
     call read_type_ntm_mode_full_evol(structure_out%full_evol, trim(adjustl(name)) // '%full_evol')
     call read_type_ntm_mode_evolution(structure_out%evolution, trim(adjustl(name)) // '%evolution')

   end subroutine read_type_ntm_mode

   subroutine read_arr_type_ntm_mode(structure_out, name)
 
     implicit none
 
     type (type_ntm_mode), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm_mode(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm_mode

   subroutine read_type_ntm_mode_evolution(structure_out, name)

     implicit none

     type (type_ntm_mode_evolution), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%w, trim(adjustl(name)) // '%w')
     call read_type_float(structure_out%dwdt, trim(adjustl(name)) // '%dwdt')
     call read_type_float(structure_out%phase, trim(adjustl(name)) // '%phase')
     call read_type_float(structure_out%dphasedt, trim(adjustl(name)) // '%dphasedt')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_float(structure_out%dfrequencydt, trim(adjustl(name)) // '%dfrequencydt')
     call read_type_ntm_mode_evolution_island(structure_out%island, trim(adjustl(name)) // '%island')
     call read_type_integer(structure_out%n, trim(adjustl(name)) // '%n')
     call read_type_integer(structure_out%m, trim(adjustl(name)) // '%m')
     call read_type_vecflt_type(structure_out%deltaw_value, trim(adjustl(name)) // '%deltaw_value')
     call read_type_vecstring_type(structure_out%deltaw_name, trim(adjustl(name)) // '%deltaw_name')
     call read_type_vecflt_type(structure_out%torque_value, trim(adjustl(name)) // '%torque_value')
     call read_type_vecstring_type(structure_out%torque_name, trim(adjustl(name)) // '%torque_name')
     call read_type_vecflt_type(structure_out%delta_diff, trim(adjustl(name)) // '%delta_diff')
     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')
     call read_type_float(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')

   end subroutine read_type_ntm_mode_evolution

   subroutine read_arr_type_ntm_mode_evolution(structure_out, name)
 
     implicit none
 
     type (type_ntm_mode_evolution), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm_mode_evolution(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm_mode_evolution

   subroutine read_type_ntm_mode_evolution_island(structure_out, name)

     implicit none

     type (type_ntm_mode_evolution_island), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_vecflt_type(structure_out%coord_values, trim(adjustl(name)) // '%coord_values')
     call read_type_vecstring_type(structure_out%coord_desc, trim(adjustl(name)) // '%coord_desc')

   end subroutine read_type_ntm_mode_evolution_island

   subroutine read_arr_type_ntm_mode_evolution_island(structure_out, name)
 
     implicit none
 
     type (type_ntm_mode_evolution_island), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm_mode_evolution_island(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm_mode_evolution_island

   subroutine read_type_ntm_mode_full_evol(structure_out, name)

     implicit none

     type (type_ntm_mode_full_evol), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%time_evol, trim(adjustl(name)) // '%time_evol')
     call read_type_vecflt_type(structure_out%w, trim(adjustl(name)) // '%w')
     call read_type_vecflt_type(structure_out%dwdt, trim(adjustl(name)) // '%dwdt')
     call read_type_vecflt_type(structure_out%phase, trim(adjustl(name)) // '%phase')
     call read_type_vecflt_type(structure_out%dphasedt, trim(adjustl(name)) // '%dphasedt')
     call read_type_vecflt_type(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_vecflt_type(structure_out%dfrequencydt, trim(adjustl(name)) // '%dfrequencydt')
     call read_type_ntm_mode_full_evol_island(structure_out%island, trim(adjustl(name)) // '%island')
     call read_type_integer(structure_out%n, trim(adjustl(name)) // '%n')
     call read_type_integer(structure_out%m, trim(adjustl(name)) // '%m')
     call read_type_matflt_type(structure_out%deltaw_value, trim(adjustl(name)) // '%deltaw_value')
     call read_type_vecstring_type(structure_out%deltaw_name, trim(adjustl(name)) // '%deltaw_name')
     call read_type_matflt_type(structure_out%torque_value, trim(adjustl(name)) // '%torque_value')
     call read_type_vecstring_type(structure_out%torque_name, trim(adjustl(name)) // '%torque_name')
     call read_type_matflt_type(structure_out%delta_diff, trim(adjustl(name)) // '%delta_diff')
     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')

   end subroutine read_type_ntm_mode_full_evol

   subroutine read_arr_type_ntm_mode_full_evol(structure_out, name)
 
     implicit none
 
     type (type_ntm_mode_full_evol), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm_mode_full_evol(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm_mode_full_evol

   subroutine read_type_ntm_mode_full_evol_island(structure_out, name)

     implicit none

     type (type_ntm_mode_full_evol_island), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_matflt_type(structure_out%coord_values, trim(adjustl(name)) // '%coord_values')
     call read_type_vecstring_type(structure_out%coord_desc, trim(adjustl(name)) // '%coord_desc')

   end subroutine read_type_ntm_mode_full_evol_island

   subroutine read_arr_type_ntm_mode_full_evol_island(structure_out, name)
 
     implicit none
 
     type (type_ntm_mode_full_evol_island), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm_mode_full_evol_island(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm_mode_full_evol_island

   subroutine read_type_ntm_mode_onset(structure_out, name)

     implicit none

     type (type_ntm_mode_onset), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%w, trim(adjustl(name)) // '%w')
     call read_type_float(structure_out%time_onset, trim(adjustl(name)) // '%time_onset')
     call read_type_float(structure_out%time_offset, trim(adjustl(name)) // '%time_offset')
     call read_type_float(structure_out%phase, trim(adjustl(name)) // '%phase')
     call read_type_integer(structure_out%n, trim(adjustl(name)) // '%n')
     call read_type_integer(structure_out%m, trim(adjustl(name)) // '%m')
     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')

   end subroutine read_type_ntm_mode_onset

   subroutine read_arr_type_ntm_mode_onset(structure_out, name)
 
     implicit none
 
     type (type_ntm_mode_onset), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_ntm_mode_onset(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_ntm_mode_onset

   subroutine read_type_nuclei(structure_out, name)

     implicit none

     type (type_nuclei), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')

   end subroutine read_type_nuclei

   subroutine read_arr_type_nuclei(structure_out, name)
 
     implicit none
 
     type (type_nuclei), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_nuclei(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_nuclei

   subroutine read_type_objects(structure_out, name)

     implicit none

     type (type_objects), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matint_type(structure_out%boundary, trim(adjustl(name)) // '%boundary')
     call read_type_array3dint_type(structure_out%neighbour, trim(adjustl(name)) // '%neighbour')
     call read_type_array4dflt_type(structure_out%geo, trim(adjustl(name)) // '%geo')
     call read_type_matflt_type(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_objects

   subroutine read_arr_type_objects(structure_out, name)
 
     implicit none
 
     type (type_objects), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_objects(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_objects

   subroutine read_type_offdiagel(structure_out, name)

     implicit none

     type (type_offdiagel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%d_ni, trim(adjustl(name)) // '%d_ni')
     call read_type_matflt_type(structure_out%d_ti, trim(adjustl(name)) // '%d_ti')
     call read_type_vecflt_type(structure_out%d_ne, trim(adjustl(name)) // '%d_ne')
     call read_type_vecflt_type(structure_out%d_te, trim(adjustl(name)) // '%d_te')
     call read_type_vecflt_type(structure_out%d_epar, trim(adjustl(name)) // '%d_epar')
     call read_type_vecflt_type(structure_out%d_mtor, trim(adjustl(name)) // '%d_mtor')

   end subroutine read_type_offdiagel

   subroutine read_arr_type_offdiagel(structure_out, name)
 
     implicit none
 
     type (type_offdiagel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_offdiagel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_offdiagel

   subroutine read_type_offdiagion(structure_out, name)

     implicit none

     type (type_offdiagion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%d_ni, trim(adjustl(name)) // '%d_ni')
     call read_type_array3dflt_type(structure_out%d_ti, trim(adjustl(name)) // '%d_ti')
     call read_type_matflt_type(structure_out%d_ne, trim(adjustl(name)) // '%d_ne')
     call read_type_matflt_type(structure_out%d_te, trim(adjustl(name)) // '%d_te')
     call read_type_matflt_type(structure_out%d_epar, trim(adjustl(name)) // '%d_epar')
     call read_type_matflt_type(structure_out%d_mtor, trim(adjustl(name)) // '%d_mtor')

   end subroutine read_type_offdiagion

   subroutine read_arr_type_offdiagion(structure_out, name)
 
     implicit none
 
     type (type_offdiagion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_offdiagion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_offdiagion

   subroutine read_type_omnigen_surf(structure_out, name)

     implicit none

     type (type_omnigen_surf), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz1D(structure_out%rz, trim(adjustl(name)) // '%rz')
     call read_type_vecflt_type(structure_out%s, trim(adjustl(name)) // '%s')

   end subroutine read_type_omnigen_surf

   subroutine read_arr_type_omnigen_surf(structure_out, name)
 
     implicit none
 
     type (type_omnigen_surf), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_omnigen_surf(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_omnigen_surf

   subroutine read_type_orbit_global_param(structure_out, name)

     implicit none

     type (type_orbit_global_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%orbit_type, trim(adjustl(name)) // '%orbit_type')
     call read_type_vecflt_type(structure_out%omega_b, trim(adjustl(name)) // '%omega_b')
     call read_type_vecflt_type(structure_out%omega_phi, trim(adjustl(name)) // '%omega_phi')
     call read_type_vecflt_type(structure_out%omega_c_av, trim(adjustl(name)) // '%omega_c_av')
     call read_type_orbit_special_pos(structure_out%special_pos, trim(adjustl(name)) // '%special_pos')

   end subroutine read_type_orbit_global_param

   subroutine read_arr_type_orbit_global_param(structure_out, name)
 
     implicit none
 
     type (type_orbit_global_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_orbit_global_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_orbit_global_param

   subroutine read_type_orbit_midplane(structure_out, name)

     implicit none

     type (type_orbit_midplane), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_orbit_pos(structure_out%outer, trim(adjustl(name)) // '%outer')
     call read_type_orbit_pos(structure_out%inner, trim(adjustl(name)) // '%inner')

   end subroutine read_type_orbit_midplane

   subroutine read_arr_type_orbit_midplane(structure_out, name)
 
     implicit none
 
     type (type_orbit_midplane), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_orbit_midplane(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_orbit_midplane

   subroutine read_type_orbit_pos(structure_out, name)

     implicit none

     type (type_orbit_pos), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%theta_b, trim(adjustl(name)) // '%theta_b')

   end subroutine read_type_orbit_pos

   subroutine read_arr_type_orbit_pos(structure_out, name)
 
     implicit none
 
     type (type_orbit_pos), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_orbit_pos(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_orbit_pos

   subroutine read_type_orbit_special_pos(structure_out, name)

     implicit none

     type (type_orbit_special_pos), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_orbit_midplane(structure_out%midplane, trim(adjustl(name)) // '%midplane')
     call read_type_orbit_turning_pts(structure_out%turning_pts, trim(adjustl(name)) // '%turning_pts')

   end subroutine read_type_orbit_special_pos

   subroutine read_arr_type_orbit_special_pos(structure_out, name)
 
     implicit none
 
     type (type_orbit_special_pos), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_orbit_special_pos(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_orbit_special_pos

   subroutine read_type_orbit_turning_pts(structure_out, name)

     implicit none

     type (type_orbit_turning_pts), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_orbit_pos(structure_out%upper, trim(adjustl(name)) // '%upper')
     call read_type_orbit_pos(structure_out%lower, trim(adjustl(name)) // '%lower')

   end subroutine read_type_orbit_turning_pts

   subroutine read_arr_type_orbit_turning_pts(structure_out, name)
 
     implicit none
 
     type (type_orbit_turning_pts), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_orbit_turning_pts(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_orbit_turning_pts

   subroutine read_type_origin(structure_out, name)

     implicit none

     type (type_origin), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi0D(structure_out%refpos, trim(adjustl(name)) // '%refpos')
     call read_type_float(structure_out%alpha, trim(adjustl(name)) // '%alpha')
     call read_type_float(structure_out%beta, trim(adjustl(name)) // '%beta')
     call read_type_float(structure_out%gamma, trim(adjustl(name)) // '%gamma')

   end subroutine read_type_origin

   subroutine read_arr_type_origin(structure_out, name)
 
     implicit none
 
     type (type_origin), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_origin(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_origin

   subroutine read_type_param(structure_out, name)

     implicit none

     type (type_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%parameters, trim(adjustl(name)) // '%parameters')
     call read_type_vecstring_type(structure_out%default_param, trim(adjustl(name)) // '%default_param')
     call read_type_vecstring_type(structure_out%schema, trim(adjustl(name)) // '%schema')

   end subroutine read_type_param

   subroutine read_arr_type_param(structure_out, name)
 
     implicit none
 
     type (type_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_param

   subroutine read_type_parameters(structure_out, name)

     implicit none

     type (type_parameters), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_equatorial_plane(structure_out%equatorial, trim(adjustl(name)) // '%equatorial')

   end subroutine read_type_parameters

   subroutine read_arr_type_parameters(structure_out, name)
 
     implicit none
 
     type (type_parameters), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_parameters(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_parameters

   subroutine read_type_pellet(structure_out, name)

     implicit none

     type (type_pellet), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_pellet_shape(structure_out%shape, trim(adjustl(name)) // '%shape')
     call read_type_pellet_elements(structure_out%elements, trim(adjustl(name)) // '%elements')
     call read_type_pellet_geometry(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_pellet_pathprofiles(structure_out%pathprofiles, trim(adjustl(name)) // '%pathprofiles')
     call read_type_pellet_deposition(structure_out%deposition, trim(adjustl(name)) // '%deposition')

   end subroutine read_type_pellet

   subroutine read_arr_type_pellet(structure_out, name)
 
     implicit none
 
     type (type_pellet), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet

   subroutine read_type_pellet_angles(structure_out, name)

     implicit none

     type (type_pellet_angles), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%horizontal, trim(adjustl(name)) // '%horizontal')
     call read_type_float(structure_out%vertical, trim(adjustl(name)) // '%vertical')

   end subroutine read_type_pellet_angles

   subroutine read_arr_type_pellet_angles(structure_out, name)
 
     implicit none
 
     type (type_pellet_angles), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_angles(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_angles

   subroutine read_type_pellet_deposition(structure_out, name)

     implicit none

     type (type_pellet_deposition), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_pol, trim(adjustl(name)) // '%rho_pol')
     call read_type_vecflt_type(structure_out%delta_ne, trim(adjustl(name)) // '%delta_ne')
     call read_type_vecflt_type(structure_out%delta_te, trim(adjustl(name)) // '%delta_te')
     call read_type_matflt_type(structure_out%delta_ni, trim(adjustl(name)) // '%delta_ni')
     call read_type_matflt_type(structure_out%delta_ti, trim(adjustl(name)) // '%delta_ti')
     call read_type_matflt_type(structure_out%delta_vtor, trim(adjustl(name)) // '%delta_vtor')
     call read_arr_type_pellet_impurity(structure_out%impurity, trim(adjustl(name)) // '%impurity')

   end subroutine read_type_pellet_deposition

   subroutine read_arr_type_pellet_deposition(structure_out, name)
 
     implicit none
 
     type (type_pellet_deposition), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_deposition(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_deposition

   subroutine read_type_pellet_elements(structure_out, name)

     implicit none

     type (type_pellet_elements), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%nucindex, trim(adjustl(name)) // '%nucindex')
     call read_type_vecflt_type(structure_out%density, trim(adjustl(name)) // '%density')
     call read_type_vecflt_type(structure_out%fraction, trim(adjustl(name)) // '%fraction')
     call read_type_vecflt_type(structure_out%subl_energy, trim(adjustl(name)) // '%subl_energy')

   end subroutine read_type_pellet_elements

   subroutine read_arr_type_pellet_elements(structure_out, name)
 
     implicit none
 
     type (type_pellet_elements), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_elements(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_elements

   subroutine read_type_pellet_geometry(structure_out, name)

     implicit none

     type (type_pellet_geometry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi0D(structure_out%pivot_point, trim(adjustl(name)) // '%pivot_point')
     call read_type_rzphi0D(structure_out%second_point, trim(adjustl(name)) // '%second_point')
     call read_type_float(structure_out%velocity, trim(adjustl(name)) // '%velocity')
     call read_type_pellet_angles(structure_out%angles, trim(adjustl(name)) // '%angles')

   end subroutine read_type_pellet_geometry

   subroutine read_arr_type_pellet_geometry(structure_out, name)
 
     implicit none
 
     type (type_pellet_geometry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_geometry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_geometry

   subroutine read_type_pellet_impurity(structure_out, name)

     implicit none

     type (type_pellet_impurity), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%delta_nz, trim(adjustl(name)) // '%delta_nz')

   end subroutine read_type_pellet_impurity

   subroutine read_arr_type_pellet_impurity(structure_out, name)
 
     implicit none
 
     type (type_pellet_impurity), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_impurity(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_impurity

   subroutine read_type_pellet_pathprofiles(structure_out, name)

     implicit none

     type (type_pellet_pathprofiles), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%distance, trim(adjustl(name)) // '%distance')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_pol, trim(adjustl(name)) // '%rho_pol')
     call read_type_vecflt_type(structure_out%velocity, trim(adjustl(name)) // '%velocity')
     call read_type_vecflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_vecflt_type(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_vecflt_type(structure_out%abl_rate, trim(adjustl(name)) // '%abl_rate')
     call read_type_vecflt_type(structure_out%abl_particles, trim(adjustl(name)) // '%abl_particles')
     call read_type_vecflt_type(structure_out%delta_drift, trim(adjustl(name)) // '%delta_drift')
     call read_type_rzphi1D(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_pellet_pathprofiles

   subroutine read_arr_type_pellet_pathprofiles(structure_out, name)
 
     implicit none
 
     type (type_pellet_pathprofiles), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_pathprofiles(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_pathprofiles

   subroutine read_type_pellet_shape(structure_out, name)

     implicit none

     type (type_pellet_shape), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%dimensions, trim(adjustl(name)) // '%dimensions')

   end subroutine read_type_pellet_shape

   subroutine read_arr_type_pellet_shape(structure_out, name)
 
     implicit none
 
     type (type_pellet_shape), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pellet_shape(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pellet_shape

   subroutine read_type_permeability(structure_out, name)

     implicit none

     type (type_permeability), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%b, trim(adjustl(name)) // '%b')
     call read_type_matflt_type(structure_out%mur, trim(adjustl(name)) // '%mur')

   end subroutine read_type_permeability

   subroutine read_arr_type_permeability(structure_out, name)
 
     implicit none
 
     type (type_permeability), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_permeability(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_permeability

   subroutine read_type_pfcircuits(structure_out, name)

     implicit none

     type (type_pfcircuits), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_vecstring_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecint_type(structure_out%nnodes, trim(adjustl(name)) // '%nnodes')
     call read_type_array3dint_type(structure_out%connections, trim(adjustl(name)) // '%connections')

   end subroutine read_type_pfcircuits

   subroutine read_arr_type_pfcircuits(structure_out, name)
 
     implicit none
 
     type (type_pfcircuits), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfcircuits(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfcircuits

   subroutine read_type_pfcoils(structure_out, name)

     implicit none

     type (type_pfcoils), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_desc_pfcoils(structure_out%desc_pfcoils, trim(adjustl(name)) // '%desc_pfcoils')
     call read_type_exp1D(structure_out%coilcurrent, trim(adjustl(name)) // '%coilcurrent')
     call read_type_exp1D(structure_out%coilvoltage, trim(adjustl(name)) // '%coilvoltage')
     call read_type_float(structure_out%p_cryo, trim(adjustl(name)) // '%p_cryo')
     call read_type_vecflt_type(structure_out%p_nh, trim(adjustl(name)) // '%p_nh')

   end subroutine read_type_pfcoils

   subroutine read_arr_type_pfcoils(structure_out, name)
 
     implicit none
 
     type (type_pfcoils), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfcoils(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfcoils

   subroutine read_type_pfelement(structure_out, name)

     implicit none

     type (type_pfelement), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_matflt_type(structure_out%turnsign, trim(adjustl(name)) // '%turnsign')
     call read_type_matflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_pfgeometry(structure_out%pfgeometry, trim(adjustl(name)) // '%pfgeometry')

   end subroutine read_type_pfelement

   subroutine read_arr_type_pfelement(structure_out, name)
 
     implicit none
 
     type (type_pfelement), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfelement(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfelement

   subroutine read_type_pfgeometry(structure_out, name)

     implicit none

     type (type_pfgeometry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matint_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_matint_type(structure_out%npoints, trim(adjustl(name)) // '%npoints')
     call read_type_rz3D(structure_out%rzcoordinate, trim(adjustl(name)) // '%rzcoordinate')
     call read_type_array3dflt_type(structure_out%rzdrdz, trim(adjustl(name)) // '%rzdrdz')

   end subroutine read_type_pfgeometry

   subroutine read_arr_type_pfgeometry(structure_out, name)
 
     implicit none
 
     type (type_pfgeometry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfgeometry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfgeometry

   subroutine read_type_pfpageometry(structure_out, name)

     implicit none

     type (type_pfpageometry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecint_type(structure_out%npoints, trim(adjustl(name)) // '%npoints')
     call read_type_rz2D(structure_out%rzcoordinate, trim(adjustl(name)) // '%rzcoordinate')
     call read_type_matflt_type(structure_out%rzdrdz, trim(adjustl(name)) // '%rzdrdz')

   end subroutine read_type_pfpageometry

   subroutine read_arr_type_pfpageometry(structure_out, name)
 
     implicit none
 
     type (type_pfpageometry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfpageometry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfpageometry

   subroutine read_type_pfpassive(structure_out, name)

     implicit none

     type (type_pfpassive), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%res, trim(adjustl(name)) // '%res')
     call read_type_vecflt_type(structure_out%eta, trim(adjustl(name)) // '%eta')
     call read_type_pfpassive_current(structure_out%current, trim(adjustl(name)) // '%current')
     call read_type_pfpageometry(structure_out%pfpageometry, trim(adjustl(name)) // '%pfpageometry')

   end subroutine read_type_pfpassive

   subroutine read_arr_type_pfpassive(structure_out, name)
 
     implicit none
 
     type (type_pfpassive), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfpassive(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfpassive

   subroutine read_type_pfpassive_current(structure_out, name)

     implicit none

     type (type_pfpassive_current), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%toroidal, trim(adjustl(name)) // '%toroidal')
     call read_type_exp1D(structure_out%poloidal, trim(adjustl(name)) // '%poloidal')

   end subroutine read_type_pfpassive_current

   subroutine read_arr_type_pfpassive_current(structure_out, name)
 
     implicit none
 
     type (type_pfpassive_current), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfpassive_current(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfpassive_current

   subroutine read_type_pfsupplies(structure_out, name)

     implicit none

     type (type_pfsupplies), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_desc_supply(structure_out%desc_supply, trim(adjustl(name)) // '%desc_supply')
     call read_type_exp1D(structure_out%voltage, trim(adjustl(name)) // '%voltage')
     call read_type_exp1D(structure_out%current, trim(adjustl(name)) // '%current')

   end subroutine read_type_pfsupplies

   subroutine read_arr_type_pfsupplies(structure_out, name)
 
     implicit none
 
     type (type_pfsupplies), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pfsupplies(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pfsupplies

   subroutine read_type_phaseellipse(structure_out, name)

     implicit none

     type (type_phaseellipse), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%invcurvrad, trim(adjustl(name)) // '%invcurvrad')
     call read_type_float(structure_out%angle, trim(adjustl(name)) // '%angle')

   end subroutine read_type_phaseellipse

   subroutine read_arr_type_phaseellipse(structure_out, name)
 
     implicit none
 
     type (type_phaseellipse), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_phaseellipse(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_phaseellipse

   subroutine read_type_planecoil(structure_out, name)

     implicit none

     type (type_planecoil), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz1D(structure_out%coordinates, trim(adjustl(name)) // '%coordinates')
     call read_type_vecflt_type(structure_out%hlength, trim(adjustl(name)) // '%hlength')
     call read_type_vecflt_type(structure_out%radialhwidth, trim(adjustl(name)) // '%radialhwidth')

   end subroutine read_type_planecoil

   subroutine read_arr_type_planecoil(structure_out, name)
 
     implicit none
 
     type (type_planecoil), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_planecoil(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_planecoil

   subroutine read_type_plasmaComplexType(structure_out, name)

     implicit none

     type (type_plasmaComplexType), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%species, trim(adjustl(name)) // '%species')
     call read_type_matflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_matflt_type(structure_out%b, trim(adjustl(name)) // '%b')
     call read_type_matflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_plasmaComplexType

   subroutine read_arr_type_plasmaComplexType(structure_out, name)
 
     implicit none
 
     type (type_plasmaComplexType), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_plasmaComplexType(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_plasmaComplexType

   subroutine read_type_plasmaedge(structure_out, name)

     implicit none

     type (type_plasmaedge), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%npoints, trim(adjustl(name)) // '%npoints')
     call read_type_vecflt_type(structure_out%distance, trim(adjustl(name)) // '%distance')
     call read_type_vecflt_type(structure_out%density, trim(adjustl(name)) // '%density')

   end subroutine read_type_plasmaedge

   subroutine read_arr_type_plasmaedge(structure_out, name)
 
     implicit none
 
     type (type_plasmaedge), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_plasmaedge(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_plasmaedge

   subroutine read_type_pol_decomp(structure_out, name)

     implicit none

     type (type_pol_decomp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%mpol, trim(adjustl(name)) // '%mpol')
     call read_type_array3dflt_type(structure_out%e_plus, trim(adjustl(name)) // '%e_plus')
     call read_type_array3dflt_type(structure_out%e_plus_ph, trim(adjustl(name)) // '%e_plus_ph')
     call read_type_array3dflt_type(structure_out%e_minus, trim(adjustl(name)) // '%e_minus')
     call read_type_array3dflt_type(structure_out%e_minus_ph, trim(adjustl(name)) // '%e_minus_ph')
     call read_type_array3dflt_type(structure_out%e_norm, trim(adjustl(name)) // '%e_norm')
     call read_type_array3dflt_type(structure_out%e_norm_ph, trim(adjustl(name)) // '%e_norm_ph')
     call read_type_array3dflt_type(structure_out%e_binorm, trim(adjustl(name)) // '%e_binorm')
     call read_type_array3dflt_type(structure_out%e_binorm_ph, trim(adjustl(name)) // '%e_binorm_ph')
     call read_type_array3dflt_type(structure_out%e_para, trim(adjustl(name)) // '%e_para')
     call read_type_array3dflt_type(structure_out%e_para_ph, trim(adjustl(name)) // '%e_para_ph')
     call read_type_array3dflt_type(structure_out%b_norm, trim(adjustl(name)) // '%b_norm')
     call read_type_array3dflt_type(structure_out%b_norm_ph, trim(adjustl(name)) // '%b_norm_ph')
     call read_type_array3dflt_type(structure_out%b_binorm, trim(adjustl(name)) // '%b_binorm')
     call read_type_array3dflt_type(structure_out%b_binorm_ph, trim(adjustl(name)) // '%b_binorm_ph')
     call read_type_array3dflt_type(structure_out%b_para, trim(adjustl(name)) // '%b_para')
     call read_type_array3dflt_type(structure_out%b_para_ph, trim(adjustl(name)) // '%b_para_ph')
     call read_type_array3dflt_type(structure_out%k_perp, trim(adjustl(name)) // '%k_perp')

   end subroutine read_type_pol_decomp

   subroutine read_arr_type_pol_decomp(structure_out, name)
 
     implicit none
 
     type (type_pol_decomp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_pol_decomp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_pol_decomp

   subroutine read_type_polarimetry(structure_out, name)

     implicit none

     type (type_polarimetry), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_msediag_setup_polarimetry(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_exp1D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_polarimetry

   subroutine read_arr_type_polarimetry(structure_out, name)
 
     implicit none
 
     type (type_polarimetry), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_polarimetry(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_polarimetry

   subroutine read_type_polarization(structure_out, name)

     implicit none

     type (type_polarization), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%epol_p_re, trim(adjustl(name)) // '%epol_p_re')
     call read_type_vecflt_type(structure_out%epol_p_im, trim(adjustl(name)) // '%epol_p_im')
     call read_type_vecflt_type(structure_out%epol_m_re, trim(adjustl(name)) // '%epol_m_re')
     call read_type_vecflt_type(structure_out%epol_m_im, trim(adjustl(name)) // '%epol_m_im')
     call read_type_vecflt_type(structure_out%epol_par_re, trim(adjustl(name)) // '%epol_par_re')
     call read_type_vecflt_type(structure_out%epol_par_im, trim(adjustl(name)) // '%epol_par_im')

   end subroutine read_type_polarization

   subroutine read_arr_type_polarization(structure_out, name)
 
     implicit none
 
     type (type_polarization), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_polarization(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_polarization

   subroutine read_type_power_conv_component(structure_out, name)

     implicit none

     type (type_power_conv_component), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_float(structure_out%temp_in, trim(adjustl(name)) // '%temp_in')
     call read_type_float(structure_out%temp_out, trim(adjustl(name)) // '%temp_out')
     call read_type_float(structure_out%press_in, trim(adjustl(name)) // '%press_in')
     call read_type_float(structure_out%press_out, trim(adjustl(name)) // '%press_out')
     call read_type_float(structure_out%power, trim(adjustl(name)) // '%power')
     call read_type_float(structure_out%flow, trim(adjustl(name)) // '%flow')

   end subroutine read_type_power_conv_component

   subroutine read_arr_type_power_conv_component(structure_out, name)
 
     implicit none
 
     type (type_power_conv_component), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_power_conv_component(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_power_conv_component

   subroutine read_type_power_exchange(structure_out, name)

     implicit none

     type (type_power_exchange), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%dep_pow, trim(adjustl(name)) // '%dep_pow')
     call read_type_float(structure_out%dep_fw, trim(adjustl(name)) // '%dep_fw')
     call read_type_float(structure_out%dep_sg, trim(adjustl(name)) // '%dep_sg')
     call read_type_float(structure_out%dep_cp, trim(adjustl(name)) // '%dep_cp')
     call read_type_float(structure_out%dep_lp, trim(adjustl(name)) // '%dep_lp')
     call read_type_float(structure_out%dep_man, trim(adjustl(name)) // '%dep_man')
     call read_type_float(structure_out%dep_pl, trim(adjustl(name)) // '%dep_pl')
     call read_type_float(structure_out%rec_fw, trim(adjustl(name)) // '%rec_fw')
     call read_type_float(structure_out%rec_sg, trim(adjustl(name)) // '%rec_sg')
     call read_type_float(structure_out%rec_cp, trim(adjustl(name)) // '%rec_cp')
     call read_type_float(structure_out%pow_dens_fw, trim(adjustl(name)) // '%pow_dens_fw')
     call read_type_float(structure_out%pow_dens_bz, trim(adjustl(name)) // '%pow_dens_bz')
     call read_type_float(structure_out%pow_dens_bz10, trim(adjustl(name)) // '%pow_dens_bz10')
     call read_type_float(structure_out%pow_dens_bp, trim(adjustl(name)) // '%pow_dens_bp')
     call read_type_float(structure_out%pow_dens_man, trim(adjustl(name)) // '%pow_dens_man')
     call read_type_float(structure_out%pow_dens_sh, trim(adjustl(name)) // '%pow_dens_sh')

   end subroutine read_type_power_exchange

   subroutine read_arr_type_power_exchange(structure_out, name)
 
     implicit none
 
     type (type_power_exchange), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_power_exchange(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_power_exchange

   subroutine read_type_powerflow(structure_out, name)

     implicit none

     type (type_powerflow), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%phi_perp, trim(adjustl(name)) // '%phi_perp')
     call read_type_vecflt_type(structure_out%phi_par, trim(adjustl(name)) // '%phi_par')
     call read_type_vecflt_type(structure_out%power_e, trim(adjustl(name)) // '%power_e')
     call read_type_matflt_type(structure_out%power_i, trim(adjustl(name)) // '%power_i')

   end subroutine read_type_powerflow

   subroutine read_arr_type_powerflow(structure_out, name)
 
     implicit none
 
     type (type_powerflow), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_powerflow(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_powerflow

   subroutine read_type_profiles1d(structure_out, name)

     implicit none

     type (type_profiles1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_coreprofile(structure_out%pe, trim(adjustl(name)) // '%pe')
     call read_type_coreprofile(structure_out%dpedt, trim(adjustl(name)) // '%dpedt')
     call read_type_coreprofion(structure_out%pi, trim(adjustl(name)) // '%pi')
     call read_type_coreprofile(structure_out%pi_tot, trim(adjustl(name)) // '%pi_tot')
     call read_type_coreprofile(structure_out%dpi_totdt, trim(adjustl(name)) // '%dpi_totdt')
     call read_type_coreprofile(structure_out%pr_th, trim(adjustl(name)) // '%pr_th')
     call read_type_coreprofile(structure_out%pr_perp, trim(adjustl(name)) // '%pr_perp')
     call read_type_coreprofile(structure_out%pr_parallel, trim(adjustl(name)) // '%pr_parallel')
     call read_type_coreprofile(structure_out%jtot, trim(adjustl(name)) // '%jtot')
     call read_type_coreprofile(structure_out%jni, trim(adjustl(name)) // '%jni')
     call read_type_coreprofile(structure_out%jphi, trim(adjustl(name)) // '%jphi')
     call read_type_coreprofile(structure_out%joh, trim(adjustl(name)) // '%joh')
     call read_type_coreprofile(structure_out%vloop, trim(adjustl(name)) // '%vloop')
     call read_type_coreprofile(structure_out%sigmapar, trim(adjustl(name)) // '%sigmapar')
     call read_type_sourceel(structure_out%qoh, trim(adjustl(name)) // '%qoh')
     call read_type_coreprofile(structure_out%qei, trim(adjustl(name)) // '%qei')
     call read_type_coreprofile(structure_out%eparallel, trim(adjustl(name)) // '%eparallel')
     call read_type_coreprofile(structure_out%e_b, trim(adjustl(name)) // '%e_b')
     call read_type_coreprofile(structure_out%q, trim(adjustl(name)) // '%q')
     call read_type_coreprofile(structure_out%shear, trim(adjustl(name)) // '%shear')
     call read_type_coreprofion(structure_out%ns, trim(adjustl(name)) // '%ns')
     call read_type_coreprofion(structure_out%mtor, trim(adjustl(name)) // '%mtor')
     call read_type_coreprofion(structure_out%wtor, trim(adjustl(name)) // '%wtor')
     call read_type_coreprofion(structure_out%vpol, trim(adjustl(name)) // '%vpol')
     call read_type_coreprofile(structure_out%zeff, trim(adjustl(name)) // '%zeff')
     call read_type_coreprofile(structure_out%bpol, trim(adjustl(name)) // '%bpol')
     call read_type_coreprofile(structure_out%dvprimedt, trim(adjustl(name)) // '%dvprimedt')

   end subroutine read_type_profiles1d

   subroutine read_arr_type_profiles1d(structure_out, name)
 
     implicit none
 
     type (type_profiles1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_profiles1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_profiles1d

   subroutine read_type_profiles_1d(structure_out, name)

     implicit none

     type (type_profiles_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%pressure, trim(adjustl(name)) // '%pressure')
     call read_type_vecflt_type(structure_out%F_dia, trim(adjustl(name)) // '%F_dia')
     call read_type_vecflt_type(structure_out%pprime, trim(adjustl(name)) // '%pprime')
     call read_type_vecflt_type(structure_out%ffprime, trim(adjustl(name)) // '%ffprime')
     call read_type_vecflt_type(structure_out%jphi, trim(adjustl(name)) // '%jphi')
     call read_type_vecflt_type(structure_out%jparallel, trim(adjustl(name)) // '%jparallel')
     call read_type_vecflt_type(structure_out%q, trim(adjustl(name)) // '%q')
     call read_type_vecflt_type(structure_out%shear, trim(adjustl(name)) // '%shear')
     call read_type_vecflt_type(structure_out%r_inboard, trim(adjustl(name)) // '%r_inboard')
     call read_type_vecflt_type(structure_out%r_outboard, trim(adjustl(name)) // '%r_outboard')
     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%dpsidrho_tor, trim(adjustl(name)) // '%dpsidrho_tor')
     call read_type_vecflt_type(structure_out%rho_vol, trim(adjustl(name)) // '%rho_vol')
     call read_type_vecflt_type(structure_out%beta_pol, trim(adjustl(name)) // '%beta_pol')
     call read_type_vecflt_type(structure_out%li, trim(adjustl(name)) // '%li')
     call read_type_vecflt_type(structure_out%elongation, trim(adjustl(name)) // '%elongation')
     call read_type_vecflt_type(structure_out%tria_upper, trim(adjustl(name)) // '%tria_upper')
     call read_type_vecflt_type(structure_out%tria_lower, trim(adjustl(name)) // '%tria_lower')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%vprime, trim(adjustl(name)) // '%vprime')
     call read_type_vecflt_type(structure_out%dvdrho, trim(adjustl(name)) // '%dvdrho')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%aprime, trim(adjustl(name)) // '%aprime')
     call read_type_vecflt_type(structure_out%surface, trim(adjustl(name)) // '%surface')
     call read_type_vecflt_type(structure_out%ftrap, trim(adjustl(name)) // '%ftrap')
     call read_type_vecflt_type(structure_out%gm1, trim(adjustl(name)) // '%gm1')
     call read_type_vecflt_type(structure_out%gm2, trim(adjustl(name)) // '%gm2')
     call read_type_vecflt_type(structure_out%gm3, trim(adjustl(name)) // '%gm3')
     call read_type_vecflt_type(structure_out%gm4, trim(adjustl(name)) // '%gm4')
     call read_type_vecflt_type(structure_out%gm5, trim(adjustl(name)) // '%gm5')
     call read_type_vecflt_type(structure_out%gm6, trim(adjustl(name)) // '%gm6')
     call read_type_vecflt_type(structure_out%gm7, trim(adjustl(name)) // '%gm7')
     call read_type_vecflt_type(structure_out%gm8, trim(adjustl(name)) // '%gm8')
     call read_type_vecflt_type(structure_out%gm9, trim(adjustl(name)) // '%gm9')
     call read_type_vecflt_type(structure_out%b_av, trim(adjustl(name)) // '%b_av')
     call read_type_vecflt_type(structure_out%b_min, trim(adjustl(name)) // '%b_min')
     call read_type_vecflt_type(structure_out%b_max, trim(adjustl(name)) // '%b_max')
     call read_type_vecflt_type(structure_out%omega, trim(adjustl(name)) // '%omega')
     call read_type_vecflt_type(structure_out%omegaprime, trim(adjustl(name)) // '%omegaprime')
     call read_type_vecflt_type(structure_out%mach_a, trim(adjustl(name)) // '%mach_a')
     call read_type_vecflt_type(structure_out%phi_flow, trim(adjustl(name)) // '%phi_flow')
     call read_type_vecflt_type(structure_out%s_flow, trim(adjustl(name)) // '%s_flow')
     call read_type_vecflt_type(structure_out%h_flow, trim(adjustl(name)) // '%h_flow')
     call read_type_vecflt_type(structure_out%rho_mass, trim(adjustl(name)) // '%rho_mass')

   end subroutine read_type_profiles_1d

   subroutine read_arr_type_profiles_1d(structure_out, name)
 
     implicit none
 
     type (type_profiles_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_profiles_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_profiles_1d

   subroutine read_type_psi(structure_out, name)

     implicit none

     type (type_psi), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%ddrho, trim(adjustl(name)) // '%ddrho')
     call read_type_vecflt_type(structure_out%d2drho2, trim(adjustl(name)) // '%d2drho2')
     call read_type_vecflt_type(structure_out%ddt_rhotorn, trim(adjustl(name)) // '%ddt_rhotorn')
     call read_type_vecflt_type(structure_out%ddt_phi, trim(adjustl(name)) // '%ddt_phi')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')
     call read_type_boundary(structure_out%boundary, trim(adjustl(name)) // '%boundary')
     call read_type_jni(structure_out%jni, trim(adjustl(name)) // '%jni')
     call read_type_coreprofile(structure_out%sigma_par, trim(adjustl(name)) // '%sigma_par')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_psi

   subroutine read_arr_type_psi(structure_out, name)
 
     implicit none
 
     type (type_psi), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_psi(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_psi

   subroutine read_type_putinfo(structure_out, name)

     implicit none

     type (type_putinfo), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%putmethod, trim(adjustl(name)) // '%putmethod')
     call read_type_vecstring_type(structure_out%putaccess, trim(adjustl(name)) // '%putaccess')
     call read_type_vecstring_type(structure_out%putlocation, trim(adjustl(name)) // '%putlocation')
     call read_type_vecstring_type(structure_out%rights, trim(adjustl(name)) // '%rights')

   end subroutine read_type_putinfo

   subroutine read_arr_type_putinfo(structure_out, name)
 
     implicit none
 
     type (type_putinfo), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_putinfo(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_putinfo

   subroutine read_type_q(structure_out, name)

     implicit none

     type (type_q), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%qvalue, trim(adjustl(name)) // '%qvalue')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_integer(structure_out%exact, trim(adjustl(name)) // '%exact')
     call read_type_vecflt_type(structure_out%weight, trim(adjustl(name)) // '%weight')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_vecflt_type(structure_out%calculated, trim(adjustl(name)) // '%calculated')
     call read_type_vecflt_type(structure_out%chi2, trim(adjustl(name)) // '%chi2')

   end subroutine read_type_q

   subroutine read_arr_type_q(structure_out, name)
 
     implicit none
 
     type (type_q), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_q(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_q

   subroutine read_type_reacprodType(structure_out, name)

     implicit none

     type (type_reacprodType), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_arr_type_amns_constituentType(structure_out%constituents, trim(adjustl(name)) // '%constituents')
     call read_type_identifier(structure_out%role, trim(adjustl(name)) // '%role')
     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_integer(structure_out%relative, trim(adjustl(name)) // '%relative')
     call read_type_float(structure_out%za, trim(adjustl(name)) // '%za')
     call read_type_float(structure_out%multiplicity, trim(adjustl(name)) // '%multiplicity')
     call read_type_vecint_type(structure_out%metastable, trim(adjustl(name)) // '%metastable')
     call read_type_vecstring_type(structure_out%metastable_label, trim(adjustl(name)) // '%metastable_label')

   end subroutine read_type_reacprodType

   subroutine read_arr_type_reacprodType(structure_out, name)
 
     implicit none
 
     type (type_reacprodType), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reacprodType(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reacprodType

   subroutine read_type_react(structure_out, name)

     implicit none

     type (type_react), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%he_fr, trim(adjustl(name)) // '%he_fr')
     call read_type_float(structure_out%lp_fr, trim(adjustl(name)) // '%lp_fr')
     call read_type_float(structure_out%he_dp, trim(adjustl(name)) // '%he_dp')
     call read_type_float(structure_out%lipb_dp, trim(adjustl(name)) // '%lipb_dp')

   end subroutine read_type_react

   subroutine read_arr_type_react(structure_out, name)
 
     implicit none
 
     type (type_react), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_react(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_react

   subroutine read_type_rectanglexyz(structure_out, name)

     implicit none

     type (type_rectanglexyz), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_xyz0D(structure_out%point01, trim(adjustl(name)) // '%point01')
     call read_type_xyz0D(structure_out%point11, trim(adjustl(name)) // '%point11')
     call read_type_xyz0D(structure_out%point10, trim(adjustl(name)) // '%point10')

   end subroutine read_type_rectanglexyz

   subroutine read_arr_type_rectanglexyz(structure_out, name)
 
     implicit none
 
     type (type_rectanglexyz), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rectanglexyz(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rectanglexyz

   subroutine read_type_recycling_neutrals(structure_out, name)

     implicit none

     type (type_recycling_neutrals), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%particles, trim(adjustl(name)) // '%particles')
     call read_type_vecflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_recycling_neutrals

   subroutine read_arr_type_recycling_neutrals(structure_out, name)
 
     implicit none
 
     type (type_recycling_neutrals), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_recycling_neutrals(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_recycling_neutrals

   subroutine read_type_reduced(structure_out, name)

     implicit none

     type (type_reduced), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_reduced

   subroutine read_arr_type_reduced(structure_out, name)
 
     implicit none
 
     type (type_reduced), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reduced(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reduced

   subroutine read_type_refl_receive(structure_out, name)

     implicit none

     type (type_refl_receive), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_t_series_real(structure_out%raw_signal, trim(adjustl(name)) // '%raw_signal')
     call read_type_t_series_real(structure_out%io_signal, trim(adjustl(name)) // '%io_signal')
     call read_type_t_series_cplx(structure_out%iq_receiver, trim(adjustl(name)) // '%iq_receiver')
     call read_type_integer(structure_out%antenna_ind, trim(adjustl(name)) // '%antenna_ind')

   end subroutine read_type_refl_receive

   subroutine read_arr_type_refl_receive(structure_out, name)
 
     implicit none
 
     type (type_refl_receive), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_refl_receive(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_refl_receive

   subroutine read_type_reflectometry_antennas(structure_out, name)

     implicit none

     type (type_reflectometry_antennas), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_origin(structure_out%origin, trim(adjustl(name)) // '%origin')
     call read_type_reflectometry_radfield(structure_out%radfield, trim(adjustl(name)) // '%radfield')
     call read_type_float(structure_out%geometry, trim(adjustl(name)) // '%geometry')
     call read_type_launchsignal(structure_out%launchsignal, trim(adjustl(name)) // '%launchsignal')

   end subroutine read_type_reflectometry_antennas

   subroutine read_arr_type_reflectometry_antennas(structure_out, name)
 
     implicit none
 
     type (type_reflectometry_antennas), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reflectometry_antennas(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reflectometry_antennas

   subroutine read_type_reflectometry_radfield(structure_out, name)

     implicit none

     type (type_reflectometry_radfield), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%position, trim(adjustl(name)) // '%position')
     call read_arr_type_reflectometry_radfield_gaussian(structure_out%gaussian, trim(adjustl(name)) // '%gaussian')
     call read_arr_type_reflectometry_radifield_efield(structure_out%efield, trim(adjustl(name)) // '%efield')

   end subroutine read_type_reflectometry_radfield

   subroutine read_arr_type_reflectometry_radfield(structure_out, name)
 
     implicit none
 
     type (type_reflectometry_radfield), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reflectometry_radfield(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reflectometry_radfield

   subroutine read_type_reflectometry_radfield_gaussian(structure_out, name)

     implicit none

     type (type_reflectometry_radfield_gaussian), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_simp_apert(structure_out%aperture, trim(adjustl(name)) // '%aperture')
     call read_type_vecflt_type(structure_out%waistsize, trim(adjustl(name)) // '%waistsize')
     call read_type_vecflt_type(structure_out%waistzpos, trim(adjustl(name)) // '%waistzpos')
     call read_type_vecflt_type(structure_out%tiltangle, trim(adjustl(name)) // '%tiltangle')
     call read_type_vecflt_type(structure_out%polar_angle, trim(adjustl(name)) // '%polar_angle')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')

   end subroutine read_type_reflectometry_radfield_gaussian

   subroutine read_arr_type_reflectometry_radfield_gaussian(structure_out, name)
 
     implicit none
 
     type (type_reflectometry_radfield_gaussian), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reflectometry_radfield_gaussian(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reflectometry_radfield_gaussian

   subroutine read_type_reflectometry_radifield_efield(structure_out, name)

     implicit none

     type (type_reflectometry_radifield_efield), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_reggrid(structure_out%grid2d, trim(adjustl(name)) // '%grid2d')
     call read_type_matcplx_type(structure_out%e1, trim(adjustl(name)) // '%e1')
     call read_type_matcplx_type(structure_out%e2, trim(adjustl(name)) // '%e2')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')

   end subroutine read_type_reflectometry_radifield_efield

   subroutine read_arr_type_reflectometry_radifield_efield(structure_out, name)
 
     implicit none
 
     type (type_reflectometry_radifield_efield), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reflectometry_radifield_efield(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reflectometry_radifield_efield

   subroutine read_type_reggrid(structure_out, name)

     implicit none

     type (type_reggrid), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%dim1, trim(adjustl(name)) // '%dim1')
     call read_type_vecflt_type(structure_out%dim2, trim(adjustl(name)) // '%dim2')

   end subroutine read_type_reggrid

   subroutine read_arr_type_reggrid(structure_out, name)
 
     implicit none
 
     type (type_reggrid), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_reggrid(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_reggrid

   subroutine read_type_rfameasure(structure_out, name)

     implicit none

     type (type_rfameasure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%ti, trim(adjustl(name)) // '%ti')

   end subroutine read_type_rfameasure

   subroutine read_arr_type_rfameasure(structure_out, name)
 
     implicit none
 
     type (type_rfameasure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rfameasure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rfameasure

   subroutine read_type_rfasetup(structure_out, name)

     implicit none

     type (type_rfasetup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1Dexp(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_rfasetup

   subroutine read_arr_type_rfasetup(structure_out, name)
 
     implicit none
 
     type (type_rfasetup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rfasetup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rfasetup

   subroutine read_type_rfbeam(structure_out, name)

     implicit none

     type (type_rfbeam), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_spot(structure_out%spot, trim(adjustl(name)) // '%spot')
     call read_type_phaseellipse(structure_out%phaseellipse, trim(adjustl(name)) // '%phaseellipse')

   end subroutine read_type_rfbeam

   subroutine read_arr_type_rfbeam(structure_out, name)
 
     implicit none
 
     type (type_rfbeam), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rfbeam(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rfbeam

   subroutine read_type_rz0D(structure_out, name)

     implicit none

     type (type_rz0D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_float(structure_out%z, trim(adjustl(name)) // '%z')

   end subroutine read_type_rz0D

   subroutine read_arr_type_rz0D(structure_out, name)
 
     implicit none
 
     type (type_rz0D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rz0D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rz0D

   subroutine read_type_rz1D(structure_out, name)

     implicit none

     type (type_rz1D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')

   end subroutine read_type_rz1D

   subroutine read_arr_type_rz1D(structure_out, name)
 
     implicit none
 
     type (type_rz1D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rz1D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rz1D

   subroutine read_type_rz1D_npoints(structure_out, name)

     implicit none

     type (type_rz1D_npoints), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_integer(structure_out%npoints, trim(adjustl(name)) // '%npoints')

   end subroutine read_type_rz1D_npoints

   subroutine read_arr_type_rz1D_npoints(structure_out, name)
 
     implicit none
 
     type (type_rz1D_npoints), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rz1D_npoints(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rz1D_npoints

   subroutine read_type_rz1Dexp(structure_out, name)

     implicit none

     type (type_rz1Dexp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')

   end subroutine read_type_rz1Dexp

   subroutine read_arr_type_rz1Dexp(structure_out, name)
 
     implicit none
 
     type (type_rz1Dexp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rz1Dexp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rz1Dexp

   subroutine read_type_rz2D(structure_out, name)

     implicit none

     type (type_rz2D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')

   end subroutine read_type_rz2D

   subroutine read_arr_type_rz2D(structure_out, name)
 
     implicit none
 
     type (type_rz2D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rz2D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rz2D

   subroutine read_type_rz3D(structure_out, name)

     implicit none

     type (type_rz3D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_array3dflt_type(structure_out%z, trim(adjustl(name)) // '%z')

   end subroutine read_type_rz3D

   subroutine read_arr_type_rz3D(structure_out, name)
 
     implicit none
 
     type (type_rz3D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rz3D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rz3D

   subroutine read_type_rzphi0D(structure_out, name)

     implicit none

     type (type_rzphi0D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_float(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_float(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_rzphi0D

   subroutine read_arr_type_rzphi0D(structure_out, name)
 
     implicit none
 
     type (type_rzphi0D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphi0D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphi0D

   subroutine read_type_rzphi1D(structure_out, name)

     implicit none

     type (type_rzphi1D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_rzphi1D

   subroutine read_arr_type_rzphi1D(structure_out, name)
 
     implicit none
 
     type (type_rzphi1D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphi1D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphi1D

   subroutine read_type_rzphi1Dexp(structure_out, name)

     implicit none

     type (type_rzphi1Dexp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_exp1D(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_exp1D(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_rzphi1Dexp

   subroutine read_arr_type_rzphi1Dexp(structure_out, name)
 
     implicit none
 
     type (type_rzphi1Dexp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphi1Dexp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphi1Dexp

   subroutine read_type_rzphi1Dexperimental(structure_out, name)

     implicit none

     type (type_rzphi1Dexperimental), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_rzphi1Dexperimental

   subroutine read_arr_type_rzphi1Dexperimental(structure_out, name)
 
     implicit none
 
     type (type_rzphi1Dexperimental), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphi1Dexperimental(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphi1Dexperimental

   subroutine read_type_rzphi2D(structure_out, name)

     implicit none

     type (type_rzphi2D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_matflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_rzphi2D

   subroutine read_arr_type_rzphi2D(structure_out, name)
 
     implicit none
 
     type (type_rzphi2D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphi2D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphi2D

   subroutine read_type_rzphi3D(structure_out, name)

     implicit none

     type (type_rzphi3D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_array3dflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_array3dflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_rzphi3D

   subroutine read_arr_type_rzphi3D(structure_out, name)
 
     implicit none
 
     type (type_rzphi3D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphi3D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphi3D

   subroutine read_type_rzphidrdzdphi1D(structure_out, name)

     implicit none

     type (type_rzphidrdzdphi1D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%dr, trim(adjustl(name)) // '%dr')
     call read_type_vecflt_type(structure_out%dz, trim(adjustl(name)) // '%dz')
     call read_type_vecflt_type(structure_out%dphi, trim(adjustl(name)) // '%dphi')

   end subroutine read_type_rzphidrdzdphi1D

   subroutine read_arr_type_rzphidrdzdphi1D(structure_out, name)
 
     implicit none
 
     type (type_rzphidrdzdphi1D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_rzphidrdzdphi1D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_rzphidrdzdphi1D

   subroutine read_type_sawteeth_diags(structure_out, name)

     implicit none

     type (type_sawteeth_diags), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%shear1, trim(adjustl(name)) // '%shear1')
     call read_type_float(structure_out%rhotorn_q1, trim(adjustl(name)) // '%rhotorn_q1')
     call read_type_float(structure_out%rhotorn_inv, trim(adjustl(name)) // '%rhotorn_inv')
     call read_type_float(structure_out%rhotorn_mix, trim(adjustl(name)) // '%rhotorn_mix')

   end subroutine read_type_sawteeth_diags

   subroutine read_arr_type_sawteeth_diags(structure_out, name)
 
     implicit none
 
     type (type_sawteeth_diags), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sawteeth_diags(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sawteeth_diags

   subroutine read_type_sawteeth_profiles1d(structure_out, name)

     implicit none

     type (type_sawteeth_profiles1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_matflt_type(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_vecflt_type(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_matflt_type(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%psistar, trim(adjustl(name)) // '%psistar')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%q, trim(adjustl(name)) // '%q')

   end subroutine read_type_sawteeth_profiles1d

   subroutine read_arr_type_sawteeth_profiles1d(structure_out, name)
 
     implicit none
 
     type (type_sawteeth_profiles1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sawteeth_profiles1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sawteeth_profiles1d

   subroutine read_type_scenario_centre(structure_out, name)

     implicit none

     type (type_scenario_centre), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%te0, trim(adjustl(name)) // '%te0')
     call read_type_scenario_ref(structure_out%ti0, trim(adjustl(name)) // '%ti0')
     call read_type_scenario_ref(structure_out%ne0, trim(adjustl(name)) // '%ne0')
     call read_type_scenario_ref(structure_out%ni0, trim(adjustl(name)) // '%ni0')
     call read_type_scenario_ref(structure_out%shift0, trim(adjustl(name)) // '%shift0')
     call read_type_scenario_ref(structure_out%psi0, trim(adjustl(name)) // '%psi0')
     call read_type_scenario_ref(structure_out%phi0, trim(adjustl(name)) // '%phi0')
     call read_type_scenario_ref(structure_out%q0, trim(adjustl(name)) // '%q0')
     call read_type_scenario_ref(structure_out%Rmag, trim(adjustl(name)) // '%Rmag')
     call read_type_scenario_ref(structure_out%Zmag, trim(adjustl(name)) // '%Zmag')
     call read_type_scenario_ref(structure_out%vtor_0, trim(adjustl(name)) // '%vtor_0')

   end subroutine read_type_scenario_centre

   subroutine read_arr_type_scenario_centre(structure_out, name)
 
     implicit none
 
     type (type_scenario_centre), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_centre(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_centre

   subroutine read_type_scenario_composition(structure_out, name)

     implicit none

     type (type_scenario_composition), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_vecflt_type(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_vecflt_type(structure_out%zion, trim(adjustl(name)) // '%zion')
     call read_type_vecint_type(structure_out%imp_flag, trim(adjustl(name)) // '%imp_flag')
     call read_type_vecint_type(structure_out%rot_imp_flag, trim(adjustl(name)) // '%rot_imp_flag')
     call read_type_vecflt_type(structure_out%pellet_amn, trim(adjustl(name)) // '%pellet_amn')
     call read_type_vecflt_type(structure_out%pellet_zn, trim(adjustl(name)) // '%pellet_zn')
     call read_type_vecflt_type(structure_out%nbi_amn, trim(adjustl(name)) // '%nbi_amn')
     call read_type_vecflt_type(structure_out%nbi_zn, trim(adjustl(name)) // '%nbi_zn')

   end subroutine read_type_scenario_composition

   subroutine read_arr_type_scenario_composition(structure_out, name)
 
     implicit none
 
     type (type_scenario_composition), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_composition(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_composition

   subroutine read_type_scenario_configuration(structure_out, name)

     implicit none

     type (type_scenario_configuration), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_int(structure_out%config, trim(adjustl(name)) // '%config')
     call read_type_vecstring_type(structure_out%lmode_sc, trim(adjustl(name)) // '%lmode_sc')
     call read_type_vecstring_type(structure_out%hmode_sc, trim(adjustl(name)) // '%hmode_sc')
     call read_type_vecstring_type(structure_out%core_sc, trim(adjustl(name)) // '%core_sc')
     call read_type_vecstring_type(structure_out%pedestal_sc, trim(adjustl(name)) // '%pedestal_sc')
     call read_type_vecstring_type(structure_out%helium_sc, trim(adjustl(name)) // '%helium_sc')
     call read_type_vecstring_type(structure_out%impurity_sc, trim(adjustl(name)) // '%impurity_sc')
     call read_type_vecstring_type(structure_out%l2h_sc, trim(adjustl(name)) // '%l2h_sc')
     call read_type_vecstring_type(structure_out%tor_rot_sc, trim(adjustl(name)) // '%tor_rot_sc')
     call read_type_vecstring_type(structure_out%wall_mat, trim(adjustl(name)) // '%wall_mat')
     call read_type_vecstring_type(structure_out%evap_mat, trim(adjustl(name)) // '%evap_mat')
     call read_type_vecstring_type(structure_out%lim_mat, trim(adjustl(name)) // '%lim_mat')
     call read_type_vecstring_type(structure_out%div_mat, trim(adjustl(name)) // '%div_mat')
     call read_type_vecstring_type(structure_out%coordinate, trim(adjustl(name)) // '%coordinate')
     call read_type_scenario_ref(structure_out%ecrh_freq, trim(adjustl(name)) // '%ecrh_freq')
     call read_type_scenario_ref(structure_out%ecrh_loc, trim(adjustl(name)) // '%ecrh_loc')
     call read_type_scenario_int(structure_out%ecrh_mode, trim(adjustl(name)) // '%ecrh_mode')
     call read_type_scenario_ref(structure_out%ecrh_tor_ang, trim(adjustl(name)) // '%ecrh_tor_ang')
     call read_type_scenario_ref(structure_out%ecrh_pol_ang, trim(adjustl(name)) // '%ecrh_pol_ang')
     call read_type_scenario_int(structure_out%ecrh_harm, trim(adjustl(name)) // '%ecrh_harm')
     call read_type_scenario_ref(structure_out%enbi, trim(adjustl(name)) // '%enbi')
     call read_type_scenario_ref(structure_out%r_nbi, trim(adjustl(name)) // '%r_nbi')
     call read_type_scenario_int(structure_out%grad_b_drift, trim(adjustl(name)) // '%grad_b_drift')
     call read_type_scenario_ref(structure_out%icrh_freq, trim(adjustl(name)) // '%icrh_freq')
     call read_type_vecstring_type(structure_out%icrh_scheme, trim(adjustl(name)) // '%icrh_scheme')
     call read_type_scenario_ref(structure_out%icrh_phase, trim(adjustl(name)) // '%icrh_phase')
     call read_type_scenario_ref(structure_out%LH_freq, trim(adjustl(name)) // '%LH_freq')
     call read_type_scenario_ref(structure_out%LH_npar, trim(adjustl(name)) // '%LH_npar')
     call read_type_scenario_ref(structure_out%pellet_ang, trim(adjustl(name)) // '%pellet_ang')
     call read_type_scenario_ref(structure_out%pellet_v, trim(adjustl(name)) // '%pellet_v')
     call read_type_scenario_ref(structure_out%pellet_nba, trim(adjustl(name)) // '%pellet_nba')

   end subroutine read_type_scenario_configuration

   subroutine read_arr_type_scenario_configuration(structure_out, name)
 
     implicit none
 
     type (type_scenario_configuration), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_configuration(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_configuration

   subroutine read_type_scenario_confinement(structure_out, name)

     implicit none

     type (type_scenario_confinement), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%tau_e, trim(adjustl(name)) // '%tau_e')
     call read_type_scenario_ref(structure_out%tau_l_sc, trim(adjustl(name)) // '%tau_l_sc')
     call read_type_scenario_ref(structure_out%tau_h_sc, trim(adjustl(name)) // '%tau_h_sc')
     call read_type_scenario_ref(structure_out%tau_he, trim(adjustl(name)) // '%tau_he')
     call read_type_scenario_ref(structure_out%tau_e_ee, trim(adjustl(name)) // '%tau_e_ee')
     call read_type_scenario_ref(structure_out%tau_e_ii, trim(adjustl(name)) // '%tau_e_ii')
     call read_type_scenario_ref(structure_out%tau_e_ei, trim(adjustl(name)) // '%tau_e_ei')
     call read_type_scenario_ref(structure_out%tau_cur_diff, trim(adjustl(name)) // '%tau_cur_diff')
     call read_type_scenario_ref(structure_out%tau_i_rol, trim(adjustl(name)) // '%tau_i_rol')

   end subroutine read_type_scenario_confinement

   subroutine read_arr_type_scenario_confinement(structure_out, name)
 
     implicit none
 
     type (type_scenario_confinement), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_confinement(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_confinement

   subroutine read_type_scenario_currents(structure_out, name)

     implicit none

     type (type_scenario_currents), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%RR, trim(adjustl(name)) // '%RR')
     call read_type_scenario_ref(structure_out%i_align, trim(adjustl(name)) // '%i_align')
     call read_type_scenario_ref(structure_out%i_boot, trim(adjustl(name)) // '%i_boot')
     call read_type_scenario_ref(structure_out%i_cd_tot, trim(adjustl(name)) // '%i_cd_tot')
     call read_type_scenario_ref(structure_out%i_eccd, trim(adjustl(name)) // '%i_eccd')
     call read_type_scenario_ref(structure_out%i_fast_ion, trim(adjustl(name)) // '%i_fast_ion')
     call read_type_scenario_ref(structure_out%i_fwcd, trim(adjustl(name)) // '%i_fwcd')
     call read_type_scenario_ref(structure_out%i_lhcd, trim(adjustl(name)) // '%i_lhcd')
     call read_type_scenario_ref(structure_out%i_nbicd, trim(adjustl(name)) // '%i_nbicd')
     call read_type_scenario_ref(structure_out%i_ni_tot, trim(adjustl(name)) // '%i_ni_tot')
     call read_type_scenario_ref(structure_out%i_ohm, trim(adjustl(name)) // '%i_ohm')
     call read_type_scenario_ref(structure_out%i_par, trim(adjustl(name)) // '%i_par')
     call read_type_scenario_ref(structure_out%i_runaway, trim(adjustl(name)) // '%i_runaway')
     call read_type_scenario_ref(structure_out%v_loop, trim(adjustl(name)) // '%v_loop')
     call read_type_scenario_ref(structure_out%v_meas, trim(adjustl(name)) // '%v_meas')

   end subroutine read_type_scenario_currents

   subroutine read_arr_type_scenario_currents(structure_out, name)
 
     implicit none
 
     type (type_scenario_currents), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_currents(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_currents

   subroutine read_type_scenario_edge(structure_out, name)

     implicit none

     type (type_scenario_edge), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%te_edge, trim(adjustl(name)) // '%te_edge')
     call read_type_scenario_ref(structure_out%ti_edge, trim(adjustl(name)) // '%ti_edge')
     call read_type_scenario_ref(structure_out%ne_edge, trim(adjustl(name)) // '%ne_edge')
     call read_type_scenario_ref(structure_out%ni_edge, trim(adjustl(name)) // '%ni_edge')
     call read_type_scenario_ref(structure_out%psi_edge, trim(adjustl(name)) // '%psi_edge')
     call read_type_scenario_ref(structure_out%phi_edge, trim(adjustl(name)) // '%phi_edge')
     call read_type_scenario_ref(structure_out%rho_edge, trim(adjustl(name)) // '%rho_edge')
     call read_type_scenario_ref(structure_out%drho_edge_dt, trim(adjustl(name)) // '%drho_edge_dt')
     call read_type_scenario_ref(structure_out%q_edge, trim(adjustl(name)) // '%q_edge')
     call read_type_scenario_ref(structure_out%neutral_flux, trim(adjustl(name)) // '%neutral_flux')
     call read_type_scenario_ref(structure_out%phi_plasma, trim(adjustl(name)) // '%phi_plasma')
     call read_type_scenario_ref(structure_out%vtor_edge, trim(adjustl(name)) // '%vtor_edge')

   end subroutine read_type_scenario_edge

   subroutine read_arr_type_scenario_edge(structure_out, name)
 
     implicit none
 
     type (type_scenario_edge), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_edge(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_edge

   subroutine read_type_scenario_energy(structure_out, name)

     implicit none

     type (type_scenario_energy), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%w_tot, trim(adjustl(name)) // '%w_tot')
     call read_type_scenario_ref(structure_out%w_b_pol, trim(adjustl(name)) // '%w_b_pol')
     call read_type_scenario_ref(structure_out%w_dia, trim(adjustl(name)) // '%w_dia')
     call read_type_scenario_ref(structure_out%dwdia_dt, trim(adjustl(name)) // '%dwdia_dt')
     call read_type_scenario_ref(structure_out%w_b_tor_pla, trim(adjustl(name)) // '%w_b_tor_pla')
     call read_type_scenario_ref(structure_out%w_th, trim(adjustl(name)) // '%w_th')
     call read_type_scenario_ref(structure_out%dwtot_dt, trim(adjustl(name)) // '%dwtot_dt')
     call read_type_scenario_ref(structure_out%dwbpol_dt, trim(adjustl(name)) // '%dwbpol_dt')
     call read_type_scenario_ref(structure_out%dwbtorpla_dt, trim(adjustl(name)) // '%dwbtorpla_dt')
     call read_type_scenario_ref(structure_out%dwth_dt, trim(adjustl(name)) // '%dwth_dt')
     call read_type_scenario_ref(structure_out%esup_icrhtot, trim(adjustl(name)) // '%esup_icrhtot')
     call read_type_scenario_ref(structure_out%esup_icrhper, trim(adjustl(name)) // '%esup_icrhper')
     call read_type_scenario_ref(structure_out%esup_nbitot, trim(adjustl(name)) // '%esup_nbitot')
     call read_type_scenario_ref(structure_out%esup_nbiperp, trim(adjustl(name)) // '%esup_nbiperp')
     call read_type_scenario_ref(structure_out%esup_lhcd, trim(adjustl(name)) // '%esup_lhcd')
     call read_type_scenario_ref(structure_out%esup_alpha, trim(adjustl(name)) // '%esup_alpha')

   end subroutine read_type_scenario_energy

   subroutine read_arr_type_scenario_energy(structure_out, name)
 
     implicit none
 
     type (type_scenario_energy), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_energy(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_energy

   subroutine read_type_scenario_global(structure_out, name)

     implicit none

     type (type_scenario_global), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%ip, trim(adjustl(name)) // '%ip')
     call read_type_scenario_ref(structure_out%dip_dt, trim(adjustl(name)) // '%dip_dt')
     call read_type_scenario_ref(structure_out%beta_pol, trim(adjustl(name)) // '%beta_pol')
     call read_type_scenario_ref(structure_out%beta_tor, trim(adjustl(name)) // '%beta_tor')
     call read_type_scenario_ref(structure_out%beta_normal, trim(adjustl(name)) // '%beta_normal')
     call read_type_scenario_ref(structure_out%li, trim(adjustl(name)) // '%li')
     call read_type_scenario_ref(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_scenario_ref(structure_out%area_pol, trim(adjustl(name)) // '%area_pol')
     call read_type_scenario_ref(structure_out%area_ext, trim(adjustl(name)) // '%area_ext')
     call read_type_scenario_ref(structure_out%len_sepa, trim(adjustl(name)) // '%len_sepa')
     call read_type_scenario_ref(structure_out%beta_pol_th, trim(adjustl(name)) // '%beta_pol_th')
     call read_type_scenario_ref(structure_out%beta_tor_th, trim(adjustl(name)) // '%beta_tor_th')
     call read_type_scenario_ref(structure_out%beta_n_th, trim(adjustl(name)) // '%beta_n_th')
     call read_type_scenario_ref(structure_out%disruption, trim(adjustl(name)) // '%disruption')
     call read_type_scenario_ref(structure_out%mode_h, trim(adjustl(name)) // '%mode_h')
     call read_type_scenario_ref(structure_out%s_alpha, trim(adjustl(name)) // '%s_alpha')

   end subroutine read_type_scenario_global

   subroutine read_arr_type_scenario_global(structure_out, name)
 
     implicit none
 
     type (type_scenario_global), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_global(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_global

   subroutine read_type_scenario_heat_power(structure_out, name)

     implicit none

     type (type_scenario_heat_power), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%plh, trim(adjustl(name)) // '%plh')
     call read_type_scenario_ref(structure_out%pohmic, trim(adjustl(name)) // '%pohmic')
     call read_type_scenario_ref(structure_out%picrh, trim(adjustl(name)) // '%picrh')
     call read_type_scenario_ref(structure_out%pecrh, trim(adjustl(name)) // '%pecrh')
     call read_type_scenario_ref(structure_out%pnbi, trim(adjustl(name)) // '%pnbi')
     call read_type_scenario_ref(structure_out%pnbi_co_cur, trim(adjustl(name)) // '%pnbi_co_cur')
     call read_type_scenario_ref(structure_out%pnbi_counter, trim(adjustl(name)) // '%pnbi_counter')
     call read_type_scenario_ref(structure_out%plh_th, trim(adjustl(name)) // '%plh_th')
     call read_type_scenario_ref(structure_out%picrh_th, trim(adjustl(name)) // '%picrh_th')
     call read_type_scenario_ref(structure_out%pecrh_th, trim(adjustl(name)) // '%pecrh_th')
     call read_type_scenario_ref(structure_out%pnbi_th, trim(adjustl(name)) // '%pnbi_th')
     call read_type_scenario_ref(structure_out%ploss_icrh, trim(adjustl(name)) // '%ploss_icrh')
     call read_type_scenario_ref(structure_out%ploss_nbi, trim(adjustl(name)) // '%ploss_nbi')
     call read_type_scenario_ref(structure_out%pbrem, trim(adjustl(name)) // '%pbrem')
     call read_type_scenario_ref(structure_out%pcyclo, trim(adjustl(name)) // '%pcyclo')
     call read_type_scenario_ref(structure_out%prad, trim(adjustl(name)) // '%prad')
     call read_type_scenario_ref(structure_out%pdd_fus, trim(adjustl(name)) // '%pdd_fus')
     call read_type_scenario_ref(structure_out%pei, trim(adjustl(name)) // '%pei')
     call read_type_scenario_ref(structure_out%pel_tot, trim(adjustl(name)) // '%pel_tot')
     call read_type_scenario_ref(structure_out%pel_fus, trim(adjustl(name)) // '%pel_fus')
     call read_type_scenario_ref(structure_out%pel_icrh, trim(adjustl(name)) // '%pel_icrh')
     call read_type_scenario_ref(structure_out%pel_nbi, trim(adjustl(name)) // '%pel_nbi')
     call read_type_scenario_ref(structure_out%pfus_dt, trim(adjustl(name)) // '%pfus_dt')
     call read_type_scenario_ref(structure_out%ploss_fus, trim(adjustl(name)) // '%ploss_fus')
     call read_type_scenario_ref(structure_out%pfus_nbi, trim(adjustl(name)) // '%pfus_nbi')
     call read_type_scenario_ref(structure_out%pfus_th, trim(adjustl(name)) // '%pfus_th')
     call read_type_scenario_ref(structure_out%padd_tot, trim(adjustl(name)) // '%padd_tot')
     call read_type_scenario_ref(structure_out%pion_tot, trim(adjustl(name)) // '%pion_tot')
     call read_type_scenario_ref(structure_out%pion_fus, trim(adjustl(name)) // '%pion_fus')
     call read_type_scenario_ref(structure_out%pion_icrh, trim(adjustl(name)) // '%pion_icrh')
     call read_type_scenario_ref(structure_out%pion_nbi, trim(adjustl(name)) // '%pion_nbi')
     call read_type_scenario_ref(structure_out%pioniz, trim(adjustl(name)) // '%pioniz')
     call read_type_scenario_ref(structure_out%ploss, trim(adjustl(name)) // '%ploss')
     call read_type_scenario_ref(structure_out%p_wth, trim(adjustl(name)) // '%p_wth')
     call read_type_scenario_ref(structure_out%p_w, trim(adjustl(name)) // '%p_w')
     call read_type_scenario_ref(structure_out%p_l2h_thr, trim(adjustl(name)) // '%p_l2h_thr')
     call read_type_scenario_ref(structure_out%p_l2h_sc, trim(adjustl(name)) // '%p_l2h_sc')
     call read_type_scenario_ref(structure_out%p_nbi_icrh, trim(adjustl(name)) // '%p_nbi_icrh')

   end subroutine read_type_scenario_heat_power

   subroutine read_arr_type_scenario_heat_power(structure_out, name)
 
     implicit none
 
     type (type_scenario_heat_power), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_heat_power(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_heat_power

   subroutine read_type_scenario_int(structure_out, name)

     implicit none

     type (type_scenario_int), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_scenario_int

   subroutine read_arr_type_scenario_int(structure_out, name)
 
     implicit none
 
     type (type_scenario_int), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_int(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_int

   subroutine read_type_scenario_itb(structure_out, name)

     implicit none

     type (type_scenario_itb), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%q_min, trim(adjustl(name)) // '%q_min')
     call read_type_scenario_ref(structure_out%te_itb, trim(adjustl(name)) // '%te_itb')
     call read_type_scenario_ref(structure_out%ti_itb, trim(adjustl(name)) // '%ti_itb')
     call read_type_scenario_ref(structure_out%ne_itb, trim(adjustl(name)) // '%ne_itb')
     call read_type_scenario_ref(structure_out%ni_itb, trim(adjustl(name)) // '%ni_itb')
     call read_type_scenario_ref(structure_out%psi_itb, trim(adjustl(name)) // '%psi_itb')
     call read_type_scenario_ref(structure_out%phi_itb, trim(adjustl(name)) // '%phi_itb')
     call read_type_scenario_ref(structure_out%rho_itb, trim(adjustl(name)) // '%rho_itb')
     call read_type_scenario_ref(structure_out%h_itb, trim(adjustl(name)) // '%h_itb')
     call read_type_scenario_ref(structure_out%width_itb, trim(adjustl(name)) // '%width_itb')
     call read_type_scenario_ref(structure_out%vtor_itb, trim(adjustl(name)) // '%vtor_itb')
     call read_type_scenario_int(structure_out%itb_type, trim(adjustl(name)) // '%itb_type')

   end subroutine read_type_scenario_itb

   subroutine read_arr_type_scenario_itb(structure_out, name)
 
     implicit none
 
     type (type_scenario_itb), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_itb(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_itb

   subroutine read_type_scenario_lim_div_wall(structure_out, name)

     implicit none

     type (type_scenario_lim_div_wall), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%te_lim_div, trim(adjustl(name)) // '%te_lim_div')
     call read_type_scenario_ref(structure_out%ti_lim_div, trim(adjustl(name)) // '%ti_lim_div')
     call read_type_scenario_ref(structure_out%ne_lim_div, trim(adjustl(name)) // '%ne_lim_div')
     call read_type_scenario_ref(structure_out%ni_lim_div, trim(adjustl(name)) // '%ni_lim_div')
     call read_type_scenario_ref(structure_out%q_peak_div, trim(adjustl(name)) // '%q_peak_div')
     call read_type_scenario_ref(structure_out%q_peak_wall, trim(adjustl(name)) // '%q_peak_wall')
     call read_type_scenario_ref(structure_out%surf_temp, trim(adjustl(name)) // '%surf_temp')
     call read_type_scenario_ref(structure_out%p_lim_div, trim(adjustl(name)) // '%p_lim_div')
     call read_type_scenario_ref(structure_out%p_rad_div, trim(adjustl(name)) // '%p_rad_div')
     call read_type_scenario_ref(structure_out%p_neut_div, trim(adjustl(name)) // '%p_neut_div')
     call read_type_scenario_ref(structure_out%p_wall, trim(adjustl(name)) // '%p_wall')
     call read_type_scenario_ref(structure_out%wall_temp, trim(adjustl(name)) // '%wall_temp')
     call read_type_scenario_ref(structure_out%wall_state, trim(adjustl(name)) // '%wall_state')
     call read_type_scenario_ref(structure_out%detach_state, trim(adjustl(name)) // '%detach_state')
     call read_type_scenario_ref(structure_out%pump_flux, trim(adjustl(name)) // '%pump_flux')
     call read_type_scenario_ref(structure_out%p_rad_fw, trim(adjustl(name)) // '%p_rad_fw')
     call read_type_scenario_ref(structure_out%p_cond_fw, trim(adjustl(name)) // '%p_cond_fw')
     call read_type_scenario_ref(structure_out%div_wetted, trim(adjustl(name)) // '%div_wetted')
     call read_type_scenario_ref(structure_out%gas_puff, trim(adjustl(name)) // '%gas_puff')
     call read_type_scenario_ref(structure_out%ar_concentr, trim(adjustl(name)) // '%ar_concentr')
     call read_type_scenario_ref(structure_out%part_exhaust, trim(adjustl(name)) // '%part_exhaust')
     call read_type_scenario_ref(structure_out%f_inner, trim(adjustl(name)) // '%f_inner')
     call read_type_scenario_ref(structure_out%f_outer, trim(adjustl(name)) // '%f_outer')
     call read_type_scenario_ref(structure_out%f_pfr, trim(adjustl(name)) // '%f_pfr')
     call read_type_scenario_ref(structure_out%f_rad_fw, trim(adjustl(name)) // '%f_rad_fw')
     call read_type_vecflt_type(structure_out%q_div, trim(adjustl(name)) // '%q_div')
     call read_type_scenario_ref(structure_out%p_cond_div, trim(adjustl(name)) // '%p_cond_div')
     call read_type_float(structure_out%pol_ext, trim(adjustl(name)) // '%pol_ext')
     call read_type_float(structure_out%flux_exp, trim(adjustl(name)) // '%flux_exp')
     call read_type_float(structure_out%tilt_angle, trim(adjustl(name)) // '%tilt_angle')
     call read_type_float(structure_out%n_div, trim(adjustl(name)) // '%n_div')
     call read_type_float(structure_out%div_dz, trim(adjustl(name)) // '%div_dz')
     call read_type_float(structure_out%div_dro, trim(adjustl(name)) // '%div_dro')
     call read_type_float(structure_out%div_dri, trim(adjustl(name)) // '%div_dri')
     call read_type_scenario_ref(structure_out%p_nh_div, trim(adjustl(name)) // '%p_nh_div')

   end subroutine read_type_scenario_lim_div_wall

   subroutine read_arr_type_scenario_lim_div_wall(structure_out, name)
 
     implicit none
 
     type (type_scenario_lim_div_wall), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_lim_div_wall(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_lim_div_wall

   subroutine read_type_scenario_line_ave(structure_out, name)

     implicit none

     type (type_scenario_line_ave), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%ne_line, trim(adjustl(name)) // '%ne_line')
     call read_type_scenario_ref(structure_out%zeff_line, trim(adjustl(name)) // '%zeff_line')
     call read_type_scenario_ref(structure_out%ne_zeff_line, trim(adjustl(name)) // '%ne_zeff_line')
     call read_type_scenario_ref(structure_out%dne_line_dt, trim(adjustl(name)) // '%dne_line_dt')

   end subroutine read_type_scenario_line_ave

   subroutine read_arr_type_scenario_line_ave(structure_out, name)
 
     implicit none
 
     type (type_scenario_line_ave), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_line_ave(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_line_ave

   subroutine read_type_scenario_neutron(structure_out, name)

     implicit none

     type (type_scenario_neutron), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%ndd_tot, trim(adjustl(name)) // '%ndd_tot')
     call read_type_scenario_ref(structure_out%ndd_th, trim(adjustl(name)) // '%ndd_th')
     call read_type_scenario_ref(structure_out%ndd_nbi_th, trim(adjustl(name)) // '%ndd_nbi_th')
     call read_type_scenario_ref(structure_out%ndd_nbi_nbi, trim(adjustl(name)) // '%ndd_nbi_nbi')
     call read_type_scenario_ref(structure_out%ndt_tot, trim(adjustl(name)) // '%ndt_tot')
     call read_type_scenario_ref(structure_out%ndt_th, trim(adjustl(name)) // '%ndt_th')

   end subroutine read_type_scenario_neutron

   subroutine read_arr_type_scenario_neutron(structure_out, name)
 
     implicit none
 
     type (type_scenario_neutron), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_neutron(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_neutron

   subroutine read_type_scenario_ninety_five(structure_out, name)

     implicit none

     type (type_scenario_ninety_five), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%q_95, trim(adjustl(name)) // '%q_95')
     call read_type_scenario_ref(structure_out%elong_95, trim(adjustl(name)) // '%elong_95')
     call read_type_scenario_ref(structure_out%tria_95, trim(adjustl(name)) // '%tria_95')
     call read_type_scenario_ref(structure_out%tria_up_95, trim(adjustl(name)) // '%tria_up_95')
     call read_type_scenario_ref(structure_out%tria_lo_95, trim(adjustl(name)) // '%tria_lo_95')
     call read_type_scenario_ref(structure_out%te_95, trim(adjustl(name)) // '%te_95')
     call read_type_scenario_ref(structure_out%ti_95, trim(adjustl(name)) // '%ti_95')
     call read_type_scenario_ref(structure_out%ne_95, trim(adjustl(name)) // '%ne_95')
     call read_type_scenario_ref(structure_out%ni_95, trim(adjustl(name)) // '%ni_95')
     call read_type_scenario_ref(structure_out%phi_95, trim(adjustl(name)) // '%phi_95')
     call read_type_scenario_ref(structure_out%rho_95, trim(adjustl(name)) // '%rho_95')
     call read_type_scenario_ref(structure_out%vtor_95, trim(adjustl(name)) // '%vtor_95')

   end subroutine read_type_scenario_ninety_five

   subroutine read_arr_type_scenario_ninety_five(structure_out, name)
 
     implicit none
 
     type (type_scenario_ninety_five), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_ninety_five(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_ninety_five

   subroutine read_type_scenario_pedestal(structure_out, name)

     implicit none

     type (type_scenario_pedestal), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%te_ped, trim(adjustl(name)) // '%te_ped')
     call read_type_scenario_ref(structure_out%ti_ped, trim(adjustl(name)) // '%ti_ped')
     call read_type_scenario_ref(structure_out%ne_ped, trim(adjustl(name)) // '%ne_ped')
     call read_type_scenario_ref(structure_out%ni_ped, trim(adjustl(name)) // '%ni_ped')
     call read_type_scenario_ref(structure_out%psi_ped, trim(adjustl(name)) // '%psi_ped')
     call read_type_scenario_ref(structure_out%phi_ped, trim(adjustl(name)) // '%phi_ped')
     call read_type_scenario_ref(structure_out%rho_ped, trim(adjustl(name)) // '%rho_ped')
     call read_type_scenario_ref(structure_out%q_ped, trim(adjustl(name)) // '%q_ped')
     call read_type_scenario_ref(structure_out%pressure_ped, trim(adjustl(name)) // '%pressure_ped')
     call read_type_scenario_ref(structure_out%vtor_ped, trim(adjustl(name)) // '%vtor_ped')

   end subroutine read_type_scenario_pedestal

   subroutine read_arr_type_scenario_pedestal(structure_out, name)
 
     implicit none
 
     type (type_scenario_pedestal), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_pedestal(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_pedestal

   subroutine read_type_scenario_reactor(structure_out, name)

     implicit none

     type (type_scenario_reactor), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%pnetwork, trim(adjustl(name)) // '%pnetwork')

   end subroutine read_type_scenario_reactor

   subroutine read_arr_type_scenario_reactor(structure_out, name)
 
     implicit none
 
     type (type_scenario_reactor), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_reactor(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_reactor

   subroutine read_type_scenario_ref(structure_out, name)

     implicit none

     type (type_scenario_ref), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_scenario_ref

   subroutine read_arr_type_scenario_ref(structure_out, name)
 
     implicit none
 
     type (type_scenario_ref), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_ref(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_ref

   subroutine read_type_scenario_references(structure_out, name)

     implicit none

     type (type_scenario_references), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%plh, trim(adjustl(name)) // '%plh')
     call read_type_scenario_ref(structure_out%picrh, trim(adjustl(name)) // '%picrh')
     call read_type_scenario_ref(structure_out%pecrh, trim(adjustl(name)) // '%pecrh')
     call read_type_scenario_ref(structure_out%pnbi, trim(adjustl(name)) // '%pnbi')
     call read_type_scenario_ref(structure_out%ip, trim(adjustl(name)) // '%ip')
     call read_type_scenario_ref(structure_out%bvac_r, trim(adjustl(name)) // '%bvac_r')
     call read_type_scenario_ref(structure_out%zeffl, trim(adjustl(name)) // '%zeffl')
     call read_type_scenario_ref(structure_out%nbar, trim(adjustl(name)) // '%nbar')
     call read_type_scenario_ref(structure_out%xecrh, trim(adjustl(name)) // '%xecrh')
     call read_type_scenario_ref(structure_out%pol_flux, trim(adjustl(name)) // '%pol_flux')
     call read_type_scenario_ref(structure_out%enhancement, trim(adjustl(name)) // '%enhancement')
     call read_type_scenario_ref(structure_out%isotopic, trim(adjustl(name)) // '%isotopic')
     call read_type_scenario_ref(structure_out%nbi_td_ratio, trim(adjustl(name)) // '%nbi_td_ratio')
     call read_type_scenario_ref(structure_out%gas_puff, trim(adjustl(name)) // '%gas_puff')

   end subroutine read_type_scenario_references

   subroutine read_arr_type_scenario_references(structure_out, name)
 
     implicit none
 
     type (type_scenario_references), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_references(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_references

   subroutine read_type_scenario_sol(structure_out, name)

     implicit none

     type (type_scenario_sol), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%l_te_sol, trim(adjustl(name)) // '%l_te_sol')
     call read_type_scenario_ref(structure_out%l_ti_sol, trim(adjustl(name)) // '%l_ti_sol')
     call read_type_scenario_ref(structure_out%l_ne_sol, trim(adjustl(name)) // '%l_ne_sol')
     call read_type_scenario_ref(structure_out%l_ni_sol, trim(adjustl(name)) // '%l_ni_sol')
     call read_type_scenario_ref(structure_out%l_qe_sol, trim(adjustl(name)) // '%l_qe_sol')
     call read_type_scenario_ref(structure_out%l_qi_sol, trim(adjustl(name)) // '%l_qi_sol')
     call read_type_scenario_ref(structure_out%p_rad_sol, trim(adjustl(name)) // '%p_rad_sol')
     call read_type_float(structure_out%p_neut, trim(adjustl(name)) // '%p_neut')
     call read_type_scenario_ref(structure_out%gas_puff, trim(adjustl(name)) // '%gas_puff')
     call read_type_float(structure_out%delta_r_in, trim(adjustl(name)) // '%delta_r_in')
     call read_type_float(structure_out%delta_r_out, trim(adjustl(name)) // '%delta_r_out')
     call read_type_float(structure_out%r_in, trim(adjustl(name)) // '%r_in')
     call read_type_float(structure_out%r_out, trim(adjustl(name)) // '%r_out')
     call read_type_float(structure_out%sol_width, trim(adjustl(name)) // '%sol_width')

   end subroutine read_type_scenario_sol

   subroutine read_arr_type_scenario_sol(structure_out, name)
 
     implicit none
 
     type (type_scenario_sol), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_sol(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_sol

   subroutine read_type_scenario_vol_ave(structure_out, name)

     implicit none

     type (type_scenario_vol_ave), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_scenario_ref(structure_out%te_ave, trim(adjustl(name)) // '%te_ave')
     call read_type_scenario_ref(structure_out%ti_ave, trim(adjustl(name)) // '%ti_ave')
     call read_type_scenario_ref(structure_out%ne_ave, trim(adjustl(name)) // '%ne_ave')
     call read_type_scenario_ref(structure_out%dne_ave_dt, trim(adjustl(name)) // '%dne_ave_dt')
     call read_type_scenario_ref(structure_out%ni_ave, trim(adjustl(name)) // '%ni_ave')
     call read_type_scenario_ref(structure_out%zeff_ave, trim(adjustl(name)) // '%zeff_ave')
     call read_type_scenario_ref(structure_out%ti_o_te_ave, trim(adjustl(name)) // '%ti_o_te_ave')
     call read_type_scenario_ref(structure_out%meff_ave, trim(adjustl(name)) // '%meff_ave')
     call read_type_scenario_ref(structure_out%pellet_flux, trim(adjustl(name)) // '%pellet_flux')
     call read_type_vecflt_type(structure_out%nions_ave, trim(adjustl(name)) // '%nions_ave')
     call read_type_scenario_ref(structure_out%omega_ave, trim(adjustl(name)) // '%omega_ave')

   end subroutine read_type_scenario_vol_ave

   subroutine read_arr_type_scenario_vol_ave(structure_out, name)
 
     implicit none
 
     type (type_scenario_vol_ave), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_scenario_vol_ave(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_scenario_vol_ave

   subroutine read_type_setup_bprobe(structure_out, name)

     implicit none

     type (type_setup_bprobe), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_vecflt_type(structure_out%polangle, trim(adjustl(name)) // '%polangle')
     call read_type_vecflt_type(structure_out%torangle, trim(adjustl(name)) // '%torangle')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')
     call read_type_vecflt_type(structure_out%length, trim(adjustl(name)) // '%length')
     call read_type_vecint_type(structure_out%turns, trim(adjustl(name)) // '%turns')

   end subroutine read_type_setup_bprobe

   subroutine read_arr_type_setup_bprobe(structure_out, name)
 
     implicit none
 
     type (type_setup_bprobe), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_setup_bprobe(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_setup_bprobe

   subroutine read_type_setup_floops(structure_out, name)

     implicit none

     type (type_setup_floops), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_rzphi2D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_vecint_type(structure_out%npoints, trim(adjustl(name)) // '%npoints')

   end subroutine read_type_setup_floops

   subroutine read_arr_type_setup_floops(structure_out, name)
 
     implicit none
 
     type (type_setup_floops), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_setup_floops(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_setup_floops

   subroutine read_type_setup_line(structure_out, name)

     implicit none

     type (type_setup_line), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1D(structure_out%pivot_point, trim(adjustl(name)) // '%pivot_point')
     call read_type_vecflt_type(structure_out%horchordang1, trim(adjustl(name)) // '%horchordang1')
     call read_type_vecflt_type(structure_out%verchordang1, trim(adjustl(name)) // '%verchordang1')
     call read_type_vecflt_type(structure_out%width, trim(adjustl(name)) // '%width')
     call read_type_rzphi1D(structure_out%second_point, trim(adjustl(name)) // '%second_point')
     call read_type_vecflt_type(structure_out%horchordang2, trim(adjustl(name)) // '%horchordang2')
     call read_type_vecflt_type(structure_out%verchordang2, trim(adjustl(name)) // '%verchordang2')
     call read_type_rzphi1D(structure_out%third_point, trim(adjustl(name)) // '%third_point')
     call read_type_integer(structure_out%nchordpoints, trim(adjustl(name)) // '%nchordpoints')

   end subroutine read_type_setup_line

   subroutine read_arr_type_setup_line(structure_out, name)
 
     implicit none
 
     type (type_setup_line), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_setup_line(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_setup_line

   subroutine read_type_setup_line_exp(structure_out, name)

     implicit none

     type (type_setup_line_exp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1Dexperimental(structure_out%pivot_point, trim(adjustl(name)) // '%pivot_point')
     call read_type_vecflt_type(structure_out%horchordang1, trim(adjustl(name)) // '%horchordang1')
     call read_type_vecflt_type(structure_out%verchordang1, trim(adjustl(name)) // '%verchordang1')
     call read_type_vecflt_type(structure_out%width, trim(adjustl(name)) // '%width')
     call read_type_rzphi1Dexperimental(structure_out%second_point, trim(adjustl(name)) // '%second_point')
     call read_type_vecflt_type(structure_out%horchordang2, trim(adjustl(name)) // '%horchordang2')
     call read_type_vecflt_type(structure_out%verchordang2, trim(adjustl(name)) // '%verchordang2')
     call read_type_rzphi1Dexperimental(structure_out%third_point, trim(adjustl(name)) // '%third_point')
     call read_type_integer(structure_out%nchordpoints, trim(adjustl(name)) // '%nchordpoints')

   end subroutine read_type_setup_line_exp

   subroutine read_arr_type_setup_line_exp(structure_out, name)
 
     implicit none
 
     type (type_setup_line_exp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_setup_line_exp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_setup_line_exp

   subroutine read_type_shield(structure_out, name)

     implicit none

     type (type_shield), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_shield_specs(structure_out%inboard, trim(adjustl(name)) // '%inboard')
     call read_type_shield_specs(structure_out%outboard, trim(adjustl(name)) // '%outboard')

   end subroutine read_type_shield

   subroutine read_arr_type_shield(structure_out, name)
 
     implicit none
 
     type (type_shield), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_shield(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_shield

   subroutine read_type_shield_specs(structure_out, name)

     implicit none

     type (type_shield_specs), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nmat, trim(adjustl(name)) // '%nmat')
     call read_type_vecflt_type(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_float(structure_out%r1, trim(adjustl(name)) // '%r1')
     call read_type_float(structure_out%r2, trim(adjustl(name)) // '%r2')
     call read_type_float(structure_out%mass, trim(adjustl(name)) // '%mass')

   end subroutine read_type_shield_specs

   subroutine read_arr_type_shield_specs(structure_out, name)
 
     implicit none
 
     type (type_shield_specs), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_shield_specs(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_shield_specs

   subroutine read_type_simp_apert(structure_out, name)

     implicit none

     type (type_simp_apert), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecflt_type(structure_out%sizes, trim(adjustl(name)) // '%sizes')
     call read_type_float(structure_out%angle, trim(adjustl(name)) // '%angle')

   end subroutine read_type_simp_apert

   subroutine read_arr_type_simp_apert(structure_out, name)
 
     implicit none
 
     type (type_simp_apert), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_simp_apert(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_simp_apert

   subroutine read_type_solcurdiag_sol_current(structure_out, name)

     implicit none

     type (type_solcurdiag_sol_current), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_solcurdiag_sol_current_setup(structure_out%setup, trim(adjustl(name)) // '%setup')
     call read_type_exp0D(structure_out%measure, trim(adjustl(name)) // '%measure')

   end subroutine read_type_solcurdiag_sol_current

   subroutine read_arr_type_solcurdiag_sol_current(structure_out, name)
 
     implicit none
 
     type (type_solcurdiag_sol_current), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_solcurdiag_sol_current(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_solcurdiag_sol_current

   subroutine read_type_solcurdiag_sol_current_setup(structure_out, name)

     implicit none

     type (type_solcurdiag_sol_current_setup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_integer(structure_out%id, trim(adjustl(name)) // '%id')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_integer(structure_out%tiles_turn, trim(adjustl(name)) // '%tiles_turn')

   end subroutine read_type_solcurdiag_sol_current_setup

   subroutine read_arr_type_solcurdiag_sol_current_setup(structure_out, name)
 
     implicit none
 
     type (type_solcurdiag_sol_current_setup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_solcurdiag_sol_current_setup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_solcurdiag_sol_current_setup

   subroutine read_type_source_imp(structure_out, name)

     implicit none

     type (type_source_imp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%exp, trim(adjustl(name)) // '%exp')
     call read_type_matflt_type(structure_out%imp, trim(adjustl(name)) // '%imp')

   end subroutine read_type_source_imp

   subroutine read_arr_type_source_imp(structure_out, name)
 
     implicit none
 
     type (type_source_imp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_source_imp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_source_imp

   subroutine read_type_source_ion(structure_out, name)

     implicit none

     type (type_source_ion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%exp, trim(adjustl(name)) // '%exp')
     call read_type_matflt_type(structure_out%imp, trim(adjustl(name)) // '%imp')

   end subroutine read_type_source_ion

   subroutine read_arr_type_source_ion(structure_out, name)
 
     implicit none
 
     type (type_source_ion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_source_ion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_source_ion

   subroutine read_type_source_rate(structure_out, name)

     implicit none

     type (type_source_rate), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_complexgrid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_type_complexgrid_scalar(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecint_type(structure_out%discrete, trim(adjustl(name)) // '%discrete')
     call read_type_parameters(structure_out%parameters, trim(adjustl(name)) // '%parameters')

   end subroutine read_type_source_rate

   subroutine read_arr_type_source_rate(structure_out, name)
 
     implicit none
 
     type (type_source_rate), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_source_rate(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_source_rate

   subroutine read_type_source_vec(structure_out, name)

     implicit none

     type (type_source_vec), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%exp, trim(adjustl(name)) // '%exp')
     call read_type_vecflt_type(structure_out%imp, trim(adjustl(name)) // '%imp')

   end subroutine read_type_source_vec

   subroutine read_arr_type_source_vec(structure_out, name)
 
     implicit none
 
     type (type_source_vec), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_source_vec(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_source_vec

   subroutine read_type_sourceel(structure_out, name)

     implicit none

     type (type_sourceel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_vecflt_type(structure_out%integral, trim(adjustl(name)) // '%integral')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_sourceel

   subroutine read_arr_type_sourceel(structure_out, name)
 
     implicit none
 
     type (type_sourceel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sourceel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sourceel

   subroutine read_type_sourceimp(structure_out, name)

     implicit none

     type (type_sourceimp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_matflt_type(structure_out%integral, trim(adjustl(name)) // '%integral')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_sourceimp

   subroutine read_arr_type_sourceimp(structure_out, name)
 
     implicit none
 
     type (type_sourceimp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sourceimp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sourceimp

   subroutine read_type_sourceion(structure_out, name)

     implicit none

     type (type_sourceion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')
     call read_type_matflt_type(structure_out%integral, trim(adjustl(name)) // '%integral')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')

   end subroutine read_type_sourceion

   subroutine read_arr_type_sourceion(structure_out, name)
 
     implicit none
 
     type (type_sourceion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sourceion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sourceion

   subroutine read_type_species_desc(structure_out, name)

     implicit none

     type (type_species_desc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_type_float(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_float(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_float(structure_out%zmin, trim(adjustl(name)) // '%zmin')
     call read_type_float(structure_out%zmax, trim(adjustl(name)) // '%zmax')

   end subroutine read_type_species_desc

   subroutine read_arr_type_species_desc(structure_out, name)
 
     implicit none
 
     type (type_species_desc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_species_desc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_species_desc

   subroutine read_type_species_reference(structure_out, name)

     implicit none

     type (type_species_reference), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_integer(structure_out%index, trim(adjustl(name)) // '%index')

   end subroutine read_type_species_reference

   subroutine read_arr_type_species_reference(structure_out, name)
 
     implicit none
 
     type (type_species_reference), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_species_reference(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_species_reference

   subroutine read_type_spectral(structure_out, name)

     implicit none

     type (type_spectral), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_msediag_emissivity(structure_out%emissivity, trim(adjustl(name)) // '%emissivity')
     call read_type_msediag_radiance(structure_out%radiance, trim(adjustl(name)) // '%radiance')
     call read_type_codeparam(structure_out%codeparam, trim(adjustl(name)) // '%codeparam')

   end subroutine read_type_spectral

   subroutine read_arr_type_spectral(structure_out, name)
 
     implicit none
 
     type (type_spectral), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_spectral(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_spectral

   subroutine read_type_spectrum(structure_out, name)

     implicit none

     type (type_spectrum), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_launchs_phi_theta(structure_out%phi_theta, trim(adjustl(name)) // '%phi_theta')
     call read_type_launchs_parallel(structure_out%parallel, trim(adjustl(name)) // '%parallel')

   end subroutine read_type_spectrum

   subroutine read_arr_type_spectrum(structure_out, name)
 
     implicit none
 
     type (type_spectrum), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_spectrum(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_spectrum

   subroutine read_type_spot(structure_out, name)

     implicit none

     type (type_spot), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%size, trim(adjustl(name)) // '%size')
     call read_type_float(structure_out%angle, trim(adjustl(name)) // '%angle')

   end subroutine read_type_spot

   subroutine read_arr_type_spot(structure_out, name)
 
     implicit none
 
     type (type_spot), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_spot(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_spot

   subroutine read_type_sputtering_neutrals(structure_out, name)

     implicit none

     type (type_sputtering_neutrals), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%physical, trim(adjustl(name)) // '%physical')
     call read_type_vecflt_type(structure_out%chemical, trim(adjustl(name)) // '%chemical')

   end subroutine read_type_sputtering_neutrals

   subroutine read_arr_type_sputtering_neutrals(structure_out, name)
 
     implicit none
 
     type (type_sputtering_neutrals), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_sputtering_neutrals(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_sputtering_neutrals

   subroutine read_type_straps(structure_out, name)

     implicit none

     type (type_straps), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp0D(structure_out%current, trim(adjustl(name)) // '%current')
     call read_type_exp0D(structure_out%phase, trim(adjustl(name)) // '%phase')
     call read_type_float(structure_out%phi_centre, trim(adjustl(name)) // '%phi_centre')
     call read_type_float(structure_out%width, trim(adjustl(name)) // '%width')
     call read_type_float(structure_out%dist2wall, trim(adjustl(name)) // '%dist2wall')
     call read_type_rz1D(structure_out%coord_strap, trim(adjustl(name)) // '%coord_strap')

   end subroutine read_type_straps

   subroutine read_arr_type_straps(structure_out, name)
 
     implicit none
 
     type (type_straps), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_straps(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_straps

   subroutine read_type_structure_cs(structure_out, name)

     implicit none

     type (type_structure_cs), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%gaptf, trim(adjustl(name)) // '%gaptf')
     call read_type_float(structure_out%ri, trim(adjustl(name)) // '%ri')
     call read_type_float(structure_out%re, trim(adjustl(name)) // '%re')
     call read_type_float(structure_out%jcable, trim(adjustl(name)) // '%jcable')
     call read_type_float(structure_out%current_nom, trim(adjustl(name)) // '%current_nom')
     call read_type_float(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_float(structure_out%tiso, trim(adjustl(name)) // '%tiso')
     call read_type_float(structure_out%nlay, trim(adjustl(name)) // '%nlay')

   end subroutine read_type_structure_cs

   subroutine read_arr_type_structure_cs(structure_out, name)
 
     implicit none
 
     type (type_structure_cs), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_structure_cs(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_structure_cs

   subroutine read_type_t_series_cplx(structure_out, name)

     implicit none

     type (type_t_series_cplx), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%time_wind, trim(adjustl(name)) // '%time_wind')
     call read_type_vecflt_type(structure_out%values_re, trim(adjustl(name)) // '%values_re')
     call read_type_vecflt_type(structure_out%values_im, trim(adjustl(name)) // '%values_im')

   end subroutine read_type_t_series_cplx

   subroutine read_arr_type_t_series_cplx(structure_out, name)
 
     implicit none
 
     type (type_t_series_cplx), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_t_series_cplx(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_t_series_cplx

   subroutine read_type_t_series_real(structure_out, name)

     implicit none

     type (type_t_series_real), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%time_wind, trim(adjustl(name)) // '%time_wind')
     call read_type_vecflt_type(structure_out%values, trim(adjustl(name)) // '%values')

   end subroutine read_type_t_series_real

   subroutine read_arr_type_t_series_real(structure_out, name)
 
     implicit none
 
     type (type_t_series_real), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_t_series_real(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_t_series_real

   subroutine read_type_table(structure_out, name)

     implicit none

     type (type_table), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%filled, trim(adjustl(name)) // '%filled')
     call read_type_float(structure_out%table_0d, trim(adjustl(name)) // '%table_0d')
     call read_type_vecflt_type(structure_out%table_1d, trim(adjustl(name)) // '%table_1d')
     call read_type_matflt_type(structure_out%table_2d, trim(adjustl(name)) // '%table_2d')
     call read_type_array3dflt_type(structure_out%table_3d, trim(adjustl(name)) // '%table_3d')
     call read_type_array4dflt_type(structure_out%table_4d, trim(adjustl(name)) // '%table_4d')
     call read_type_array5dflt_type(structure_out%table_5d, trim(adjustl(name)) // '%table_5d')
     call read_type_array6dflt_type(structure_out%table_6d, trim(adjustl(name)) // '%table_6d')
     call read_type_vecstring_type(structure_out%coord1_str, trim(adjustl(name)) // '%coord1_str')
     call read_type_vecstring_type(structure_out%coord2_str, trim(adjustl(name)) // '%coord2_str')
     call read_type_vecstring_type(structure_out%coord3_str, trim(adjustl(name)) // '%coord3_str')
     call read_type_vecstring_type(structure_out%coord4_str, trim(adjustl(name)) // '%coord4_str')
     call read_type_vecstring_type(structure_out%coord5_str, trim(adjustl(name)) // '%coord5_str')
     call read_type_vecstring_type(structure_out%coord6_str, trim(adjustl(name)) // '%coord6_str')
     call read_type_identifier(structure_out%quality, trim(adjustl(name)) // '%quality')

   end subroutine read_type_table

   subroutine read_arr_type_table(structure_out, name)
 
     implicit none
 
     type (type_table), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_table(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_table

   subroutine read_type_tables(structure_out, name)

     implicit none

     type (type_tables), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%ndim, trim(adjustl(name)) // '%ndim')
     call read_type_integer(structure_out%coord_index, trim(adjustl(name)) // '%coord_index')
     call read_type_vecstring_type(structure_out%result_label, trim(adjustl(name)) // '%result_label')
     call read_type_vecstring_type(structure_out%result_unit, trim(adjustl(name)) // '%result_unit')
     call read_type_integer(structure_out%result_trans, trim(adjustl(name)) // '%result_trans')
     call read_type_vecint_type(structure_out%zmin, trim(adjustl(name)) // '%zmin')
     call read_type_vecint_type(structure_out%zmax, trim(adjustl(name)) // '%zmax')
     call read_type_vecstring_type(structure_out%state_label, trim(adjustl(name)) // '%state_label')
     call read_arr_type_table(structure_out%table, trim(adjustl(name)) // '%table')
     call read_type_vecstring_type(structure_out%data_source, trim(adjustl(name)) // '%data_source')
     call read_type_vecstring_type(structure_out%data_provide, trim(adjustl(name)) // '%data_provide')
     call read_type_vecstring_type(structure_out%data_citation, trim(adjustl(name)) // '%data_citation')

   end subroutine read_type_tables

   subroutine read_arr_type_tables(structure_out, name)
 
     implicit none
 
     type (type_tables), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tables(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tables

   subroutine read_type_tables_coord(structure_out, name)

     implicit none

     type (type_tables_coord), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_coords(structure_out%coords, trim(adjustl(name)) // '%coords')

   end subroutine read_type_tables_coord

   subroutine read_arr_type_tables_coord(structure_out, name)
 
     implicit none
 
     type (type_tables_coord), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tables_coord(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tables_coord

   subroutine read_type_temporary_nt(structure_out, name)

     implicit none

     type (type_temporary_nt), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_temporary_nt_0dr(structure_out%float0d, trim(adjustl(name)) // '%float0d')
     call read_arr_type_temporary_nt_0di(structure_out%integer0d, trim(adjustl(name)) // '%integer0d')
     call read_arr_type_temporary_nt_0dc(structure_out%complex0d, trim(adjustl(name)) // '%complex0d')
     call read_arr_type_temporary_nt_0ds(structure_out%string0d, trim(adjustl(name)) // '%string0d')
     call read_arr_type_temporary_nt_1dr(structure_out%float1d, trim(adjustl(name)) // '%float1d')
     call read_arr_type_temporary_nt_1di(structure_out%integer1d, trim(adjustl(name)) // '%integer1d')
     call read_arr_type_temporary_nt_1dr(structure_out%string1d, trim(adjustl(name)) // '%string1d')
     call read_arr_type_temporary_nt_1dc(structure_out%complex1d, trim(adjustl(name)) // '%complex1d')
     call read_arr_type_temporary_nt_2dr(structure_out%float2d, trim(adjustl(name)) // '%float2d')
     call read_arr_type_temporary_nt_2di(structure_out%integer2d, trim(adjustl(name)) // '%integer2d')
     call read_arr_type_temporary_nt_2dc(structure_out%complex2d, trim(adjustl(name)) // '%complex2d')
     call read_arr_type_temporary_nt_3dr(structure_out%float3d, trim(adjustl(name)) // '%float3d')
     call read_arr_type_temporary_nt_3di(structure_out%integer3d, trim(adjustl(name)) // '%integer3d')
     call read_arr_type_temporary_nt_3dc(structure_out%complex3d, trim(adjustl(name)) // '%complex3d')
     call read_arr_type_temporary_nt_4dr(structure_out%float4d, trim(adjustl(name)) // '%float4d')

   end subroutine read_type_temporary_nt

   subroutine read_arr_type_temporary_nt(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt

   subroutine read_type_temporary_nt_0dc(structure_out, name)

     implicit none

     type (type_temporary_nt_0dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_complex(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_0dc

   subroutine read_arr_type_temporary_nt_0dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_0dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_0dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_0dc

   subroutine read_type_temporary_nt_0di(structure_out, name)

     implicit none

     type (type_temporary_nt_0di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_integer(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_0di

   subroutine read_arr_type_temporary_nt_0di(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_0di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_0di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_0di

   subroutine read_type_temporary_nt_0dr(structure_out, name)

     implicit none

     type (type_temporary_nt_0dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_float(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_0dr

   subroutine read_arr_type_temporary_nt_0dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_0dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_0dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_0dr

   subroutine read_type_temporary_nt_0ds(structure_out, name)

     implicit none

     type (type_temporary_nt_0ds), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecstring_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_0ds

   subroutine read_arr_type_temporary_nt_0ds(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_0ds), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_0ds(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_0ds

   subroutine read_type_temporary_nt_1dc(structure_out, name)

     implicit none

     type (type_temporary_nt_1dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_veccplx_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_1dc

   subroutine read_arr_type_temporary_nt_1dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_1dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_1dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_1dc

   subroutine read_type_temporary_nt_1di(structure_out, name)

     implicit none

     type (type_temporary_nt_1di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecint_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_1di

   subroutine read_arr_type_temporary_nt_1di(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_1di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_1di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_1di

   subroutine read_type_temporary_nt_1dr(structure_out, name)

     implicit none

     type (type_temporary_nt_1dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_1dr

   subroutine read_arr_type_temporary_nt_1dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_1dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_1dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_1dr

   subroutine read_type_temporary_nt_1ds(structure_out, name)

     implicit none

     type (type_temporary_nt_1ds), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecstring_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_1ds

   subroutine read_arr_type_temporary_nt_1ds(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_1ds), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_1ds(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_1ds

   subroutine read_type_temporary_nt_2dc(structure_out, name)

     implicit none

     type (type_temporary_nt_2dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_matcplx_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_2dc

   subroutine read_arr_type_temporary_nt_2dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_2dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_2dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_2dc

   subroutine read_type_temporary_nt_2di(structure_out, name)

     implicit none

     type (type_temporary_nt_2di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_matint_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_2di

   subroutine read_arr_type_temporary_nt_2di(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_2di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_2di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_2di

   subroutine read_type_temporary_nt_2dr(structure_out, name)

     implicit none

     type (type_temporary_nt_2dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_2dr

   subroutine read_arr_type_temporary_nt_2dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_2dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_2dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_2dr

   subroutine read_type_temporary_nt_3dc(structure_out, name)

     implicit none

     type (type_temporary_nt_3dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array3dcplx_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_3dc

   subroutine read_arr_type_temporary_nt_3dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_3dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_3dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_3dc

   subroutine read_type_temporary_nt_3di(structure_out, name)

     implicit none

     type (type_temporary_nt_3di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array3dint_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_3di

   subroutine read_arr_type_temporary_nt_3di(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_3di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_3di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_3di

   subroutine read_type_temporary_nt_3dr(structure_out, name)

     implicit none

     type (type_temporary_nt_3dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array3dflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_3dr

   subroutine read_arr_type_temporary_nt_3dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_3dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_3dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_3dr

   subroutine read_type_temporary_nt_4dr(structure_out, name)

     implicit none

     type (type_temporary_nt_4dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array4dflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_nt_4dr

   subroutine read_arr_type_temporary_nt_4dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_nt_4dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_nt_4dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_nt_4dr

   subroutine read_type_temporary_t(structure_out, name)

     implicit none

     type (type_temporary_t), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_temporary_t_0dr(structure_out%float0d, trim(adjustl(name)) // '%float0d')
     call read_arr_type_temporary_t_0di(structure_out%integer0d, trim(adjustl(name)) // '%integer0d')
     call read_arr_type_temporary_t_0dc(structure_out%complex0d, trim(adjustl(name)) // '%complex0d')
     call read_arr_type_temporary_t_0ds(structure_out%string0d, trim(adjustl(name)) // '%string0d')
     call read_arr_type_temporary_t_1dr(structure_out%float1d, trim(adjustl(name)) // '%float1d')
     call read_arr_type_temporary_t_1di(structure_out%integer1d, trim(adjustl(name)) // '%integer1d')
     call read_arr_type_temporary_t_1dc(structure_out%complex1d, trim(adjustl(name)) // '%complex1d')
     call read_arr_type_temporary_t_2dr(structure_out%float2d, trim(adjustl(name)) // '%float2d')
     call read_arr_type_temporary_t_2di(structure_out%integer2d, trim(adjustl(name)) // '%integer2d')
     call read_arr_type_temporary_t_2dc(structure_out%complex2d, trim(adjustl(name)) // '%complex2d')
     call read_arr_type_temporary_t_3dr(structure_out%float3d, trim(adjustl(name)) // '%float3d')
     call read_arr_type_temporary_t_3di(structure_out%integer3d, trim(adjustl(name)) // '%integer3d')
     call read_arr_type_temporary_t_3dc(structure_out%complex3d, trim(adjustl(name)) // '%complex3d')
     call read_arr_type_temporary_t_4dr(structure_out%float4d, trim(adjustl(name)) // '%float4d')

   end subroutine read_type_temporary_t

   subroutine read_arr_type_temporary_t(structure_out, name)
 
     implicit none
 
     type (type_temporary_t), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t

   subroutine read_type_temporary_t_0dc(structure_out, name)

     implicit none

     type (type_temporary_t_0dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_complex(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_0dc

   subroutine read_arr_type_temporary_t_0dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_0dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_0dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_0dc

   subroutine read_type_temporary_t_0di(structure_out, name)

     implicit none

     type (type_temporary_t_0di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_integer(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_0di

   subroutine read_arr_type_temporary_t_0di(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_0di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_0di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_0di

   subroutine read_type_temporary_t_0dr(structure_out, name)

     implicit none

     type (type_temporary_t_0dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_float(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_0dr

   subroutine read_arr_type_temporary_t_0dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_0dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_0dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_0dr

   subroutine read_type_temporary_t_0ds(structure_out, name)

     implicit none

     type (type_temporary_t_0ds), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecstring_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_0ds

   subroutine read_arr_type_temporary_t_0ds(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_0ds), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_0ds(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_0ds

   subroutine read_type_temporary_t_1dc(structure_out, name)

     implicit none

     type (type_temporary_t_1dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_veccplx_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_1dc

   subroutine read_arr_type_temporary_t_1dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_1dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_1dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_1dc

   subroutine read_type_temporary_t_1di(structure_out, name)

     implicit none

     type (type_temporary_t_1di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecint_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_1di

   subroutine read_arr_type_temporary_t_1di(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_1di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_1di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_1di

   subroutine read_type_temporary_t_1dr(structure_out, name)

     implicit none

     type (type_temporary_t_1dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_vecflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_1dr

   subroutine read_arr_type_temporary_t_1dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_1dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_1dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_1dr

   subroutine read_type_temporary_t_2dc(structure_out, name)

     implicit none

     type (type_temporary_t_2dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_matcplx_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_2dc

   subroutine read_arr_type_temporary_t_2dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_2dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_2dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_2dc

   subroutine read_type_temporary_t_2di(structure_out, name)

     implicit none

     type (type_temporary_t_2di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_matint_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_2di

   subroutine read_arr_type_temporary_t_2di(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_2di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_2di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_2di

   subroutine read_type_temporary_t_2dr(structure_out, name)

     implicit none

     type (type_temporary_t_2dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_matflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_2dr

   subroutine read_arr_type_temporary_t_2dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_2dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_2dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_2dr

   subroutine read_type_temporary_t_3dc(structure_out, name)

     implicit none

     type (type_temporary_t_3dc), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array3dcplx_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_3dc

   subroutine read_arr_type_temporary_t_3dc(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_3dc), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_3dc(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_3dc

   subroutine read_type_temporary_t_3di(structure_out, name)

     implicit none

     type (type_temporary_t_3di), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array3dint_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_3di

   subroutine read_arr_type_temporary_t_3di(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_3di), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_3di(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_3di

   subroutine read_type_temporary_t_3dr(structure_out, name)

     implicit none

     type (type_temporary_t_3dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array3dflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_3dr

   subroutine read_arr_type_temporary_t_3dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_3dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_3dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_3dr

   subroutine read_type_temporary_t_4dr(structure_out, name)

     implicit none

     type (type_temporary_t_4dr), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%identifier, trim(adjustl(name)) // '%identifier')
     call read_type_array4dflt_type(structure_out%value, trim(adjustl(name)) // '%value')

   end subroutine read_type_temporary_t_4dr

   subroutine read_arr_type_temporary_t_4dr(structure_out, name)
 
     implicit none
 
     type (type_temporary_t_4dr), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_temporary_t_4dr(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_temporary_t_4dr

   subroutine read_type_tf_desc_tfcoils(structure_out, name)

     implicit none

     type (type_tf_desc_tfcoils), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_float(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_circularcoil(structure_out%circularcoil, trim(adjustl(name)) // '%circularcoil')
     call read_type_planecoil(structure_out%planecoil, trim(adjustl(name)) // '%planecoil')
     call read_type_tf_structure(structure_out%inboard, trim(adjustl(name)) // '%inboard')
     call read_type_tf_structure(structure_out%outboard, trim(adjustl(name)) // '%outboard')

   end subroutine read_type_tf_desc_tfcoils

   subroutine read_arr_type_tf_desc_tfcoils(structure_out, name)
 
     implicit none
 
     type (type_tf_desc_tfcoils), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tf_desc_tfcoils(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tf_desc_tfcoils

   subroutine read_type_tf_desc_tfcoils_board(structure_out, name)

     implicit none

     type (type_tf_desc_tfcoils_board), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_tf_structure(structure_out%structure, trim(adjustl(name)) // '%structure')

   end subroutine read_type_tf_desc_tfcoils_board

   subroutine read_arr_type_tf_desc_tfcoils_board(structure_out, name)
 
     implicit none
 
     type (type_tf_desc_tfcoils_board), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tf_desc_tfcoils_board(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tf_desc_tfcoils_board

   subroutine read_type_tf_structure(structure_out, name)

     implicit none

     type (type_tf_structure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%jcable, trim(adjustl(name)) // '%jcable')
     call read_type_float(structure_out%tisotf, trim(adjustl(name)) // '%tisotf')
     call read_type_float(structure_out%efcasing, trim(adjustl(name)) // '%efcasing')
     call read_type_float(structure_out%escasing, trim(adjustl(name)) // '%escasing')
     call read_type_float(structure_out%sigjackettf, trim(adjustl(name)) // '%sigjackettf')
     call read_type_float(structure_out%sigvaulttf, trim(adjustl(name)) // '%sigvaulttf')
     call read_type_float(structure_out%ktf, trim(adjustl(name)) // '%ktf')
     call read_type_float(structure_out%ritf, trim(adjustl(name)) // '%ritf')
     call read_type_float(structure_out%riitf, trim(adjustl(name)) // '%riitf')
     call read_type_float(structure_out%retf, trim(adjustl(name)) // '%retf')
     call read_type_float(structure_out%he_fraction, trim(adjustl(name)) // '%he_fraction')
     call read_type_float(structure_out%ss_fraction, trim(adjustl(name)) // '%ss_fraction')
     call read_type_float(structure_out%pow_dens_wp, trim(adjustl(name)) // '%pow_dens_wp')

   end subroutine read_type_tf_structure

   subroutine read_arr_type_tf_structure(structure_out, name)
 
     implicit none
 
     type (type_tf_structure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tf_structure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tf_structure

   subroutine read_type_theta_info(structure_out, name)

     implicit none

     type (type_theta_info), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%angl_type, trim(adjustl(name)) // '%angl_type')
     call read_type_matflt_type(structure_out%th2th_pol, trim(adjustl(name)) // '%th2th_pol')

   end subroutine read_type_theta_info

   subroutine read_arr_type_theta_info(structure_out, name)
 
     implicit none
 
     type (type_theta_info), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_theta_info(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_theta_info

   subroutine read_type_topo_regions(structure_out, name)

     implicit none

     type (type_topo_regions), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%ind_omnigen, trim(adjustl(name)) // '%ind_omnigen')
     call read_type_array6dflt_type(structure_out%dim1, trim(adjustl(name)) // '%dim1')
     call read_type_array6dflt_type(structure_out%dim2, trim(adjustl(name)) // '%dim2')
     call read_type_array6dflt_type(structure_out%dim3, trim(adjustl(name)) // '%dim3')
     call read_type_array6dflt_type(structure_out%dim4, trim(adjustl(name)) // '%dim4')
     call read_type_array6dflt_type(structure_out%dim5, trim(adjustl(name)) // '%dim5')
     call read_type_array6dflt_type(structure_out%dim6, trim(adjustl(name)) // '%dim6')
     call read_type_array6dflt_type(structure_out%jacobian, trim(adjustl(name)) // '%jacobian')
     call read_type_array6dflt_type(structure_out%distfunc, trim(adjustl(name)) // '%distfunc')

   end subroutine read_type_topo_regions

   subroutine read_arr_type_topo_regions(structure_out, name)
 
     implicit none
 
     type (type_topo_regions), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_topo_regions(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_topo_regions

   subroutine read_type_toroid_field(structure_out, name)

     implicit none

     type (type_toroid_field), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%b0, trim(adjustl(name)) // '%b0')
     call read_type_float(structure_out%b0prime, trim(adjustl(name)) // '%b0prime')
     call read_type_float(structure_out%r0, trim(adjustl(name)) // '%r0')
     call read_type_float(structure_out%time, trim(adjustl(name)) // '%time')

   end subroutine read_type_toroid_field

   subroutine read_arr_type_toroid_field(structure_out, name)
 
     implicit none
 
     type (type_toroid_field), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_toroid_field(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_toroid_field

   subroutine read_type_trace(structure_out, name)

     implicit none

     type (type_trace), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%time_orb, trim(adjustl(name)) // '%time_orb')
     call read_type_vecint_type(structure_out%ntorb, trim(adjustl(name)) // '%ntorb')
     call read_type_matflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_matflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_matflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_matflt_type(structure_out%theta_b, trim(adjustl(name)) // '%theta_b')
     call read_type_matflt_type(structure_out%v_parallel, trim(adjustl(name)) // '%v_parallel')
     call read_type_matflt_type(structure_out%v_perp, trim(adjustl(name)) // '%v_perp')

   end subroutine read_type_trace

   subroutine read_arr_type_trace(structure_out, name)
 
     implicit none
 
     type (type_trace), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_trace(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_trace

   subroutine read_type_transcoefel(structure_out, name)

     implicit none

     type (type_transcoefel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%diff_eff, trim(adjustl(name)) // '%diff_eff')
     call read_type_vecflt_type(structure_out%vconv_eff, trim(adjustl(name)) // '%vconv_eff')
     call read_type_vecflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_offdiagel(structure_out%off_diagonal, trim(adjustl(name)) // '%off_diagonal')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')

   end subroutine read_type_transcoefel

   subroutine read_arr_type_transcoefel(structure_out, name)
 
     implicit none
 
     type (type_transcoefel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_transcoefel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_transcoefel

   subroutine read_type_transcoefimp(structure_out, name)

     implicit none

     type (type_transcoefimp), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%diff_eff, trim(adjustl(name)) // '%diff_eff')
     call read_type_matflt_type(structure_out%vconv_eff, trim(adjustl(name)) // '%vconv_eff')
     call read_type_matflt_type(structure_out%exchange, trim(adjustl(name)) // '%exchange')
     call read_type_matflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')

   end subroutine read_type_transcoefimp

   subroutine read_arr_type_transcoefimp(structure_out, name)
 
     implicit none
 
     type (type_transcoefimp), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_transcoefimp(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_transcoefimp

   subroutine read_type_transcoefion(structure_out, name)

     implicit none

     type (type_transcoefion), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%diff_eff, trim(adjustl(name)) // '%diff_eff')
     call read_type_matflt_type(structure_out%vconv_eff, trim(adjustl(name)) // '%vconv_eff')
     call read_type_matflt_type(structure_out%exchange, trim(adjustl(name)) // '%exchange')
     call read_type_matflt_type(structure_out%qgi, trim(adjustl(name)) // '%qgi')
     call read_type_matflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_offdiagion(structure_out%off_diagonal, trim(adjustl(name)) // '%off_diagonal')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')

   end subroutine read_type_transcoefion

   subroutine read_arr_type_transcoefion(structure_out, name)
 
     implicit none
 
     type (type_transcoefion), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_transcoefion(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_transcoefion

   subroutine read_type_transcoefvtor(structure_out, name)

     implicit none

     type (type_transcoefvtor), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%diff_eff, trim(adjustl(name)) // '%diff_eff')
     call read_type_matflt_type(structure_out%vconv_eff, trim(adjustl(name)) // '%vconv_eff')
     call read_type_matflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_offdiagion(structure_out%off_diagonal, trim(adjustl(name)) // '%off_diagonal')
     call read_type_integer(structure_out%flag, trim(adjustl(name)) // '%flag')

   end subroutine read_type_transcoefvtor

   subroutine read_arr_type_transcoefvtor(structure_out, name)
 
     implicit none
 
     type (type_transcoefvtor), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_transcoefvtor(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_transcoefvtor

   subroutine read_type_trap_type(structure_out, name)

     implicit none

     type (type_trap_type), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%trap_id, trim(adjustl(name)) // '%trap_id')
     call read_type_integer(structure_out%compound, trim(adjustl(name)) // '%compound')
     call read_type_integer(structure_out%gas_species, trim(adjustl(name)) // '%gas_species')
     call read_type_float(structure_out%energy, trim(adjustl(name)) // '%energy')
     call read_type_matflt_type(structure_out%fill_factor, trim(adjustl(name)) // '%fill_factor')
     call read_type_matflt_type(structure_out%density, trim(adjustl(name)) // '%density')

   end subroutine read_type_trap_type

   subroutine read_arr_type_trap_type(structure_out, name)
 
     implicit none
 
     type (type_trap_type), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_trap_type(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_trap_type

   subroutine read_type_trianglexyz(structure_out, name)

     implicit none

     type (type_trianglexyz), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_xyz0D(structure_out%point1, trim(adjustl(name)) // '%point1')
     call read_type_xyz0D(structure_out%point2, trim(adjustl(name)) // '%point2')
     call read_type_xyz0D(structure_out%point3, trim(adjustl(name)) // '%point3')

   end subroutine read_type_trianglexyz

   subroutine read_arr_type_trianglexyz(structure_out, name)
 
     implicit none
 
     type (type_trianglexyz), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_trianglexyz(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_trianglexyz

   subroutine read_type_tsmeasure(structure_out, name)

     implicit none

     type (type_tsmeasure), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_exp1D(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_exp1D(structure_out%ne, trim(adjustl(name)) // '%ne')

   end subroutine read_type_tsmeasure

   subroutine read_arr_type_tsmeasure(structure_out, name)
 
     implicit none
 
     type (type_tsmeasure), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tsmeasure(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tsmeasure

   subroutine read_type_tssetup(structure_out, name)

     implicit none

     type (type_tssetup), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rzphi1D(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_tssetup

   subroutine read_arr_type_tssetup(structure_out, name)
 
     implicit none
 
     type (type_tssetup), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_tssetup(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_tssetup

   subroutine read_type_turbcomposition(structure_out, name)

     implicit none

     type (type_turbcomposition), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%amn, trim(adjustl(name)) // '%amn')
     call read_type_vecflt_type(structure_out%zn, trim(adjustl(name)) // '%zn')
     call read_type_vecflt_type(structure_out%zion, trim(adjustl(name)) // '%zion')
     call read_type_vecflt_type(structure_out%ie_mass, trim(adjustl(name)) // '%ie_mass')

   end subroutine read_type_turbcomposition

   subroutine read_arr_type_turbcomposition(structure_out, name)
 
     implicit none
 
     type (type_turbcomposition), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbcomposition(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbcomposition

   subroutine read_type_turbcoordsys(structure_out, name)

     implicit none

     type (type_turbcoordsys), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%grid_type, trim(adjustl(name)) // '%grid_type')
     call read_type_turbgrid(structure_out%turbgrid, trim(adjustl(name)) // '%turbgrid')
     call read_type_matflt_type(structure_out%jacobian, trim(adjustl(name)) // '%jacobian')
     call read_type_matflt_type(structure_out%g_11, trim(adjustl(name)) // '%g_11')
     call read_type_matflt_type(structure_out%g_12, trim(adjustl(name)) // '%g_12')
     call read_type_matflt_type(structure_out%g_13, trim(adjustl(name)) // '%g_13')
     call read_type_matflt_type(structure_out%g_22, trim(adjustl(name)) // '%g_22')
     call read_type_matflt_type(structure_out%g_23, trim(adjustl(name)) // '%g_23')
     call read_type_matflt_type(structure_out%g_33, trim(adjustl(name)) // '%g_33')
     call read_type_rzphi3D(structure_out%position, trim(adjustl(name)) // '%position')

   end subroutine read_type_turbcoordsys

   subroutine read_arr_type_turbcoordsys(structure_out, name)
 
     implicit none
 
     type (type_turbcoordsys), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbcoordsys(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbcoordsys

   subroutine read_type_turbenv1d(structure_out, name)

     implicit none

     type (type_turbenv1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%vor, trim(adjustl(name)) // '%vor')
     call read_type_vecflt_type(structure_out%jpl, trim(adjustl(name)) // '%jpl')
     call read_type_vecflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_vecflt_type(structure_out%he, trim(adjustl(name)) // '%he')
     call read_type_vecflt_type(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_matflt_type(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_matflt_type(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_matflt_type(structure_out%ui, trim(adjustl(name)) // '%ui')
     call read_type_vecflt_type(structure_out%fe, trim(adjustl(name)) // '%fe')
     call read_type_vecflt_type(structure_out%qe, trim(adjustl(name)) // '%qe')
     call read_type_matflt_type(structure_out%qi, trim(adjustl(name)) // '%qi')
     call read_type_vecflt_type(structure_out%me, trim(adjustl(name)) // '%me')
     call read_type_matflt_type(structure_out%mi, trim(adjustl(name)) // '%mi')

   end subroutine read_type_turbenv1d

   subroutine read_arr_type_turbenv1d(structure_out, name)
 
     implicit none
 
     type (type_turbenv1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbenv1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbenv1d

   subroutine read_type_turbgrid(structure_out, name)

     implicit none

     type (type_turbgrid), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%dim1, trim(adjustl(name)) // '%dim1')
     call read_type_vecflt_type(structure_out%dim2, trim(adjustl(name)) // '%dim2')
     call read_type_vecflt_type(structure_out%dim3, trim(adjustl(name)) // '%dim3')
     call read_type_vecflt_type(structure_out%dim_v1, trim(adjustl(name)) // '%dim_v1')
     call read_type_vecflt_type(structure_out%dim_v2, trim(adjustl(name)) // '%dim_v2')

   end subroutine read_type_turbgrid

   subroutine read_arr_type_turbgrid(structure_out, name)
 
     implicit none
 
     type (type_turbgrid), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbgrid(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbgrid

   subroutine read_type_turbspec1d(structure_out, name)

     implicit none

     type (type_turbspec1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%kperp, trim(adjustl(name)) // '%kperp')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%vor, trim(adjustl(name)) // '%vor')
     call read_type_vecflt_type(structure_out%b, trim(adjustl(name)) // '%b')
     call read_type_vecflt_type(structure_out%jpl, trim(adjustl(name)) // '%jpl')
     call read_type_vecflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_vecflt_type(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_matflt_type(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_vecflt_type(structure_out%fe, trim(adjustl(name)) // '%fe')
     call read_type_vecflt_type(structure_out%qe, trim(adjustl(name)) // '%qe')
     call read_type_matflt_type(structure_out%qi, trim(adjustl(name)) // '%qi')
     call read_type_vecflt_type(structure_out%me, trim(adjustl(name)) // '%me')
     call read_type_matflt_type(structure_out%mi, trim(adjustl(name)) // '%mi')

   end subroutine read_type_turbspec1d

   subroutine read_arr_type_turbspec1d(structure_out, name)
 
     implicit none
 
     type (type_turbspec1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbspec1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbspec1d

   subroutine read_type_turbvar0d(structure_out, name)

     implicit none

     type (type_turbvar0d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%dtime_type, trim(adjustl(name)) // '%dtime_type')
     call read_type_vecflt_type(structure_out%dtime, trim(adjustl(name)) // '%dtime')
     call read_type_vecflt_type(structure_out%en_exb, trim(adjustl(name)) // '%en_exb')
     call read_type_vecflt_type(structure_out%en_mag, trim(adjustl(name)) // '%en_mag')
     call read_type_vecflt_type(structure_out%en_el_th, trim(adjustl(name)) // '%en_el_th')
     call read_type_matflt_type(structure_out%en_ion_th, trim(adjustl(name)) // '%en_ion_th')
     call read_type_vecflt_type(structure_out%en_el_par, trim(adjustl(name)) // '%en_el_par')
     call read_type_matflt_type(structure_out%en_ion_par, trim(adjustl(name)) // '%en_ion_par')
     call read_type_vecflt_type(structure_out%en_tot, trim(adjustl(name)) // '%en_tot')
     call read_type_vecflt_type(structure_out%fl_el, trim(adjustl(name)) // '%fl_el')
     call read_type_vecflt_type(structure_out%fl_heatel, trim(adjustl(name)) // '%fl_heatel')
     call read_type_matflt_type(structure_out%fl_ion, trim(adjustl(name)) // '%fl_ion')
     call read_type_matflt_type(structure_out%fl_heation, trim(adjustl(name)) // '%fl_heation')
     call read_type_vecflt_type(structure_out%fl_magel, trim(adjustl(name)) // '%fl_magel')
     call read_type_vecflt_type(structure_out%fl_magheatel, trim(adjustl(name)) // '%fl_magheatel')
     call read_type_matflt_type(structure_out%fl_magion, trim(adjustl(name)) // '%fl_magion')
     call read_type_matflt_type(structure_out%flmagheation, trim(adjustl(name)) // '%flmagheation')

   end subroutine read_type_turbvar0d

   subroutine read_arr_type_turbvar0d(structure_out, name)
 
     implicit none
 
     type (type_turbvar0d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbvar0d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbvar0d

   subroutine read_type_turbvar1d(structure_out, name)

     implicit none

     type (type_turbvar1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%er, trim(adjustl(name)) // '%er')
     call read_type_vecflt_type(structure_out%vor, trim(adjustl(name)) // '%vor')
     call read_type_vecflt_type(structure_out%apl, trim(adjustl(name)) // '%apl')
     call read_type_vecflt_type(structure_out%jpl, trim(adjustl(name)) // '%jpl')
     call read_type_vecflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_vecflt_type(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_matflt_type(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_matflt_type(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_matflt_type(structure_out%ui, trim(adjustl(name)) // '%ui')

   end subroutine read_type_turbvar1d

   subroutine read_arr_type_turbvar1d(structure_out, name)
 
     implicit none
 
     type (type_turbvar1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbvar1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbvar1d

   subroutine read_type_turbvar2d(structure_out, name)

     implicit none

     type (type_turbvar2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')
     call read_type_matflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_matflt_type(structure_out%apl, trim(adjustl(name)) // '%apl')
     call read_type_matflt_type(structure_out%jpl, trim(adjustl(name)) // '%jpl')
     call read_type_matflt_type(structure_out%vor, trim(adjustl(name)) // '%vor')
     call read_type_matflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')
     call read_type_matflt_type(structure_out%te, trim(adjustl(name)) // '%te')
     call read_type_array3dflt_type(structure_out%ni, trim(adjustl(name)) // '%ni')
     call read_type_array3dflt_type(structure_out%ti, trim(adjustl(name)) // '%ti')
     call read_type_array3dflt_type(structure_out%ui, trim(adjustl(name)) // '%ui')

   end subroutine read_type_turbvar2d

   subroutine read_arr_type_turbvar2d(structure_out, name)
 
     implicit none
 
     type (type_turbvar2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbvar2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbvar2d

   subroutine read_type_turbvar3d(structure_out, name)

     implicit none

     type (type_turbvar3d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array3dflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_array3dflt_type(structure_out%vor, trim(adjustl(name)) // '%vor')
     call read_type_array3dflt_type(structure_out%jpl, trim(adjustl(name)) // '%jpl')
     call read_type_array3dflt_type(structure_out%ne, trim(adjustl(name)) // '%ne')

   end subroutine read_type_turbvar3d

   subroutine read_arr_type_turbvar3d(structure_out, name)
 
     implicit none
 
     type (type_turbvar3d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbvar3d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbvar3d

   subroutine read_type_turbvar4d(structure_out, name)

     implicit none

     type (type_turbvar4d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array4dflt_type(structure_out%fe, trim(adjustl(name)) // '%fe')
     call read_type_array5dflt_type(structure_out%fi, trim(adjustl(name)) // '%fi')

   end subroutine read_type_turbvar4d

   subroutine read_arr_type_turbvar4d(structure_out, name)
 
     implicit none
 
     type (type_turbvar4d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbvar4d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbvar4d

   subroutine read_type_turbvar5d(structure_out, name)

     implicit none

     type (type_turbvar5d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_array5dflt_type(structure_out%fe, trim(adjustl(name)) // '%fe')
     call read_type_array6dflt_type(structure_out%fi, trim(adjustl(name)) // '%fi')

   end subroutine read_type_turbvar5d

   subroutine read_arr_type_turbvar5d(structure_out, name)
 
     implicit none
 
     type (type_turbvar5d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_turbvar5d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_turbvar5d

   subroutine read_type_version_ind(structure_out, name)

     implicit none

     type (type_version_ind), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%description, trim(adjustl(name)) // '%description')
     call read_type_vecstring_type(structure_out%releasedate, trim(adjustl(name)) // '%releasedate')
     call read_arr_type_data_release(structure_out%data_release, trim(adjustl(name)) // '%data_release')

   end subroutine read_type_version_ind

   subroutine read_arr_type_version_ind(structure_out, name)
 
     implicit none
 
     type (type_version_ind), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_version_ind(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_version_ind

   subroutine read_type_wall2d(structure_out, name)

     implicit none

     type (type_wall2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%wall_id, trim(adjustl(name)) // '%wall_id')
     call read_type_wall_limiter(structure_out%limiter, trim(adjustl(name)) // '%limiter')
     call read_type_wall_vessel(structure_out%vessel, trim(adjustl(name)) // '%vessel')
     call read_arr_type_plasmaComplexType(structure_out%plasma, trim(adjustl(name)) // '%plasma')
     call read_arr_type_wall_unitsComplexType(structure_out%wall_state, trim(adjustl(name)) // '%wall_state')

   end subroutine read_type_wall2d

   subroutine read_arr_type_wall2d(structure_out, name)
 
     implicit none
 
     type (type_wall2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall2d

   subroutine read_type_wall2d_mhd(structure_out, name)

     implicit none

     type (type_wall2d_mhd), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_mhd_res_wall2d(structure_out%res_wall, trim(adjustl(name)) // '%res_wall')
     call read_type_mhd_ideal_wall2d(structure_out%ideal_wall, trim(adjustl(name)) // '%ideal_wall')

   end subroutine read_type_wall2d_mhd

   subroutine read_arr_type_wall2d_mhd(structure_out, name)
 
     implicit none
 
     type (type_wall2d_mhd), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall2d_mhd(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall2d_mhd

   subroutine read_type_wall3d(structure_out, name)

     implicit none

     type (type_wall3d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%wall_id, trim(adjustl(name)) // '%wall_id')
     call read_type_complexgrid(structure_out%grid, trim(adjustl(name)) // '%grid')
     call read_arr_type_plasmaComplexType(structure_out%plasma, trim(adjustl(name)) // '%plasma')
     call read_arr_type_wall_unitsComplexType(structure_out%wall_state, trim(adjustl(name)) // '%wall_state')
     call read_type_integer(structure_out%basis_index, trim(adjustl(name)) // '%basis_index')

   end subroutine read_type_wall3d

   subroutine read_arr_type_wall3d(structure_out, name)
 
     implicit none
 
     type (type_wall3d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall3d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall3d

   subroutine read_type_wall_blocks(structure_out, name)

     implicit none

     type (type_wall_blocks), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_wall_blocks_unit(structure_out%blocks_unit, trim(adjustl(name)) // '%blocks_unit')

   end subroutine read_type_wall_blocks

   subroutine read_arr_type_wall_blocks(structure_out, name)
 
     implicit none
 
     type (type_wall_blocks), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_blocks(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_blocks

   subroutine read_type_wall_blocks_unit(structure_out, name)

     implicit none

     type (type_wall_blocks_unit), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_float(structure_out%eta, trim(adjustl(name)) // '%eta')
     call read_type_float(structure_out%permeability, trim(adjustl(name)) // '%permeability')
     call read_type_float(structure_out%j_phi, trim(adjustl(name)) // '%j_phi')
     call read_type_float(structure_out%resistance, trim(adjustl(name)) // '%resistance')

   end subroutine read_type_wall_blocks_unit

   subroutine read_arr_type_wall_blocks_unit(structure_out, name)
 
     implicit none
 
     type (type_wall_blocks_unit), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_blocks_unit(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_blocks_unit

   subroutine read_type_wall_limiter(structure_out, name)

     implicit none

     type (type_wall_limiter), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%limiter_id, trim(adjustl(name)) // '%limiter_id')
     call read_arr_type_limiter_unit(structure_out%limiter_unit, trim(adjustl(name)) // '%limiter_unit')

   end subroutine read_type_wall_limiter

   subroutine read_arr_type_wall_limiter(structure_out, name)
 
     implicit none
 
     type (type_wall_limiter), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_limiter(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_limiter

   subroutine read_type_wall_types(structure_out, name)

     implicit none

     type (type_wall_types), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%label, trim(adjustl(name)) // '%label')
     call read_arr_type_wall_types_layers(structure_out%layers, trim(adjustl(name)) // '%layers')

   end subroutine read_type_wall_types

   subroutine read_arr_type_wall_types(structure_out, name)
 
     implicit none
 
     type (type_wall_types), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_types(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_types

   subroutine read_type_wall_types_layers(structure_out, name)

     implicit none

     type (type_wall_types_layers), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%thickness, trim(adjustl(name)) // '%thickness')
     call read_type_vecflt_type(structure_out%chem_comp, trim(adjustl(name)) // '%chem_comp')

   end subroutine read_type_wall_types_layers

   subroutine read_arr_type_wall_types_layers(structure_out, name)
 
     implicit none
 
     type (type_wall_types_layers), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_types_layers(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_types_layers

   subroutine read_type_wall_unitsComplexType(structure_out, name)

     implicit none

     type (type_wall_unitsComplexType), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%wall_type, trim(adjustl(name)) // '%wall_type')
     call read_type_integer(structure_out%n_depo_layer, trim(adjustl(name)) // '%n_depo_layer')
     call read_arr_type_wall_unitsComplexType_layers(structure_out%layers, trim(adjustl(name)) // '%layers')
     call read_type_complexgrid_scalar(structure_out%eta, trim(adjustl(name)) // '%eta')
     call read_type_complexgrid_scalar(structure_out%permeability, trim(adjustl(name)) // '%permeability')
     call read_type_complexgrid_vector(structure_out%j, trim(adjustl(name)) // '%j')

   end subroutine read_type_wall_unitsComplexType

   subroutine read_arr_type_wall_unitsComplexType(structure_out, name)
 
     implicit none
 
     type (type_wall_unitsComplexType), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_unitsComplexType(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_unitsComplexType

   subroutine read_type_wall_unitsComplexType_layers(structure_out, name)

     implicit none

     type (type_wall_unitsComplexType_layers), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecint_type(structure_out%elements, trim(adjustl(name)) // '%elements')
     call read_type_vecint_type(structure_out%gases, trim(adjustl(name)) // '%gases')
     call read_type_vecint_type(structure_out%compounds, trim(adjustl(name)) // '%compounds')
     call read_type_matflt_type(structure_out%density, trim(adjustl(name)) // '%density')
     call read_type_matflt_type(structure_out%dx, trim(adjustl(name)) // '%dx')
     call read_type_vecflt_type(structure_out%thickness, trim(adjustl(name)) // '%thickness')
     call read_type_array3dflt_type(structure_out%roughness, trim(adjustl(name)) // '%roughness')
     call read_type_array3dflt_type(structure_out%porosity, trim(adjustl(name)) // '%porosity')
     call read_type_matflt_type(structure_out%dpa, trim(adjustl(name)) // '%dpa')
     call read_type_matflt_type(structure_out%temperature, trim(adjustl(name)) // '%temperature')
     call read_type_array3dflt_type(structure_out%element_frac, trim(adjustl(name)) // '%element_frac')
     call read_type_array3dflt_type(structure_out%chem_comp, trim(adjustl(name)) // '%chem_comp')
     call read_type_array4dflt_type(structure_out%bulk_D, trim(adjustl(name)) // '%bulk_D')
     call read_type_array4dflt_type(structure_out%surface_D, trim(adjustl(name)) // '%surface_D')
     call read_type_array4dflt_type(structure_out%bulk_solute, trim(adjustl(name)) // '%bulk_solute')
     call read_type_array4dflt_type(structure_out%surf_solute, trim(adjustl(name)) // '%surf_solute')
     call read_type_array3dflt_type(structure_out%pore_content, trim(adjustl(name)) // '%pore_content')
     call read_arr_type_trap_type(structure_out%trap_type, trim(adjustl(name)) // '%trap_type')

   end subroutine read_type_wall_unitsComplexType_layers

   subroutine read_arr_type_wall_unitsComplexType_layers(structure_out, name)
 
     implicit none
 
     type (type_wall_unitsComplexType_layers), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_unitsComplexType_layers(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_unitsComplexType_layers

   subroutine read_type_wall_vessel(structure_out, name)

     implicit none

     type (type_wall_vessel), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_identifier(structure_out%vessel_id, trim(adjustl(name)) // '%vessel_id')
     call read_arr_type_wall_vessel_unit(structure_out%vessel_unit, trim(adjustl(name)) // '%vessel_unit')

   end subroutine read_type_wall_vessel

   subroutine read_arr_type_wall_vessel(structure_out, name)
 
     implicit none
 
     type (type_wall_vessel), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_vessel(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_vessel

   subroutine read_type_wall_vessel_annular(structure_out, name)

     implicit none

     type (type_wall_vessel_annular), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_rz1D(structure_out%inside, trim(adjustl(name)) // '%inside')
     call read_type_rz1D(structure_out%outside, trim(adjustl(name)) // '%outside')
     call read_type_float(structure_out%eta, trim(adjustl(name)) // '%eta')
     call read_type_float(structure_out%permeability, trim(adjustl(name)) // '%permeability')

   end subroutine read_type_wall_vessel_annular

   subroutine read_arr_type_wall_vessel_annular(structure_out, name)
 
     implicit none
 
     type (type_wall_vessel_annular), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_vessel_annular(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_vessel_annular

   subroutine read_type_wall_vessel_unit(structure_out, name)

     implicit none

     type (type_wall_vessel_unit), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_wall_vessel_annular(structure_out%annular, trim(adjustl(name)) // '%annular')
     call read_type_wall_blocks(structure_out%blocks, trim(adjustl(name)) // '%blocks')
     call read_type_wall_wall2d_vessel_radial_build(structure_out%radial_build, trim(adjustl(name)) // '%radial_build')

   end subroutine read_type_wall_vessel_unit

   subroutine read_arr_type_wall_vessel_unit(structure_out, name)
 
     implicit none
 
     type (type_wall_vessel_unit), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_vessel_unit(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_vessel_unit

   subroutine read_type_wall_wall0d(structure_out, name)

     implicit none

     type (type_wall_wall0d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%pumping_speed, trim(adjustl(name)) // '%pumping_speed')
     call read_type_vecflt_type(structure_out%gas_puff, trim(adjustl(name)) // '%gas_puff')
     call read_type_vecflt_type(structure_out%wall_inventory, trim(adjustl(name)) // '%wall_inventory')
     call read_type_vecflt_type(structure_out%recycling_coefficient, trim(adjustl(name)) // '%recycling_coefficient')
     call read_type_float(structure_out%wall_temperature, trim(adjustl(name)) // '%wall_temperature')
     call read_type_float(structure_out%power_from_plasma, trim(adjustl(name)) // '%power_from_plasma')
     call read_type_float(structure_out%power_to_cooling, trim(adjustl(name)) // '%power_to_cooling')
     call read_type_wall_wall0d_plasma(structure_out%plasma, trim(adjustl(name)) // '%plasma')

   end subroutine read_type_wall_wall0d

   subroutine read_arr_type_wall_wall0d(structure_out, name)
 
     implicit none
 
     type (type_wall_wall0d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_wall0d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_wall0d

   subroutine read_type_wall_wall0d_plasma(structure_out, name)

     implicit none

     type (type_wall_wall0d_plasma), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matint_type(structure_out%species_index, trim(adjustl(name)) // '%species_index')
     call read_type_vecflt_type(structure_out%flux, trim(adjustl(name)) // '%flux')
     call read_type_vecflt_type(structure_out%energy, trim(adjustl(name)) // '%energy')

   end subroutine read_type_wall_wall0d_plasma

   subroutine read_arr_type_wall_wall0d_plasma(structure_out, name)
 
     implicit none
 
     type (type_wall_wall0d_plasma), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_wall0d_plasma(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_wall0d_plasma

   subroutine read_type_wall_wall2d_vessel_radial_build(structure_out, name)

     implicit none

     type (type_wall_wall2d_vessel_radial_build), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%r1_inb, trim(adjustl(name)) // '%r1_inb')
     call read_type_float(structure_out%r2_inb, trim(adjustl(name)) // '%r2_inb')
     call read_type_float(structure_out%r1_outb, trim(adjustl(name)) // '%r1_outb')
     call read_type_float(structure_out%r2_outb, trim(adjustl(name)) // '%r2_outb')
     call read_type_float(structure_out%raddim, trim(adjustl(name)) // '%raddim')
     call read_type_float(structure_out%nmat, trim(adjustl(name)) // '%nmat')
     call read_type_vecflt_type(structure_out%composition, trim(adjustl(name)) // '%composition')
     call read_type_float(structure_out%pow_dens_inb, trim(adjustl(name)) // '%pow_dens_inb')
     call read_type_float(structure_out%pow_dens_outb, trim(adjustl(name)) // '%pow_dens_outb')
     call read_type_float(structure_out%fn_flux_inb, trim(adjustl(name)) // '%fn_flux_inb')
     call read_type_float(structure_out%fn_flux_outb, trim(adjustl(name)) // '%fn_flux_outb')

   end subroutine read_type_wall_wall2d_vessel_radial_build

   subroutine read_arr_type_wall_wall2d_vessel_radial_build(structure_out, name)
 
     implicit none
 
     type (type_wall_wall2d_vessel_radial_build), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_wall_wall2d_vessel_radial_build(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_wall_wall2d_vessel_radial_build

   subroutine read_type_waveguides(structure_out, name)

     implicit none

     type (type_waveguides), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%nwm_theta, trim(adjustl(name)) // '%nwm_theta')
     call read_type_integer(structure_out%nwm_phi, trim(adjustl(name)) // '%nwm_phi')
     call read_type_vecint_type(structure_out%mask, trim(adjustl(name)) // '%mask')
     call read_type_integer(structure_out%npwbm_phi, trim(adjustl(name)) // '%npwbm_phi')
     call read_type_integer(structure_out%npwe_phi, trim(adjustl(name)) // '%npwe_phi')
     call read_type_float(structure_out%sw_theta, trim(adjustl(name)) // '%sw_theta')
     call read_type_float(structure_out%hw_theta, trim(adjustl(name)) // '%hw_theta')
     call read_type_float(structure_out%bwa, trim(adjustl(name)) // '%bwa')
     call read_type_float(structure_out%biwp, trim(adjustl(name)) // '%biwp')
     call read_type_float(structure_out%bewp, trim(adjustl(name)) // '%bewp')
     call read_type_vecflt_type(structure_out%e_phi, trim(adjustl(name)) // '%e_phi')
     call read_type_vecflt_type(structure_out%scl, trim(adjustl(name)) // '%scl')

   end subroutine read_type_waveguides

   subroutine read_arr_type_waveguides(structure_out, name)
 
     implicit none
 
     type (type_waveguides), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waveguides(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waveguides

   subroutine read_type_waves_global_param(structure_out, name)

     implicit none

     type (type_waves_global_param), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%name, trim(adjustl(name)) // '%name')
     call read_type_vecstring_type(structure_out%type, trim(adjustl(name)) // '%type')
     call read_type_vecint_type(structure_out%f_assumption, trim(adjustl(name)) // '%f_assumption')
     call read_type_integer(structure_out%code_type, trim(adjustl(name)) // '%code_type')
     call read_type_float(structure_out%frequency, trim(adjustl(name)) // '%frequency')
     call read_type_vecint_type(structure_out%ntor, trim(adjustl(name)) // '%ntor')
     call read_type_float(structure_out%power_tot, trim(adjustl(name)) // '%power_tot')
     call read_type_vecflt_type(structure_out%p_frac_ntor, trim(adjustl(name)) // '%p_frac_ntor')
     call read_type_float(structure_out%pow_e, trim(adjustl(name)) // '%pow_e')
     call read_type_vecflt_type(structure_out%pow_i, trim(adjustl(name)) // '%pow_i')
     call read_type_matflt_type(structure_out%pow_z, trim(adjustl(name)) // '%pow_z')
     call read_type_float(structure_out%pow_fe, trim(adjustl(name)) // '%pow_fe')
     call read_type_vecflt_type(structure_out%pow_fi, trim(adjustl(name)) // '%pow_fi')
     call read_type_matflt_type(structure_out%pow_fz, trim(adjustl(name)) // '%pow_fz')
     call read_type_vecflt_type(structure_out%pow_ntor_e, trim(adjustl(name)) // '%pow_ntor_e')
     call read_type_matflt_type(structure_out%pow_ntor_i, trim(adjustl(name)) // '%pow_ntor_i')
     call read_type_array3dflt_type(structure_out%pow_ntor_z, trim(adjustl(name)) // '%pow_ntor_z')
     call read_type_vecflt_type(structure_out%pow_ntor_fe, trim(adjustl(name)) // '%pow_ntor_fe')
     call read_type_matflt_type(structure_out%pow_ntor_fi, trim(adjustl(name)) // '%pow_ntor_fi')
     call read_type_array3dflt_type(structure_out%pow_ntor_fz, trim(adjustl(name)) // '%pow_ntor_fz')
     call read_type_float(structure_out%cur_tor, trim(adjustl(name)) // '%cur_tor')
     call read_type_vecflt_type(structure_out%cur_tor_ntor, trim(adjustl(name)) // '%cur_tor_ntor')
     call read_type_rz0D(structure_out%mag_axis, trim(adjustl(name)) // '%mag_axis')
     call read_type_b0r0(structure_out%toroid_field, trim(adjustl(name)) // '%toroid_field')

   end subroutine read_type_waves_global_param

   subroutine read_arr_type_waves_global_param(structure_out, name)
 
     implicit none
 
     type (type_waves_global_param), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_global_param(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_global_param

   subroutine read_type_waves_grid_1d(structure_out, name)

     implicit none

     type (type_waves_grid_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_vecflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%volume, trim(adjustl(name)) // '%volume')
     call read_type_vecflt_type(structure_out%area, trim(adjustl(name)) // '%area')

   end subroutine read_type_waves_grid_1d

   subroutine read_arr_type_waves_grid_1d(structure_out, name)
 
     implicit none
 
     type (type_waves_grid_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_grid_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_grid_1d

   subroutine read_type_waves_grid_2d(structure_out, name)

     implicit none

     type (type_waves_grid_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_integer(structure_out%grid_type, trim(adjustl(name)) // '%grid_type')
     call read_type_matflt_type(structure_out%rho_tor_norm, trim(adjustl(name)) // '%rho_tor_norm')
     call read_type_matflt_type(structure_out%rho_tor, trim(adjustl(name)) // '%rho_tor')
     call read_type_matflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_matflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')
     call read_type_matflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_matflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_theta_info(structure_out%theta_info, trim(adjustl(name)) // '%theta_info')

   end subroutine read_type_waves_grid_2d

   subroutine read_arr_type_waves_grid_2d(structure_out, name)
 
     implicit none
 
     type (type_waves_grid_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_grid_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_grid_2d

   subroutine read_type_waves_profiles_1d(structure_out, name)

     implicit none

     type (type_waves_profiles_1d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%powd_tot, trim(adjustl(name)) // '%powd_tot')
     call read_type_vecflt_type(structure_out%powd_e, trim(adjustl(name)) // '%powd_e')
     call read_type_matflt_type(structure_out%powd_i, trim(adjustl(name)) // '%powd_i')
     call read_type_array3dflt_type(structure_out%powd_z, trim(adjustl(name)) // '%powd_z')
     call read_type_vecflt_type(structure_out%powd_fe, trim(adjustl(name)) // '%powd_fe')
     call read_type_matflt_type(structure_out%powd_fi, trim(adjustl(name)) // '%powd_fi')
     call read_type_array3dflt_type(structure_out%powd_fz, trim(adjustl(name)) // '%powd_fz')
     call read_type_matflt_type(structure_out%powd_ntor, trim(adjustl(name)) // '%powd_ntor')
     call read_type_matflt_type(structure_out%powd_ntor_e, trim(adjustl(name)) // '%powd_ntor_e')
     call read_type_array3dflt_type(structure_out%powd_ntor_i, trim(adjustl(name)) // '%powd_ntor_i')
     call read_type_array4dflt_type(structure_out%powd_ntor_z, trim(adjustl(name)) // '%powd_ntor_z')
     call read_type_matflt_type(structure_out%powd_ntor_fe, trim(adjustl(name)) // '%powd_ntor_fe')
     call read_type_array3dflt_type(structure_out%powd_ntor_fi, trim(adjustl(name)) // '%powd_ntor_fi')
     call read_type_array4dflt_type(structure_out%powd_ntor_fz, trim(adjustl(name)) // '%powd_ntor_fz')
     call read_type_vecflt_type(structure_out%curd_tor, trim(adjustl(name)) // '%curd_tor')
     call read_type_matflt_type(structure_out%curd_torntor, trim(adjustl(name)) // '%curd_torntor')
     call read_type_vecflt_type(structure_out%pow_tot, trim(adjustl(name)) // '%pow_tot')
     call read_type_vecflt_type(structure_out%pow_e, trim(adjustl(name)) // '%pow_e')
     call read_type_matflt_type(structure_out%pow_i, trim(adjustl(name)) // '%pow_i')
     call read_type_array3dflt_type(structure_out%pow_z, trim(adjustl(name)) // '%pow_z')
     call read_type_vecflt_type(structure_out%pow_fe, trim(adjustl(name)) // '%pow_fe')
     call read_type_matflt_type(structure_out%pow_fi, trim(adjustl(name)) // '%pow_fi')
     call read_type_array3dflt_type(structure_out%pow_fz, trim(adjustl(name)) // '%pow_fz')
     call read_type_matflt_type(structure_out%pow_ntor, trim(adjustl(name)) // '%pow_ntor')
     call read_type_matflt_type(structure_out%pow_ntor_e, trim(adjustl(name)) // '%pow_ntor_e')
     call read_type_array3dflt_type(structure_out%pow_ntor_i, trim(adjustl(name)) // '%pow_ntor_i')
     call read_type_array3dflt_type(structure_out%pow_ntor_z, trim(adjustl(name)) // '%pow_ntor_z')
     call read_type_matflt_type(structure_out%pow_ntor_fe, trim(adjustl(name)) // '%pow_ntor_fe')
     call read_type_array3dflt_type(structure_out%pow_ntor_fi, trim(adjustl(name)) // '%pow_ntor_fi')
     call read_type_array3dflt_type(structure_out%pow_ntor_fz, trim(adjustl(name)) // '%pow_ntor_fz')
     call read_type_vecflt_type(structure_out%curd_par, trim(adjustl(name)) // '%curd_par')
     call read_type_matflt_type(structure_out%curd_parntor, trim(adjustl(name)) // '%curd_parntor')
     call read_type_vecflt_type(structure_out%cur_tor, trim(adjustl(name)) // '%cur_tor')
     call read_type_matflt_type(structure_out%cur_tor_ntor, trim(adjustl(name)) // '%cur_tor_ntor')
     call read_type_matflt_type(structure_out%e_plus_ave, trim(adjustl(name)) // '%e_plus_ave')
     call read_type_matflt_type(structure_out%e_minus_ave, trim(adjustl(name)) // '%e_minus_ave')
     call read_type_matflt_type(structure_out%e_para_ave, trim(adjustl(name)) // '%e_para_ave')
     call read_type_matflt_type(structure_out%k_perp_ave, trim(adjustl(name)) // '%k_perp_ave')

   end subroutine read_type_waves_profiles_1d

   subroutine read_arr_type_waves_profiles_1d(structure_out, name)
 
     implicit none
 
     type (type_waves_profiles_1d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_profiles_1d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_profiles_1d

   subroutine read_type_waves_profiles_2d(structure_out, name)

     implicit none

     type (type_waves_profiles_2d), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_matflt_type(structure_out%powd_tot, trim(adjustl(name)) // '%powd_tot')
     call read_type_matflt_type(structure_out%powd_e, trim(adjustl(name)) // '%powd_e')
     call read_type_array3dflt_type(structure_out%powd_i, trim(adjustl(name)) // '%powd_i')
     call read_type_array4dflt_type(structure_out%powd_z, trim(adjustl(name)) // '%powd_z')
     call read_type_matflt_type(structure_out%powd_fe, trim(adjustl(name)) // '%powd_fe')
     call read_type_array3dflt_type(structure_out%powd_fi, trim(adjustl(name)) // '%powd_fi')
     call read_type_array4dflt_type(structure_out%powd_fz, trim(adjustl(name)) // '%powd_fz')
     call read_type_array3dflt_type(structure_out%powd_ntor, trim(adjustl(name)) // '%powd_ntor')
     call read_type_array3dflt_type(structure_out%powd_ntor_e, trim(adjustl(name)) // '%powd_ntor_e')
     call read_type_array4dflt_type(structure_out%powd_ntor_i, trim(adjustl(name)) // '%powd_ntor_i')
     call read_type_array5dflt_type(structure_out%powd_ntor_z, trim(adjustl(name)) // '%powd_ntor_z')
     call read_type_array3dflt_type(structure_out%powd_ntor_fe, trim(adjustl(name)) // '%powd_ntor_fe')
     call read_type_array4dflt_type(structure_out%powd_ntor_fi, trim(adjustl(name)) // '%powd_ntor_fi')
     call read_type_array5dflt_type(structure_out%powd_ntor_fz, trim(adjustl(name)) // '%powd_ntor_fz')
     call read_type_array5dflt_type(structure_out%powd_iharm, trim(adjustl(name)) // '%powd_iharm')

   end subroutine read_type_waves_profiles_2d

   subroutine read_arr_type_waves_profiles_2d(structure_out, name)
 
     implicit none
 
     type (type_waves_profiles_2d), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_profiles_2d(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_profiles_2d

   subroutine read_type_waves_rtposition(structure_out, name)

     implicit none

     type (type_waves_rtposition), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%r, trim(adjustl(name)) // '%r')
     call read_type_vecflt_type(structure_out%z, trim(adjustl(name)) // '%z')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')
     call read_type_vecflt_type(structure_out%psi, trim(adjustl(name)) // '%psi')
     call read_type_vecflt_type(structure_out%theta, trim(adjustl(name)) // '%theta')

   end subroutine read_type_waves_rtposition

   subroutine read_arr_type_waves_rtposition(structure_out, name)
 
     implicit none
 
     type (type_waves_rtposition), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_rtposition(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_rtposition

   subroutine read_type_waves_rtwavevector(structure_out, name)

     implicit none

     type (type_waves_rtwavevector), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%kr, trim(adjustl(name)) // '%kr')
     call read_type_vecflt_type(structure_out%kz, trim(adjustl(name)) // '%kz')
     call read_type_vecflt_type(structure_out%kphi, trim(adjustl(name)) // '%kphi')
     call read_type_vecflt_type(structure_out%npar, trim(adjustl(name)) // '%npar')
     call read_type_vecflt_type(structure_out%nperp, trim(adjustl(name)) // '%nperp')
     call read_type_vecflt_type(structure_out%ntor, trim(adjustl(name)) // '%ntor')
     call read_type_integer(structure_out%var_ntor, trim(adjustl(name)) // '%var_ntor')

   end subroutine read_type_waves_rtwavevector

   subroutine read_arr_type_waves_rtwavevector(structure_out, name)
 
     implicit none
 
     type (type_waves_rtwavevector), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_waves_rtwavevector(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_waves_rtwavevector

   subroutine read_type_weighted_markers(structure_out, name)

     implicit none

     type (type_weighted_markers), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_arr_type_identifier(structure_out%variable_ids, trim(adjustl(name)) // '%variable_ids')
     call read_type_matflt_type(structure_out%coord, trim(adjustl(name)) // '%coord')
     call read_type_vecflt_type(structure_out%weight, trim(adjustl(name)) // '%weight')

   end subroutine read_type_weighted_markers

   subroutine read_arr_type_weighted_markers(structure_out, name)
 
     implicit none
 
     type (type_weighted_markers), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_weighted_markers(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_weighted_markers

   subroutine read_type_whatref(structure_out, name)

     implicit none

     type (type_whatref), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecstring_type(structure_out%user, trim(adjustl(name)) // '%user')
     call read_type_vecstring_type(structure_out%machine, trim(adjustl(name)) // '%machine')
     call read_type_integer(structure_out%shot, trim(adjustl(name)) // '%shot')
     call read_type_integer(structure_out%run, trim(adjustl(name)) // '%run')
     call read_type_integer(structure_out%occurrence, trim(adjustl(name)) // '%occurrence')

   end subroutine read_type_whatref

   subroutine read_arr_type_whatref(structure_out, name)
 
     implicit none
 
     type (type_whatref), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_whatref(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_whatref

   subroutine read_type_width(structure_out, name)

     implicit none

     type (type_width), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_vecflt_type(structure_out%dtheta, trim(adjustl(name)) // '%dtheta')
     call read_type_vecflt_type(structure_out%phi, trim(adjustl(name)) // '%phi')

   end subroutine read_type_width

   subroutine read_arr_type_width(structure_out, name)
 
     implicit none
 
     type (type_width), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_width(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_width

   subroutine read_type_xpts(structure_out, name)

     implicit none

     type (type_xpts), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_rz1D(structure_out%position, trim(adjustl(name)) // '%position')
     call read_type_vecstring_type(structure_out%source, trim(adjustl(name)) // '%source')
     call read_type_vecflt_type(structure_out%weight, trim(adjustl(name)) // '%weight')
     call read_type_vecflt_type(structure_out%sigma, trim(adjustl(name)) // '%sigma')
     call read_type_vecflt_type(structure_out%calculated, trim(adjustl(name)) // '%calculated')
     call read_type_vecflt_type(structure_out%chi2, trim(adjustl(name)) // '%chi2')

   end subroutine read_type_xpts

   subroutine read_arr_type_xpts(structure_out, name)
 
     implicit none
 
     type (type_xpts), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_xpts(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_xpts

   subroutine read_type_xyz0D(structure_out, name)

     implicit none

     type (type_xyz0D), intent(inout) :: structure_out
     character(len = *), intent(in) :: name

     call read_type_float(structure_out%x, trim(adjustl(name)) // '%x')
     call read_type_float(structure_out%y, trim(adjustl(name)) // '%y')
     call read_type_float(structure_out%z, trim(adjustl(name)) // '%z')

   end subroutine read_type_xyz0D

   subroutine read_arr_type_xyz0D(structure_out, name)
 
     implicit none
 
     type (type_xyz0D), pointer :: structure_out(:)
     character(len = *), intent(in) :: name
 
     character(len = 132) :: text_line
     integer :: rank
     integer :: n1
     integer :: i

     read(in_cpo, *) text_line
     if (trim(adjustl(text_line)) /= trim(adjustl(name))) then
       write(iu6, *) 'ERROR: corrupt input file'
       write(iu6, *) 'Element: ', trim(adjustl(text_line))
       stop
     end if
     read(in_cpo, *) rank
     if (rank == -1) then
       if (verbose > 0) &
        write(iu6, *) trim(adjustl(name)) // ' not defined'
     else
       if (associated(structure_out)) then
         write(iu6, *) 'WARNING: ', trim(adjustl(name)) &
          // ' was associated'
         deallocate(structure_out)
       end if
       if (rank == 1) then
         read(in_cpo, *) n1
         allocate(structure_out(n1))
       else
         write(iu6, *) 'ERROR: wrong rank'
         stop
       end if

       do i = 1, size(structure_out)
         call read_type_xyz0D(structure_out(i), name)
       end do
       if (verbose > 0) &
        write(iu6, *) 'read ', size(structure_out), trim(adjustl(name))
     end if

   end subroutine read_arr_type_xyz0D


 end module read_structures
